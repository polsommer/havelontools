UdpLibrary Release Notes
=================================================================================================================
-----------------------------------------------------------------------------------------------------------------
2006-06-08
-----------------------------------------------------------------------------------------------------------------

- Been a year and a half since the last UdpLibrary release, but interim versions of the UdpLibrary are in use by some
  projects (EQ and ULPS3 in particular), so most all new features of the library are well tested.  As always, if you
  find any bugs or need any features added to the library, just let me know.  I would like to avoid API bloat, so only 
  features that can't be implemented outside the library will generally be considered for inclusion.  The exception to
  this is a steam compression scheme I am mulling over for the future. - Jeff Petersen
  
- Added a driver for the PS3 platform.  This driver is not 100% feature complete, but it does everything you likely
  need to do.  Most notably, it doesn't currently support the GetSelfAddress function.  When the driver was first
  written using preliminary PS3 SDK's some features (such as changing the size of the socket send buffer) were either
  not supported or buggy.  The driver has been updated to work with the latest SDK along the way, but old issues
  that were not supported were not always revisited with each new SDK release.  It's possible that some features are
  now available that are not implemented, but like I said, they are rare features that an application is unlikely to 
  mess with anyways.  The current driver is tested against PS3 SDK 084.006.  This driver supports infrastructure mode
  only (ie, it does not support adhoc mode)

- The corrupt-packet checking code wasn't properly trapping the condition where the first fragment of a large
  logical packet was specifying a negative length to follow (it was handling too large and zero sized, but not
  negative sized).

- UdpPlatformAddress:SetAddress was taking a non-const parameter when it should have been const.

- there was a minor bug whereby packets sent on the ordered-channel and the ordered-unbuffered channel were actually
  being order-guaranteed against the other channel.  Meaning, that it would preserve the order regardless of which
  channel it was sent on.  This was incorrect behavior because if I sent something buffered, then sent something
  unbuffered immediately, the unbuffered data would get lost every time, since it would always arrive before
  the buffered data which would not have been flushed out the pipe yet.  This is all somewhat academic I think, as I
  can't imagine anybody using both buffered and unbuffered ordered channels.  Quite frankly, I don't of anybody who
  has ever even used the ordered channel.

- fixed some portability warnings related to 64-bit compilation.  The UdpLibrary compiles and runs fine under 64-bit
  Windows (and probably under other 64-bit platforms that have drivers), but the library is still limited to only being
  able to send application packets that are under 2gb in size.  That is, the internal wire protocol only supports
  signed 32-bit packet lengths.  Of course, it would be a bit crazy to try and send anything that large anyways.  If you
  need to send something that large, the application is just going to have to break it up into pieces itself (at least
  for now).
  
- got rid of the use of several functions that have been deprecated in the latest version of the ISO spec, including in
  the soon to be released Visual Studio 2005 compiler.

- fixed bug in Linux driver Clock function where it was not initializing the currentCorrection and lastStamp variables
  in the constructor.  This would cause wierd clock problems in the very rare cases where the currentCorrection randomly
  ended up being a very large or negative 64-bit value.  I would think this would have been causing all sorts of problems,
  but apparently it has gone undetected in the library for years.  The Sparc and PS3 drivers also had the same issue.

- fixed bug in the ExpireSendBin and ExpireReceiveBin functions that caused it to index off the front of an array and 
  tromp the UdpConnection object whenever the clock rolled over (2^31)*25ms, which would occur every 621 days and crash
  the process.  This was a particularly nasty problem on Linux since the clock didn't reset on reboots since it was based
  off real-time.  Without this fix, next crash was due to occur around July 7, 2007 at 12:45am on Linux.

- create the concept of a cached clock, which is simply a cached version of the driver clock function that is only updated
  when the real clock version is called, which occurs once per give time (and at a few other times where a cached clock
  won't do the job).  The goal here was to reduce the number of calls to the driver's Clock function, since the the driver's
  clock is likely going to be slower.  Additionally, since record and playback drivers record every call to the driver,
  reducing the number of driver calls can significantly reduce the amount of record/playback data needed (which is the
  main motivation for this change).  I don't expect any unusual artifacts to occur because of this change, but it's always 
  a bit dicey playing with timing information.

- tiny change to Linux ICMP error processing.  It used to only process port-unreachable errors, but now it processes
  all the various flavors of destination-unreachable errors.

- fixed a small race-condition in the UdpStress program that might have caused it to try to establish a connection to
  somebody who was already trying to establish a connection to them.  Basically if two stress programs connected to the
  cluster at the same time, then both requested the connection list, they would both try to connect to each other.

- reduced the maximum raw packet size that the library will support to 8192 (used to be 16384) bytes.  Like other recent
  changes, this one is designed to minimize the stack footprint of the library for the PS3.  In reality, nobody should
  be configuring the library to use packets larger than 1460 bytes anyways, since doing so is inefficient on ethernet
  networks.  For any communications over the internet, the limit is 512 bytes, so 8k is a very reasonable upper limit.
  If for some reason you needed it larger than that, you can modify the UdpManager::cHardMaxRawPacketSize constant to
  as large as you need, up to the theoretical maximum of a little under 64k.

- optimized stack-usage in the reliable channel object.  Basically, instead of queuing up all the ready to send packets
  in one pass, I queue up to 1000 and then if we can still send more we repeat the whole process.  This will actually
  increase the number of packets that could be sent in a single frame, which might help super-high bandwidth situations
  a bit, while at the same time reducing the stack-space requirements considerably, which turns out to be fairly critical
  on the PS3.
  
  Unfortunately, this will cause it to use quite a bit more CPU in LFN situations.  Since nobody uses the LFN
  settings and a LFN situations is very likely to be a process dedicated to that purpose, I think we can ignore the extra
  CPU cost.  I can think of some ways I could optimize this CPU usage, but it would complicate the code substantially
  for very little real benefit, so I am leaving it alone.  If you are in an LFN situation and want absolutely maximum
  performance, search for the constant cReadyQueueSize in the code and change it to 30000.  This will use a bunch of stack
  space, but give you optimal CPU performance (again, only in cases where bandwidth usage between two connections is
  in excess of 10mb per second).

- modified UdpStress program to be more portable and to support the PS3.  Turns out that application level packets in
  the stress program were not properly taking into account structure-packing or byte-ordering.  The PS3 had some special
  startup code that needed executing, and temporarily I have made the command-line parameters hard-coded for the PS3
  as I don't have any way of passing in command line parameters.

- reworked the way UdpIpAddress objects are represented.  UdpIpAddress used to be considered a portable object, but
  then we came across scenarios where it would be useful if the representation of the address were platform dependent.
  This would allow for an IPv6 driver or even a non-ip network driver.  We actually ran into this scenario doing
  ad-hoc networking on the PSP.  The portable UdpLibrary code never actually looked at the contents of the UdpIpAddress
  object anyways, so making it a platform object wasn't too much work.  The UdpIpAddress::GetAddress() function that
  used to return a uint had to be removed, since it exposed a platform dependency.  So, if you made use of that function
  you will need to change your code.  As implemented now, the only way to get the address is as a string, since that
  can be made to represent any underlying scheme.
  
  To reflect the UdpIpAddress role as a platform dependent object, it has been renamed to UdpPlatformAddress.  There is 
  a typedef to make UdpIpAddress equivalent for backwards compatibility, but it should be considered deprecated.
  
  The implementation of the UdpPlatformAddress class is now duplicated in every Driver file.  The UdpPlatformDriver is
  a friend of this class, allowing it to manipulate the internal representation directly.  All existing drivers were
  modified to participate in the new scheme; however, I was unable to check my changes to the sparc driver, since I don't
  have access to this platform.  If you are using the sparc platform and upgrade to this latest version, could you drop me
  a note and let me know that it works ok, and if it doesn't, what I need to do to fix it.  If there are any issues
  it will most likely just be a typo or cut/paste error.
  
  The GetAddress as a string function was changed to take a destination buffer length, such that it can be implemented
  in a buffer-safe manner.

- a couple minor portability issues fixed (it turns out memory.h is not supported on all platforms, so string.h
  was used instead, likewise for malloc.h).  This was fixed as part of the port to the PS3.  There is now a
  PS3 driver (UdpDriverPS3.cpp).  The PS3 driver is currently incomplete in that it doesn't support ICMP and a
  couple other things.  These things should be fixed soon.

- fixed a potential threading issue whereby the UdpManager was using the UdpConnection handler without guarding it.
  In practice this would likely never happen anyways, since the UdpManager only ever used the handler from the
  main application thread (during DeliverEvents), which means the main thread by definition couldn't swap it out
  in that brief moment.  Still, in theory some third thread could swap it out (though in practice I can't imagine
  this ever happening).  For completeness the code has been changed slightly to have a guard on the connection
  handler that is held during the course of the callback.

- made some tiny changes to the code to make it even more ISO C++ compiant so it wouldn't complain on GCC 3.4.x.

- added new function, UdpManager::DisconnectAll.  This function causes the UdpManager to disconnect all currently
  live connections.  The disconnect reason reported by connections disconnected in this manner will be
  cDisconnectReasonApplication, as it is really just a convienence mechanism for the application looping over the
  connections and disconnecting them itself.  If you are using an event queuing (threading), it can also be the case 
  that the UdpManager has connections that the application has not yet been notified about that may need to be
  disconnected.  Explicitly disconnecting all connections can be useful when the server is in the process of
  shutting down.  Doing it in this manner increases the likelyhood that the other end of the connection will get
  notification that the connection has been terminated (instead of having to find out by other slower means).  As
  a general rule if you plan on doing this and are using a threaded model, you should do it after the background
  thread has been stopped, such that new connections are not added by the background thread after the call.  This 
  makes the recommended shutdown sequence for a threaded UdpManager as follows:

      udpManager->ThreadStop();       // stop background thread (non-threaded model skip this step)
      udpManager->DisconnectAll();    // disconnect everybody
      udpManager->SetHandler(NULL);   // clear our handler
      udpManager->Release();          // release our reference (should cause UdpManager destructor generally)
      udpManager = NULL;

- fixed potential threading issue with UdpManagerHandler.  The code was not thread-safe in allowing the application
  to change the UdpManagerHandler on-the-fly while a background thread was processing.  I can't think of any reason
  why an application would want to do this; nevertheless, it is now safe.

- note: The user supplied encryption callback routines that are part of the UdpManagerHandler are NOT event-queued
  callbacks like all the other callbacks.  This means that if you are using the threading model, the 
  OnUserSuppliedEncrypt and OnUserSuppliedDecrypt callbacks to the application are going to occur asynchronously
  from the background UdpLibrary thread, instead of in the applications main thread during DeliverEvents (like all
  other callbacks).  Unfortunately there is no way around this (ie, there is no way to event-queue these callbacks),
  as the UdpLibrary is not able to do it's job without calling these, since encryption occurs at the very lowest
  level of the library just after a physical-packet has been prepped, or just after a physical packet comes off the
  wire.  As such, you need to make sure that everything you do inside of these two callbacks is completely threadsafe.
  One example where this came up is somebody was using zlib to do compression in the callback and they were having
  zlib use a custom-written pooled memory manager to do it's allocations.  A second UdpManager thread talking to a
  different process was also using the zlib in a similar manner and the pooled memory manager was not thread safe,
  causing all sorts of issues.
  
  Along these same lines, it's entirely possible that the OnUserSuppliedEncrypt/Decrypt functions may be called
  for data for which the application has not been notified of the existence of the UdpConnection.  In other words,
  the OnConnectRequest callback could be waiting in the event queue.  In these situations, the UdpConnection object
  passed to the OnUserSuppliedDecrypt function may be one that the application does not know about.  Additionally,
  the handler for that UdpConnection would likely still be set to NULL if this occurred.  As such, it is also fairly
  important that the application not rely on the handler in order to store state information or other stuff needed
  for decryption.  One possible solution to this particular issue might be that if the UdpConnection object sent
  to the OnUserSuppliedDecrypt function has a NULL handler, the function could simply return 0, which would cause
  the packet to be thrown away as-if it never arrived.  The application could continue to do this behavior until
  the main thread delivered events, processed the OnConnectRequest event, and setup a handler for that connection.
  The end result would be no different than if the packets in question had just been lost on the wire for some
  reason.

- apparently somebody was using the UdpLibrary under sparc still.  With Dave Taylor's help, the sparc driver has
  now been tested and fixed.

- fix potential buffer overrun bug in GetDisconnectReasonText.

- note: just a heads-up on an issue EQ ran into.  On the client side, EQ was creating a single UdpManager and then
  using it to create a connection to the world-server, then tear down that connection and use it to create a connection
  to the zone-server.  As it turns out, some routers were having problems with this behavior for security reasons.
  Because the client-side ip/port did not change, yet the destination did, it messed up the routers firewall and/or
  NAT mappings and caused it to block the connection.  Users found that removing the NAT router or moving the PC
  into a lower security zone setting within the device solved their problem.  To prevent this problem, it is 
  recommended that client applications destroy the UdpManager object when the connection is destroyed and
  recreate it.  In this manner, the UdpManager will select a new port (assuming the UdpParams::port is set to 0
  meaning let the OS pick the port) with every new connection attempt.  This would be the case if the application
  were simply switching from one zone-server to another as well.  Using the same UdpManager over and over for
  connections to different machines on the client side should be avoided due to this issue.

- added a construction parameter to the UdpParams object such that the application can specify a particular role
  and all the various params will automatically be set to reflect reasonable settings for a manager that will
  be playing the specified role.  The UdpParams object still has a default constructor that will take upon itself
  the cManagerRoleDefault settings, which are settings identical to what they were in previously releases of the
  UdpLibrary (to ensure compatibility with existing configurations).  New applications should likely explicitly
  specify one of the other roles that is appropriate for how they are being used.  Picking a particular role does
  nothing but setup the various UdpParams members with different default values; the UdpManager doesn't have a
  role per se.
  
  After constructing the UdpParams object with the appropriate role, the application is still responsible for 
  changing some of the parameters to reflect how they will be using the library.  For example, if the application
  intended to be using threaded mode, they will still likely have to set the UdpParams::eventQueuing
  parameter to true.  The application may also wish to further tweak the settings to more tightly cater to their
  situation.  For example, the application may want to adjust the noDataTimeout value to be more agressive.  Some
  applications may also have very specialized needs that need further tweaking.  For example, by default the various
  'server' roles are configured to handle at most 2000 connections.  Some situations may require this number be set
  much larger (like our LoggingServer for example which handles upwards of 15000 connections).  For server side
  managers, the application will still have to explicity set the UdpParams::port value.  If you wish to review 
  the settings for the various roles, the easiest way is to simply look at the UdpParams constructor, which is located 
  at the bottom of the UdpManager.h file.  The various roles that are available are documented briefly in the enum
  at the top of the UdpManager.h file as well.  Generally speaking, there are is a high-bandwidth and a low-bandwidth
  version of a client and server side configuration, plus a specialty configuration for LFN's.
  
  The goal of this particular change is to decrease the likelyhood of bad UdpParams settings screwing up application
  performance.  That said, there is no perfect solution; the application programmer would still be wise to read the 
  various release notes and become educated on how the various parameters work and how they may be able to benefit
  from them.  As always, if you are having a particular performance issue that you can't resolve, feel free to contact
  me.  It's through these conversations that I am able to add improvements such as this to the library.

- fixed compatibility issue with old version of Microsoft compiler (VC6).  VC6 does not support friend templates,
  which were being used for the linked-list template.  This modification makes it use friend-templates for all
  compilers except VC6 or older.  Also, VC6 does not support nested classes accessing parent class types that are
  declared private.  To solve this problem, the CallbackEventType enumeration was moved down into the
  CallbackEvent class.

- fixed bug in Linux/Sparc threading stuff.  Basically it was not properly setting the thread into a detached state
  causing it to effectively leak process address space everytime a thread was terminated.  This is typically only an
  issue for an application that is using threading and creates and destroys UdpManager objects multiple-times over
  the course of the application.

- modified the packetloss simulation parameters to be floating point, such that loss-percentages less than 1% could
  be specified.  Also restructured the main socket polling loop a bit such that packets thrown away by the simulation
  did not cause it to quit polling for that interation.

- added new reliable channel configuration parameter, toleranceLossCount.  Like other reliable channel configuration
  parameters, this is considered an advanced feature that should really only be used if you have a specialized need.
  This parameter is primarily designed to optimize the flow control window scaling in situations where high
  bandwidth is needed and some small amount of packetloss is to be expected without it necessarily indicating
  an overloaded situation.  For example, it takes quite a while (seconds) for the flow control algorithm to ramp-up
  to full speed on a gigabit network.  Even a single lost packet (out of tens-of-thousands per second) will cause
  the flow control window to reset back to 75%.  So if you lose 1 packet every 25% of the ramp-up time, the maximum
  flow-rate will never be achieved.  This tolerance setting allows us to configure the library to ignore individual
  packetlosses (for purposes of flow control), and wait for more seriously events (large groups of losses) before
  adjusting the window.  This can allow it to achieve much higher speeds on these types of networks.  A word of
  warning, setting this value too high can also cause a connection to be unfriendly to other connections on the
  same network.

- tweaked the buffered-ack algorithm a bit such that if multiple selective-acks are buffered, a later ack-all will
  replace the earliest ack in the buffer, such that the receiver will get the ack-all before the selective acks
  and thus be able to avoid doing a potential accellerated resend that need not occur.  This is an optimizations to
  better deal with connections that can have out of order packet issues.
  
- just a quick reminder, any connection that talks off of our local-area-network should set the maxRawPacketSize to 512
  bytes.  Setting it larger will work in most circumstances, but there will be isolated incidences where it will not
  work that are difficult to track down.  If you know a particular UdpManager will only be handling connections between
  internal server boxes on the LAN, then setting the maxRawPacketSize to 1460 bytes will make optimal use of internal
  network resources.  If you are unsure, leaving it at 512 is always a safe bet.

-----------------------------------------------------------------------------------------------------------------
2004-11-15
-----------------------------------------------------------------------------------------------------------------
- Welcome to the first release of the UdpLibrary in a very long time.  It's not that the library has not been
  changing over the past year+, but that there has not been a compelling reason to release a new version of the
  library.  The major changes to this version that justify a new release are:
  
  1) Namespaces were added to better facilitate versioning and easier integration into projects
  2) Objects reorganized into separate files to make maintenance easier
  3) Full threading support
  4) Cleaner implementation of some aspects (use of templatized containers)
  5) Driver based platform dependency model (makes porting to other platforms much easier)
  6) misc bug fixes and minor enhancements as noted below
  
  Just below you will find a list of steps that you need to take in order to upgrade an existing application
  to this latest version.  In the release notes I have documented recommended behaviors that have become even
  more important due to the changes needed for threading.  I recommend that you read all the new release notes
  to ensure that your application is making optimal use of the library.  As always, the library remains protocol
  level compatible with older versions, so the new library can connect and talk with applications using older
  versions of the library and vice-versa.

- Existing applications: summary of changes needed to upgrade to latest version of UdpLibrary

  1) Complete file reorganization will require a lot of new files be added to your UdpLibrary project.  The latest
     version of the library now ships with a Visual Studio .NET 2003 project that builds the UdpLibrary into a
     .lib file.  There are no special settings and you are welcome to use this project, or make one of your own
     and just include all the needed source files.  Also, header files now have .h extensions instead of .hpp.
     
  2) Rename all references to UdpLibrary classes to be prefixed with UdpLibrary::, reflective of the fact that
     everything is now in a unique namespace.
     
  3) Certain UdpManager::Params settings have been removed.  Odds are you were just letting these take on the
     default value, but if you were setting them explicitly, simply remove any settings that no longer exist.
     Parameters used to simulate line conditions were removed from Params and are now set through a separate
     function/structure and can be changed on the fly.
     
  4) Base data types such as uchar are now named udp_uchar.  This is reflected in the handler functions as well.
     If your application made use of uchar (which it would need to in order to declare handler functions), then
     it should rename all those uses to udp_uchar.  Likewise for a few other core types.  So, go change all
     you handler functions to take udp_uchar instead of uchar.
  
  5) First off, I do not recommend using the new threading functionality of the library unless your main loop
     is not able to give time to the UdpManager on a frequent enough basis (say 8 times per second depending 
     on the volume of data it is processing).  If you wish to take advantage of the new threading functionality 
     of the UdpLibrary by having it GiveTime in a separate thread, you need to do the following steps:
     
     a) change your current call to UdpManager::GiveTime into a call to UdpManager::DeliverEvents.
     b) put the UdpManager in event queuing mode, most likely by setting UdpManager::Params::eventQueuing to true.
     c) call UdpManager::ThreadStart to start background thread.
     d) call UdpManager::ThreadStop before destroying your UdpManager object to stop the background thread.
     e) make sure you clear your UdpConnection handler when you release a connection (see below for details)
     
- The UdpManager now holds a reference to all UdpConnection objects until they go into a disconnected state.  If the
  application releases a UdpConnection object that is not disconnected, the UdpConnection will not be deleted until
  the manager determines that it holds the only reference to the connection, at which point it will disconnect the
  connection and release it, effectively destroying it.  Because the connection may stay alive for some period of
  time after the application releases it, it is vital that the application clear the handler to NULL by calling
  SetHandler before it releases the connection.  The rule is that the handler object MUST hold a reference to the
  UdpConnection, meaning that when it releases its reference, it must also remove itself from being the handler for
  that connection (using UdpConnection::SetHandler(NULL)).
  
- applications must now link with the multi-threaded version of the runtime library, or else they will get link failures
  on functions such as beginthreadex (under Windows).  There is little harm in linking with the multi-threaded version of
  the runtime library, even if you are not using threading.  If for some reason you really don't want to do this, and you
  do not plan on using the new threading support provided by the library, you can define the preprocessor symbol:
  UDPLIBRARY_SINGLE_THREAD to prevent the UdpLibrary from making use of functions only found in the multi-threaded version
  of the standard C library.
        
- added two new manager statistics: maxDeliveryTimeExceeded and maxPollingTimeExceeded.  These two counters increment
  whenever the DeliverEvents or GiveTime functions abort early due to the maximum processing time being exceeded, which
  indicates that all the data that was ready to be processed that frame was not processed.  If you find your application
  is incrementing these statistics, it could be an indication that you have a problem.  Typically, it would mean that you
  needed to set the max processing time to those function calls higher.  Leaving work undone by aborting early is usually
  just a recipe for causing a backlog in the socket buffer, and can even result in increased packetloss if it gets
  backed up far enough.  As a general rule, it is best for the applications frame-rate to slow down however much is
  needed to effectively process everything that is pending that frame.  To do otherwise might give the application the
  false impression that it is heathier than it really is.  Along the sames lines, you will note further down in the
  release notes that max processing time default for these functions was increased.

- fixed bug in all drivers where GetSelfAddress was not properly checking for an error condition that in theory should
  never happen, but in fact does happen if the process is signalled during a gethostbyname call.

- fixed bug in Linux driver where it was creating threads in joinable mode instead of detached mode.  This caused it
  to leak address-space everytime the UdpManager::ThreadStop was called.

- fixed a nasty bug that in practice would only appear when you were running two processes on the same machine
  talking to each other.  The bug was that when one of the processes shutdown ungracefully, it would return ICMP
  errors to the other process.  The other process would attempt to route those ICMP errors to an internal connection
  object, which may not exist.  If the connection object didn't exist, then it would send a destination-unreachable
  packet to the ip/port that the unknown packet came from.  In this case, the unknown packet was an ICMP error and
  the send caused an infinite loop.  This issue was fixed by simply ignoring ICMP errors for ip/port's that we don't
  have an associated connection with.

- added a whole lot more data-integrity checking to ensure that packets that have been tampered with do not accidentally
  cause the application to crash.  You will find that there are many more corruption reasons now possible in the
  OnCorruptPacket callback.  This vulnerability was discovered when a hacker in Infantry was repeatedly crashing
  the servers.  About the only way this class of bugs can happen in practice is if somebody is hacking the stream,
  since CRC checks largely prevent accidental corruption.  I think I have caught all the circumstances where a
  bad packet could cause problems, but ultimately, there will no doubt be countless application-level issues that
  may arise from packet tampering.  This is a never ending battle against hackers.
  
- note: in the linux version of the library, socket overflow errors (tracked in UdpManagerStatistics) are not really
  indicative of an overflow.  The linux manual says that linux quietly just discards packets that do not fit in the
  socket buffer without even telling the application.  As of this writing, it is unclear to me what socket overflow
  errors would indicate in the linux version.  It basically means the sendto call on the socket failed for some reason.
  We have seen some of these errors occurring in EQ2, but the quantity is negligable so we just ignore it, since there
  is little harm done, and nothing we could do about it anyways probably.

- made the UdpLibrary disconnect any connection that managed to trigger a corrupt packet alert.  Previously it would
  just ignore the packet, but 99% of the time this alert gets triggered, it means somebody is hacking the packet
  stream.  The application should likely log the OnCorruptPacket callback information somewhere and the associated
  account should be scrutinized.  As such, a new disconnect reason has been added, cDisconnectReasonCorruptPacket.

- added an assert in cases where the UdpManager::GiveTime is called recursively during an application callback.
  Previously the UdpLibrary would simply ignore this recursive call (doing nothing), but odds are it is indicative
  of an application bug.  If for some odd reason this is not a bug in your application and you need to handle this
  case without asserting, then simply remove the assert and send me an email detailing how it is that you get into
  this situation legitimately.

- added the ability to change UdpParams::maxDataHoldTime on the fly using UdpManager::SetMaxDataHold time.  This is
  a global setting used by all connections and as such will be used by existing connections as well.

- since we are now in a namespace anyways, and in an effort to make the UdpManager object less congested, I have
  moved some of nested classes of the UdpManager out to the namespace scope.  In particular, UdpManager::Params 
  should now be referred to as simple UdpParams.  The EncryptMethod enumation was moved as well, so if you were
  using UdpManager::cEncryptMethodNone (or similar), that should now simply be cEncryptMethodNone.  The sole purpose
  for doing this was to make the code easier to maintain and view, since it now simpler to find the UdpManager
  interface declaration.  SimulationParameters was also moved out to namespace scope and named UdpSimulationParameters.
  I currently have UdpManager::Params typedef'ed to be equivalent to UdpParams to make migration of existing 
  applications easier; however, that is considered deprecated.

- upgrade warning: in order for the new threading model to work, the UdpLibrary needed to support event queuing,
  whereby all callback events get queued and only delivered when the application called DeliverEvents.  In order for
  this to work, the UdpLibrary had to guarantee that callbacks never occurred except during a DeliverEvents call
  (when in queuing mode).  This is a different behavior than previous versions of the library, where
  if the application called UdpConnection::Disconnect, it would callback the application immediately via the
  OnTerminated callback.  If you are not event queuing, then it should operate as before, calling back the application
  during the Disconnect call.
  
- There is now a requirement that UdpConnection objects always have a valid handler.  If the UdpConnection ever finds
  itself without a handler after the OnConnectRequest callback has occurred, it will automatically disconnect itself.

- fixed bug where a deadlock condition could possibly occur when the application explicitly disconnected a connection.
  Also made it such that all access to connection objects from within the UdpManager ensure that they AddRef the
  connection before they release connection lock.

- fixed cEncryptMethodXor to be compatible on big-endian machines.  Previously, big-endian machines could not use
  this encyption method when talking to little-endian based machines.  Since all existing installations are intel
  based, I made the intel encryption the official library protocol format.  As such, big-endian hardware ends up
  jumping through some hoops to be compatible.  As with the big-endian nature of everything else, the implementation
  is such that the exact same code works on either endian based machine.  The performance cost should be negligable.

- added built-in support for spinning a thread to give the UdpManager time.  Previously, I had simply recommended
  that the application mimic the StressThread class in UdpStress.cpp; however, I decided that it was worthwhile
  to make this process even easier.  The application is still free to spin their own thread to GiveTime as before, 
  but most applications will want to simply call UdpManager::ThreadStart and UdpManager::ThreadStop in order to
  get background GiveTime processing.  It is the applications responsibility to make sure the UdpLibrary is in
  event-queuing mode (see Params::eventQueuing).  If the application starts a thread in this manner, it should
  generally call DeliverEvents where it now calls GiveTime, and then never call GiveTime from the application.
  
  The application is free to start/stop the background thread as much as they want, though I have no idea why they
  would want to do this (it would be fairly inefficient).  The running background thread MUST hold a reference to
  the UdpManager in order to prevent it from getting used after the last Release has been executed.  As such, if you
  Release the UdpManager thinking it is going to disappear without calling ThreadStop first, then the object will
  not actually be deleted, and instead will keep running in the background forever.  It does not hurt to call
  ThreadStop if no thread is actually running, so if your application ever uses ThreadStart, it should make sure
  and call ThreadStop before releasing its last reference to the UdpManager.
  
  The UdpStress program now uses the built-in threading stuff, so the StressThread class no longer exists.  If you
  want a sample class for doing your own, see the UdpManagerThread class in UdpManager.cpp.

- fixed bug where the connection guard object was being touched after the application had released the final
  reference to the connection.  It used to be the case that after a callback to the application, the library
  either guaranteed it did not touch anything else in the connection, or held a reference to the connection until
  such time that destruction was safe.  When the application was calling Disconnect directly it was relying on the
  former, but that changed when the thread-guarding object was added and then touched.  The solution was for the
  library to change to the latter method of holding a reference during the course of the call until after the guard
  section was left.  There were actually several other cases in which this could occur that were fixed as well.
  
- fixed a bug where the UdpConnection::mGuard was not being reserved during the processing of packets.  This bug
  likely would never show up in practice since the only one thread will be processing packets from the socket at
  a time anyways, and the application send side of the equation did not touch any resources that would have been
  shared.  Still, better safe than sorry.

- note: when switching to the driver based model for platform dependencies, every effort was made to make existing
  supported platforms work.  Currently the UdpLibrary supports Windows, linux, and sparc.  The Windows and linux
  drivers are fairly well tested.  The sparc version may not even compile successfully, as I don't have access to
  a sparc to test it on.  It is unclear as to whether we even have any more sparc servers/applications left in the
  company.  If anybody is using the UdpLibrary under sparc, if they could verify that the sparc driver is working
  and fix it if not, then provide me with an updated driver for inclusion in the library, it would be appreciated.
        
- helpful hint:  In the past when a server application was unable to keep up with the incoming data rate,
  queues of data would form on the client side, waiting to be sent.  The server would effectively limit the amount
  of incoming data by virtue of the fact that it did not give the UdpLibrary enough time to process the incoming
  packets.  This resulted in a backlog on the client side, spread out among all the clients.  If you switch to a
  threading model on the server, the net result will be that all that data will successfully make it to the server
  and will be queued on the server, waiting for processing.  The danger here is that the queue on the server could
  grow extremely large and cause a low-memory situation.  There is no substitute for a server not being able to
  process the incoming data quickly enough.  Fundamentally something is broken that must be fixed, whether the
  queuing is occuring on the client or the server.  If you have a server that is particularly tight on memory, and
  has occassional bursts of slow processing, this may be the straw that breaks the back of a system that might
  have otherwise been hobbling along successfully.  There are new UdpManager statistics that will tell you how
  much data is in the event queue waiting for processing.  It may be worthwhile to have your application monitor
  this value as a means of helping to identify if this problem occurs.  On a more positive note, the threaded
  approach can also serve to get data being sent from the server to the client out of server memory more quickly,
  so it could help the memory situation.
  
- The library does not provide makefiles for other platforms such as linux, though nothing particularly special
  is required.  You can compile the sample UdpStress application using GNU by removing the driver files for
  other platforms and doing something like this:
  
    g++ -lpthread -oUdpStress *.cpp
  
- helpful hint:  Tired of the UdpLibrary being the first 15 levels of all your call stacks, but don't want to go
  to the threading model?  Event queuing mode can be used even if you are not in threading mode.  Simply turn on
  event queuing mode and add a DeliverEvents call right after your GiveTime call.  The only UdpLibrary function
  that will be on your call stack during application packet processing will be the DeliverEvents call.  There is
  a slight performance hit to do this, as incoming data will need to be copied and queued up during the GiveTime
  call, but it may make debugging a little easier.
  
- helpful hint:  If you switch to a threaded model, you may find that your destruction sequence for handler objects
  needs a bit of reworking, depending on how it was structured previously.  It used to be the case that if you
  Release() a UdpConnection that was still connected, it would callback your OnTerminated callback during the call.
  In event queuing mode, this callback would have been queued; however, because the Release call could have caused
  the destruction of the UdpConnection object, it was not possible to queue the entry.  To this end, there is a 
  behavior change in the UdpLibrary whereby OnTerminated will no longer be called when the application releases
  a UdpConnection object that is in a connected state.  Generally speaking, it is recommended that the
  application call UdpConnection::SetHandler(NULL) before releasing the UdpConnection, since it is possible that
  there are pending events in the queue that might try to deliver themselves to the application via the handler
  after the application has released the connection.  The applications held-reference to the UdpConnection object
  is effectively the applications promise to the UdpConnection that it is free to use the handler it was
  given.  The application should assume that the connection will potentially live on for a brief period of time
  after it has released it, and since the application no longer has a reference to it, there is no way the
  application could notify the connection if the handler object were then destroyed.  As such, the application should
  always clear the handler before releasing its final reference to the UdpConnection.

- made the library thread-safe, such that created objects can be accessed from multiple threads simultaneously.
  This should allow multiple threads to do UdpConnection::Send calls for example.  It will also allow
  UdpManager::GiveTime to be called simultaneously from multiple threads.  If the application does this, they need
  to be aware that only one thread will be allowed into the GiveTime function at a time.  Additionally, callbacks
  to the application are made during GiveTime, so the application needs to be prepared to receive callbacks inside
  of any thread that calls GiveTime.  If the application blocks for an extended period of time processing callbacks,
  it will cause all other threads calling GiveTime to stall as well.  To prevent this from happening and to get
  rid of the dangers of receiving callbacks on multiple threads, it is HIGHLY recommended that the application
  enable callback event queuing when they want to have a background thread do the GiveTime call.  See below for
  more details on the callback event queuing system.  If for some reason you do not want the thread-safe
  functionality of the library even included in your project, you can define UDPLIBRARY_SINGLE_THREAD and it will
  compile out.  The only reason I can think of that you might want to do this if you need to link to the single
  threaded version of the C Runtime library, which lacks the beginthread function used by the windows driver.
  
- got rid of the concepted of wrapped logical packets.  The purpose of these packets (and the associated pool), was
  to allow the application to send a LogicalPacket to multiple connections and effectively have the UdpLibrary
  hold onto a reference to that data until the data was successfully sent.  In practice, since adding coalescing
  at the reliable channel layer, the UdpLibrary very rarely would hold onto an application sent LogicalPacket and
  would instead make a copy of it into the coalesce buffer anyways.  To the best of my knowledge, few applications
  are even making use of the Send(LogicalPacket *) interface, and even fewer are sending the same LogicalPacket
  to multiple connections, and even more rare than that are times when that LogicalPacket are larger than the
  coalesce buffer.  It was only under those rare circumstances that the application would see any benefit from the
  scheme.  Unfortunately, the scheme fell apart when we went multi-threaded, as it would require that the
  LogicalPacket object itself be thread safe; which would mean a critical section object for every LogicalPacket
  created (see below for more on LogicalPacket thread safeness).  Because of this limitation, the UdpLibrary was
  basically forced to end up copying the data into its own exclusive buffers and LogicalPackets anyways.  If the
  copy is going to be made, then there is no point in having a WrappedLogicalPacket concept at all, so the entire
  system was removed, including the object definition and the associated pool management.  One nice thing about
  this change is that it also serves to simplify the code path, making maintenance easier.  If this becomes an
  issue for anybody (ie, they used this feature and can't afford the copy), then let me know, I have a backup
  scheme in mind that can be added to re-add support for this concept (through the use of a new API function for
  sending and a thread-safe version of the WrappedLogicalPacket).
  
- note: LogicalPackets are NOT thread safe.  It was deemed too costly to try and make the LogicalPacket itself
  thread safe (requiring a critical section object for ever LogicalPacket, when there are potentially millions of
  them).  This does not mean that they can't be used in a threaded environment, it simply means that care must
  be taken by the application to ensure that different threads will not access the same LogicalPacket at the same
  time.  The UdpLibrary itself will never do this, instead having LogicalPackets it uses internally strictly owned
  by only one thread at at time.  This is ensured through the use of thread-safe queues that are used to transfer
  the packets around as needed for processing.  The primary queues used for this purpose are the pooled packet queue
  and the event queue.  The application is still safe to send the same LogicalPacket to multiple connections
  simultaneously.
  
- there is a new platform dependent object called a UdpPlatformGuardObject.  This object is basically a critical
  section or mutex object that serves to protect access to resources that may be touched by multiple threads.
  There is also a UdpPlatformThreadObject.  Threading can be very complicated, and the thread-safeness of the 
  UdpLibrary is particularly complex at times.  The stress application cannot possible test all the race conditions 
  that an application may be able to produce.  When applications are doing odd things, there may be unforseen race 
  and deadlock conditions.  Over time these will hopefully be weeded out of the library.  I guess this is just a 
  heads up warning that using the threaded aspects of the library may be somewhat dangerous in this initial threaded 
  release.  (update: EQ2 is successfully using the threading aspects at this point, so most thread related bugs 
  appear to be taken care of).
  
- added a callback event queuing system.  When callback event queuing is enabled, all callbacks that would normally
  go to the application are queued by the UdpManager.  Those events are not delivered to the application under either
  event queuing is turned off, or the application explicitly calls UdpManager::DeliverEvents.  This feature allows
  the application to give the UdpManager processing time (via GiveTime) during periods of time where it is incapable
  of processing incoming packets.  For example, a client application may wish to turn on event queuing (via the
  UdpManager::SetEventQueuing call) while it is loading graphic resources, then periodically call the UdpManager's
  GiveTime during graphic loading, such that incoming data from the server is acknowledged and queued up.  When the
  application then finishes loaded and is ready to start processing packets, it can turn queuing off and the
  packets will be delivered.  This has the advantage that data transfers can occur in the background during loading
  of resources, and it can prevent the connection from getting disconnected due to inactivity in situations where
  the loading takes a very long time.
  
  The UdpManager can be configured to start in event queuing mode by setting the UdpManager::Params::eventQueuing
  to true.  It defaults to false.
  
  One of the main purposes of event queuing is to allow the application to GiveTime to the UdpManager in a separate
  thread to do the processing, then in the main application thread that processes the incoming data, call
  UdpManager::DeliverEvents to actually process the incoming data.  Because of the way the event queuing is
  implemented, the application can deliver events from the processing queue without blocking the give time
  thread from adding new events to the queue.  This will mean that while the application is processing packets,
  new packets could be being added to the queue.
  
  Queuing events comes at a price.  All incoming packet data that is queued must have memory allocated to hold
  the data until it can be processed.  This allocation process uses the existing pooled packet scheme to try and
  reduce the performance hit.  Nevertheless, there is more overhead in queuing events.  Because of this, it is
  still recommended that the application try to do everything in a single thread.  If the applications frame rate
  generally stays above 8fps (depending on data volume connection is trying to push), then it is probalby best
  to simply GiveTime to the UdpManager in the main thread and avoid queuing and other potential threading issues.

- added a few new statistics to manager statistics.  In particular, statistics on the callback event queue.

- the reliable channels processOnSend setting has been removed from the library.  The problem was that processing
  packets on send could potentially cause the application to be called-back during a Send call, which is something
  the library would like to guarantee can never happen.  The benefits from the feature were truely negligable and
  to the best of my knowledge, nobody was using it anyways.  In fact, use of the feature would likely be very
  detrimental as it circumvented coalescing at the reliable layer.  In order to insure the integrity of the
  threading model, this change was necessary.  I can't imagine it will effect anybody.

- changed the default GiveTime max polling time from 50ms to 500ms.  The logic here is that a lot of applications
  are likely making use of the default and that 50ms is probably not enough time to empty the socket buffer if the
  application spends very much time at all actually processing the packets.  It should likely be set even higher,
  and I recommend applications set this higher themselves.  If GiveTime ever falls out due to running out of time,
  then there is the possibility of a steadily building backlog of packets.  The fact that this may be happening
  may be hidden to the application, as their frame rate may remain high.  With a longer polling time, slow processing
  of packets will be reflected by a slowing frame rate.

- created a ref counting base class and had all ref counting classes derive themselves from it.  Previously, every
  class had implemented their own AddRef/Release scheme.  The new scheme has a variant that is thread safe and is used
  by objects such as the UdpManager and UdpConnection.  The new scheme also has a lot more integrity checks (asserts),
  that make sure the application is not misbehaving.  As such, you may find yourself getting an assert where you
  never used to.  Odds are this means that your application was doing something it should not have been doing.
  
- created the UdpLinkedList template and converted the library over to using it in most circumstances.  Previously,
  every linked list was just hand-coded inline for performance.  With the UdpLinkedList class still supporting the
  concept of a threaded linked list (that is, a linked list where the link information is contained in the contained
  class itself for performance reasons), the performance difference should be negligable and the code is much cleaner
  and less bug prone done this way.  It also serves to make it easier to make the classes thread-safe as it is more
  clear when the linked lists are being accessed and for what purpose.

- fixed bug where it was not properly holding a reference onto a connection object when the library was operating
  in avoidPriorityQueue mode.  Since nobody I know of uses this mode (nor should they really), this bug will not
  effect anybody.

- replaced tabs with spaces to ensure proper formatting of code regardless of users tab-settings.  If you are doing
  version control histories, this really messes things up as it will show every single line as having changed, sorry.

- changed multiple-include protection macro's to include the current namespace, such that a single compilation unit
  can potentially include two different versions of the UdpLibrary.  Without this change, inclusion of the first header
  file would effectively prevent inclusion of the second.
  
- put everything in the library under the namespace 'UdpLibrary'. Unless the application has a naming conflict 
  with one of the UdpLibrary classes (which themselves have attempted to use unique naming), the application 
  should likely just use a 'using namespace' directive to pull the UdpLibrary namespace into the applications namespace.
  The purpose of this change is to allow multiple versions of the UdpLibrary to be included in a project, since
  often times the application will include external technologies that make use of older versions of the UdpLibrary.
  To this end, as new versions of the UdpLibrary are released, the namespace will be bumped with a version number.
  It is recommended that developers make an effort to use the latest version of the UdpLibrary that is available.
  Just because the namespace is bumped does not mean that the library is then api or even protocol incompatible
  with previous versions of the library.  In fact, unless otherwise noted in the release notes, all new versions
  of the library will remain protocol compatible with older versions of the library, such that an application
  using the newest version of the library can communicate with a server using an older version of the library.
  Similarly, upgrading to a new version of the UdpLibrary will usually only involve changing the 'using namespace'
  directive to point to the next versions namespace.  Occassionally API changes will require code changes, and
  they will be noted here in the release notes as always.
  
- got rid of warnings when compiling in 64-bit compatibility mode.  Rather than convert a lot of existing stuff over
  to using size_t instead of int, I decided to simply impose a limitation on the library that it cannot send a
  logical packet larger than what an 'int' can hold, which means 2gb on most platforms.  This seems like a very 
  reasonable limitation.  Even if the UdpLibrary is being used on a 64-bit platform, it seems very unlikely that 
  the application would ever have a single packet larger than 2gb.  For protocol reasons, packet headers and such
  can't handle logical packets larger than 2gb anyways.
  
- changed typedefs for uchar, uint, ulong, and ushort to be udp_uchar, etc..., such that when applications choose
  to pull the namespace into the application entirely, they don't get conflicts.  Existing applications wishing to
  upgrade to the latest version of the UdpLibrary will need to change their handler callback functions to take
  udp_uchar instead of simply uchar.  If the application has a type uchar defined itself, then in theory no change
  would be required; however, it is recommended that you go to the trouble of renaming any uchar usage in the
  application to match the new udp_uchar as appropriate for code clarity when dealing with the callback functions.
  
- just a quick administrative note:  Applications are welcome to use some of my internal objects, such as the
  HashTable or the PriorityQueue; however, those objects are not considered part of the formal UdpLibrary API, and
  as such, they may change down the road or be removed from the project entirely.  For example, I no longer include
  a Deque object that I once had.  I recommend that applications copy those kinds of utility objects out into their
  own source base, just to prevent future issues.  I will document any changes to internal objects here in the release
  notes if the object is of a nature that I think somebody might be using it externally.
  
- (update: the whole concept of wrapped packets has been removed in future versions)
  fixed bug where Params::wrappedPoolMax was not getting initialized properly.  This probably would have little to
  no effect on anybody, unless they were sending the same large LogicalPacket to multiple connections at the same
  time.  Even then, the net result would be that it might cause a few more allocations to occur.

- made a major overhaul to how the library interacts with platform dependent OS calls.  In particular, the library
  now internally uses a UdpDriver object to access all OS dependencies.  There is a Windows, Linux, and Sparc version
  of the driver object.  You should include the appropriate .cpp file for the platform you are running on.  For
  Windows, this would be UdpDriverWindows.cpp.
  
- as part of the overhaul to be driver-based, I also took the opportunity to separate all the major objects into their
  own files, instead of everything being in UdpLibrary.cpp.  In addition to the driver file listed above, you will
  also need to add the following files to your project: UdpLogicalPacket.cpp, UdpManager.cpp, UdpConnection.cpp,
  UdpReliableChannel.cpp, UdpMisc.cpp, as well as their associated .h files of the same name.  You will also need to
  add UdpDriver.h and UdpTypes.h to your project or source-control.
  
- once converted to a driver based model, it opened the door for allowing the application to hook the driver.  The
  driver must be hooked during UdpManager construction, by having the application create their own UdpDriver derived
  object and passing it into the UdpManager via the Params::udpDriver parameter.  If a udpDriver parameter is specified,
  the UdpManager will use that driver object, instead of creating the default UdpPlatformDriver object and using that.
  The application owns the driver object and the driver object must not be deleted by the application until the
  UdpManager that is using it is destroyed.  A common thing to do with an application driver would be to have it create
  the UdpPlatformDriver and simply chain every call on through to the platform driver.  This gives the application
  the opportunity to do other stuff as it desires.
  
- included with the library is a sample application-driver called UdpDriverRecord.  Normally this file would not need
  to be included in the project, unless you application plans on using it.  Odds are, the application will have to
  customize this driver a bit to make it useful for its needs.  What this sample driver does, is record all the activity
  of the driver to a specified file.  There is a corresponding UdpDriverPlayback, that does the reverse, simulating
  the response to various calls from the file.  As long as the application is making the exact same series of calls,
  the playback will completely replicate what was recorded, completely from the file alone.  If the application were to
  extend this concept to other input, such as user-input, then it would be possible to record and completely playback
  a play session, without ever actually talking to any server on the playback.  This can be very useful for debugging
  and performance testing.  The udpstress application makes use of this driver.

- fixed a bug where if you released the UdpManager while it had active connections, it would destroy those connections,
  but if those connections attempted to send something to other connections that were not yet destroyed during
  their OnTerminated callback, the other connections would effectively be trying to use a UdpManager that had
  been partially destroyed.  The reason it had been partially destroyed is because it had destroyed it's pooled
  packet system without clearing the variables, leaving it in a state at the time where it though it still had
  valid packets in the pool to use.  To fix this problem, I cleared the pool variables after destroying the pool
  to reflect the fact there was no pool packets available.  More importantly, I moved the code that tells everybody
  to disconnnect because their manager is being destroyed to the top of the UdpManager destructor.  In this manner,
  everybody is disassociated from the manager before the real UdpManager destruction process actually starts to
  take place.

- added re-entrancy protection to UdpManager::GiveTime function.  It is illegal to call GiveTime when inside of
  a callback from the UdpLibrary.  I considered asserting when this happened, but for now I simply ignore the nested
  call.  The UdpManager GiveTime should generally only be called from your main loop.  Calling it from inside of a
  callback (like inside OnRoutePacket), used to cause weird results and memory corruption.  If you think about it,
  it doesn't make sense to do that anyways, since calling GiveTime is basically giving the manager permission to
  call you back at that point, which wouldn't make much sense if you were already in a callback (generally).  The
  bigger problem is the internal reliable-channel object can't handle it at all, and ends up double-delivering data
  and other wierdness.

- initialized UdpConnection::mConnectAttemptTimeout in server-side UdpConnection objects.  This actually has no
  effect, since the variable is not used unless the connection is in a negotiating state, which doesn't happen on
  the server side of connections, but it's good housekeeping.

- moved UdpManager::Params::Params constructor into the header file as a convienence for one of the library users
  who needed to construct Params objects in a module that did not link in the UdpLibrary.cpp file.
  
- fixed a bug where a connection could mis-schedule itself for processing time during connection negotiation, causing
  it to not attempt to send a connect-request packet for up to 10 minutes.  This would occur because it was possible
  when in a cStatusNegotiating state to make it through UdpConnection::InternalGiveTime without it overriding the
  default max-scheduling time of 10 minutes.  In theory this could happened anytime that the connection was given
  time before it was read to send a connect-request packet (or resend a connect-request packet).  In practice, since
  that is the only thing ever scheduled during negotiations, it was impossible for InternalGiveTime to be called
  when it wasn't ready to send the next packet.  However, since mLastSendTime starts out at zero, it was possible
  on some platforms (depending on the implementation of the UdpMisc::Clock function) for UdpMisc::ClockElapsed(0) to
  return an elapsed-time that is less than the connect-attempt delay.  This would mean that it would never even send
  the initial connect-request packet.  Thanks to Don Neufeld and the Planetside team for finding this bug.

- Modified the ObjectHashTable template to allow it to support the concept of an object existing in multiple hash
  tables more gracefully.  The UdpLibrary was enhanced to use the new schema.  Any existing use of the ObjectHashTable
  remains completely compatible.

- Changed EstablishConnection call to allow the port number to be specified as part of the address by appending
  it with a ":port".  If this syntax is used, the serverPort parameter should be set to 0 and is ignored.  This should
  not break any backward compatibility with how the call previously worked, but will allow applications to generally
  treat connection-addresses as a single string for convienence.

- Added UdpMisc::GetSelfAddress function.  This function will return the IP-address of the local machine.  This is
  similar to UdpConnection::GetLocalIp only it can be done before a socket is created.  Additionally, GetLocalIp only
  works after there has been traffic on the socket.  Since machines can and often do have multiple IP addresses, this
  function also allows you to specify a preference for a non-routeable IP address.  By default, it will exhibit a
  preference for a routeable IP address.  In this manner, this function may be able to be used in distinguishing
  between front-end (internet-facing) IP addresses and back-end (internal) IP addresses.

- Changed code to include winsock2.h instead of winsock.h.  This may require that you link to ws2_32.lib instead of
  wsock32.lib.  The winsock version number that gets requested is still 1.1 by default, so the implementation should
  still work fine on older boxes that do not support winsock2.  If you wish to require winsock2 functionality, you
  can define UDPLIBRARY_WINSOCK2 to make it request version 2.0 of winsock.  If this causes anybody grief, let me know
  and I will fix it.

- API CHANGE:  got rid of the line-simulation parameters from the UdpManager::Params struct that is used to initialize
  the library.  In it's place I added a UdpManager::SimulationParameters struct and a corresponding 
  UdpManager::SetSimulation and UdpManager::GetSimulation command.  The advantage of doing it this way was the system
  now supports changing the line condition simulation parameters on the fly.  So you can add debug commands that allow
  you to toy with these while playing to see what kind of experience a typical user might be seeing.  If you did not use
  these simulation parameters, this API change will not effect you.  If you did use them, the change is quite trivial.
  
- added simulateOutgoingLatency and simulateIncomingLatency parameters.  These parameters (like the other simulation 
  parameters) allow you to simulate various line conditions.  In this case, it simulates simple latency on the 
  outgoing/incoming data.  If you specify 100ms for this parameter, it will delay every packet being sent by 100ms.
  It was a bit of an oversight that this functionality wasn't including with all the other simulation stuff in the first place.
  Simulating latency is not terribly efficient as it causes a dynamic allocation to hold onto every packet until it is
  time for actual delivery.

- FILE CHANGE: renamed all .hpp extension to .h.  The use of .hpp is an outdated convention that used to be used back in 
  the CFront days.  Renamed some of the internal headers files while at it for consistency, should make identifying
  UdpLibrary related stuff easier.  This change will require that that some minor changes be made to the users source
  in order to integrate this latest version (just change what you include).
  
- changed ObjectHashTable::Remove function to not take the hash value as the second parameter as it was unneccessary
  since the object being removed contained the hash value.  Also made the string hashing functions take const.
  
- reorganized the ObjectHashTable object template quite a bit to make it more consistent with other templates I am
  using.  The main changes are 1) The template type is the base type, not a pointer to the base type like it used to be.
  2) The HashTableMember base class that people derive from is now a template itself, preventing the need for 
  type casting in the implementation, and as it turns out, prevents a bug that was occurring.  I can't quite explain it,
  but the upcasting that was occurring in the implementation was apparently messing up in some circumstances (ie. it
  wasn't adjusting the pointer appropriately).  Templatizing it seems to have fixed the problem.  None of this should
  matter to you unless you used the UdpLibrary's hash table for some reason in your own code.  If you did, the changes
  are fairly trivial, email me if you have any questions.
  
- added helper functions UdpManager::GetLocalString, UdpConnection::GetDestinationString, and
  UdpConnection::GetDisconnectReasonText.  These functions return displayable strings equivalent to their
  non-string counterparts.  They were merely added for convienence since doing things such as logging
  the ip:port and disconnect-reason are such common tasks.

- made a slight optimization to the ObjectHashTable Reset function.

- made a slight change in the ICMP error processing under Linux.  It now obeys the ICMP error type indicator
  properly, before it was ignoring it.  In practice this didn't make much difference, as none of the other
  common ICMP error types used the ICMP code field, which was being checked.  Also changed it such that it would
  process as many ICMP errors as it found on a given iteration.  Before, it would only process one ICMP error
  per UdpManager::GiveTime, which meant that it might not be able to keep up with the ICMP error rate in some
  circumstances.

- changed the algorithm for how it resets the flow control window after packetloss.  The problem was that on high
  bandwidth connections when we would lose packets, we would likely lose dozens of packets.  With each one resetting
  the flow-control window, what effectively happened is the flow Reno algorithm wasn't really doing it's job of
  doing a slow pull-back, since each lost packet was applying the logic in succession, meaning it didn't take very
  many packets for it to pull all the way back to near starting levels.  This change basically causes it to only reset
  the flow control window once per round-trip-time, such that accelerated resends (the ones likely to happen on
  high-bandwidth connections) would not cause it to pull back too far.  The net result, much faster recovery to full
  send speed in situations where the destination or network was overloaded.  This also helps substantially when there
  is a buffering node inbetween the two connections, as is commonplace with cable-modem, DSL, and modem links.
  Experiments with my cable-modem provider shows that they are using approximately a 256k buffer.
  
- changed algorithm to make it not reset the slow-start threshhold when the pipe goes dry.  It still resets the 
  congestion window.  The problem with reseting the slow-start is it would cause a newly formed connection to
  immediately reset the slow-start threshhold to the largest congestion window size, which would have been the
  minimum congestion window size at that point in time.  The slow-start threshhold will grow larger after getting
  smaller in situations where the congestion-control managed to increase the window size substantially above the
  slow-start level.  Combined with the above change regarding flow-control window resets, this should result in
  the library ramping up to full send speed substantially faster.
  
- changed the recommended congestionWindowMinimum for server-to-server connections from 50000 down to 20000.  Turns
  out that 50000 was probably a bit too aggressive unless you knew for sure that you had the entire local network
  to yourself for sending data.  It would depend on the GiveTime frame-rate as well.  If you are giving time very
  quickly (say 50+ times per second), then having too large a congestion window minimum could cause it to saturate
  the network and cause packetloss issues.

-----------------------------------------------------------------------------------------------------------------
2003-6-26
-----------------------------------------------------------------------------------------------------------------
- sorry for the quick release, but a fairly serious bug was found that needed to be released to everybody.

- fixed a serious bug in the reliable-channel object that would cause the pipe to stall until the application sent
  more data (even if there was pending data in the queue).

- made a slight change to the way it handles protocol version numbering.  This doesn't effect anything, it just causes
  that it will now establish connections with versions of the library that have specified a different protocol version
  number.  It now tracks what protocol-version the other side it is connected to is using, such that in the future if
  we want to make protocol changes, the library can be programmed in a manner that newer versions of the library could
  talk backwards compatible to applications using an older protocol.  Once this change has filtered its way out to all
  applications anybody might talk to (in a few months I suppose), then we will be free to start making some minor
  protocol enhancements to the library without messing up compatiblity.  How it will basically work is, both ends of the
  connection will operate at the lowest-common protocol version, regardless of who initiated the connection.  This simply
  puts a burden on future protocol development to require that it still maintain the ability to talk older protocols
  if needed.  This shouldn't be too hard, as protocol enhancements I have planned are very minor new features (like
  the ability for the application to specify an application-level protocol version during initial connection
  negotiation).

- added new configuration parameter, lingerDelay.  This option specifies how long the UdpManager destructor will block
  before destroying the socket in order to give the OS time to finish flushing the socket-buffer.  Unforunately, unlike
  TCP, the OS will not do the lingering functionality for us on UDP sockets, so we have to sort of fake it.  The main
  reason for doing this is such that the final-terminate packet has a chance of actually going out the wire before
  the socket is closed, particularly on client-side connections.  I have set the default for this option quite low
  at 10ms, and that is far better than giving it no time at all, but if you don't mind the UdpManager destructor
  blocking for longer, I would recommend setting it to more like 100ms to 500ms, as it will increase the likelyhood
  of a timely termination, and increase the odds of the other side being properly notified of the disconnect reason.

- changed the disconnect-reason handling code such that the first reason for disconnect becomes the definitive reason.
  Before if the connection was terminated due to an ICMP error (for example), then the application explicitly terminated
  it after that as well (for some reason), the reported reason would be cDisconnectReasonApplication.  Now, it will
  preserve the first reason for the connection going dead and never let a subsequent reason override that.

- added one more disconnect reason, cDisconnectReasonApplicationReleased.  This is virtually identical to
  cDisconnectReasonApplication, only it means that the application 'Release'd the UdpConnection object while it was
  in a cStatusConnected state.  Since the connection-object is effectively destroyed when this reason is set, the only
  way a query could return a reason of this sort is if you were asking for why the other side terminated.

- fixed bug where the library was messing up if the connection was terminated (disconnected) during an encryption
  or decryption callback.

- tiny optimization to make it not reschedule the reliable channel for time in situations where there was already
  data pending in the coalesce buffer at the time of the send.  In practice this will make no difference at all.


-----------------------------------------------------------------------------------------------------------------
2003-6-11
-----------------------------------------------------------------------------------------------------------------
- There are a lot of significant changes in this release.  CPU usage, throughput ability, and memory-usage
  have all been improved substantially, particularly for high-stress server-to-server type environments.
  The optimizations are such that old settings that used up a lot of memory can be changed to more reasonable
  values without adversely effecting throughput ability or CPU usage.  To make things simpler in this regard, 
  below is a list of recommended settings for different types of connections.  If you have connections of
  different types, ideally you would setup your architecture such that the different types were managed by
  different UdpManager's, such that optimal settings can be applied to both.  As always, you should not have
  more managers than is needed (perhaps one for all client connections and one for all interserver connections).
  Settings not specified below should be left at their default.  It is still important that you keep the GiveTime
  frame rate reasonably high.  For high-bandwidth server to server connections, I recommend at least 20, 8 minimum.
  If your frame rate drops below that and you are sending more than 500k/sec of data, then you better seriously
  consider putting the UdpManager into it's own thread.  In a future release (next release probably), I plan on
  including a threaded-wrapper version of the UdpLibrary to make this painless.  Until then, you may wish to
  talk to the SWG team, which has already done this, and may be able to provide you with some getting-started code.

  Server side settings for incoming player connections (ie. clients connecting are relatively low bandwidth)
  (total bandwidth per connection is intended to be low)
  -----------------------------------------------------------------------------------------------------------
    Params::maxConnections                    set as appropriate
    Params::port                              set as appropriate
    Params::outgoingBufferSize                set to 1mb-4mb
    Params::incomingBufferSize                set to 1mb-4mb
    Params::keepAliveDelay                    set to 15000 (15 second keep-alives generally do the trick)
    Params::noDataTimeout                     set to 46000 (46 seconds, typically just over 3 times client side keepAliveDelay)
    Params::reliableOverflowBytes             set to 2mb (however much you are willing to let them have backlogged)
    Params::hashTableSize                     set to 10 times max expected connections
    Params::pooledPacketMax                   set to roughly 5 times max expected connections, but rarely over 10000
    Params::crcBytes                          set to 2
    Params::bindIpAddress[32]                 set as appropriate (I like to leave it blank)

    Params::clockSyncDelay                    leave at default of 0 (client side will do clock syncing)
    Params::portRange                         leave at default
    Params::packetHistoryMax                  leave at default
    Params::portAliveDelay                    leave at default of 0
    Params::replyUnreachableConnection        leave at default of true
    Params::allowPortRemapping                leave at default of true
    Params::allowAddressRemapping             leave at default of false
    Params::icmpErrorRetryPeriod              leave at default of 5000
    Params::oldestUnacknowledgedTimeout       leave at default of 90000 (or set more aggressively even, down to 30000)
    Params::maxDataHoldTime                   leave at default of 50 (or set longer up to 100 possibly)
    Params::maxDataHoldSize                   leave at default of -1 (meaning same as raw packet size)
    Params::maxRawPacketSize                  leave at default of 512
    Params::avoidPriorityQueue                leave at default of false
    Params::pooledPacketInitial               leave at default of 0 (or set to pooledPacketMax for extra efficiency at cost of memory)
    Params::pooledPacketSize                  leave at default of -1 (uses same size as raw packet size, this is critical)
    Params::wrappedPoolMax                    leave at default of 1000
    Params::processIcmpErrors                 leave at default of true
    Params::connectAttemptDelay               leave at default (irrelevant for server side)
    Params::reliable[0]                       leave all settings at defaults


  Server-to-server settings for LAN connections (ie. connections are local on high-bandwidth)
  (total bandwidth per connection is intended to be high)
  (same settings used regardless of who intiates connection)
  -----------------------------------------------------------------------------------------------------------
    Params::maxRawPacketSize                  set to 1460
    Params::maxConnections                    set as appropriate
    Params::port                              set as appropriate
    Params::outgoingBufferSize                set to 4mb
    Params::incomingBufferSize                set to 4mb
    Params::keepAliveDelay                    set to 15000 (15 second keep-alives generally do the trick)
    Params::noDataTimeout                     set to 61000 (61 seconds, typically just over 4 times client side keepAliveDelay)
    Params::reliableOverflowBytes             set to 10mb (however much you are willing to let them have backlogged before disconnecting)
    Params::hashTableSize                     set to 10 times max expected connections
    Params::pooledPacketMax                   set to 5000
    Params::crcBytes                          set to 2
    Params::bindIpAddress[32]                 set as appropriate (I like to leave it blank)
    Params::icmpErrorRetryPeriod              set to 2000 (optional)
    Params::allowPortRemapping                set to false (optional)
    Params::oldestUnacknowledgedTimeout       set to 30000 (longer for debugging tolerance)
    Params::maxDataHoldTime                   set to 0 (this is critical)
    Params::reliable[].maxOutstandingBytes    set to 2mb
    Params::reliable[].maxOutstandingPackets    set to 4000
    Params::reliable[].resendDelayAdjust        set to 1500
    Params::reliable[].congestionWindowMinimum  set to 20000

    Params::reliable[]                        leave all other settings at defaults
    Params::clockSyncDelay                    leave at default of 0 (client side will do clock syncing)
    Params::portRange                         leave at default
    Params::packetHistoryMax                  leave at default
    Params::portAliveDelay                    leave at default of 0
    Params::replyUnreachableConnection        leave at default of true
    Params::allowAddressRemapping             leave at default of false
    Params::maxDataHoldSize                   leave at default of -1 (meaning same as raw packet size)
    Params::avoidPriorityQueue                leave at default of false
    Params::pooledPacketInitial               leave at default of 0 (or set to pooledPacketMax for extra efficiency at cost of memory)
    Params::pooledPacketSize                  leave at default of -1 (uses same size as raw packet size, this is critical)
    Params::wrappedPoolMax                    leave at default of 1000
    Params::processIcmpErrors                 leave at default of true
    Params::connectAttemptDelay               leave at default


  Client side settings for player connections (ie. client is connecting over the internet to the server)
  (total bandwidth per connection is intended to be low)
  -----------------------------------------------------------------------------------------------------------
    Params::maxConnections                    set as appropropriate (probably something small like 5)
    Params::port                              set to 0 (let client pick port)
    Params::outgoingBufferSize                set to 64k (default I believe)
    Params::incomingBufferSize                set to 64k (default I believe)
    Params::keepAliveDelay                    set to 15000 (15 second keep-alives generally do the trick)
    Params::noDataTimeout                     set to 46000 (46 seconds, typically just over 3 times client side keepAliveDelay)
    Params::reliableOverflowBytes             set to 512k (however much you are willing to let them have backlogged)
    Params::hashTableSize                     set to 10 times max connections
    Params::clockSyncDelay                    set to 60000 if you want packetloss stats or clock-sync features, otherwise 0
    Params::pooledPacketMax                   set to 50
    Params::crcBytes                          set to 2
    Params::maxDataHoldTime                   set to 20 (more agressive for client to server data generally)
    Params::packetHistoryMax                  set to 5 (to save memory on client)

    Params::bindIpAddress[32]                 leave at default
    Params::portRange                         leave at default
    Params::portAliveDelay                    leave at default of 0
    Params::replyUnreachableConnection        leave at default of true
    Params::allowPortRemapping                leave at default of true
    Params::allowAddressRemapping             leave at default of false
    Params::icmpErrorRetryPeriod              leave at default of 5000
    Params::oldestUnacknowledgedTimeout       leave at default of 90000 (or set more aggressively even, down to 30000)
    Params::maxDataHoldTime                   leave at default of 60 (or set longer up to 100 possibly)
    Params::maxDataHoldSize                   leave at default of -1 (meaning same as raw packet size)
    Params::maxRawPacketSize                  leave at default of 512
    Params::avoidPriorityQueue                leave at default of false
    Params::pooledPacketInitial               leave at default of 0 (or set to pooledPacketMax for extra efficiency at cost of memory)
    Params::pooledPacketSize                  leave at default of -1 (uses same size as raw packet size, this is critical)
    Params::wrappedPoolMax                    leave at default of 1000
    Params::processIcmpErrors                 leave at default of true
    Params::connectAttemptDelay               leave at default
    Params::reliable[0]                       leave all settings at defaults


- added reliable-channel level coalescing support.  This is a major feature enhancements to the UdpLibrary.
  Originally, the UdpLibrary only did coalescing at the low-level, such that it could combine together
  unreliable, reliable, and internal data into the same physical packet.  This is still a vital and key
  feature of the UdpLibrary.  Not coalescing up at the higher level of the reliable channel had its
  problems: 1) it required that ACK packets on a per-logical packet basis, meaning that if
  lots of tiny reliable packets were being sent, there was a bit more ack-overhead in the process.  This
  overhead is generally negligable except in the most extreme circumstances.  2) it required that the
  reliable channel object track all those outstanding packets, which proved to be a bit of a performance
  burden.  3) it required the reliable channel object allocated LogicalPacket objects to hold onto each
  individual application packet (in the usual case where the application wasn't directly sending
  LogicalPacket objects).  To make matters worse in this regard, it ended up getting these objects from
  the memory pool, which often effectively meant that tiny applications packets were stealing much
  larger pooled packets and wasting memory.  The new scheme has the advantage that many reliable sends
  will now be performed without an allocation and without using up a pooled packet.
  
  One nice effect of this change will be that a much smaller pool needs to be reserved.  Due to a
  limitation in the low-level coalescing, if your application sends lots of medium sized packets
  (256 to maxRawPacketSize bytes), then you may see a significant reduction in physical packets sent
  per second.  This change may sound like it would have a drastic effect on the protocol, but that is not
  the case, we remain protocol compatible with old version.  This is because the underlying protocol
  has always supported the concept of a group logical packet.

  The benefits of this feature will be most evident in high-bandwidth server-to-server connections.  You
  should make sure you pooledPacketSize = maxRawPacketSize, and you should be able to reduce the size of
  your pool substantially.

  Internally, the reliable channel will coalesce things up to the fragment size, which defaults to being
  the same as the maxRawPacketSize.  There is no hold-time for coalescing.  The next time the connection
  is given time (next time manager is given time), if there is flow-control-window space available, it
  will flush the coalesce buffer in an attempt to use it up.  So, it will effectively coalesce application
  sends until there is an opening in the flow-control-window and GiveTime is called.

  The only disadvantage I can see to leaving this feature enabled (it is configurable in
  UdpManager::Params::reliable[].coalesce) is for client-side low-bandwidth connections.  In those situations,
  it is important that the ACK traffic back to the server coalesce with application data.  This will occur
  even if this feature is enabled, but because the low-level coalescer is incapable of coalescing packets
  larger than 256 bytes, it is possible the reliable-sends from the client headed to the server might
  result in more physical packets per second.  Even then, I don't see it being a performance issue,
  so I would leave it enabled.  The configurability was largely added such that the library could be
  configured to operate as before, just in case there were some unforseen issues that cropped up with this.

  It's worth noting, that configuring the reliable channel to processOnSend will effectively circumvent
  any coalescing that you might have been getting.  (update: processOnSend was removed as a feature)

- if reliable-channel coalescing is used (it defaults to ON), then the pooledPacketSize should be set
  to the maxRawPacketSize.  This is critical to performance.  The previous recommendation of setting
  it to the typical packet size won't work anymore, since it is now coalescing at the reliable channel
  level, effectively increaseing the size of packet it will grab from the pool typically.

- made substantial CPU-usage improvements to the reliable channel resend algorithm in situations where
  thousands of outstanding packets needs to be supported to achieve server-to-server throughput.
  This does not effect the protocol in any way, just uses slightly less memory to manage the process and
  potentially substantially less CPU.

- made a slight change to the reliable channel fast-recovery algorithm (based on the TCP Reno algorithm)
  When we notice that packetloss is selective (ie. some packet after the lost packet is acked and serves
  as a notice to do an accelerated resend on the other), we used to shrink the flow-control window
  by 50% (as opposed to non-selective loss which completely resets it).  We now only shrink the window
  by 33%, in an attempt to make for an even faster recovery and less hiccup.  I don't believe being this
  aggressive will be an issue, as we know more about the nature of the circumstances than Reno does, since
  we have selective acks.

- fixed a nasty design flaw that was causing the maximum effective reliable logical packet transfer rate
  to be limited to 256 times the number of GiveTime iterations per second.  When small packets are being
  sent, this can turn into a serious limitation, particularly on server-to-server communications where
  these packet rates potentially get very high.  The limit has been increased to 8192, which should be
  plenty large for even the highest bandwidth connections.  Note: this fix causes that an additional
  31k of stack space is used during the GiveTime call -- I am doubting this will cause anybody grief.

- improved the pooled packet scheme.  The old scheme used to fall back to standard SimpleLogicalPackets
  after it has created the maximum number it was allowed in the pool.  The new scheme always creates
  packets that can go into the pool when they are returned (if possible size wise).  It then releases
  packets that are returned to the pool if the pool is already at its max.  So as before when max
  represent the max anywhere, the max now represents the max it will hold onto in the available queue.
  This will make a big performance difference in situations where just one of many connections is
  backlogging.  In the old scheme, a backlogging connection could eat up the entire pool, leaving
  all other connections left doing allocs and frees of their packets.  With the new scheme, the
  bad connection can't monopolize the pool, as when the bad connection finally clears up and release
  all those packets, those packets will be destroyed even though they were gotten from the pool, because
  the pool available will have likely grown as appropriate.  Between this change and the reliable
  coalescing, the pooledPacketMax setting should be set MUCH smaller than it previously was.  I
  wouldn't set it to over 5000, even for server-to-server connections.  Additionally, I would set
  pooledPacketInitial to under 1000, since the vast majority of the time I don't see this ever
  being exceeded.

- changed the default setting of pooledPacketMax down to 1000 (from 2000), in order to reflect the
  recent optimizations noted above and the lack of need for a large pool most of the time.

- changed the default setting of pooledPacketSize from 256 to -1.  -1 means use whatever size the
  maxRawPacketSize is set to.  As a general rule, you should never change this setting from this.
  Now that the reliable channel is coalescing, all allocations from the pool are of maxRawPacketSize.
  If you set the pool size smaller than this, then odds are the pool will be completely worthless.
  There are some odd cases where you may wish to set it higher, depending on the nature of the
  packets your application sends.

- (update: the whole concept of wrapped packets has been removed in future versions)
  got rid of the deque object that was used internally to track outstanding LogicalPackets that were
  queued up on the reliable channel.  Since we put in coalescing at the top, all packets smaller than
  the maxRawPacketSize were getting coalesced into a larger logical packet anyways, meaning that the
  logical packet that we owned was extremely unlikely to be shared.  If we knew for a fact that all the
  logical packets we had queued were not shared by other connections, then we could get rid of the deque
  object and have a much faster and simpler linked-list scheme.  Since shared packets are now so rare,
  I decided it would be worthwhile to switch to a linked list and in situations where the logical packet
  is shared, I create a WrapperLogicalPacket object to effectively make it appear unique from a linked-list
  management point of view.  This wrappers are actually gotten from a pool owned by the UdpManager.  You
  can set the size to allow this pool to grow with Params::wrappedPoolMax.  I recommend leaving this
  value at the default of 1000, though if you are a server doing a lot of large shared packets, then it
  may be worth your while setting this to a larger value.  This optimizations gets rid of the nasty
  deque expansion problem that was eating up so much CPU when backlogging occurred.

  Note:  This also means the PointerDeque.hpp has been removed from the UdpLibrary as it is no longer
  used.  You can remove this object from your build.

- added ack-deduping support.  This can be disabled (Params::reliable[].ackDeduping), but defaults to
  enabled (true).  I really can't think of any reason you would ever want to turn it off.  What it does
  is cause ack-packets in the low-level coalesce buffer to be deduped.  There are no performance
  implications (in fact, it is faster when enabled).  How it works is if the library is sending an
  ack-all packet and there is a previous ack-packet of some sort still sitting in the low-level
  multi-buffer, then it will replace the existing ack instead of appending  one onto the multi-buffer.
  In high-bandwidth situations (or if reliable coalescing is disabled), this can result in an appreciable
  bandwidth savings.  The only situation where you might want to disable this is if for some reason you
  were counting on the additional acks to intentionally overflow the multi-buffer and force it to send
  rather than waiting for multi-buffer timeout.  But, that doesn't make a whole lot of sense.

- changed the default value of maxDataHoldSize to -1 (used to be 512).  Setting it to -1 now causes it
  to use the maxRawPacketSize for this.  Generally you should always be wanting to coalesce to as
  large of a packet as is allowed.

- added new configuration parameter, icmpErrorRetryPeriod.  This setting allows you to not terminate the
  connection at the first sign of trouble (ie. an ICMP error), but instead wait for a period of time in
  hopes that the situation will correct itself.  Normally, a single ICMP error packet is sufficient cause
  to terminate a connection.  However, there are situations where it may be desireable to tolerate ICMP
  errors for a few seconds as sometimes these situations resolve themselves.  In particular, the new
  port-remapping feature (see below) requires that some tolerance be set in this regard, as ICMP errors
  will likely occur for a short period of time while remapping is occurring.  Although it changes
  previous behavior of the library, I have decided to make this new setting start out at 5000ms.  This
  means that ICMP errors for port unreachable and such will not occur for at least 5 seconds, whereas
  before they may have occurred nearly instantly.  If you want the previous behavior, setting this value
  to 0 will cause it to disconnect on even a single ICMP error.  Once the first ICMP error is received,
  the timer is started.  If a subsequent ICMP error comes in after the timeout period has expired, then
  it will be processed and the connection will be closed.  Once a successful packet is received on the
  connection, the ICMP timeout period is reset, such that a subsequent ICMP error will be treated as if
  it were the first.

- added new configuration parameter, allowPortRemapping.  This setting allows the UdpLibrary to effectively
  change the port-number associated with a particular connection dynamically on-the-fly.  Now, normally
  this would never happen, but sometimes a user may be going through a NAT router that feels the need to
  change the associated mapping mid-session.  Normally when this occurs, connections are simply lost.
  However, due to a bug in the #1 selling Linksys router whereby it does this remapping every 10 minutes,
  we have decided to add this feature to deal with it.  This feature is also generally useful in other
  situations.  For example, with the EQ channel-chat system, the user often goes for quite a while without
  sending or receiving any messages.  Many NAT routers expire the port-mappings fairly quickly if data
  is not being sent.  The usual solution to this problem is to configure it to send keep-alives, and
  generally that works.  In the case of the EQ channel-chat, we have keep-alives configured to go out
  every 45 seconds, which keeps 99% of NAT routers alive and happy.  The other 1% seem to expire after as
  little as 30 seconds.  We put in an override setting in EQ to have it send the keep alives every 15
  seconds instead, but it is a less than ideal solution as it requires the user changing things.  We 
  don't want to configure everybody to send keep-alives that frequently, as there are 100,000 connections
  to the server, and the keep-alives alone start to really add up.  This port remapping system will
  effectively allow the mapping to expire and the connection never miss a beat.  See allowAddressRemapping
  for a discussion of security concerns.  This parameter defaults to 'true' or enabled.  While this
  feature adds some new packetting, it remains protocol compatible with old versions.  You will need to
  upgrade both ends of the connection for this feature to be available though.

- added new configuration parameter, allowAddressRemapping.  This setting is almost identical to the
  allowPortRemapping setting, only it takes the concept one step further, and allows for the IP address
  itself to be changed on-the-fly as well.  Normally when only port remapping is enabled, if the IP address
  is changed, it will not be able to pick up on it.  By default, this parameter is 'false' or disabled.  It
  is highly unlikely that under any sort of normal operating conditions this will occur.  About the only
  reason I can think of for this is if you wanted to be so tolerant as to allow a modem user to disconnect
  and reconnect from their ISP and maintain their connection.  The biggest danger in enabling this feature
  is the potential for somebody to hijack somebody elses connection.  This is extremely unlikely however
  as the UdpLibrary effectively uses a 64-bit randomly generated key to authenticate any request for
  a remapping to occur.  To hijack a connection, somebody would have to guess what that 64-bit key value
  is for a particular IP address.

- added a new static UdpConnection::DisconnectReasonText function that will translate a disconnect reason
  into a displayable reason-string to make logging of disconnect reasons easier to read.

- put in safety checks to try and identify packets that are corrupt for some reason.  When one of these
  packets is spotted, the application is notified via the UdpConnectionHandler::OnPacketCorrupt callback.
  Statistics are also kept on the connection and on the manager regarding how many of these occur.  If you
  have CRC bytes enabled, then the odds of a corrupt packet making it through the check are extremely low.
  In this case, odds are the actual cause of the corruption is intentional packet tampering by the user;
  that is, they modify the packet and touchup the CRC so it passes.  This is why we callback the application
  as they may wish to log this event as a means of monitoring possible cheating.  This new callback provides
  the application with the packet data at the time the corruption is sensed.  This means that if the
  corruption is sensed after the decryption has occurred (say, by the multi-packet unpacker), then the
  data passed to the application will reflect the decrypted packet.  Additionally, the callback provides
  a reason why the packet was deemed corrupt.  If you are seeing a lot of corrupt packets for some reason,
  it may be worth logging the reason and trying to find a pattern (I also like to log the IP of where it
  came from, as often times bad packets tend to come from the same IP over and over, often due to
  tampering).

- added new configuration parameter, reliableOverflowBytes.  Normally, you can send an unlimited amount
  of data to a connection and it will never overflow, instead it will queue up the data until it runs
  out of memory and crashes.  In the past, it has been the applications responsibility to periodically
  check how many bytes are pending using UdpConnection::TotalPendingBytes and take appropriate action.
  This new parameter causes the UdpLibrary to do this check for the application, and if a connection
  ever overflows this amount (all reliable channels added together), then the connection is disconnected
  with a reason of cDisconnectReasonReliableOverflow.  The default setting for this parameter is zero, 
  which disables this check and makes it operate as it always has.  The check for an overflow condition
  does not occur at send time as this would result in a callback to the application at an illegal time;
  instead, the overflow condition is checked the next time the connection object is given time.

- added a new sample-program to the distribution.  This program is called 'udpstress' and simulates what
  one might see in a backend server-to-server cluster implementation.  Each udpstress client that starts
  up connects to one of the existing udpstress clients that is already running, and effectively adds itself
  to the cluster.  Each node in the cluster transfers data to every other node in the cluster at a compile
  time configurable rate.  Since everybody is connecting to everybody else, this stress program operates as
  both a client and a server.  Unlike the other sample program, it fully takes advantage of the new
  callbacks that were added and more accurately reflects the proper way of setting up an architecture.
  This program is also portable to other platforms.

- removed the old client/server test programs from the distribution.  The udpstress program covers both
  client and server examples, is far more flexible for testing, and is written to take advantage of the
  latest features, providing a better example to follow.

- moved the processing of the flagged port unreachable further up in the InternalGiveTime function.  This
  would have only effected the sparc version of the UdpLibrary and the way it handles ICMP errors.  There
  was a bug whereby it was going through the connected give-time logic when in fact it may have been
  disconnected by a port unreachable.  This likely didn't cause any problems, but I moved it just to be
  safe.

- added new UdpMisc::Sleep function.  This is not used by the UdpLibrary, but is used by the sample
  applications and in general provides a portable way for applications to sleep.

- made some internal optimizations that allows the UdpLibrary to avoid making an extra copy of the data
  (in most circumstances) in order to append CRC bytes.  When coalescing is likely to occur and encryption
  is not being used, this optimization will speed up the cost of CRC checking on the send side a fair amount.

- created a new variation of the HashTable called an ObjectHashTable.  The UdpLibrary now uses this variation
  which is optimized to assume that the contents of the hash table are pointers to objects that are derived 
  from HashTableMember.  This allows the hash table to avoid allocations/deallocations entirely when new 
  entries are added/removed.  UdpConnection objects make use of this optimization.  The new hash table object
  has restrictions the old one does not, namely, its members can only ever be in one hash table, and then
  only in it one time.  For most applications, this is not an issue.  The old version is no longer used by
  the UdpLibrary but has been kept in the header file because some applications have started making use of it,
  and we don't want to mess them up.

- recently, the UdpLibrary has been seeing much heavier load as a server-to-server interprocess communications
  protocol.  While it was designed to handle this sort of thing, it did have one short-sighted limitation; it
  was only capable of transferring 4 billion logical reliable packets per session before it would fall apart.
  Even at a very high average trasfer rate of 1000 packets per second on a single connection, it would take over
  a month to exceed this rate.  It seemed at first that this might be a reasonable limitation, until Planetside
  and SWG came along.  These games have interprocess packet rates that are sometimes 10 times that high, meaning
  that critical failure could occur in only a few days in extreme circumstances.  Fixing this limitation did
  not require a protocol change, merely some internal changes to the way packets are tracked.  You need only
  upgrade both sides of a connection simultaneously to maintain compatibility if that particular connection
  will exceed 4 billion packets in a single session.  There is now no limit on the amount of data that a single
  session can send reliably.

- for the Win32 version of the Clock function, I had come up with a rather clever technique to avoid threading
  issues and clock-wrap.  Turns out the thread-local-storage scheme I was using doesn't work if the UdpLibrary
  is stuck in a DLL.  The odds of a clock wrap that occurs once every 47 days thread-slicing between two
  consecutive interger assignments and causing a problem are astronomically rare, so I have decided not to
  worry about the potential issue.  What I really need is a 64-bit interlocked increment, but Windows doesn't
  add support for that until the next version (after XP).

- added new configuration parameter, processIcmpErrorsDuringNegotiating.  This boolean parameter defaults to
  false, which was the default behavior of the UdpLibrary before this became configurable.  Setting this to 
  true will cause a client side connection attempt to fail immediately if the server process is not running
  (ie. doesn't have the port open).  Usually you will want to leave this at the default as often times two
  processes that talk to each other are started at the same time, and you don't want a race-condition to cause
  the client to fail because it happened to startup quicker than the server.

- put a hard cap on the maximum allowed maxOutstandingPackets configuration value.  If this value were ever
  set past 30000, things potentially could have fallen apart.  I can't imagine there ever being a need for this
  many outstanding packets.  Eventually when I get the reliable-channel coalescing put in, this cap will become
  even more meaningless.

- made the maximum allowed resend delay configurable.  This allows the application to put a cap on the longest
  it will ever wait to resend a lost packet.  Without a cap, lost-packet throttling can potentially cause the
  resend delay to get excessively long.  You should generally leave this value alone, but tweaking with it for
  certain internal-network connections may be desireable to optimize performance.  For example, if you know you
  are on an internal network, then it may be safe to set this value to the larger of double the typical ping-time
  and the longest GiveTime cycle time of either end of the connection.  Like many values, unless you really
  know what you are doing, you probably shouldn't mess with this.  I would never set this value to less than
  1000 for anything, but setting it to a value like 2000 might be desireable for some internal server-to-server
  connections.  The default is 5000.  This cap has always existed in the UdpLibrary, it has just been hard-coded
  in the past.

- got rid of the temporary encryption and decryption buffers in the UdpManager and replaced with stack-based
  buffers.  Doing this has two side effects.  1) more stack space is used, though it won't be very much.
  2) there is now a hard-limit on how large you can set the maxRawPacketSize.  Currently that hard limit
  is set to 16384 bytes.  I can't imagine anybody in their right mind would want to set it anywhere near
  that high.  On some crazy chance that you did want to set it higher, you would simply need to change the
  cHardMaxRawPacketSize constant in the header file.  In theory it could never go over 65535 anyways, since
  that is an IP protocol hard limit.  The only implication to increasing this number is more stack space usage.

- added debug signatures to the end of the encryption buffer and an assert to catch cases where user-supplied
  encryption routines overflow the end of the destination buffer.  Have yet to see this happen, but I am
  learning more and more that the more stuff the UdpLibrary can do to help the application find bugs in its
  usage of the library, the better.

- made sure UdpManager constructor initialized mPassThroughData to NULL.

- got rid of UdpMisc::FindAvailablePort function.  The reason for getting rid of this is that any use of
  it will almost surely be an unsafe/bad practice, as once it has found a port for you, it is entirely possible
  that some other process on the machine may grab that port before you create a UdpManager and bind to it.  We
  found this out the hard way in EQ.

- added a new configuration option, Params::portRange.  This new parameter accomplished what FindAvailablePort
  was supposed to do, only it does it in a safe manner.  If you wanted a to bind to a random port between
  40000 and 40999, you would specify 'port' to be 40000 and portRange to be 1000.  Upon construction, the
  manager would then randomly pick a port in that range and try binding to it.  It will try all ports in the
  range before it completely fails and gives up.  You cannot specify a portRange to use if you have 'port'
  set to zero as this makes no sense.  By default this parameter is 0, which causes it to act as it always has
  previously.

- against my better judgement, I added a GetRefCount function to the UdpConnection, UdpManager, 
  and LogicalPacket objects.  I actually needed it on the UdpConnection object internally such that the
  UdpManager could tell if the application had accepted a connection during an OnConnectRequest callback.

- added a new disconnect reason, cDisconnectReasonConnectionRefused.  You will never actually see this reason
  returned from GetDisconnectReason, since the object that would return it will already be destroyed so you can't
  ask it.  Where you will actually see it is from the GetOtherSideDisconnectReason function.  When a client
  attempts to connect to a server and that server ignores their connect request (by simply not AddRef'ing 
  it during the OnConnectRequest callback), the server responds back to the client with a terminate-packet.  The
  client will see the disconnect reason as cDisconnectOtherSideTerminated, but can further query to see that the
  server explicitly refused the connection.

- added a new disconnect reason, cDisconnectReasonMutualConnectError.  You will only ever see this from
  GetDisconnectReasonOther and it is a form of connection-refusal as well.  In this case, what it means is
  that the guy you are trying to connect to is simulatanously in the process of trying to connect to you.  The
  odds of this happening are very rare, but since the code was able to distinguish it from other situations, I
  figured it was worth clarifying if it ever did happen.

- added a new disconnect reason, cDisconnectReasonConnectingToSelf.  This is identical to the MutualConnectError
  and occurs whenever you try to establish a connection to yourself.  This is somewhat more likely, and in fact
  was added to the library because it actually happened.  For the sake of others who might run into this, I will
  give a brief description of how we managed to get bit by it.  We had enabled ICMP error processing during
  connection-negotiation, such that we could instantly tell if the server were down.  Our client application would
  then fail the connection, and immediately try again.  Each time it tried, it picked the next available port.
  The client in this case was another server process that happened to be running on the same box as the server
  it was trying to connect to.  The server it was trying to connect to was down. The server it was trying to
  connect to was supposed to be listening on port 44452.  The application-level retry loop was very tight with
  no delay, and eventually (30 seconds or so), it had managed to cycle through enough ports that the one it
  randomly picked (next available) was 44452.  This effectively made it connect to itself, which actually caused
  the library to eventually crash.  This was SWG btw.

- fixed bug in CRC calculation whereby it was applying the encrypt code in a byte-order dependent manner.  Nobody
  actually found this bug since nobody is running on big-endian based hardware.  There may be other endian issues
  that have yet to be tested, but in general the library is supposed to handle endian issues.  Internally, all
  protocols and such are done in network-byte-order (motorola big-endian order that is)

- added new api-function UdpConnection::GetOtherSideDisconnectReason().  When a connection is terminated, if the 
  GetDisconnectReason function returns to you the value cDisconnectReasonOtherSideTerminated, then you will be able to
  call this new function and find out what the other-sides reason was for disconnecting.  While this latest version of
  the library remains backwards protocol compatible, this new API feature will only be available if both sides of the
  connection are using the latest version of the library.  If the other side is not using the latest version, then
  this function will return cDisconnectReasonNone, meaning that it doesn't know.  Likewise, if this function is ever
  called when the primary disconnect reason is not OtherSideTerminated, then it will return None.  This should make
  tracking client-disconnects easier in situations where you don't have easy access to the client that is having the 
  problem.

- added new api-function UdpConnection::SetSilentDisconnect(bool silent).  This function allows the application to tell
  a connection that it should not notify the other end of the connection when it terminates (by sending the usual terminate
  packet to the other side).  This was actually added for internal reasons such that we didn't reply to a terminate-packet
  from the other side with a terminate packet of our own; however, it was thought that in some circumstances it may
  be desireable to let the other side languish and have to time-out, rather than us explicitly telling them that we
  have shutdown our side of the connection.  An example of wanting to do this might be if you were testing timeout
  functionality, or if you wanted to dump a cheater hard without telling them explicitly that they had been disconnected.

- added statistics to track how many socket-overflow errors occurred.  A socket overflow error can be caused if the
  socket-buffer size is too small for the overall datarate that the manager is trying to send (which could very well
  happen on a busy server if you gave it a small buffer.  The net result is packetloss, which will cause extra resends
  later on (for reliable data), etc.  If you have a fairly big outgoing socket buffer size, then this may be caused
  if the application is spamming too much unreliable data out the pipe.  Remember, unreliable data is not flow-controlled
  in any way, so if the server instantly dumps 500k of unreliable data to all connections combined and the server only
  has a 256k outgoing socket buffer, then you are going to lose a healthy chunk of that data.  This statistic can be
  used to determine if you have this problem occurring on a frequent basis.

- made UdpManagerHandler::OnConnectRequest non-pure-virtual (ie. provided a default implementation).  It used to be the
  case that the only reason you would want a UdpManagerHandler is if you were listening for connections, now it is quite
  likely that you will want one for user-supplied encyrption on the client side, so it was thought that we really should
  provide a default implementation that basically ignored incoming connection requests.


-----------------------------------------------------------------------------------------------------------------
2003-3-7
-----------------------------------------------------------------------------------------------------------------
- Added new configuration parameter to reliable channels UdpManager::Params::reliable[].congestionWindowMinimum.  It is very
  unlikely that you would want to change this parameter from its default value of zero.  What this parameter does is allow
  you to control how small (in bytes) the flow-control congestion window is able to shrink.  How flow control works is that
  as connections get congested, they slow down sending data by controlling how much outstanding unacknowledged data there
  is.  The congestion-window itself represents how much data this is, and it changes constantly as appropriate.  When packets
  are getting lost it shrinks.  This new parameter added here lets you control how small you will let it shrink in response
  to bad connection conditions.  The UdpLibrary will never let the congestion-window shrink below the size of a single
  physical packet (512 bytes by default), so all values for this setting below maxRawPacketSize are meaningless.  Instead,
  the purpose of this setting is to allow you to set this minimum higher than that.  Setting this number higher can result
  in the connection getting flooded beyond its capacity, as it may not be able to slow itself down enough to meet
  current line conditions.
  
  A situation where you may want to toy with this number is in a game (surprise), where you expect to be the only 
  process using bandwidth in the system, and you don't really care to be 'friendly' to other connections running 
  on the system.  Normally, if a modem-user is playing the game and has an TCP transfer going on in the background,
  then the TCP connection and the UdpLibrary connection will both effectively settle-in on using about half the available
  bandwidth.  That is, the flow-control algorithms used by the UdpLibrary and TCP are such that over a fairly short period
  of time, they will both settle in on a happy split.  However, if half-the-bandwidth was equal to a 2k window-size, and
  the UdpLibrary was configured to have a minimum window size of 3k, then the UdpLibrary would not scale down.  Because
  the TCP connection is willing to scale down further, it would, and you would effectively end up with a 3k/1k split
  with TCP kindly taking a backseat to the UdpLibrary (of course, if you had put two 3k-configured UdpLibrary connections
  in this same environment, the net result would be massive/wasteful packetloss).

  The advantage of setting a higher minimum is just the scenario described above, you can effectively configure your
  application to be a bandwidth pig at the expense of other connections in the system; like I said, sometimes this is
  desireable.  Another advantage of having a larger minimum window size is that it allows the connection to more
  quickly scale-up to optimal speed in situations where packets are lost, or there are long stalls in the outgoing
  packet stream.  So, if the game is plugging away at 500 bytes per second and has a window size of a minimum of 3k, then
  when a sudden burst of data transfer is needed for something, it can burst a good chunk of it all at once and not
  wait for the flow control window to scale up via the slow-start algorithm (which really should be called the fast-start
  algorithm).

  Another case where you might want to set this higher, is if you know for a fact that the connection is always going
  to be very high quality (internal ethernet).  In those situation, you may want to set the minimum window size to 30k
  or so, again, such that transfers get up to full-speed quicker.

  Basically, you can look at this value as the guaranteed bandwidth that you want the connection to claim.  The effects of
  playing with this setting are going to be very difficult to quantify, but if anybody does decide to try playing with it
  and notices an appreciable difference (good or bad), I would appreciate hearing about it, just so I know when others ask
  me about it.

- Added new helper function UdpMisc::FindAvailablePort(int startPortScan, int endPortScan), that will find you a randomly
  available port in the specified range, or return 0 if no available port was found.  This can be used in situations where
  you want the server to be listening on a random port in a particular range.  Sometimes it is nice to limit the random
  port selection to a particular range as it allows easier configuration of firewalls.  It's worth noting that when it
  finds an available port, it does not reserve it, but rather releases it and returns which one it is.  It is entirely
  possible that the port could be claimed by somebody else before you effectively bind to it.  A better way of handling
  this situation would be to actually create UdpManager's giving them a random listenPort in the range and then checking
  the UdpManager::GetErrorCondition to see if it successfully bound and try again if not.  In this way, you don't have to
  worry about your port getting stolen.  This helper function was added merely to handle a situation that was unique to
  Everquest where we did not have control of the underlying communications library in order to add this functionality.

- API CHANGE: UdpManager::GetHostByName has been moved and made a static function of UdpMisc.  This allows you to do this
  function without creating a UdpManager.

- API CHANGE: UdpConnection::Disconnect no longer gives the application the option of not being notified via OnTerminated for
  the disconnect event.  The application can only specify a flushTimeout.  When the application does specify a flushTimeout
  the OnTerminated callback does not occur until the actual connection is fully disconnected (by either timing out on the flush
  time, or successfully sending all the pending data and terminating).  While the connection is in a cStatusDisconnectPending
  state, it is possible for some other event (like an ICMP error for example) to cause the connection to switch to a
  cStatusDisconnected state before all pending data is sent.

- API CHANGE: OnTerminated callback will now be called ANYTIME a UdpConnection object switches to a cStatusDisconnected state,
  regardless of the reason.  Once a UdpConnection is in a cStatusDisconnected state, it will always remain as such.  Since
  newly created UdpConnection objects start out in a non-disconnected state (they are either connected or negotiating to start
  with), all UdpConnection objects created are guaranteed to eventually receive one and only-one OnTerminated callback.  In 
  previous versions of the library, a connection that was still negotiating (trying to connect) would not call OnTerminated
  if it failed, now it will.  In this manner, it will be easier and more clear for an application to maintain a strict balance
  between connection creation and destruction.  Furthermore, connections that are explicitly terminated by an application
  call to Disconnect will now callback via OnTerminated (if necessary).

- API CHANGE: OnConnectComplete callback is now only called when a connection is successfully established (as initiated by an
  EstablishConnection call).  Previously, any negotiating connection would callback via this function when it left the
  negotiating state (either succeed or fail).

- API CHANGE: moved user-supplied encryption callbacks from the UdpConnectionHandler to the UdpManagerHandler.  If you are
  using the user-supplied encryption callbacks, then you will likely need to make some minor changes to your code, by creating
  a handler object for the manager and moving the callback routines to there.  This should in no way effect the type of
  encryption you can do as you will still have access to the UdpConnection object.  The purpose of this change was to deal
  with a bug whereby the encryption routines could have been called on before the application had an opportunity to set
  a connection-specific handler.

- made API and library more const safe.  There are likely a few other places where I could have used const that I did not, I
  am sure they will all get tracked down eventually.

- fixed bug where in theory an infinite loop situation could occur.  This could have happened in a situation where one
  connection was bumping another connection to the top of the priority queue and vice-versa during priority-queue processing.
  This is the second time this issue has come up, so this time I put in a more comprehensive fix.  Now, the priority queue
  will refuse to let any connection schedule itself for processing time sooner than 1 ms after the current processing cutoff
  line.  This will also help to deal with issues where the clock might go backwards (though in theory that won't happen now
  either).

- documented the UdpHandler.hpp file more thoroughly to describe what the various callback functions do.

- fixed a bug where the congestion-window used for flow control was able to shrink down to zero when certain rare packet-loss
  patterns occurred.  It turns out that if you are under heavy flow and the timing mechanism used by the library goes
  backwards it can cause this to happen.  This only happened on Linux which uses the real time clock for timing, and the system
  clock was changed while the program was running.  The fix prevents the congestion-window from dropping below the size of
  a single packet.  (Thanks Thomas Farthing for help in finding this one)

- changed the Linux version of the UdpMisc::Clock function to compensate for a backwards moving clock caused by the system
  time being changed mid-application.  There is still and issue with time jumping forward when the clock is changed, but
  that will tend to cause less problems.  If anybody knows a relatively portable way of getting millisecond accurate timing
  that isn't relative to the real-time clock under Linux (something equivalent to Windows GetTickCount), let me know.
  (copied Vince Harron's time-correction routine for this purpose).

- changed the Windows version of the Clock function to better handle clock-wrap in situations where there are multiple
  threads in the process calling the function at the same time.  (used thread-local-storage to solve the issue)

- enhanced user-supplied encryption/decryption callback functions such that if they return -1 it is treated as an
  error-condition and the packet is thrown away by the UdpLibrary.  This could occur if the application detected during 
  decryption that something wasn't right.  Perhaps somebody tampered with the packet, or it got corrupted on-route yet 
  still managed to make it through the UDP header checksum and any UdpLibrary CRC checks that might have been in place.

- fixed bug in explicit bind where it was getting the network byte-ordering wrong (thanks Justin Randall for finding this one).

- fixed a bug where the OnTerminated callback was not being called in situations where an existing connection was terminated
  due to a subsequent new connect-request coming from the same IP and port.  Basically, the InternalDisconnect function was
  being called and told not to bother notifying the application of the event...I have no idea why I would have told it not
  to notify the application of termination for this reason, but it is now fixed.

- added direct winsock2 support.  If you want the UdpLibrary to use version winsock v2.2, then you should define the 
  symbol UDPLIBRARY_WINSOCK2.  This will cause it to use the winsock2.h header files and request version 2.2 of winsock
  on WSAStartup.  Since the library itself doesn't make use of any winsock2-only features, it really doesn't buy you much
  to do this.  The exception is if other parts of your program are using winsock2 functionality for some reason, you may
  have to define this in order to successfully compile, since the winsock.h and winsock2.h headers conflict.

- modified the hashtable template class and gave it the ability to iterate through its contents with WalkFirst and WalkNext.
  This feature isn't actually used by the UdpLibrary, but some other stuff I am working on that shares that hash table object
  needed it.

- fixed some code issues that were causing level 4 warnings (all future releases will be checked against level 4 warnings now)

- fixed problem where NULL was being implicitly converted to a UdpIpAddress inside of GetHostByName


-----------------------------------------------------------------------------------------------------------------
11/26/2002
-----------------------------------------------------------------------------------------------------------------
- thanks to Ben Hulse for porting the library to Solaris/sparc.  His changes have been rolled into the master distribution.
  The ICMP error processing on this platform is done in yet another way from the other platforms.  When you attempt
  to send data to a destination that has previously returned and ICMP unreachable error, the sendto function fails.  Given
  that we use the same port for multiple destinations and that hundreds of outgoing packets to other connections could have
  occurred before we send to the one that returned the error, I suspect this feature may not be working under Solaris.  I
  have seem some references on the web that indicate that UDP sockets do not receive ICMP errors unless they are connected
  (which obviously we can't do).  I didn't immediately see a way that this could work; though, I think it would be worth
  trying to do it the basically the same way Windows does on the recvfrom call.

- we have discovered that ICMP errors are not being forwarded up to the application under Windows NT and Windows 98.  These
  operating systems echo back ICMP errors as appropriate, but applications running on these platforms will not receive
  them on the other end.  Windows 2000/XP do not appear to have this problem.  Our NT testing was using service-pack 6.

- fixed bug in replyUnreachableConnection processing.  The net result is that the library should more accurately
  detect when a connection has gone dead in situations where the server has shutdown and restarted again fairly quickly.

- optimized the code dealing with removing a connection from the manager.  In previous versions of the library this required
  a linear search through all connections as they were tracked with a single linked list.  They are now tracked with a
  double linked list such that they can be removed without the search.  This change gets rid of the last linear operation in
  the library relative to the number of the connections (in normal processing).

- removed the UDPLIBRARY_SAME_ENDIAN flag.  This turned out to be a source of confusion and in practice probably should
  never have been used anyways.  It was merely an optimization that allowed the integer packing routine to operate more
  quickly in situation where both ends of the connection were guaranteed to be the same byte-order platform.

- added function UdpManager::GetHostByName, which does a DNS lookup to translate a name into an IP address.  Even though
  functions such as EstablishConnection will automatically do the DNS lookup if necessary, it is recommended that the 
  application do this translation themselves on startup if the architecture is such that the connection might be established 
  multiple times.  The reason for this is the lookup is a blocking call and it saves having to do it multiple times potentially.

- added support for binding the socket used to a particular IP address (UdpManager::Params::bindIpAddress)
  Normally, and by default, the library will bind the socket to any address in the machine.  This setting should
  not be messed with unless you really know what you are doing.  In multi-homed machines it is generally NOT
  necessary to bind to a particular address, even if there are firewall issues involved, and even if you want
  to limit traffic to a particular network (firewalls do a better job of serving that purpose).  If you are having
  problems communicating with a server on a multi-homed machine and think this might solve the problem, think again.
  You most likely need to configure the OS to route data appropriately, or make sure that internal network clients
  are connecting to the machine via the machines internal IP address (or vice versa).  The only reason I have come up
  with to bind to a specific IP is for security reasons above and beyond those that would normally be provided by
  a firewall.

- added configuration parameter UdpManager::Params::processIcmpErrors to turn on/off ICMP error processing.  By default
  ICMP error processing will be enabled.  If you are having problems with false ICMP errors causing disconnections, then
  you may want to disable this option.  False ICMP errors can occur when a router along the way momentarily goes down
  but is traffic is quickly re-routed, such that termination of the connection wasn't really necessary (at least, that's
  my theory).

- added configuration parameter UdpManager::Params::connectAttemptDelay.  During connection negotiation, the client will
  periodically send the server connect-attempt packets until the server acknowledges the request for a connection.  This
  value represents how frequently the client sends the connect-attempt packets.  By default this is set to 1000 and as a 
  general rule, should not be changed.  The reason this configuration parameter was added was such that I could slow down
  the attempt-rate used by clients of the EQ channel-server.  At peak, the channel server will have upwards of 90,000
  simultaneous connections.  Additionally, there will be up to 2000 people who are attempting to connect but cannot (most
  likely due to a firewall issue on their end).  These 2000 people will continously try to connect for 30 seconds, sending
  the channel-server a packet once per second, resulting in an extra 2000 packets/second coming into the channel server from
  people who will never be able to form a connection.  Since packetloss is relatively rare and rapid connection establishment
  is not critical, I wanted to slow down the rate at which these connection-attempts flooded the server.

- included <stdio.h> to get the definition of NULL.

- added carriage return to end of some header files to prevent warnings from gcc compiler

- removed an assert that could happen in normal processing after all.  Turns out that some ICMP error packets will show
  as coming from port 0 (presumeably when the entire IP address is not reachable?).  We have no way of doing an IP-only
  base connection query without looping through every connection, which we really don't want to do, so for now we are
  ignoring ICMP error packets that have a port of 0.  The appropriate behavior would probably be to terminate all
  connections that came from that IP address.  This doesn't appear to happen very often though; we had the EQ Channel Server
  running for 3 hours with 80,000 connections before it happened for the first time.  ICMP processing to accellerate
  disconnection recognition is really a bit of a luxury, so I don't feel too bad ignoring this rare case.


-----------------------------------------------------------------------------------------------------------------
2002-10-3
-----------------------------------------------------------------------------------------------------------------
- added new function UdpConnection::IncomingBytesLastSecond(), which returns the number of raw bytes the connection object
  has received in the last second (accurate to within 25ms).

- made sure ScheduleTimeNow was never executed during a GiveTime call.  If it was, then the net result would potentially be
  an immediate re-giving of time again, which I am thinking could possible create an infinite processing loop.

- added new function UdpManager::GetErrorCondition(), which returns an enum ErrorCondition value (see header file).  The
  only error conditions that it currently checks for is the ability to create and bind the socket.  If you are using a fixed
  port and are concerned that somebody else (like another copy of the program running) might already have it, then you should
  check the error condition after constructing the UdpManager object.


-----------------------------------------------------------------------------------------------------------------
2002-9-18
-----------------------------------------------------------------------------------------------------------------
- fixed problem where it was unable to establish a new connection because the server-side thought it already had a connection.
  This actually would not happen except under very unique circumstances.  In particular, you had to establish a connection
  to the server, then, using the same UdpManager object, establish another connection to the same server.  It is illegal
  to have multiple connections between the same two UdpManagers, as the resultant UdpConnection objects would effectively
  have the same ip/port combo's, effectively making it impossible for the UdpManager to know who incoming data was coming
  from.  The problem arose when the client had actually terminated one of the connections, but the server was unaware of it.
  Then, the next conenct-attempt would simply be ignored since the server would think it already had a connection to that
  ip/port.  You would think that the server would eventually timeout the old connection object, but the problem was that
  the new connect-attempts (that were being ignored) were actually refreshing the no-data-timeout on the existing connection.
  This effectively put it in a state where the client could never re-establish the connection.

  This would actually only occur if the second-connection attempt was using the same UdpManager as it had for the first
  connection, or if the UdpManager it was using had been assigned the same port-number again (either by explicit override,
  or by dumb-luck).  The fix for this is to have the existing connection terminate if it gets a new connect-attempt that
  is using a different encrypt-code.  When this set of circumstances happens and is the cause for a connection to be
  terminated, the disconnect-reason will be set to cDisconnectReasonNewConnectionAttempt.

  On a side note, since clients generally only have one outgoing connection for a given manager, it is generally a good
  idea to have the UdpManager created and destroyed along with the connection. Each time the UdpManager is re-created, it
  picks a new port to use, which effectively eliminates these issues.  This is also a good reason not to explicitly
  set the Params::port on client side connections, but instead leave it at 0, so the library will let the OS pick a random
  port (that presumeably hasn't been used recently).

  The situation where this bug first appeared was one where the client was actually using the same UdpManager to connect
  to dozens of servers simultaneously, so re-making the UdpManager wasn't really an option, since all the other connections
  would still be operating.

- got rid of C-style callback functions.  If you are currently using this style of callback you will need to convert
  your code over to using handlers.  I don't think anybody was using user-supplied encryption/compression routines
  yet, but those have been removed as C-style callbacks as well and added to the UdpConnectionHandler class.  See the
  UdpLibrary.doc file or the udpserver.cpp sample code for a description on how to use handler based callbacks.  A quick
  and dirty way of converting an existing C-style callback implementation into a handler based one would be to use the
  following class:

    class MyHandler : public UdpManagerHandler, public UdpConnectionHandler
    {
        public:
            inline virtual void OnConnectRequest(UdpConnection *con) { AppConnectRequest(NULL, con); }
            inline virtual void OnRoutePacket(UdpConnection *con, const udp_uchar *data, int dataLen) { AppRoutePacket(NULL, con, data, dataLen); }
            inline virtual void OnConnectComplete(UdpConnection *con) { AppConnectComplete(NULL, con); }
            inline virtual void OnTerminated(UdpConnection *con) { AppTerminated(NULL, con); }
    };

  Where the AppXXXXXXXXX functions are functions you had previously passed in as callback functions in the UdpManager::Params.
  The only thing lost is there is not a UdpManager mainPassThrough pointer anymore (first parameter to the ConnectRequest 
  callback in the old scheme), but odds are it wasn't used anyways.  Finally, you need to create an instance of the above
  class and set it up as the UdpManager::Params::handler for the UdpManager, and call UdpConnection::SetHandler(...) for
  each newly created connection as well (just after either EstablishConnection or on the server-side in the OnConnectRequest
  function).

  The above dummy-handler is primarily intended to handle converting existing code that uses the old method. New code
  should generally have one handler object for the UdpManager and a separate handler object for each UdpConnection created.
  Again, see the udpserver.cpp code for an example of this should be set up.

- when reliable data is sent, it remains in the queue until it is acknowledged by the other side.  When you query
  the reliable channel status, you can find out the age of the oldest piece of data in the queue that has been sent
  yet has not been acknowledged yet.  As a general rule, if things are operating correctly, it should be very rare
  for something that has been sent to not be acknowledged within a few seconds, even if resending had to occur.
  Eventually, the sender could use this statistic to determine that the other side is no longer talking and terminate
  the connection.  In past version of the UdpLibrary, the sending-application has checked this statistic itself.  A new
  parameter has been added UdpManager::Params::oldestUnacknowledgedTimeout. This parameter will cause the UdpLibrary 
  to monitor this for you and automatically change the connection to a disconnected state when the value goes over 
  this setting (in milliseconds) (0 means do not perform this check at all)  The default is set fairly liberally, 
  on client-side connections, you could safely set this to as low as 30 seconds (30000) allowing for quicker realization 
  of lost connections.  Often times the connection will realize it is dead much quicker for other reasons.
  When disconnected due to this, the disconnect reason is set to cDisconnectReasonUnacknowledgedTimeout

- added UdpManager::Params::replyUnreachableConnection.  When this parameter is set to true (the default), it causes the 
  UdpManager to reply back to destinations with unreachable-connection error packets when the server does not have a 
  UdpConnection object representing the destination.  The purpose of this is to allow a client who has had its connection
  terminated by the server to quickly realize that the server no longer considers the connection valid.  Normally the
  client would be told when the server terminated the connection, but that termination notice can get lost leaving a client
  thinking it is connected for longer than it should.  See the header file for this new parameter for more details.  
  (note: the client can sort of sense this is occurring now by monitoring the oldestUnacknowledgedAge in the reliable
  channel status, this just makes it occur quickly instead of having to time-out).


-----------------------------------------------------------------------------------------------------------------
2002-8-26
-----------------------------------------------------------------------------------------------------------------
- when I fixing the bug below, I also took the liberty of having the UdpConnection object hold a reference to the
  UdpManager during processing, such that it would handle the case where the UdpManager was deleted during a callback
  as well.  The problem is, I made the same mistake that caused me to mess with the code in the first place, that is,
  referencing the mUdpManager pointer after a callback.  But the release still needs to take place, even if we lose
  our link to the UdpManager due to a disconnect, so to fix it, I have the UdpConnection object hold its reference to
  the UdpManager in a stack variable (effectively).


-----------------------------------------------------------------------------------------------------------------
2002-8-23
-----------------------------------------------------------------------------------------------------------------
- fixed bug where during a UdpConnection::GiveTime call, the mUdpManager member could become NULL (if the application
  did a hard-disconnect during a callback function), and the GiveTime function later on used the mUdpManager pointer
  without checking it.  I think in practice this would have only happened if the application did a hard Disconnect call
  during the processing of an incoming reliable application packet.  Whatever the case, I have went through the code
  and verified that mUdpManager is checked for NULL everywhere it could possibly be used after a callback.

- added the ability to modify the keep-alive delay on a per-connection basis (see UdpConnection::SetKeepAliveDelay)

- fixed some compiler warnings/errors for the Linux compile (I don't actually compile the Linux version, so I count on
  those who do to tell me when I break things :).


-----------------------------------------------------------------------------------------------------------------
2002-8-19
-----------------------------------------------------------------------------------------------------------------
- added a UdpConnection::GetDisconnectReason function that returns the reason that a connection was terminated.

- fixed bug where it wasn't tracking the duplicate-packet-received statistic correctly

- added two new parameters for configuring reliable-channels.  I now allow you to set the resendDelayAdjust and the 
  resendDelayPercent.  These two values allow you to fine-tune the resending algorithm to make the channel either more or
  less aggressive about correcting lost packets.  On some channels, you may be willing to unnecessarily send the packet twice
  to ensure that it gets there as soon as possible; whereas on other channels that are less critical, you may be willing
  to tolerate a slower correction time to avoid sending something you might not need to.  See header-file for details on these
  parameter values.

- changed several of the UdpMisc functions to take void* instead of udp_uchar*.  This was to make it easier for applications to
  use these helper functions to hand-pack packets in order to be byte-ordering and structure-packing safe.

- added string-hashing functions to the hashtable.hpp file, since I have found myself using the hash table object in a lot
  of places for strings and it seemed generally useful.

- added the ability to force the UdpManager to pre-allocate a certain portion of the packet pool.  You might want to do this
  if you are very concerned about memory fragmentation and you know for sure that you are going to be using a certain minimum
  number of packets from the pool anyways.  The new parameter is UdpManager::Params::pooledPacketInitial.

- modified the ReliableChannel object to get temporary packets from the pool instead of allocating them.  It uses temporary
  LogicalPackets to hold onto incoming data that arrives out of order.  Again, if you are not configuring the UdpManager to
  have a pool and having your application use it as well, you are doing yourself a huge disservice.

- changed the logical-packet queue to expand itself 64 packet-pointers at a time instead of 1024 at a time.  This effectively
  reduces the minimum connection footprint by almost 4k at the cost of having to expand this buffer on the fly if the number
  of queued logical packets ever exceeds 64.  Most of the time this expansion will not have to occur, if I find otherwise in
  some application, I will make the expansion rate of this queue a setting instead of hardcoded.

- added a slightly more efficient, though not quite as effective non-buffer based Xor encryption method.  I ended up adding
  this as I am trying to avoid the 512 bytes/connection overhead of the XorBuffer method.  This should be good enough for
  most situations, we are just trying to make the packet-stream look like work to hack to the casual hacker.  This small amount
  of memory saved actually turns out to be critical for the application I am doing as I am trying to get 200,000 players
  connected to a single server.


-----------------------------------------------------------------------------------------------------------------
2002-7-1
-----------------------------------------------------------------------------------------------------------------
- added a new 'interations' statistic to the UdpManagerStatistics.  This represents how many times UdpManager::GiveTime has
  been called.  Divide this by elapsedTime to get an average number of times per second GiveTime is called.  This should
  generally be at least 10 or else you are likely creating too much processing-induced-lag (as I call it).  A similar statistic
  has been added to UdpConnectionStatistics

- changed code to ignore ICMP port unreachable errors while in cStatusNegotiating mode. This was necessary in order to prevent
  a client who happened to startup moments before the server did from aborting it's connection attempt because the port wasn't
  open yet when the first packet went out.

- added a new UdpManager::Params::portAliveDelay parameter which is intended to be used on the client side to keep the NAT or
  firewall port alive without having to actually send the server unnecessary keep alive packets.  This is very similar to the 
  keep alive delay, but serves a completely different purpose and may not have the desired effect on all platforms.  The purpose
  of the keepAliveDelay is generally to keep data flowing to the server so it knows that the client is still there.  In this 
  manner if the server doesn't get data within a certain period of time, it can know that the connection is probably dead.
  Sometimes it is the case that the server does not need to be kept alive, or at least kept alive very often (like for a chat 
  server perhaps where nobody is talking much).  For some people, it may be necessary to send data more frequently in order to 
  keep their NAT mapping fresh, or their firewall software happy.  However, we don't want to be in a situation where our server 
  is receiving a lot more data than it needs to just so these people can keep their port open.  I have seen NAT's that lose 
  mappings in as short as 20 seconds.  What this feature does is a bit tricky.  It changes the time-to-live (TTL) for a special 
  keep-alive packet to some small value (5) which is enough for the packet to get past local firewalls and NAT's, but not make 
  it all the way to our server.  In this manner, the port gets kept alive, but we don't waste bandwidth with these packets.
  These special packets are not counted statistically in any way and they do not reset any timers of any kind.  Their sole 
  purpose is to keep the port alive on the client side.  Any other data (including standard keepAlive packets will reset the 
  timer for this packet, so obviously the portAliveDelay must be smaller than the keepAliveDelay in order to be meaningful.
  By default this feature is off.  It's worth noting that the client-side will receive-back an ICMP TTL-expired packet; however,
  the client will simply ignore it.  It is unknown as to whether all NAT's will ignore the ICMP return packet, it is assumed
  that they will.  You should not set this value too aggressively as the returning ICMP packets will be taking up valuable
  incoming bandwidth on the client side, even though they have no effect on our end at all.

  (update: we put this live on EQ and it fixed the problem for a lot of people; however, it also caused a different small
  set of players to start having problems...probably firewalls or NATs that interpret the ICMP error packet as a reason to
  shut down the port/mapping.  Anyways, I am not sure it is a viable option because of this.  You could make it an advanced
  user option, but clearly it isn't the fool-proof solution we had hoped it would be.)

- added an optional parameter to UdpConnection::Disconnect as to whether it should callback the application via OnTerminated
  to notify of it of this Disconnect call.  In either case, the callback would only occur if connection had previously
  been in a cStatusConnected state.  This api enhancement was primarily added for internal purposes, though it will
  allow the application to receive OnTerminated callbacks when it explicitly calls Disconnect itself (if it so desires)

- added the ability for the library to auto-terminate connections that are not receiving data.  This feature is supported
  via the UdpManager::Params::noDataTimeout setting.  The timeout can also be overridden/controlled on a per-connection
  basis via the UdpConnection::SetNoDataTimeout and UdpConnection::GetNoDataTimeout functions.  Setting the timeout to
  zero (the default) causes the connections to never auto-disconnect due to not receiving data.

- added UdpManager::GetHandler and UdpConnection::GetHandler calls (added for completeness, not currently used by anybody)

- some minor changes to the non-windows version so it compiled cleaner.

- made it so keep-alive packets do not cause UdpConnection objects to be rescheduled in the priority queue.  They really
  don't need to reschedule things since the worst thing that can happen is it might get processing time sooner than it
  might otherwise need to.  But scheduling it for immediate processing time just makes that worse if you think about it.


-----------------------------------------------------------------------------------------------------------------
2002-5-15
-----------------------------------------------------------------------------------------------------------------
- added the ability to have a Disconnect'ed connection continue processing until there is no more data outstanding
  on any of the reliable channels.  The UdpConnection::Disconnect function now takes a 'flushTimeout' value, which is
  how long (in milliseconds) the connection will attempt to finish sending queued reliable data before giving up.  If
  the application specifies a flushTimeout of zero (the default), then the connection is immediately terminated as before.

  When the application specifies a timeout, the connection status is changed to cStatusDisconnectPending.  From the
  applications point of view the connection should be thought of as disconnected the moment the call is made.  The
  connection will never callback the application again to deliver data and it will not allow the application to Send
  any more data on the connection.  About all the application can with the connection is query its various status', or
  force an immediate disconnect by calling Disconnect again giving it no flush timeout.

  It is generally thought that the application will call Disconnect with a timeout and then immediately Release the
  connection and have nothing else to do with it again.  This is how it is intended to work.  The Release by the application
  will not actually free the connection if there is still data pending to be sent.
  
  Internally how this works is when the application calls Disconnect with a timeout, the status of the connection
  is changed to cStatusDisconnectPending.  The connection object registers itself with the UdpManager telling it 
  to keep a reference to the connection until the connection status changes to cStatusDisconnected.  The connection will 
  be given scheduled time by the UdpManager as before and when the connection has no more reliable data to send, or when
  its 'flushTime' expires, the connection will change itself to a cStatusDisconnected state, at which point the UdpManager
  will 'Release' its reference to the connection and the connection will actually be deleted.  So, take the following
  code for example:

    void ApplicationFunction()
    {
        myConnection->Send(cUdpChannelReliable, data, 100000);    // send 100,000 byte packet
        myConnection->Disconnect(30000);        // disconnect us, but give it up to 30 seconds to get any pending reliable data sent
        myConnection->Release();                // we are finished with this connection
        myConnection = NULL;
    }

  The above code will not block and will deliver the 100k packet if it can manage to do it in the 30 second timeframe.
  Releasing the UdpManager while there is pending disconnects will result in everybody being disconnected immediately
  and the data will not be delivered.

- added a new function UdpConnection::TotalPendingBytes(), which returns the total number of reliable-bytes that
  are outstanding.  When this returns zero, you can be assured that all data on all reliable channels has been successfully
  delivered.  (note: this is same as adding up ChannelStatus::totalPendingBytes on all reliable channels)

- added a GetStatistics function to the internally used hash-table object (in case anybody is using it externally for their
  own purposes.  The UdpLibrary itself does not make use of the statistics.


-----------------------------------------------------------------------------------------------------------------
2002-5-9
-----------------------------------------------------------------------------------------------------------------
- seeded the CRC algorithm with the negotiated encryption key, such that the CRC values calculated for packets cannot
  be easily calculated by off the shelf CRC algorithms (to prevent packet tampering).  This gives us some level of
  protection without the huge disadvantage of encryption which is 1) potentially slow, and 2) encrypting of a typical
  data stream reduces how effective modems hardware compress.  In Infantry, we found turning encryption on (where the
  data did not change size) significantly lagged modem users.  For this reason, encryption should likely only be used
  in conjunction with compression.  General byte-level compression itself is probably sufficient encryption for out needs.

- added OnCrcReject handler function.  This function is only available if a handler object is used (there is no callback
  equivalent right now...if somebody wants one, let me know; but, I would encourage everybody to switch over to handler based
  callbacks instead).  Whenever a packet is rejected due to a CRC error, this function is called to report the incident to
  the application.  Corrupt packets are fairly rare as they must first get through the 16 bit checksum that the UDP packet
  inherently puts on it.  If it makes it through that, then our CRC check will probably catch it.  The reason why an
  application would want to know this, is because there is a very good chance that the corruption was caused by somebody
  intentionally trying to tamper with the packet data, but not touching up the CRC on the end.  The application may want
  to take note of the IP address and if too many corrupt packets come from the same IP, consider banning the player for
  cheating.

- made manager check the protocol version for compatibility before creating an associated UdpConnection object.  This prevents
  the application from seeing connections that may later be rejected because of protocol version incompatibility.

- tweaked the flow control algorithm a bit.  The two main changes were 1) selective acks now adjust the congestion window
  differently similar to the TCP Reno algorithm, and 2) The slow start threshhold was reset when the pipe went dead (before
  we only reset the congestion window, but this resulted in a circumstance whereby the slow-start threshhold once low would
  never be able to go back up.

- modified the resend-timer to not take into account the amount of outstanding data in the window.  It turns out that
  this adjustments is redundant in that the slow-start flow control mechanisms will ramp things up to speed in a manner
  such that the average ack time will grow longer as the window gets bigger as appropriate.

- (update: the following feature was removed from the library in later versions)
  Added a new parameter to the reliable channel configuration.  ReliableConfig::processOnSend if 'true' will configure that 
  particular reliable channel to do processing on sent packets at the time they are sent instead of waiting until the next
  UdpManager::GiveTime call.  Normally the application will want to leave this at its default value of 'false' because it
  is more efficient on CPU usage, since it can avoid doing all the ReliableChannel::GiveTime processing on a per-sent packet
  basis by delaying it until the next global GiveTime.  The downside of delaying is that it is often the case that the next
  GiveTime simply causes the reliable packet to get moved into the multi-buffer inside the UdpConnection object.  Then another
  GiveTime a bit later finally sends it.
  
  Setting this value to 'true' is similar to issuing a FlushChannels command after each reliable Send (with the 
  exception that rather than giving every channel and the UdpConnection object time, it only has to give the channel
  doing the send time).

  This feature is most useful when you are on the client side and the overhead of processing the packet on-send 
  will not add up to much, compared to what the server-side has to do managing thousands of connections.  Most clients
  should probably set this to 'true', since timeliness of sent packets generally exceeds any need for code efficiency on
  the client side in this regard.

  It's worth noting that the reliable channel object ends up scheduling time for the connection the next GiveTime, 
  regardless of how this value is set.

  If you have the multi-buffer set to 0 (no multibuffering) and you have this parameter set to 'true', then the actual
  send of a physical packet will end up occuring during your reliable-send call (assuming there is room in the reliable
  flow control window for the packet to go out at that time).  As a reminder, I don't recommend setting the multibuffer
  to zero, even on the client side, because it effectively circumvents the mechanism by which ACK packets get combined
  and piggy-backed on other packets (ie. every ACK would end up taking its own physical packet).  A better approach I feel
  is to have a multibuffer and then do explicit FlushMultiBuffer calls after sends.  In this manner, ACK's still have some
  chance of piggy-backing as they will wait around until the next send call (or the multibuffer timeout).

- fixed a tiny problem whereby packets that were rejected due to CRC mismatches were not causing the connection receiving
  them to schedule itself for processing time as it probably should.  In practice this didn't really effect anything.

- added a (UdpConnection *) parameter to the UdpConnectionHandler callback functions.  This was done such that an application
  could setup one object as the handler for multiple connections and be able to distinguish between which connection the
  callback was coming from.  You will have to change your handler functions appropriately to make them compile, and odds
  are you will be able to simply ignore the incoming UdpConnection parameter.

- added UdpManager::GetPassThroughData and UdpManager::SetPassThroughData calls to allow application to change the pass through
  data after construction (makes it more consistent with the way UdpConnection objects work as well)

- made it negotiate the maxRawPacketSize between the client and server side during connection establishment.  It will actually
  end up using the smaller of the two values specified on the client or server side.  In this manner, the server can be
  configured to support 1k packets (for example) and some client could be configured to only support 512 byte packets and they
  would still be able to talk to each other (they would end up doing all talking with 512 byte packets in this case).  This 
  will prevent the client and server from accidentally getting configured differently and then refusing to talk to each other.  
  It will also allow clients who are behind networks that can only handle tiny packets to be configured to talk in the smaller
  chunks to support that.  You will have to update both ends of the connection with this code in order for them to talk, since
  this change effected the initial negotiation process.


-----------------------------------------------------------------------------------------------------------------
2002-4-12
-----------------------------------------------------------------------------------------------------------------
- Removed the Handler base class declarations from being nested and put them in their own header file such that we could avoid
  having to expose the entire UdpLibrary header everywhere (along with all it's baggage).  You can now only include UdpHandler.hpp
  to get these declarations, which have now been named UdpConnectionHandler and UdpManagerHandler.

- Removed the nesting of ConnectionStatistics and ManagerStatistics, they are now UdpConnectionStatistics and UdpManagerStatistics.

- Optimized the UdpLibrary.hpp header file to avoid including stuff we really didn't need to.  In particular, with a few trivial
  changes, we managed to be able to avoid including any other header files (including winsock.h).  The only file we could not
  get rid of including is stddef.h, which has the offsetof() macro that we need in the hashtable.hpp template implementation.

- merged latest Linux implementation into main distribution.  Hopefully I didn't change anything in the Linux implementation in
  doing so as I have not tested it.


-----------------------------------------------------------------------------------------------------------------
2002-4-9
-----------------------------------------------------------------------------------------------------------------
- switched UdpManager over to an AddRef/Release scheme as well.  This is to allow the application to release/delete the UdpManager
  during a callback as well.  Internally the UdpManager keeps a reference to itself when it calls back the application, such
  that the actual delete doesn't occur until the UdpManager is safely off the stack.

- added UdpManager::SetHandler function.  Normally the handler for the UdpManager is set in the UdpManager::Params and passed to the
  constructor; however, I wanted to let the application change or get rid of the handler if needed.  In particular, if the application
  has set the handler to a particular object, and that object gets deleted before the manager, then that object should clear itself
  from being the handler for the manager by setting the handler to NULL (presumeably).  In particular, it is probably a good idea
  to get in the habit of having handler objects set and clear themselves on construction and destruction as appropriate, for both
  UdpConnection and UdpManager handlers.  For example, this is the best way to set things up (similar things should be done
  for UdpManagers):

        class Player : public UdpConnection::Handler;

        Player::Player(UdpConnection *con)
        {
            mConnection = con;
            mConnection->AddRef();
            mConnection->SetHandler(this);
        }

        Player::~Player()
        {
            mConnection->SetHandler(NULL);
            mConnection->Disconnect();
            mConnection->Release();
        }

  Clearing the Handler on destruction is probably not necessary, but on the odd chance that somebody else has a reference to
  your object and it lives on, it would seem to be a safe practice.  In particular, during callbacks the connection will actually keep
  a reference to itself momentarily.  The Disconnect call should keep it from every trying to call you back, but clearing the
  handler is a good safety step to be sure.

- fixed bugged array delete in PriorityQueue.

- fixed another bug in the ICMP handling that prevented the application from deleting the connection during that callback.

- changed ICMP processing such that it would not quit trying to poll packets when it got an ICMP error return.  I am not sure if
  Windows avoids sending ICMP error results via recvfrom if there are legit packets in the queue or not, but just in case, this
  change will make it handle the situation slightly better.


-----------------------------------------------------------------------------------------------------------------
2002-4-8
-----------------------------------------------------------------------------------------------------------------
- added ICMP port-unreachable support.  This will allow the sending end of a connection to quickly determine that the other side
  has terminated servicing its port for some reason.  Again, props to Justin for this idea.  I tested it and it appears to work.

- changed UdpConnection objects to be AddRef/Release based.  This effectively meant we could get rid of the UDPGIFT ownership
  passing paradigm because ownership is now a function of having a reference to it.  This means that when you are called back
  and given a UdpConnection object from a ConnectRequest callback, you must AddRef it if you intend to keep a hold of it; otherwise
  it will be destroyed by the UdpManager when the callback returns.  If you have an existing application you must remember to put
  the AddRef in the callback, otherwise your connection will be destroyed immediately after it is created.  The compiler will give you
  errors for the destructors which need to be changed as noted below.
  
  Similarly, the application should Disconnect() and Release() the UdpConnection object when it is done using it and wants 
  it to go away.  This change was needed such that the application would be free to delete the connection object 
  during packet processing inside a callback.  The UdpManager keeps a reference to the object during packet processing 
  and releases it when done.  The problem was that the callback to the application to route the packet came from deep 
  inside the UdpConnection object which was being destoryed.  Because the UdpConnection object may be breaking apart
  a multi-packet at the time the application releases the UdpConnection object, it will continue to route the remaining parts of the
  multi-packet, as it has no idea that the application no longer wants to receive them.  The application may have released its reference
  to the UdpConnection, but the UdpManager maintains a reference until the raw packet is finished processing.  What this means is that
  if the application wants to ensure that when it releases the UdpConnection object that it also prevents all future callbacks from that
  connection, it must also call UdpConnection::Disconnect before calling Release().  The bottom line is the proper way for the application
  to destroy a connection during packet processing is to call Disconnect() and Release().  A Disconnected UdpConnection object will
  never callback the application to route a packet.

- fixed UdpMisc::Clock such that if different threads were calling it at the same time and got time sliced away, it wouldn't accidentally 
  double-increment or miscalculate in some way the next stamp.

- Justin Randall modified library to compile properly under Linux and his changes have been included into official distribution.
  The sample client/server programs are still WIN32 specific.


-----------------------------------------------------------------------------------------------------------------
2002-4-2
-----------------------------------------------------------------------------------------------------------------
- made API const safe for most things.

- added support for using object-based handler objects instead of callback functions for notifications.  See the header file
  under Params::handler and UdpConnection::SetHandler for more details on how these work.  The UdpLibrary.doc file has been updated 
  to talk briefly about them as well.  The UdpServer sample application included in the distribution has been modified to use 
  handlers instead of callbacks by default as well.

- changed hashtable template interface slightly.  It now has a simpler FindFirst/FindNext interface, avoiding the need to expose
  the linked-list implementation details.


-----------------------------------------------------------------------------------------------------------------
2002-3-24
-----------------------------------------------------------------------------------------------------------------
- added a pooled memory manager for logical packets to the UdpManager object.  This should virtually eliminate
  allocations for the vast majority of usage if configured properly.  Using the UdpManager::CreatePacket is now the recommended
  method for allocating logical packets to send since it will use the pool automatically if possible.

- implemented function UdpConnection::OutgoingBytesLastSecond (replaces the unimplemented BytesInLastSecond)

- added new FlushChannels function which allows the application to force all channels (particularly reliable ones) to send
  out any queued data that they have time for immediately, instead of waiting for the next time they get processing time.

- added new totalBytesPending statistic to the ChannelStatus, so you could tell for certainty that everything had made it

- tweaked resend-time calculation...I will probably toy with this for a while til I am perfectly happy with it.

- moved clock-sync packet sending ahead of reliable-queue packet processing to better the odds of getting a fast ping.


-----------------------------------------------------------------------------------------------------------------
2002-3-22
-----------------------------------------------------------------------------------------------------------------
- optimized the flow-control window algorithm for our unique situation.  Basically, I changed it so that the window-size does not
  increase when the application is pacing the data rate itself such that the window is not getting filled.  The problem was that
  a slow stream from the application would give the flow-control mechanism the impression that packets were never being lost and it
  would keep increasing it's window size forever.  Then if the application suddenly dumped a huge chunk of data into the pipe, the large
  window size would cause the client to get seriously over-flooded.  This is one area where TCP falls flat on its face as well.
  For more information on this flow-optimization, search for the mMaxxedOutCurrentWindow variable in the implementation and read the 
  associated comments.

- fixed nasty bug where UdpReliableChannel::mLastTimeStampAcknowledged was not being initialized.  This potentially caused the
  first reliable packet sent to think that it had been ack-accelerated by a later packet and resent a second time.  What made the bug
  really nasty is that would resend this packet over and over again very very rapidly until it had been acknowledged.  But because
  the packet had been sent more than once, it would not use that packets last send stamp to reseed the accelleration stamp.  This meant
  that the next reliable packet sent experienced the same problem.  The net effect was a ton of traffic and 80% packetloss to the destination.
  I'm surprised this did not show up more in testing, but it should be fixed now.

- fixed bug where it would crash if the timeout expired on EstablishConnection call (optional feature)
- fixed bug in trickle channels where they were sending faster than the specified trickle rate
- fixed bug in UdpConnection::LastReceive(...) (the version added last rev, accidentally compared the wrong stamp)
- added more ChannelStatus statistics (not real useful, but they have some gee-wiz value)


-----------------------------------------------------------------------------------------------------------------
2002-3-12
-----------------------------------------------------------------------------------------------------------------
- enhanced UdpManager::GiveTime to allow it to be told to process only 1 physical packet out of the socket per call.  See the docs
  for GiveTime for an explanation of when this might be useful.

- added support for reliable-channel specific fragment sizes (as opposed to using maxRawPacketSize for all channels).  See the docs
  for ReliableConfig::fragmentSize for details on when you might want to do this.

- fixed bug whereby a client-side connection could possibly try and process a packet before it received the connection confirmation
  This was a serious problem, but would only happen if the very first communication a client/server did originated from the server
  side and the connection confirmation packet had been lost, and encryption was being used.

- changed UdpMisc::CreateQuickLogicalPacket to allow it to take a NULL primary pointer (ie. just allocate space)

- added a UdpConnection::LastReceive function that takes the current time as a parameter, this saves the connection having
  to poll the clock to accomplish this, which can add up if you are looping through a ton of connections just to check this info

- moved several functions into the header as inline implementations for performance


-----------------------------------------------------------------------------------------------------------------
2002-3-8
-----------------------------------------------------------------------------------------------------------------
- Fixed bug in UdpConnection::GetLocalPort, it was incorrectly returning the port number in network-byte-order
- Added a UdpConnection::GetUdpManager call to get the UdpManager associated with a connection
- initialized UdpConnection's pass-through pointer to NULL
- got rid of UdpManager::Initialize and UdpManager::Terminate.  These functions weren't needed after all since WSAStartup/WSACleanup do ref-counting.
  You can now simply create the UdpManager immediately and it will take care of it.


-----------------------------------------------------------------------------------------------------------------
2002-3-6
-----------------------------------------------------------------------------------------------------------------
- UdpManager::ManagerStatistics::elapsedTime changed to milliseconds from seconds.
- Added bytesSent tracking to UdpConnection::ConnectionStatistics
- changed all byte and packet count tracking to 64-bit values to prevent rollover. (cleaned up stat tracking code internally while at it)
- fixed an off-by-one bug in statistics where it was improperly counting the clock-reflect packet it had just sent when calculating packet-loss statistics
- added a UdpManager::GetLocalPort call to complement the GetLocalIp call (oversight, it should have been there all along).
- documentation continues to be fleshed out (still a lot of sections missing though, UdpManager::GiveTime section is worth reading)


-----------------------------------------------------------------------------------------------------------------
2002-3-5
-----------------------------------------------------------------------------------------------------------------
- Added two new callback functions, one for when an EstablishConnection
  call either succeeds or fails and one for when the connection is
  is terminated by the other end.  EstablishConnection function used for
  establishing client-side connections now takes a timeout value for how
  long it should attempt to establish the connection.  Both are completely optional
  if the application wishes to have callback notification of these events.

- Fixed compiler incompatibility with MSVC 7.0 (template friend function related)
- Fixed compiler level 4 warnings for unused parameters
- Modified the resend protocol to throttle back resend times when packetloss
  occurs to prevent unnecessary spamming on truely link-dead connections.


-----------------------------------------------------------------------------------------------------------------
2002-2-26
-----------------------------------------------------------------------------------------------------------------
- Initial release of library to EQ2 team (only)
  Documentation not yet finished, see header file comments for full documentation.


-----------------------------------------------------------------------------------------------------------------
Distribution Files
-----------------------------------------------------------
UdpLibrary.cpp                - main file (not used as much as in the past, contains very little now)
UdpLogicalPacket.cpp          - contains the implementation of the various LogicalPacket objects
UdpMisc.cpp                   - contains miscellaneous functions used by the library
UdpManager.cpp                - implementation of UdpManager object
UdpConnection.cpp             - implementation of UdpConnection object
UdpReliableChannel.cpp        - implementation of UdpReliableChannel object
UdpDriverWindows.cpp          - Windows version of UdpPlatformDriver object
UdpDriverLinux.cpp            - Linux version of UdpPlatformDriver object
UdpDriverSparc.cpp            - Sparc/Solaris version of UdpPlatformDriver object
UdpDriverPS3.cpp              - PS3 version of UdpPlatformDriver object
UdpDriver.h                   - declaration of UdpDriver and UdpPlatformDriver classes
UdpTypes.h                    - declaration of various base types used throughout the library
UdpHandler.h                  - declaration of handler-classes used by application for callbacks (can be directed used by application if desired)
UdpLibrary.h                  - main include used by application (largely just includes all the other files that are needed)
UdpHashTable.h                - internally used hash table object
UdpPriority.h                 - internally used priority queue object
UdpLogicalPacket.h            - LogicalPacket declarations
UdpManager.h                  - UdpManager declarations
UdpConnection.h               - UdpConnection declarations
UdpReliableChannel.h          - UdpReliableChannel declarations
UdpMisc.h                     - declaration of miscellaneous helper functions
UdpHelper.h                   - declaration of misc helper objects
UdpLinkedList.h               - linked list object used by library

UdpStress.cpp                 - sample application used to test library (can be used as a sample reference for implementors)
UdpDriverRecord.cpp           - sample application-driver that does recording and playback (not required)
UdpDriverRecord.h             - sample application-dirver that does recording and playback (not required)

UdpLibrary.vcproj             - Visual Studio.NET project for building the UdpLibrary into a .lib.  (feel free to just create your own if you want)
UdpLibraryRelease.txt         - these release notes
UdpLibrary.doc                - documentation for library (out of date typically, see release notes for latest info)



