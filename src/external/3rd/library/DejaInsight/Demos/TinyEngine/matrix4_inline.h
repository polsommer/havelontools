//==============================================================================
// matrix4_inline.h
//==============================================================================
//  Copyright (C) DejaTools, LLC.  All rights reserved.
//==============================================================================

#ifndef matrix4_inline_h
#define matrix4_inline_h

//==============================================================================
//  DEFINES
//==============================================================================

#define M( Column, Row )   m_Cell[ Column ][ Row ]

//==============================================================================
//
// Construct the matrix.
//
//==============================================================================

inline 
matrix4::matrix4( void )
{
}

//==============================================================================
//
// Construct the matrix.
//
//==============================================================================

inline 
matrix4::matrix4( const matrix4& Matrix )
{
    memcpy( &m_Cell, &Matrix.m_Cell, sizeof(m_Cell) );
}

//==============================================================================
//
// Zero the matrix.
//
//==============================================================================

inline 
void matrix4::Zero( void )
{
    M(0,0) = M(1,0) = M(2,0) = M(3,0) = 0.0f;
    M(0,1) = M(1,1) = M(2,1) = M(3,1) = 0.0f;
    M(0,2) = M(1,2) = M(2,2) = M(3,2) = 0.0f;
    M(0,3) = M(1,3) = M(2,3) = M(3,3) = 0.0f;
}

//==============================================================================
//
// Set the matrix to Identity.
//
//==============================================================================

inline 
void matrix4::Identity( void )
{
             M(1,0) = M(2,0) = M(3,0) = 0.0f;
    M(0,1) =          M(2,1) = M(3,1) = 0.0f;
    M(0,2) = M(1,2) =          M(3,2) = 0.0f;
    M(0,3) = M(1,3) = M(2,3) =          0.0f;

    M(0,0) = M(1,1) = M(2,2) = M(3,3) = 1.0f;
}

//==============================================================================
//
// Transpose the matrix.
//
//==============================================================================

inline
void matrix4::Transpose( void )
{
    float Temp;    
   
    Temp   = M(1,0);
    M(1,0) = M(0,1);
    M(0,1) = Temp;
    
    Temp   = M(2,0);
    M(2,0) = M(0,2);
    M(0,2) = Temp;
    
    Temp   = M(3,0);
    M(3,0) = M(0,3);
    M(0,3) = Temp;

    Temp   = M(2,1);
    M(2,1) = M(1,2);
    M(1,2) = Temp;
    
    Temp   = M(3,1);
    M(3,1) = M(1,3);
    M(1,3) = Temp;

    Temp   = M(3,2);
    M(3,2) = M(2,3);
    M(2,3) = Temp;
}

//==============================================================================
//
// Rotate the matrix on x.
//
//==============================================================================

inline 
void matrix4::RotateX( radian r )
{
    float s = sinf( r );
    float c = cosf( r );

    // Rotate the matrix.
    float m01 = M(0,1);   M(0,1) = c*m01 - s*M(0,2);  M(0,2) = s*m01 + c*M(0,2);
    float m11 = M(1,1);   M(1,1) = c*m11 - s*M(1,2);  M(1,2) = s*m11 + c*M(1,2);
    float m21 = M(2,1);   M(2,1) = c*m21 - s*M(2,2);  M(2,2) = s*m21 + c*M(2,2);
    float m31 = M(3,1);   M(3,1) = c*m31 - s*M(3,2);  M(3,2) = s*m31 + c*M(3,2);
}

//==============================================================================
//
// Rotate the matrix on y.
//
//==============================================================================

inline 
void matrix4::RotateY( radian r )
{
    float s = sinf( r );
    float c = cosf( r );

    // Rotate the matrix.
    float m00 = M(0,0);   M(0,0) = c*m00 + s*M(0,2);  M(0,2) = c*M(0,2) - s*m00;
    float m10 = M(1,0);   M(1,0) = c*m10 + s*M(1,2);  M(1,2) = c*M(1,2) - s*m10;
    float m20 = M(2,0);   M(2,0) = c*m20 + s*M(2,2);  M(2,2) = c*M(2,2) - s*m20;
    float m30 = M(3,0);   M(3,0) = c*m30 + s*M(3,2);  M(3,2) = c*M(3,2) - s*m30;
}

//==============================================================================
//
// Rotate the matrix on z.
//
//==============================================================================

inline 
void matrix4::RotateZ( radian r )
{
    float s = sinf( r );
    float c = cosf( r );

    // Rotate the matrix.
    float m00 = M(0,0);   M(0,0) = c*m00 - s*M(0,1);  M(0,1) = s*m00 + c*M(0,1);
    float m10 = M(1,0);   M(1,0) = c*m10 - s*M(1,1);  M(1,1) = s*m10 + c*M(1,1);
    float m20 = M(2,0);   M(2,0) = c*m20 - s*M(2,1);  M(2,1) = s*m20 + c*M(2,1);
    float m30 = M(3,0);   M(3,0) = c*m30 - s*M(3,1);  M(3,1) = s*m30 + c*M(3,1);
}

//==============================================================================
//
// Pre-rotate the matrix on x.
//
//==============================================================================

inline 
void matrix4::PreRotateX( radian r )
{
    matrix4 RM;
    float   s, c;    

    if( r == 0 )  return;

    sincosf( r, s, c );

    RM.Identity();

    RM.M(1,1) =  c;
    RM.M(2,1) = -s;
    RM.M(1,2) =  s;
    RM.M(2,2) =  c;

    *this *= RM;    
}

//==============================================================================
//
// Pre-rotate the matrix on y.
//
//==============================================================================

inline 
void matrix4::PreRotateY( radian r )
{
    matrix4 RM;
    float   s, c;    

    if( r == 0 )  return;

    sincosf( r, s, c );

    RM.Identity();

    RM.M(0,0) =  c;
    RM.M(2,0) =  s;
    RM.M(0,2) = -s;
    RM.M(2,2) =  c;

    *this *= RM;    
}

//==============================================================================
//
// Pre-rotate the matrix on z.
//
//==============================================================================

inline 
void matrix4::PreRotateZ( radian r )
{
    matrix4 RM;
    float   s, c;    

    if( r == 0 )  return;

    sincosf( r, s, c );

    RM.Identity();

    RM.M(0,0) =  c;
    RM.M(1,0) = -s;
    RM.M(0,1) =  s;
    RM.M(1,1) =  c;
          
    *this *= RM;    
}

//==============================================================================
//
// Translate the matrix.
//
//==============================================================================

inline 
void matrix4::Translate( const vector3& v )
{
    // OPTIMIZATION - If the matrix is pure SRT (bottom row is 0,0,0,1), then
    //                the translation is simply addition in the T cells.

    M(0,0) += M(0,3) * v.x;
    M(1,0) += M(1,3) * v.x;
    M(2,0) += M(2,3) * v.x;
    M(3,0) += M(3,3) * v.x;

    M(0,1) += M(0,3) * v.y;
    M(1,1) += M(1,3) * v.y;
    M(2,1) += M(2,3) * v.y;
    M(3,1) += M(3,3) * v.y;

    M(0,2) += M(0,3) * v.z;
    M(1,2) += M(1,3) * v.z;
    M(2,2) += M(2,3) * v.z;
    M(3,2) += M(3,3) * v.z;
}

//==============================================================================
//
// Translate the matrix.
//
//==============================================================================

inline 
void matrix4::PreTranslate( const vector3& v )
{
    M(3,0) += (M(0,0) * v.x) + (M(1,0) * v.y) + (M(2,0) * v.z);
    M(3,1) += (M(0,1) * v.x) + (M(1,1) * v.y) + (M(2,1) * v.z);
    M(3,2) += (M(0,2) * v.x) + (M(1,2) * v.y) + (M(2,2) * v.z);
    M(3,3) += (M(0,3) * v.x) + (M(1,3) * v.y) + (M(2,3) * v.z);
}

//==============================================================================
//
// Scale the matrix.
//
//==============================================================================

inline 
void matrix4::Scale( float s )
{
    M(0,0) = M(0,0) * s;
    M(0,1) = M(0,1) * s;
    M(0,2) = M(0,2) * s;
    M(1,0) = M(1,0) * s;
    M(1,1) = M(1,1) * s;
    M(1,2) = M(1,2) * s;
    M(2,0) = M(2,0) * s;
    M(2,1) = M(2,1) * s;
    M(2,2) = M(2,2) * s;
}

//==============================================================================
//
// Set the matrix translation.
//
//==============================================================================

inline 
void matrix4::SetTranslation( const vector3& v )
{
    M(3,0) = v.x;
    M(3,1) = v.y;
    M(3,2) = v.z;
}

//==============================================================================
//
// Transform a vertex.
//
//==============================================================================

inline 
vector3 matrix4::operator * ( const vector3& v ) const
{
    return( vector3( (M(0,0)*v.x) + (M(1,0)*v.y) + (M(2,0)*v.z) + M(3,0),
                     (M(0,1)*v.x) + (M(1,1)*v.y) + (M(2,1)*v.z) + M(3,1),
                     (M(0,2)*v.x) + (M(1,2)*v.y) + (M(2,2)*v.z) + M(3,2) ) );
}

//==============================================================================
//
// Transform a matrix.
//
//==============================================================================

inline
matrix4& matrix4::operator *= ( const matrix4& aM )
{
    *this = (*this) * aM;
    return( *this );
}

//==============================================================================
//
// Access (for read) a matrix cell.
//
//==============================================================================

inline
float matrix4::operator () ( int Column, int Row ) const
{       
    return( M( Column, Row ) );
}

//==============================================================================
//
// Access (for write) a matrix cell.
//
//==============================================================================

inline
float& matrix4::operator () ( int Column, int Row )
{       
    return( M( Column, Row ) );
}

//==============================================================================
//  CLEAR DEFINES
//==============================================================================

#undef M

//==============================================================================
#endif // matrix4_inline_h
//==============================================================================
