#!/usr/bin/perl

# This generates a C++ header file from the DDL for the database tables.
# The header file contains structs to represent each database table's rows.
#
# Note that the DDL file must be formatted like this:
# create table <table>
# (
#    <column> <datatype>,
#     ...
# );
#
# It is recommended that the header file be called Schema.h
#
# usage:  make_schema_h.pl < [DDL file] > [header file]

print <<EOF;
\#ifndef INCLUDED_Schema_H
\#define INCLUDED_Schema_H

// DO NOT EDIT this file.
// This file is automatically generated by make_schema_h.pl

\#include "sharedDatabaseInterface/Bindable.h"
\#include "sharedDatabaseInterface/DbRow.h"
\#include "serverDatabase/BindableNetworkId.h"

namespace DBSchema
{
EOF

while (<>)
{
    if (/create table/)
    {
	&parseTable();
    }
}

print <<EOF;
}
#endif
EOF

sub parseTable
{
    die unless (/create table (\w*)/);
    $tablename = $1;
    $tablename =~ s/s$//; #remove plural
    $tablename =~ s/_/\\u/g;
    eval("\$tablename = \"\\u".$tablename."\";"); #Gotta love that PERL.  (This converts _[a-z] to _[A-Z])
    print "struct $tablename"."Row : public DB::Row\n{\n";
    $_=<>; # eat "("
    $_=<>;
    while ($_ ne ");\n")
    {
	chop;
	if (/\-\-\s*BIND_AS\(([^\)]*)\)/)
	{
	    $forcetype=$1;
	}
	else
	{
	    $forcetype="";
	}
	s/\s*\-\-.*//;
	s/,\s*$//;
	die unless (/^\s*(\w*)\s+(.*)$/);
	($name,$type)=($1,$2);
	if ($forcetype eq "")
	{
	    print "\t".&translateType($type);
	}
	else
	{
	    print "\t".$forcetype;
	}
	print " $name;\n";
	$_=<>;
    }
    print "\n\tvirtual void copy(const DB::Row &rhs)\n";
    print "\t{\n";
    print "\t\t*this = dynamic_cast<const ".$tablename."Row&>(rhs);\n";
    print "\t}\n";
    if ($tablename =~ /Object$/) #TODO:  parse PRIMARY_KEY declaration instead of making assumptions based on table name
    {
	print "\n\tvoid setPrimaryKey(const NetworkId &keyValue)\n";
	print "\t{\n";
	print "\t\tobject_id.setValue(keyValue);\n";
	print "\t}\n";
    }
    if ($tablename eq "Message") #TODO:  parse PRIMARY_KEY declaration instead of making assumptions based on table name
    {
	print "\n\tvoid setPrimaryKey(const NetworkId &keyValue)\n";
	print "\t{\n";
	print "\t\tmessage_id.setValue(keyValue);\n";
	print "\t}\n";
    }
    print "};\n\n";
}

sub translateType
{
    my($dbtype)=@_;
  SWITCH:
    {
	if ($dbtype eq "int") { $ctype="DB::BindableLong"; last SWITCH; }
	if ($dbtype eq "float") { $ctype="DB::BindableDouble"; last SWITCH; }
	if ($dbtype eq "date") { $ctype="DB::BindableTimestamp"; last SWITCH; }
	if ($dbtype eq "char(1)") { $ctype="DB::BindableBool"; last SWITCH; }
	if ($dbtype =~ /^varchar\((\d+)\)/) { $ctype="DB::BindableString<$1>"; last SWITCH; }
	die "Datatype $dbtype not handled.";
    }
    
    $ctype
}
