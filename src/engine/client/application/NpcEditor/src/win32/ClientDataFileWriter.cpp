// ============================================================================
//
// ClientDataFileWriter.cpp
// Copyright 2004 Sony Online Entertainment, Inc.
// All Rights Reserved.
//
// ============================================================================

#include "FirstNpcEditor.h"
#include "ClientDataFileWriter.h"

#include "sharedFoundation/CrcLowerString.h"
#include "sharedFoundation/TemporaryCrcString.h"
#include "sharedGame/AssetCustomizationManager.h"
#include "sharedMath/PaletteArgb.h"
#include "sharedObject/Appearance.h"
#include "sharedObject/CustomizationData.h"
#include "sharedObject/CustomizationDataProperty.h"
#include "sharedObject/Object.h"
#include "sharedObject/PaletteColorCustomizationVariable.h"
#include "sharedRegex/RegexServices.h"
#include "clientSkeletalAnimation/SkeletalAppearance2.h"
#include "clientSkeletalAnimation/SkeletalAppearanceTemplate.h"

// ----------------------------------------------------------------------------

#include <stdio.h>
#include <string>
#include <vector>

#include "pcre/pcre.h"

// ----------------------------------------------------------------------------

namespace ClientDataFileWriterNamespace
{
	CustomizationData * s_defaultCustomizationData = 0;
	size_t const c_maxLineSize = 1024;

	char const * const c_fileHeader =
		"/* Generated by the NpcEditor built on " __DATE__ " " __TIME__ " */\n"
		"\n"
		"#include \"../../../../../../include/ClientDataFileManager.h\"\n"
		"\n"
		"FORM \"CLDF\"\n"
		"{\n"
		"\tFORM \"0000\"\n"
		"\t{\n";

	char const * const c_fileFooter =
		"\t}\n"
		"}\n";

	void copySourceFileToBuffer(char const * sourceFileName, std::vector< std::string > & lineBuffer);
	void copyFilteredSourceFileToBuffer(char const * sourceFileName, std::vector< std::string > & lineBuffer);
	void writeBufferToOutputFile(std::vector< std::string > & lineBuffer, FILE * outputFile);

	void writeOwnerData(const std::string &fullVariablePathName, const CustomizationVariable *customizationVariable, void *context);
	void writeWearableData(const std::string &fullVariablePathName, const CustomizationVariable *customizationVariable, void *context);

	int getIntData(const CustomizationVariable *customizationVariable);
	bool isValueDefault(const std::string &fullVariablePathName, int value);
}

using namespace ClientDataFileWriterNamespace;

// ----------------------------------------------------------------------------

void ClientDataFileWriterNamespace::copySourceFileToBuffer(char const * sourceFileName, std::vector< std::string > & lineBuffer)
{
	char line[c_maxLineSize];

	lineBuffer.clear();

	FILE *sourceFile = fopen(sourceFileName, "r");
	if (!sourceFile)
	{
		DEBUG_WARNING(true, ("Failed to open file [%s] for reading.", sourceFileName));
		return;
	}

	while(!feof(sourceFile) && fgets(line, c_maxLineSize, sourceFile))
		lineBuffer.push_back(line);

	//-- done
	fclose(sourceFile);

	return;
}

// ----------------------------------------------------------------------------

void ClientDataFileWriterNamespace::copyFilteredSourceFileToBuffer(char const * sourceFileName, std::vector< std::string > & lineBuffer)
{
	char line[c_maxLineSize];

	//-- regular expression support
	char const * const filterExpr = "SoundEvent|ClientEffectEvent";
	char const *errorString = 0;
	int errorOffset = 0;
	pcre *filterCompiledRegex = 0;

	//-- compile the mif regex.
	filterCompiledRegex = pcre_compile(filterExpr, 0, &errorString, &errorOffset, NULL);
	WARNING(filterCompiledRegex == NULL, ("ClientDataFileWriterNamespace::copyFilteredSourceToOutputFile(): pcre_compile() failed, error=[%s], errorOffset=[%d], regex text=[%s].", errorString, errorOffset, filterExpr));

	FILE *sourceFile = fopen(sourceFileName, "r");
	if (!sourceFile)
	{
		DEBUG_WARNING(true, ("Failed to open file [%s] for reading.", sourceFileName));
		return;
	}

	//-- read each line of the source file and add it to buffer if it matches the filter expression
	while(!feof(sourceFile) && fgets(line, c_maxLineSize, sourceFile))
	{
		int const matchCode = pcre_exec(filterCompiledRegex, NULL, line, static_cast<int>(strlen(line)), 0, 0, 0, 0);

		DEBUG_REPORT_LOG(false, ("[%d:%s] %s", matchCode, sourceFileName, line));

		if (matchCode < -1)
			WARNING(true, ("ClientDataFileWriterNamespace::copyFilteredSourceFileToBuffer() - ERROR: pcre_exec() failed, error code [%d].\n", matchCode));

		if (matchCode >= 0)
			lineBuffer.push_back(line);
	}

	//-- done
	fclose(sourceFile);

	if (filterCompiledRegex != 0)
	{
		RegexServices::freeMemory(filterCompiledRegex);
		filterCompiledRegex = 0;
	}

	return;
}

// ----------------------------------------------------------------------------

void ClientDataFileWriterNamespace::writeBufferToOutputFile(std::vector< std::string > & lineBuffer, FILE * outputFile)
{
	std::vector< std::string >::const_iterator i = lineBuffer.begin();

	for (; i != lineBuffer.end(); ++i)
		fputs(i->c_str(), outputFile);
}

// ----------------------------------------------------------------------------

int ClientDataFileWriterNamespace::getIntData(const CustomizationVariable *customizationVariable)
{
	NOT_NULL(customizationVariable);

	RangedIntCustomizationVariable const *const rangedIntVariable = dynamic_cast<RangedIntCustomizationVariable const*>(customizationVariable);
	FATAL(!rangedIntVariable, ("variable not a ranged int-compatible variable, programmer error."));

	return rangedIntVariable->getValue();
}

// ----------------------------------------------------------------------------

bool ClientDataFileWriterNamespace::isValueDefault(const std::string &fullVariablePathName, int value)
{
	bool ret = false;

	NOT_NULL(s_defaultCustomizationData);

	RangedIntCustomizationVariable const *const defaultRangedIntVariable = dynamic_cast<RangedIntCustomizationVariable const*>(s_defaultCustomizationData->findConstVariable(fullVariablePathName));

	//-- when npcs are loaded via there shared template file, several non-ranged custom variables will show up.
	//-- this just ignores them and assumes their default is zero.
	if(!defaultRangedIntVariable)
	{
		DEBUG_REPORT_LOG(true, ("ClientDataFileWriterNamespace::isValueDefault() - Assuming default 0 [%s]\n", fullVariablePathName.c_str()));
		ret = value == 0;
	}
	else
		ret = value == defaultRangedIntVariable->getValue();

	return ret;
}

// ----------------------------------------------------------------------------

void ClientDataFileWriterNamespace::writeWearableData(const std::string &fullVariablePathName, const CustomizationVariable *customizationVariable, void *context)
{
	NOT_NULL(customizationVariable);
	NOT_NULL(context);
	FATAL(fullVariablePathName.empty(), ("fullVariablePathName is zero-length."));

	int const setValue = getIntData(customizationVariable);

	DEBUG_REPORT_LOG(false, ("Wearable: [%s] = %d\n", fullVariablePathName.c_str(), setValue));

	//-- Don't write default values
	if(!isValueDefault(fullVariablePathName, setValue))
	{
		FILE *const outputFile = static_cast<FILE*>(context);

		//-- Write the wearable customization int setting override.
		fprintf(outputFile, "\t\t\tWearableCustomizationSetInt(\"%s\", %d)\n", fullVariablePathName.c_str(), setValue);
	}
}

// ----------------------------------------------------------------------------

void ClientDataFileWriterNamespace::writeOwnerData(const std::string &fullVariablePathName, const CustomizationVariable *customizationVariable, void *context)
{
	NOT_NULL(customizationVariable);
	NOT_NULL(context);
	FATAL(fullVariablePathName.empty(), ("fullVariablePathName is zero-length."));

	int const setValue = getIntData(customizationVariable);

	DEBUG_REPORT_LOG(false, ("Avatar: [%s] = %d\n", fullVariablePathName.c_str(), setValue));

	//-- Don't write default values
	if(!isValueDefault(fullVariablePathName, setValue))
	{
		FILE *const outputFile = static_cast<FILE*>(context);

		//-- Write the wearable customization int setting override.
		fprintf(outputFile, "\t\tCustomizationSetInt(\"%s\", %d)\n", fullVariablePathName.c_str(), setValue);
	}
}

// ----------------------------------------------------------------------------

bool ClientDataFileWriter::write(Object const * object, char const *outputFileName, char const * sourceFileName, bool mifSource)
{
	//-- Get the skeletal appearance template.
	Appearance const*const app = object->getAppearance();
	SkeletalAppearance2 const*const app2 = app->asSkeletalAppearance2();

	std::vector< std::string > lineBuffer;

	if (!app)
	{
		DEBUG_WARNING(true, ("Object has a NULL appearance."));
		return false;
	}

	SkeletalAppearanceTemplate const *const appearanceTemplate = dynamic_cast<SkeletalAppearanceTemplate const*>(app->getAppearanceTemplate());
	if (!appearanceTemplate)
	{
		DEBUG_WARNING(true, ("Object's appearance template is NULL or not a skeletal appearance template."));
		return false;
	}

	if (mifSource)
		copyFilteredSourceFileToBuffer(sourceFileName, lineBuffer);
	else
		copySourceFileToBuffer(sourceFileName, lineBuffer);

	//-- Open the output file for writing.
	FILE *outputFile = fopen(outputFileName, "w");
	if (!outputFile)
	{
		DEBUG_WARNING(true, ("Failed to open file [%s] for writing.", outputFileName));
		return false;
	}

	//-- Begin output.
	fprintf(outputFile, c_fileHeader);

	//-- Source file
	writeBufferToOutputFile(lineBuffer, outputFile);

	fprintf(outputFile, "\n");

	//-- Add mesh generators.
	int const count = app2->getWearableCount();
	for (int i = 0; i < count; ++i)
	{
		SkeletalAppearance2 const*const sa = app2->getWearableAppearance(i);

		CustomizationData * cd = const_cast<SkeletalAppearance2 *>(sa)->fetchCustomizationData();

		fprintf(outputFile, "\t\tBeginWearable\n");

		const SkeletalAppearanceTemplate * sat = dynamic_cast<const SkeletalAppearanceTemplate *>(sa->getAppearanceTemplate());

		s_defaultCustomizationData = new CustomizationData(*const_cast<Object *>(sa->getOwner()));
		s_defaultCustomizationData->fetch();

		for(int j=0; sat && j < sat->getMeshGeneratorCount(); ++j)
		{
			char const *const mgnName = sat->getMeshGeneratorName(j).getString();
			if (mgnName && (strlen(mgnName) > 0))
			{
				fprintf(outputFile, "\t\t\tUseMeshGenerator(\"%s\")\n", mgnName);
				IGNORE_RETURN(AssetCustomizationManager::addCustomizationVariablesForAsset(sat->getMeshGeneratorName(j), *s_defaultCustomizationData, false));
			}
		}

		cd->iterateOverConstVariables(writeWearableData, outputFile, false);

		s_defaultCustomizationData->release();
		s_defaultCustomizationData = 0;

		//-- End output.
		fprintf(outputFile, "\t\tEndWearable\n");

		cd->release();
	}

	fprintf(outputFile, "\n");

	//-- Write out non-default owner variables
	{
		//-- Add modifed shared_owner customized variables
		CustomizationData * cd = const_cast<SkeletalAppearance2 *>(app2)->fetchCustomizationData();

		s_defaultCustomizationData = new CustomizationData(*const_cast<Object *>(object));
		s_defaultCustomizationData->fetch();

		AppearanceTemplate const * t = app2->getAppearanceTemplate();
		IGNORE_RETURN(AssetCustomizationManager::addCustomizationVariablesForAsset(t->getCrcName(), *s_defaultCustomizationData, false));

		cd->iterateOverConstVariables(writeOwnerData, outputFile, false);

		s_defaultCustomizationData->release();
		s_defaultCustomizationData = 0;

		cd->release();
	}

	//-- Done
	fprintf(outputFile, c_fileFooter);

	//-- Close output file.
	fclose(outputFile);

	//-- Success.
	return true;
}

// ============================================================================
