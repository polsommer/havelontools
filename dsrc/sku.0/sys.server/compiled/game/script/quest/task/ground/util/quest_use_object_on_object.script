/*

This script is placed on an object to make the object usable when the player has a specific
Object Targeted.
*/

include library.utils;
include library.static_item;
include library.buff;
include library.collection;
include library.sui;
include library.utils;

//constants
const string_id SID_USE_CAMERA				= new string_id("collection", "use_camera");
const string_id SID_PICTURE_TAKEN			= new string_id("collection", "picture_taken");
const string_id SID_INVALID_TARGET			= new string_id("collection", "invalid_target");
const string_id SID_SUCCESS_SNAPSHOT			= new string_id("collection", "successful_snapshot");
const string_id SID_PHOTO_SLOT_COMPLETE			= new string_id("collection", "photo_slot_complete");
const string_id NOT_WHILE_INCAPPED			= new string_id ("quest/ground/util/quest_giver_object", "not_while_incapped");
const string_id SID_NOT_WHILE_IN_COMBAT			= new string_id("base_player", "not_while_in_combat");
const string_id MUST_DISMOUNT				= new string_id ("collection", "must_dismount");
const string_id CREATURE_IS_DEAD			= new string_id ("collection", "creature_is_dead");

const string OBJECT_KEY 				= "quest.object_key";


trigger OnObjectMenuRequest(obj_id player, menu_info mi)
{	
	if(!canManipulate(player, self, true, true, 15, true))
	{
		return SCRIPT_CONTINUE;
	}
	
	if(!utils.isNestedWithinAPlayer(self))
	{
		return SCRIPT_CONTINUE;
	}

	menu_info_data mid = mi.getMenuItemByType(menu_info_types.ITEM_USE);
	if(mid != null)
	{
		mid.setServerNotify(true);
	}
	else
	{
		mi.addRootMenu(menu_info_types.ITEM_USE, new string_id("spam", "costume_learn"));
	}

	return SCRIPT_CONTINUE;
}

trigger OnObjectMenuSelect(obj_id player, int item)
{
	sendDirtyObjectMenuNotification(self);

	if(utils.getContainingPlayer(self) != player)
	{
		return SCRIPT_CONTINUE;
	}
	
	//congrats! You clicked on the USE option, lets see if you pass all the checks
	if(item != menu_info_types.ITEM_USE)
	{
		return SCRIPT_CONTINUE;
	}
	
	if(isIncapacitated(player) || isDead(player))
	{
		sendSystemMessage(player, new string_id("player_structure", "while_dead"));
		return SCRIPT_CONTINUE;
	}
	if(getState(player, STATE_RIDING_MOUNT) == 1)
	{
		sendSystemMessage(player, MUST_DISMOUNT);
		return SCRIPT_CONTINUE;
	}
	if(isDead(player) || isIncapacitated(player))
	{
		sendSystemMessage(player, NOT_WHILE_INCAPPED);
		return SCRIPT_CONTINUE;
	}

	//get the lookAtTarget
	obj_id intended = getIntendedTarget(player);
	
	if(!isIdValid(intended))
	{
		//both targets are null	
		sendSystemMessage(player, SID_INVALID_TARGET);				
	}
	else
	{			
		//check to see if the target qualifies
		checkValidTarget(player, intended, self);
	}

	return SCRIPT_CONTINUE;
}

boolean checkValidTarget(obj_id player, obj_id target, obj_id self)
{
	if(!isValidId(player) || !exists(player))
	{
		return false;	
	}

	if(!isValidId(target) || !exists(target))
	{
		return false;	
	}

	if(!isValidId(self) || !exists(self))
	{
		return false;	
	}
	
	if(!hasObjVar(self, OBJECT_KEY))
	{
		return false;	
	}

	if(!hasObjVar(target, OBJECT_KEY))
	{
		sendSystemMessage(player, SID_INVALID_TARGET);	
		return false;	
	}

	string keyString = getStringObjVar(self, OBJECT_KEY);
	if(keyString == null || keyString.length() <= 0)
	{
		return false;	
	}
	
	if(!keyString.equals(getStringObjVar(target, OBJECT_KEY)))
	{
		return false;	
	}

	if(isMob(target) && (isDead(target) || isIncapacitated(target)))
	{
		sendSystemMessage(player, CREATURE_IS_DEAD);	
		return false;		
	}

	return true;	
}
