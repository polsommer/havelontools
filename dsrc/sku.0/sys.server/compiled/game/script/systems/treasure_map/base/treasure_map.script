/**
 * Copyright (c) ©2000-2003 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        treasure_map.script
 * Description:  treasure_map base logic
 * @author       $Author: breinhart $
 * @version      $Revision: 2007 Jeff Haskell Version 2 $
 */

//------------------------------------------------
// Includes
//------------------------------------------------

include library.buff;
include library.combat;
include library.groundquests;
include library.locations;
include library.stealth;
include library.sui;
include library.utils;

//------------------------------------------------
// Constants
//------------------------------------------------

const string_id SID_USE					= new string_id("treasure_map/treasure_map", "use");
const string_id SID_SEARCH_AREA				= new string_id("treasure_map/treasure_map", "search_area");
const string_id SID_EXTRACT_TREASURE 			= new string_id("treasure_map/treasure_map", "extract_treasure");
const string_id SID_SYS_NO_REGIONS 			= new string_id("treasure_map/treasure_map", "sys_no_regions");
const string_id SID_SYS_STORE_WAYPOINT 			= new string_id("treasure_map/treasure_map", "sys_store_waypoint");
const string_id SID_SYS_WAYPOINT_EXISTS 		= new string_id("treasure_map/treasure_map", "sys_waypoint_exists");
const string_id SID_SYS_DIST_HERE 			= new string_id("treasure_map/treasure_map", "sys_dist_here");
const string_id SID_SYS_DIST_NEAR			= new string_id("treasure_map/treasure_map", "sys_dist_near");
const string_id SID_SYS_DIST_FAR 			= new string_id("treasure_map/treasure_map", "sys_dist_far");
const string_id SID_SYS_NOT_IN_INV 			= new string_id("treasure_map/treasure_map", "sys_not_in_inv");
const string_id SID_SYS_NO_WAYPOINT 			= new string_id("treasure_map/treasure_map", "sys_no_waypoint");
const string_id SID_SYS_START_PINPOINT			= new string_id("treasure_map/treasure_map", "sys_start_pinpoint");
const string_id SID_SYS_CANT_PINPOINT 			= new string_id("treasure_map/treasure_map", "sys_cant_pinpoint");
const string_id SID_SYS_PINPOINT 			= new string_id("treasure_map/treasure_map", "sys_pinpoint");
const string_id SID_SYS_FOUND 				= new string_id("treasure_map/treasure_map", "sys_found");
const string_id SID_SYS_EXTRACTING 			= new string_id("treasure_map/treasure_map", "sys_extracting");
const string_id SID_SYS_NO_COMBAT			= new string_id("treasure_map/treasure_map", "sys_no_combat");
const string_id SID_SYS_NO_MOUNT			= new string_id("treasure_map/treasure_map", "sys_no_mount");
const string_id SID_SYS_NO_DEAD_INCAP			= new string_id("treasure_map/treasure_map", "sys_no_dead_incap");
const string_id SID_SYS_TREASURE_TIME_LIMIT		= new string_id("treasure_map/treasure_map", "sys_time_limit");


const string SID_STORE_WAYPOINT 			= "@treasure_map/treasure_map:store_waypoint";
const string SID_CLOSE 					= "@treasure_map/treasure_map:close";
const string SCRIPT_DUMMY_CHEST 			= "systems.treasure_map.base.dummy_treasure_drum";
const string TREASURE_TABLE 				= "datatables/treasure_map/treasure_map.iff";
const string DUMMY_CHEST 				= "object/tangible/container/drum/nonopening_treasure_drum.iff";
const string LOOT_TABLE_81_90 				= "treasure/treasure_81_90";

const int EXPLOITER_RANGE 				= 64;
const int MIN_DISTANCE_TO_MAP_OWNER 			= 300;
const int MAX_DISTANCE_FOR_SEARCH			= 16;
//------------------------------------------------
// OnAttach
//------------------------------------------------
trigger OnAttach()
{
	obj_id map = self;	
	messageTo(map, "getMapTreasurePlanet", null, 1, false);
	return SCRIPT_CONTINUE;
}

//------------------------------------------------
// OnDestroy
//------------------------------------------------
trigger OnDestroy()
{
	//Destroy the associated waypoint if the map is destroyed in the player inventory or by a CSR
	obj_id map = self;	
	obj_id player = getObjIdObjVar(map, "owner");
	if (!isIdValid(player) || !exists(player))
		return SCRIPT_CONTINUE;
	//If the chest exists, don't destroy the waypoint, the player may still need it.
	obj_id chest = getObjIdObjVar(map, "chest");
	if (!isIdValid(chest) || !exists(chest))
	{
		obj_id mapWaypoint = getObjIdObjVar(map, "treasureMapWaypoint");
		if ( isIdValid(mapWaypoint) )
		{		
			//destroyWaypointInDatapad(getWaypoint(map, player), player);
			destroyWaypointInDatapad(mapWaypoint, player);
			removeObjVar(chest, "treasureMapWaypoint");
		}
	}
	return SCRIPT_CONTINUE;
}

//------------------------------------------------
// OnObjectMenuRequest
// This is the dynamic Radial Menu for the inventory Map object
//------------------------------------------------

trigger OnObjectMenuRequest(obj_id player, menu_info mi)
{
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to retrieve a menu for player " + player + ". [ OnObjectMenuRequest() ]");
		sendSystemMessage(player, "The treasure map failed to retrieve the menu correctly.", null);
		return SCRIPT_CONTINUE;
	}
	
	obj_id map = self;	
	if (!hasObjVar( map, "pinpoint"))
	{
		//There is no need to show the player a search area menu option if they haven't even received
		//a treasure map waypoint
		if (!isValidId(getWaypoint(map, player)))
		{
			mi.addRootMenu (menu_info_types.ITEM_USE, SID_USE);
		}
		else
		{
			mi.addRootMenu (menu_info_types.ITEM_USE, SID_SEARCH_AREA);
			setObjVar( map, "searchArea", true );
		}
	}
	else
	{
		if (!isValidId(getWaypoint(map, player)))
		{
			mi.addRootMenu (menu_info_types.ITEM_USE, SID_USE);
		}
		else
		{	
			mi.addRootMenu (menu_info_types.ITEM_USE, SID_EXTRACT_TREASURE);
		}
	}
	return SCRIPT_CONTINUE;
}

//------------------------------------------------
// OnObjectMenuSelect
// The trigger that handle the map radial selection
//------------------------------------------------
trigger OnObjectMenuSelect(obj_id player, int item)
{
	if (!isIdValid(player) && item == -1)
	{
		CustomerServiceLog("treasureMap", "a treasure map trigger failed for player " + player + ". [ OnObjectMenuSelect() ]");
		sendSystemMessage(player, "The treasure map failed to select the menu correctly.", null);
		return SCRIPT_CONTINUE;		
	}
	
	obj_id map = self;	
	sendDirtyObjectMenuNotification(map);
	if (item == menu_info_types.ITEM_USE)
	{
		if (hasObjVar(map, "pinpoint") && hasObjVar(map, "searchArea"))
		{
			doDebugLogging("treasureMap", "Player has pinpoint and searchArea");					
			
			boolean statePass = checkState(player);			
			if(!statePass)
				return SCRIPT_CONTINUE;
				
			boolean planetCheck = checkScene(player, map);			
			if(!planetCheck)
				return SCRIPT_CONTINUE;

			// Extract treasure.
			extractTreasure(map, player);
	
			return SCRIPT_CONTINUE;
		}
		else if (!hasObjVar(map, "pinpoint") && hasObjVar(map, "searchArea") && isValidId(getWaypoint(map, player)))
		{
			doDebugLogging("treasureMap", "Player has just searchArea");					
					
			boolean statePass = checkState(player);			
			if(!statePass)
				return SCRIPT_CONTINUE;
				
			boolean planetCheck = checkScene(player, map);			
			if(!planetCheck)
				return SCRIPT_CONTINUE;
			
			// Search the area.
			searchArea(map, player);
			
			return SCRIPT_CONTINUE;
		}
		else
		{
			doDebugLogging("treasureMap", "player has no objvars or has deleted waypoint");					
		
			// Display info dialog.
			// This function kicks off the SUI with a Store Waypoint button 
			displayDialog( map, player );

			return SCRIPT_CONTINUE;
		}

	}
	return SCRIPT_CONTINUE;
}

//------------------------------------------------
// getWaypoint
// This function checks the player waypoints in the player datapad
// if a waypoint for the map is not found it returns a NULL
//------------------------------------------------
obj_id getWaypoint(obj_id map, obj_id player)
{
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not retrieve a waypoint for player because the map OID was not passed properly. [ getWaypoint() ]");
		sendSystemMessage(player, "The treasure map failed to get a waypoint.", null);			
		return null;
	}
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not retrieve a waypoint for player because the player OID was not passed properly. [ getWaypoint() ]");
		return null;
	}
	// Get treasure location.
	location treasureLoc = getLocationObjVar(map, "treasureLoc");
	// Check to see if any waypoints are already to that location.
	obj_id[] data = getWaypointsInDatapad(player);
	if (data != null)
	{
		for (int i=0; i<data.length; i++)
		{
			if (isIdNull(data[i]))
				continue;
			location waypointLoc = getWaypointLocation(data[i]);
			if ((waypointLoc != null) && (waypointLoc == treasureLoc))
			{
				// Matching waypoint.
				doDebugLogging("treasureMap", "Waypoint found ");					
				return data[i];
				
			}
		}
	}
	return null;
}

//------------------------------------------------
// displayDialog
//------------------------------------------------
void displayDialog(obj_id map, obj_id player)
{
	if(utils.hasScriptVar(map,"suiOpen"))
	{
		return;
	}
	
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not allow the player to view dialog for player because the map OID was not passed properly. [ displayDialog() ]");
		sendSystemMessage(player, "The treasure map failed to display dialog properly.", null);	
		return;
	}	
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not allow the player to view dialog for player because the player OID was not passed properly. [ displayDialog() ]");
		return;
	}
	// Make sure we are in the player's inventory.
	obj_id inventory = getObjectInSlot( player, "inventory" );
	if ( !contains( inventory, map ) )
	{
		sendSystemMessage( player, SID_SYS_NOT_IN_INV );
		return;
	}

	// Get our localization file.
	if ( !dataTableOpen( TREASURE_TABLE ) )
		return;

	//Get the dialog for the popup UI.  This objvar was set in the onAttach trigger	
	string entryName = getStringObjVar(map, "mob");

	// Get string ids.
	string text = "@treasure_map/treasure_map:text_" + entryName;
	string title = "@treasure_map/treasure_map:title_" + entryName;

	// Check for speical text and title.
	if ( hasObjVar( map, "map_text" ) )
		text = "@treasure_map/treasure_map:" + getStringObjVar( map, "map_text" );
	if ( hasObjVar( map, "map_title" ) )
		title = "@treasure_map/treasure_map:" + getStringObjVar( map, "map_title" );

	// Display the dialog.
	createDialog( map, player, text, title );
}

//------------------------------------------------
// createDialog
// This fucntion creates the SUI message box with the basic back story on what the treasure map is
// as well as providing the player with the STORE WAYPOINT and CLOSE Buttons
//------------------------------------------------

int createDialog(obj_id map, obj_id player, string text, string title)
{
	
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to create map dialog because no player OID was passed. [ createDialog() ]");
		return -1;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to create map dialog because no map OID was passed. [ createDialog() ]");
		sendSystemMessage(player, "The treasure map failed to create dialog properly.", null);			
		return -1;
	}
	if (text == null || text == "")
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to create dialog because no map text was passed. [ createDialog() ]");
		sendSystemMessage(player, "The treasure map failed to attain the dialog text properly.", null);			
		return -1;
	}
	if (title == null || title == "")
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to create a dialog title because no title text was passed. [ createDialog() ]");
		sendSystemMessage(player, "The treasure map failed to attain the dialog title properly.", null);			
		return -1;
	}
	
	//MAKE SURE THE UI DIALOG CANNOT BE OPENED MORE THAN ONCE VIA SCRIPTVAR
	utils.setScriptVar(map, "suiOpen", true);
	// Create the dialog page.
	int pid = sui.createSUIPage( sui.SUI_MSGBOX, map, player, "handleDialogInput" );
	// Add elements text.
	sui.setSUIProperty( pid, sui.MSGBOX_PROMPT, sui.PROP_TEXT, text );
	sui.setSUIProperty (pid, sui.MSGBOX_TITLE, sui.PROP_TEXT, title );
	// Add buttons.
	sui.msgboxButtonSetup( pid, sui.OK_CANCEL );
	sui.setSUIProperty( pid, sui.MSGBOX_BTN_CANCEL, sui.PROP_TEXT, SID_CLOSE);
	sui.setSUIProperty( pid, sui.MSGBOX_BTN_OK, sui.PROP_TEXT, SID_STORE_WAYPOINT);
	// Show dialog.
	sui.showSUIPage( pid );
	return pid;
}

//------------------------------------------------
// handleDialogInput
// This function handles the player's selection on the SUI message box
// If the player selects STORE WAYPOINT (or hits the cancel X in corner) the storeWaypoint function is called
// If the player selects CLOSE the treasure map remains intact and no waypoint is issued.
//------------------------------------------------

messageHandler handleDialogInput()
{
	obj_id map = self;	
	if ( (params == null) || (params.isEmpty()) )
	{
		//make sure the objvar is removed so that the player can re-read the treasure map dialog		
		removeObjVar(map, "pinpoint");
		return SCRIPT_CONTINUE;
	}

	// Determine which button was pressed.
	obj_id player = sui.getPlayerId( params );
	int bp = sui.getIntButtonPressed( params );
	switch ( bp )
	{

		case sui.BP_OK:		// "Close"		
			//Where map is the actual map object in player inventory
			boolean waypointStored = storeWaypoint(map, player);
			if (waypointStored)
				setObjVar( map, "searchArea", true );
			
			utils.removeScriptVar(map, "suiOpen");
			return SCRIPT_CONTINUE;

		case sui.BP_CANCEL: // "Store Waypoint"
			//make sure the objvar is removed so that the player can re-read the treasure map dialog
			utils.removeScriptVar(map, "suiOpen");
			return SCRIPT_CONTINUE;
	}

	return SCRIPT_CONTINUE;
}

//------------------------------------------------
// storeWaypoint
// the treasure creates a waypoint in the player's datapad and stores the location on itmap when used (storedLoc)
// The waypoint is always on the same planet in which the player reads the treasure map
// obj_id map = map object in player inventory
//------------------------------------------------
boolean storeWaypoint(obj_id map, obj_id player)
{	
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not allow the player to store a waypoint because no player OID was passed. [ storeWaypoint() ]");
		return false;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not allow the player to store a waypoint because no waypoint OID was passed. [ storeWaypoint() ]");
		sendSystemMessage(player, "The treasure map failed to create a waypoint.", null);			
		return false;
	}

	string req_planet = getStringObjVar(map, "planet");
	//Set a default if no objvar attained
	if (req_planet == null || req_planet == "")
	{
		//req_planet = "tatooine";
		CustomerServiceLog("treasureMap", "a treasure map failed to find the planet variable for player " + player + " "+ getName(player)+".  It is probably an old legacy treasure map. [ storeWaypoint() ]");
		sendSystemMessage(player, "This map is so old that when you attempt to get the waypoint the disk fails.  The disk doesn't seem to function properly.", null);					
		return false;
	}	

	string scene = getCurrentSceneName();
	//Set a default if no scene attained
	if (scene == null || scene == "")
	{
		scene = "tatooine";
		CustomerServiceLog("treasureMap", "a treasure map failed to find the current scene for player " + player + ". [ storeWaypoint() ]");
		sendSystemMessage(player, "The treasure map failed to attain the correct planet scene, Tatooine is now the current scene.", null);					
	}

	if (!scene.equals(req_planet) && !(isGod(player)))
	{
		// This is the wrong planet.
		//*********Temporary string message to player?
		string requiredPlanet = localize(new string_id("planet_n", req_planet));
		sendSystemMessage(player, "You need to travel to " + requiredPlanet + " before receiving the waypoint.", null);
		return false;
	}
	
	location locationMapLocation = getMapLocation(map, player);
	if (locationMapLocation != null && locationMapLocation != "")
	{
		// Check to see if any waypoints are already to that location.
		if (isValidId(getWaypoint(map, player)) && exists(getWaypoint(map, player)))
		{
			sendSystemMessage( player, SID_SYS_WAYPOINT_EXISTS );
			return true;
		}
		else if (isGod(player))
		{
			sendSystemMessage(player, "Since you are in GODMODE, the treasure map will be on this planet. Test the treaure planet variable by getting the waypoint while not in GODMODE.", null);
			
			CustomerServiceLog("treasureMap", "Player: " + player + " " + getName(player)
				+ " is godplayer using map: " + map
				+ " to make the map waypoint on their current planet location as opposed to: " + locationMapLocation
				+". [ storeWaypoint() ]");
		}

		//this happens either when the player is on the correct planet or if the tester is in godmode.
		boolean boolSuccessWaypointCreation = createMapWaypointAtLocation(map, player, locationMapLocation);
		return true;
	}
	else
	{
		CustomerServiceLog("treasureMap", "a treasure map " + map + "failed to attain a valid location for player " + player + ". [ storeWaypoint() ]");
		sendSystemMessage(player, "The treasure map failed to attain a valid location.", null);			
	}
	
	return false;
}	

//------------------------------------------------
// searchArea
//
// Used to pinpoint the exact location of the treasure once we get close.
//------------------------------------------------

void searchArea(obj_id map, obj_id player)
{
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not allow the player to search the waypoint because no player OID was passed. [ searchArea() ]");
		return;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not allow the player to search the waypoint for exact treasure location with player " + player + ". [ searchArea() ]");
		sendSystemMessage(player, "The treasure map failed.  You cannot search at this time.", null);	
		return;
	}

	boolean inPlayerInventory = utils.isNestedWithin(map, player);
	if (!inPlayerInventory)
	{
		sendSystemMessage( player, SID_SYS_NOT_IN_INV );
		return;
	}
	
	// Make sure we have a location.
	if ( !hasObjVar( map, "treasureLoc" ) || (!isValidId(getWaypoint(map, player))) )
	{
		sendSystemMessage( player, SID_SYS_NO_WAYPOINT );
		return;
	}

	// Start to pinpoint location.
	sendSystemMessage( player, SID_SYS_START_PINPOINT );
	dictionary params = new dictionary();
	params.put("player", player);
	messageTo( map, "finishSearchArea", params, 5, false );

}

//------------------------------------------------
// finishSearchArea
//------------------------------------------------

messageHandler finishSearchArea()
{
	obj_id map = self;	
	if ( params == null )
		return SCRIPT_CONTINUE;
	obj_id player = params.getObjId("player");

	// Make sure we are in the player's inventory.
	obj_id inventory = getObjectInSlot(player, "inventory");
	if (!contains( inventory, map))
	{
		sendSystemMessage(player, SID_SYS_NOT_IN_INV);
		return SCRIPT_CONTINUE;
	}

	// Make sure we have a location.
	if (!hasObjVar(map, "treasureLoc") || (!isValidId(getWaypoint(map, player))))
	{
		sendSystemMessage( player, SID_SYS_NO_WAYPOINT );
		return SCRIPT_CONTINUE;
	}

	// Pinpoint actual location.
	location treasureLoc = getLocationObjVar( map, "treasureLoc" );
	location curLoc = getLocation( player );
	float dist = utils.getDistance2D(treasureLoc, curLoc);
	if (dist <= MAX_DISTANCE_FOR_SEARCH && dist >= 0)
	{
		// Close enough to pinpoint.
		obj_id waypoint = getWaypoint( map, player );
		
		//avoid trees and rocks
		treasureLoc = groundquests.getRandom2DLocationAroundLocation(player, 1, 1, 10, 40);
		sendSystemMessage( player, SID_SYS_PINPOINT );
		setWaypointLocation( waypoint, treasureLoc );
		setObjVar( map, "treasureLoc", treasureLoc );
		
		//If the player is within a certain distance, the menu changes
		setObjVar( map, "pinpoint", true );
	}
	else
	{
		// Not close enough.
		sendSystemMessage( player, SID_SYS_CANT_PINPOINT );
	}

	return SCRIPT_CONTINUE;
}

//------------------------------------------------
// extractTreasure
//
// Used to find treasure once the location has been pinpointed.
//------------------------------------------------

void extractTreasure(obj_id map, obj_id player)
{
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not allow the player to extract the treasure because no player OID was passed. [ extractTreasure() ]");
		return;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map would not allow the player to extract the treasure for player " + player + ". [ extractTreasure() ]");
		sendSystemMessage(player, "The treasure map failed.  You cannot extract the treasure.", null);	
		return;
	}		
	// Make sure we are in the player's inventory.
	obj_id inventory = getObjectInSlot( player, "inventory" );
	if ( !contains( inventory, map ) )
	{
		sendSystemMessage( player, SID_SYS_NOT_IN_INV );
		return;
	}

	// Make sure we have a location.
	if ( !hasObjVar( map, "treasureLoc" ) || (getWaypoint( map, player ) == null) )
	{
		sendSystemMessage( player, SID_SYS_NO_WAYPOINT );
		return;
	}

	// Can't do this multiple times at once.
	if ( hasObjVar( map, "extracting" ) )
	{
		sendSystemMessage( player, SID_SYS_EXTRACTING );
		return;
	}
	// Attempt to find the treasure.
	location treasureLoc = getLocationObjVar( map, "treasureLoc" );
	location curLoc = getLocation(player);
	float dist = utils.getDistance2D( treasureLoc, curLoc );
	if (dist <= 8 && dist >= 0)
	{
		// Close enough.
		sendSystemMessage( player, SID_SYS_DIST_HERE );
			
		CustomerServiceLog("treasureMap", "Player: " + player + " " + getName(player)
			+ " is extracting a chest using: " + map
			+ " at location " + getLocation(player) + ". [ extractTreasure() ]");

		// Start spawn timer.
		dictionary params = new dictionary();
		params.put( "player", player );
		messageTo( map, "spawnTreasure", params, 2, false );

		setObjVar( map, "extracting", true );
		//removeObjVar(map, "pinpoint");
	}
	else if ( dist <= 30 )
	{
		// Almost close enough.
		sendSystemMessage( player, SID_SYS_DIST_NEAR );
	}
	else
	{
		// Not even close.
		sendSystemMessage( player, SID_SYS_DIST_FAR );
	}
}

//------------------------------------------------
// spawnTreasure
// This function handles most of the dynamic facets of the script.  
//------------------------------------------------
messageHandler spawnTreasure()
{
	obj_id map = self;	
	if ((params == null) || (params.isEmpty()))
	{
		return SCRIPT_CONTINUE;
	}
	
	obj_id player = params.getObjId( "player" );
	boolean paramsReceived = getTreasureParams(map, player);
	
	if (!paramsReceived)
	{
		CustomerServiceLog("treasureMap", "TREASURE MAP ERROR: Player: " + player + " " + getName(player)
			+ " could not spawn a treasure chest at location: " + getLocation(player)
			+ ". Please notify development. [ spawnTreasure() ]");

		doDebugLogging("treasureMap", "a treasure map failed to spawn for player: "+player+". [ spawnTreasure() ]");
		sendSystemMessage(player, "You could not extract the chest. Notify Customer Service.", null);					

		return SCRIPT_CONTINUE;
	}				

	int treasureLevel = getIntObjVar(map, "max");

	removeObjVar(map, "extracting");
	// You found something!
	sendSystemMessage( player, SID_SYS_FOUND );
	sendSystemMessage(player, SID_SYS_TREASURE_TIME_LIMIT);		
	// Destroy waypoint.
	obj_id waypoint = getWaypoint( map, player );
	if (isIdNull(waypoint))
		destroyObject( waypoint );

	location playerLocation = getLocation(player);
	playerLocation.y = getHeightAtLocation( playerLocation.x, playerLocation.z );

	// Get treasure location.
	//location treasureLoc = getLocationObjVar( map, "treasureLoc" );
	//treasureLoc.y = getHeightAtLocation( treasureLoc.x, treasureLoc.z );

	// Create a treasure drum here.
	obj_id treasureChest = createObject(DUMMY_CHEST, playerLocation);
	if (!isValidId(treasureChest))
	{
		CustomerServiceLog("treasureMap", "TREASURE MAP ERROR: Player: " + player + " " + getName(player)
			+ " could not spawn a treasure chest at location: " + playerLocation
			+ ". Please notify development. [ spawnTreasure() ]");

		doDebugLogging("treasureMap", "a treasure map failed to spawn for player: "+player+". [ spawnTreasure() ]");
		sendSystemMessage(player, "You could not extract the chest. Notify Customer Service.", null);					

		return SCRIPT_CONTINUE;
	}

	//Keeps the chest from being looted by another player
	setObjVar(treasureChest, "owner", player);
	setOwner(treasureChest, player);

	//if the player is invisible, they will become visible when extracting
	string invis = stealth.getInvisBuff(player);
	if(invis != null)
	{
		stealth.checkForAndMakeVisibleNoRecourse(player);
	}

	//New script
	attachScript(treasureChest, SCRIPT_DUMMY_CHEST);
	//this is so the waypoint isn't destroyed too soon.
	setObjVar(map, "chest", treasureChest);			
	//this is used for loot level in treasur_drum.script
	setObjVar(treasureChest, "treasureLevel", treasureLevel);

	if (hasObjVar(map, "treasureMapWaypoint"))
	{
		obj_id treasureMapWaypoint = getObjIdObjVar(map, "treasureMapWaypoint");
		setObjVar(treasureChest, "treasureMapWaypoint", treasureMapWaypoint);
	}

	//grab all the needed vars to pass as params later
	string loot_table = getStringObjVar(map, "loot_table");
	setObjVar(treasureChest, "loot_table", loot_table);			
	string type = getStringObjVar(map, "mob");			
	int mobLevel = getIntObjVar(map, "mobLevel");
	int groupModifier = getIntObjVar(map, "groupModifier");
	int count = getIntObjVar(map, "count");
	int dataTableIdx = getIntObjVar(map, "dataTableIdx");

	boolean verifiedAllVars = verifyVariablesNotNull(loot_table, type, mobLevel, groupModifier, count, dataTableIdx);
	if(!verifiedAllVars)
	{
		CustomerServiceLog("treasureMap", "TREASURE MAP ERROR: Player: " + player + " " + getName(player)
			+ " could not spawn guards correctly because data taken off the map: " + map
			+ " was incomplete, corrupted or invalid. [ spawnTreasure() ]");

		doDebugLogging("treasureMap", "a treasure map failed to retrieve all data necessary to spawn treasure for player: "+player+". [ spawnTreasure() ]");
		sendSystemMessage(player, "The treasure map failed to attain treasure guard data. Notify Customer Service.", null);					
	}

	//Check to make sure the boss is added under certain situations
	string boss_mob = checkForBossMobSpawn(player, mobLevel, groupModifier, dataTableIdx, loot_table);

	dictionary outparams = new dictionary();
	outparams.put("loot_table", loot_table);
	outparams.put("count", count);
	outparams.put("type", type);
	outparams.put("mobLevel", mobLevel);
	outparams.put("location", playerLocation);
	outparams.put("player", player);
	outparams.put("boss_mob", boss_mob);
	outparams.put("groupModifier", groupModifier);

	doDebugLogging("treasureMap", "loot_table: " + loot_table 
		+ " count: " + count 
		+ " type: " + type
		+ "player: " + player
		+ "treasureLoc: " + playerLocation
		+ "boss_mob: " + boss_mob								
		);

	CustomerServiceLog("treasureMap", "Player: " + player + " " + getName(player) 
		+ " spawned treasure chest: " + treasureChest 
		+ " at location: " + getLocation(treasureChest)
		+ " with " + count 
		+ " mobs of type: " + type
		+ " and their level being: " + mobLevel 
		+". [ spawnTreasure() ]");

	messageTo(treasureChest, "spawnTreasureGuards", outparams, 0, false);

	CustomerServiceLog("treasureMap", "Player: " + player + " " + getName(player)
		+ " extracted the treasure chest at location: " + playerLocation
		+ " and the map:" + map 
		+ " was destroyed. [ spawnTreasure() ]");

	doDebugLogging("treasureMap", "map: "+ map + " destroyed. [ spawnTreasure() ]");
	
	// Destroy the treasure map in the player inventory.
	destroyObject(map);
	return SCRIPT_CONTINUE;
}

//------------------------------------------------
// getTreasureParams
// This function grabs all of the treasure parameters.
// It is important to note that this function is called as the player is EXTRACTING the
// treasure.  
//------------------------------------------------
boolean getTreasureParams(obj_id map, obj_id player)
{
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to get the treasure parameters because the player OID was not passed. [ getTreasureParams() ]");
		return false;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to get the treasure parameters because the map OID was not passed. [ getTreasureParams() ]");
		sendSystemMessage(player, "The treasure map failed to get the loot table and group modifier.", null);	
		return false;
	}		
	
	if (!hasObjVar(map, "max"))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to get the treasure parameters because the max variable was not found on the map. [ getTreasureParams() ]");
		sendSystemMessage(player, "The treasure map failed to find the map max level.", null);	
		return false;
	}

	boolean successPlayerLvl = setPlayerGroupLevel(map, player);
	if (!successPlayerLvl)
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to retrieve the player combat level. [ getTreasureParams() ]");
		sendSystemMessage(player, "The treasure map failed to retrieve your combat level.", null);	
		return false;		
	}
	
	int intMaxLevel = getIntObjVar(map, "max");
	int intMinLevel = getIntObjVar(map, "min");
	int dataTableIdx = getIntObjVar(map, "dataTableIdx");

	if (dataTableIdx == -1)
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to retrieve the datatable index. This is possibly due to the datatable being changed or corrupted . [ getTreasureParams() ]");
		sendSystemMessage(player, "The treasure map failed to retrieve a data index.", null);	
		return false;			
	}

	//count will eventually be the number of mobiles created
	int count = 0;
	//type will eventually be the mobile spawn name
	string type = null;	
	dictionary params = dataTableGetRow(TREASURE_TABLE, dataTableIdx);
	if(params.isEmpty() || params == null)
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to get the treasure loot table and group modifier for player " + player + ". [ getTreasureParams() ]");
		sendSystemMessage(player, "The treasure map failed to get the loot table and group modifier.", null);	
		return false;
	}

	//create/save objvar for treasure associated with map level
	setObjVar(map, "loot_table", params.getString("loot_table"));

	//Mobile Count gets saved to the map here
	if (!hasObjVar(map, "count"))
	{
		count = rand(params.getInt("mob_count_min"), params.getInt("mob_count_max"));
		if (hasObjVar(map, "playerLevel"))
		{
			int playerLevel = getIntObjVar(map, "playerLevel");

			//how much higher do we want to make the mob for challeng?
			int mobLevelModifier = params.getInt("mob_level_modifier");

			int mobLevel = getMobLevel(map, player, playerLevel, intMaxLevel, intMinLevel, mobLevelModifier);
			setObjVar(map, "mobLevel", mobLevel);
			if (hasObjVar(map, "groupModifier"))
			{
				count = getEnemyReCount(player, map, count);
			}
		}
		setObjVar(map, "count", count);
	}
	return true;
}

//------------------------------------------------
// setPlayerGroupLevel
// This function gets the player level or the highest level of a group player,
// whichever is higher.  If the group members are more than 300 meters away, they aren't
// counted as part of the final group.  
// If the group is less than 8 an exploiter function can be called to see if players are standing by
// waiting to ambush the guards and help the owner.
//------------------------------------------------
boolean setPlayerGroupLevel(obj_id map, obj_id player)
{
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to set the group level because the player OID was not passed. [ setPlayerGroupLevel() ]");
		return false;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to set the group level because the map OID was not passed. [ setPlayerGroupLevel() ]");
		sendSystemMessage(player, "The treasure map failed to set the group level.", null);	
		return false;
	}
	
	//init the intPlayerLevel and possibly overwrite it later	
	int intPlayerLevel = getLevel(player);	
	if (intPlayerLevel == -1|| intPlayerLevel == 0)
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to use the player's correct combat level. [ setPlayerGroupLevel() ]");
		sendSystemMessage(player, "The treasure map failed to retrieve your current level.", null);	
		//if no level returned, set the level to 5
		intPlayerLevel = 5;
		return false;
	}
	
	location ownerLocation = getLocation(player);
	string ownerArea = ownerLocation.area;
	obj_id groupId = getGroupObject(player);
	if (isValidId(groupId))
	{
		obj_id[] groupOids = getGroupMemberIds(groupId);

		//set to one because we are counting the player as group member
		//then excluding the player from examination below
		int finalCount = 1; 
		//If another player in the group has a higher level, that player's level is used
		for (int i = 0; i < groupOids.length; i++)
		{
			if(!isValidId(groupOids[i]) || !exists(groupOids[i]))
				continue;
				
			if(groupOids[i] == player)
				continue;
			
			location groupMemberLocation = getLocation(groupOids[i]);
			if(groupMemberLocation == null)
				continue;

			string groupMemberArea = groupMemberLocation.area;
			if(ownerArea != groupMemberArea)
				continue;

			float dist = utils.getDistance2D(ownerLocation, groupMemberLocation);
			if(dist > MIN_DISTANCE_TO_MAP_OWNER)
				continue;

			int groupMemberLevel = getLevel(groupOids[i]);
			//if the group member is within min meters and valid
			if(groupMemberLevel > intPlayerLevel)
			{
				intPlayerLevel = groupMemberLevel;				
			}
			//Add to get an accurate mob count scale
			finalCount++;
		}
		
		//set a modifier to be used to increase the mobile count
		//add 1 so the player themselves are counted
		if(finalCount > 0 && finalCount <= 8)
		{
			setObjVar(map, "groupModifier", finalCount);
		}
		else if (finalCount > 8 )
		{
			//just in case
			setObjVar(map, "groupModifier", 8);
		}
	}
	//This is used to remove the groupModifier if the player received the initial
	//planet waypoint in a group, but since has dispanded the group
	else
	{
		removeObjVar(map, "groupModifier");
	}
	
	//sniff out the exploiter group
	/*
	if(getIntObjVar(map, "groupModifier") < 8)
	{
		int exploiterLevel = findAmbushNearBy(map, player, intPlayerLevel, ownerLocation);		
		if((exploiterLevel > 0) && (exploiterLevel > intPlayerLevel))
		{
			setObjVar(map, "playerLevel", exploiterLevel);
			return true;	
		}
	}
	*/
	setObjVar(map, "playerLevel", intPlayerLevel);
	return true;
}

//------------------------------------------------
// findGroupNearBy
// This function looks at the surrounding area and attempts to locate 
// others waiting by to ambush the enemies for the map owner.  Unfortunately 
// this will also pick up bystanders as well as exploiters
//------------------------------------------------

int findAmbushNearBy(obj_id map, obj_id player, int intPlayerLevel, location ownerLocation)
{
	if(!isIdValid(player))
		return 0;
	if(intPlayerLevel < 0)
		return 0;
	if(ownerLocation == null)
		return 0;
		
	int exploiterLevel = intPlayerLevel;
	int exploiterGroup = 0;
	
	obj_id[] playersNear = getAllObjectsWithScript(ownerLocation, EXPLOITER_RANGE, "player.base.base_player");
	if(playersNear == null || playersNear.length == 0)
		return 0;

	for (int i = 0; i < playersNear.length; i++)
	{
		if(!isValidId(playersNear[i]) || !exists(playersNear[i]))
			continue;
		//we need to make sure we are county PCs and nothing else
		if(!isPlayer(playersNear[i]))
			continue;
		//we don't care if this is the player
		if(playersNear[i] == player)
			continue;
		//if this player is moving, driving or riding by disregard
		if(getLocomotion(playersNear[i]) == 3)
			continue;
		//no need to go on forever
		if(i == 14)
			break;
		
		// If the player is just standing there waiting we assume the player 
		// is there within the range designated to help the map owner.
		int playerNearLevel = getLevel(playersNear[i]);
		if( playerNearLevel > intPlayerLevel)
		{
			exploiterLevel = playerNearLevel;
			exploiterGroup =+ 1;
		}
	}
		
	int groupModifier = getIntObjVar(map, "groupModifier");
	if(groupModifier > 0)
		exploiterGroup =+ groupModifier;
		
	if(exploiterGroup > 8)
		exploiterGroup = 8;
		
	sendSystemMessage(player, "exploiterGroup:"+exploiterGroup, null);	
	sendSystemMessage(player, "groupModifier:"+groupModifier, null);	
	
	//We need to set the objvar so the number of enemy spawns is correct
	if(exploiterGroup > 0 && exploiterGroup > groupModifier)
		setObjVar(map, "groupModifier", exploiterGroup);
	
	return exploiterLevel;
}

//------------------------------------------------
// getEnemyReCount
// This function evaluates to see if a group is involved in the treasure extraction.
// If a group is involved, the enemy count is increased based on the number of player (or pets)
// in the group (the number of group members = groupModifier objvar.
// This function is called once when the treasure is extracted.
//------------------------------------------------
int getEnemyReCount(obj_id player, obj_id map, int intCurrentCount)
{
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to recount the enemies before treasure extraction because the player OID was not received. [ getEnemyReCount() ]");
		return -1;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to recount the enemies before treasure extraction because the map OID was not received. [ getEnemyReCount() ]");
		sendSystemMessage(player, "The treasure map failed to recount enemies.", null);
		return -1;
	}
	if (intCurrentCount == -1)
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to recount the enemies before treasure extraction because the enemy count was -1. [ getEnemyReCount() ]");
		sendSystemMessage(player, "The treasure map failed to recount enemies due to incorrect enemy count variable.", null);
		return -1;	
	}

	int groupRecount = 0;
	int finalCount = 0;

	if (hasObjVar(map, "groupModifier"))
	{
		//The 'modifier' here is just the number of players in the group
		int modifier = getIntObjVar(map, "groupModifier");
		if (modifier >= 2)
		{
			if(modifier <= 4)
			{
				groupRecount = modifier+2;
			}
			else
			{
				groupRecount = rand(modifier, modifier+1);
			}
		}
	}
	if (groupRecount > intCurrentCount)
	{
		return groupRecount;
	}

	return intCurrentCount;
}

//------------------------------------------------
// getMapLocation
// This function selects a good location within a certain distance of the player
// Planet isn't needed for this function.  The planet objvar is used to make sure this function isn't called on the wrong planet.
//------------------------------------------------
location getMapLocation(obj_id map, obj_id player)
{
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to recount the enemies before treasure extraction because the player OID was not received. [ getEnemyReCount() ]");
		return null;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to recount the enemies before treasure extraction because the map OID was not received. [ getEnemyReCount() ]");
		sendSystemMessage(player, "The treasure map failed to recount enemies.", null);
		return null;
	}

	// Get treasure location.
	location treasureLoc = null;
	location storedLoc = getLocationObjVar( map, "treasureLoc" );
	//if null, this gets the location for the first time
	if ( storedLoc == null )
	{
		setObjVar(map, "owner", player);
		setObjVar(map, "noTrade", true);

		// Get list of our regions.
		region[] nearRegions = getRegionsAtPoint( getLocation( player ) );
		if ( nearRegions == null )
		{
			// Found no regions.  Major error.
			sendSystemMessage( player, SID_SYS_NO_REGIONS );
			destroyObject( map );
			return null;
		}
		//Get the nearest city and find a location outside of it
		region closestCity = locations.getClosestCityRegion( nearRegions[0] );		
		boolean goodLoc = false;
		for (int i=0; (i<30)&&!goodLoc; i++)
		{
			// Find a location to use. If the first location is in a city, get a new location
			treasureLoc = locations.getGoodLocationOutsideOfRegion(closestCity, 1, 1, 8000);
			
			if (!isValidLocation(treasureLoc, 10.f) || treasureLoc == null || locations.isInCity(treasureLoc))
			{
				continue;
			}
			goodLoc = true;
		}
		
		if (treasureLoc == null)
		{
			return null;		
		}

		//Set the treasureLoc on the map object
		setObjVar( map, "treasureLoc", treasureLoc );
	}
	else
	{
		treasureLoc = storedLoc;
	}
	return treasureLoc;
}

//------------------------------------------------
// createMapWaypointAtLocation
// All this function does is create a waypoint in the player datapad to the correct 
// location and stores the waypoint on the map object
//------------------------------------------------
boolean createMapWaypointAtLocation(obj_id map, obj_id player, location locationMapLocation)
{
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to create a waypoint because the player OID was not passed. [ getMobLevel() ]");
		return false;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to create a waypoint for player " + player + " because the map object was not passed. [ createMapWaypointAtLocation() ]");
		sendSystemMessage(player, "The treasure map failed to attain a waypoint because there was no map found.", null);
		return false;
	}
	if (locationMapLocation == null)
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to create a waypoint for player " + player + " because the map object was not passed. [ createMapWaypointAtLocation() ]");
		sendSystemMessage(player, "The treasure map failed to attain a waypoint because there was no map found.", null);
		return false;
	}

	// Create a waypoint to specified location.
	obj_id waypoint = createWaypointInDatapad(player, locationMapLocation);
	if (!isIdValid(waypoint))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to create a waypoint for player " + player + " because the waypoint couldn't be created in the player datapad. [ createMapWaypointAtLocation() ]");
		sendSystemMessage(player, "The treasure map failed to create a waypoint in your datapad.", null);
		return false;
	}
	
	setWaypointVisible(waypoint, true);
	setWaypointActive(waypoint, true);
	setWaypointName(waypoint, "Treasure Location");

	//Set the waypoint object Id on the map object itmap
	setObjVar(map, "treasureMapWaypoint", waypoint);

	// Notify the player.
	sendSystemMessage( player, SID_SYS_STORE_WAYPOINT );
	return true;
}

//------------------------------------------------
// getMobLevel
// simple function to return the level of the mob based on the map min/max 
// or the player level + modifier if the player is between map min/max
//------------------------------------------------
int getMobLevel(obj_id map, obj_id player, int playerLevel, int intMaxLevel, int intMinLevel, int mobLevelModifier)
{
	if (!isIdValid(player))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to get the mob enemy level because the player OID was not passed. [ getMobLevel() ]");
		return -1;
	}
	if (!isIdValid(map))
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to get the mob enemy level for " + player + " because the map OID was not passed. [ getMobLevel() ]");
		sendSystemMessage(player, "The treasure map failed to attain an accurate enemy mob level.", null);
		return -1;
	}
	if (playerLevel < 5)
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to get a useabel player level for " + player + ".  The player level is less than 5. [ getMobLevel() ]");
		sendSystemMessage(player, "The treasure map failed to attain your player level accurately.", null);
		return -1;
	}
	if (intMaxLevel < 10 || intMinLevel > 90)
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to get a mob level for " + player + " because the map maximum level was out of range [ getMobLevel() ]");
		sendSystemMessage(player, "The treasure map failed to attain your player level accurately.", null);
		return -1;
	}
	if (intMinLevel < 1 || intMinLevel > 81)
	{
		CustomerServiceLog("treasureMap", "a treasure map failed to get a mob level for " + player + " because the map minimum level was out of range [ getMobLevel() ]");
		sendSystemMessage(player, "The treasure map failed to attain your player level accurately.", null);
		return -1;
	}			
	
	if (playerLevel > intMaxLevel)
	{
		int newMobLevel = intMaxLevel + mobLevelModifier;
		if(newMobLevel > 90)
		{
			return 90;
		}
		return newMobLevel;
	}	
	if (playerLevel < intMinLevel)
		return intMinLevel;

	int newMobLevel = playerLevel + mobLevelModifier;
	if(newMobLevel > 90)
	{
		return 90;
	}
	return newMobLevel;
}

messageHandler getMapTreasurePlanet()
{
	obj_id map = self;
	int intMaxLevel = getIntObjVar(map, "max");
	
	//The following conditions change the planet data to tatooine when given an error
	if (intMaxLevel <= 0)
	{
		//set to tatooine in failure, there is no player OID at this point so no message to player
		setObjVar(map, "planet", "tatooine");
		CustomerServiceLog("treasureMap", "a treasure map failed to get the correct planet, setting map to Tatooine instead. [ getMapTreasurePlanet() ]");
	}
	
	int dataTableIdx = dataTableSearchColumnForInt(intMaxLevel, "map_level_max", TREASURE_TABLE);
	if (dataTableIdx == -1)
	{
		//set to tatooine in failure. No player OID to send system message for failure
		setObjVar(map, "planet", "tatooine");
		CustomerServiceLog( "treasureMap", "a treasure map failed to get the correct planet because the treasure map data table failed to return a row number. [ getMapTreasurePlanet() ]");
	}
	
	//set the row on the datatable as an objvar so the script is more efficient
	setObjVar(map, "dataTableIdx", dataTableIdx);

	string allPlanets = dataTableGetString(TREASURE_TABLE, dataTableIdx, "planets");
	string chosenPlanet = "";

	string[] planetList = split(allPlanets, ',');
	if (planetList.length == 1)
	{
		chosenPlanet = planetList[0];
	}
	else
	{
		int planetIndex = rand(0,planetList.length-1);
		chosenPlanet = planetList[planetIndex];
	}
	if (chosenPlanet != null && chosenPlanet != "")
	{
		//create/save objvar for planet on the map
		setObjVar(map, "planet", chosenPlanet);
	}
	else
	{
		//set to tatooine in failure
		setObjVar(map, "planet", "tatooine");
	}
	return SCRIPT_CONTINUE;
}

string checkForBossMobSpawn(obj_id player, int mobLevel, int groupModifier, int dataTableIdx, string loot_table)
{
	if(!loot_table.equals(LOOT_TABLE_81_90)) 
		return "none";
	//for testing purposes
	if(isGod(player) && hasObjVar(player, "boss_mob"))
		return dataTableGetString(TREASURE_TABLE, dataTableIdx, "boss_mob");
	if(mobLevel < 80)
		return "none";
	if(groupModifier < 8)
		return "none";
	
	return dataTableGetString(TREASURE_TABLE, dataTableIdx, "boss_mob");
}

boolean verifyVariablesNotNull(string loot_table, string type, int mobLevel, int groupModifier, int count, int datTableIdx)
{
	if(loot_table == "" || loot_table.equals(""))
		return false;
	if(type == "" || type.equals(""))
		return false;
	if(mobLevel <= 0)
		return false;
	if(groupModifier < 0)
		return false;
	if(count < 2)
		return false;
	if(datTableIdx < 0)
		return false;
	
	return true;
}

boolean checkState(obj_id player)
{
	if(getState(player, STATE_COMBAT) == 1)
	{
		sendSystemMessage(player, SID_SYS_NO_COMBAT);
		return false;
	}
	if(getState(player, STATE_RIDING_MOUNT) == 1)
	{
		sendSystemMessage(player, SID_SYS_NO_MOUNT);
		return false;
	}
	if(isDead(player) || isIncapacitated(player))
	{
		sendSystemMessage(player, SID_SYS_NO_DEAD_INCAP);
		return false;
	}
		
	return true;
}

boolean checkScene(obj_id player, obj_id map)
{	
	//validate same planet
	string req_planet = getStringObjVar(map, "planet"); 
	string scene = getCurrentSceneName();
	doDebugLogging("treasureMap", "planet: " +req_planet);
	if(scene.equals(req_planet))
		return true;

	// This is the wrong planet.
	string requiredPlanet = localize(new string_id("planet_n", req_planet));
	sendSystemMessage(player, "You need to travel to " + requiredPlanet + " before using the map.", null);
	return false;
}

void doDebugLogging(string section, string message)
{
	LOG(section, message);
}