include library.create;
include library.utils;
include library.ai_lib;
include ai.ai_combat;
include library.factions;
include library.xp;

inherits theme_park.poi.base;

const string CREATURE_TABLE				= "datatables/mob/creatures.iff";
const int MAX_ITERATIONS				= 5;
const int MIN_NON_DIFFICULTY_CREATURES			= 2;
const int MAX_NON_DIFFICULTY_CREATURES			= 5;	// between min/max of non-difficulty creatures. We use these to backfill
const int MAX_LAIR_HEALTH				= 850000;


const float CREATURE_LAIR_EXCHANGE			= 0.25f;	//amount multiplied by creature xp value

										   // in order to determine the lair xp value

/* -----------------12/5/2002 8:20PM-----------------
 * This script is attached to a POI object by the POI Launch
 * script.
 * --------------------------------------------------*/
trigger OnAttach()
{
	location locTest = getLocation(self);
	float fltHeight = getHeightAtLocation(locTest.x, locTest.z);

	if(fltHeight != locTest.y)
	{
		locTest.y = fltHeight;
		setLocation(self, locTest);	// reset y height

	}

	// HACK HACK HACK HACK STARTS HERE!
	string strLairType = getStringObjVar(self, "spawning.lairType");

	if(strLairType == null)
	{
		LOG("DESIGNER_FATAL", "Object " + self + " at " + getLocation(self) + " has no lairType objvar. Please fix ASAP");
		destroyObject(self);
		return SCRIPT_CONTINUE;
	}

	int intIndex = strLairType.indexOf("theater");

	if(intIndex > -1)
	{
		if(!hasObjVar(self, "intTheaterCheck"))
		{
			int intRoll = rand(1, 2);

			if(intRoll < 75)
			{
				setObjVar(self, "intNoTheaters", 1);
				setObjVar(self, "spawning.buildingType", "none");
			}

			setObjVar(self, "intTheaterCheck", 1);
		}
	}

	if(hasObjVar(self, "npc_lair.target"))
	{
		removeObjVar(self, "npc_lair.target");
	}

	// HACK HACK HACK HACK ENDS HERE!, NO MORE HACKS BELOW, PLEASE STOP LOOKING
	initializePoi(self);
	//messageTo( self, "handleNpcLairDecay", null, 604800.0f, true );//one week

	return SCRIPT_CONTINUE;
}

trigger OnInitialize()
{
	initializePoi(self);
	return SCRIPT_CONTINUE;
}

/* -----------------12/7/2002 12:41PM----------------
 * Creates the theater (building) and spawns all the
 * mobiles.
 *
 * @param poiBaseObject	the central poi object
 * --------------------------------------------------*/
void initializePoi(obj_id poiBaseObject)
{
	obj_id self = getSelf();

	if(hasObjVar(self, "npc_lair.numberOfMobiles"))
	{
		int numRespawned = getIntObjVar(self, "npc_lair.numRespawned");
		int population = getIntObjVar(self, "npc_lair.numberOfMobiles");

		if(numRespawned >= (population * 3))
		{
			if(!poiIsCompleted(self))
			{
				poiComplete(self);
			}

			destroyObject(self);

			return;
		}
	}

	string diff = getStringObjVar(poiBaseObject, "spawning.lairDifficulty");
	int lairLevel = getIntObjVar(poiBaseObject, "spawning.intDifficultyLevel");
	int groupSize = getIntObjVar(poiBaseObject, "spawning.groupSize");
	string lairType = getStringObjVar(poiBaseObject, "spawning.lairType");
	string lairDatatable = "datatables/npc_lair/" + lairType + ".iff";

	if(!dataTableOpen(lairDatatable))
	{
		destroyObject(self);
		return;
	}

	PROFILER_START("npc_lair.script.initializePoi." + lairType);

	string strFaction = utils.getFactionSubString(lairType);

	if(strFaction != null)
	{
		setObjVar(poiBaseObject, factions.FACTION, strFaction);
	}

	dictionary dctParams = new dictionary();

	dctParams.put("lairType", lairType);
	dctParams.put("diff", diff);
	messageTo(poiBaseObject, "doTheater", dctParams, 1, false);

	dctParams = new dictionary();
	dctParams.put("lairType", lairType);
	dctParams.put("lairLevel", lairLevel);
	dctParams.put("groupSize", groupSize);

	if(lairType.equals("") || lairLevel < 1)
	{
		LOG("designer_fatal", "Failed spawning lairType " + lairType + " at level " + lairLevel);
		destroyObject(self);
		return;
	}

	messageTo(poiBaseObject, "makeSomeMobiles", dctParams, 4, false);

	//spawnNpcLairMobiles( poiBaseObject, lairType, lairLevel );

	messageTo(poiBaseObject, "handleNpcAiManagement", null, 20, false);
	PROFILER_STOP("npc_lair.script.initializePoi." + lairType);
}

messageHandler doTheater()
{
	string lairType = params.getString("lairType");
	string diff = params.getString("diff");

	createTheater(self, lairType, diff);
	return SCRIPT_CONTINUE;
}

messageHandler makeSomeMobiles()
{
	string lairType = params.getString("lairType");
	int lairLevel = params.getInt("lairLevel");
	int groupSize = params.getInt("groupSize");

	if(groupSize < 1)
		groupSize = 2;
	spawnNpcLairMobiles(self, lairType, lairLevel, groupSize);
	return SCRIPT_CONTINUE;
}

/** After spawning shit, see if it is a creature lair:
 */
void flagCreatureLairs(obj_id poiBaseObject)
{
	PROFILER_START("npc_lair.flagCreatureLairs");

	if(hasObjVar(poiBaseObject, "npc_lair.isNotCreatureLair"))
	{
		PROFILER_STOP("npc_lair.flagCreatureLairs");
		return;
	}

	//A creature lair spawned by the mission system has this:
	obj_id target = getObjIdObjVar(poiBaseObject, "npc_lair.target");	//used by AI to defend the poi target

	if(isIdValid(target))
	{
		setObjVar(poiBaseObject, "npc_lair.isCreatureLair", true);
		setObjVar(target, "npc_lair.isCreatureLair", true);
		setYaw(target, rand(0.0f, 360.0f));
	}

	PROFILER_STOP("npc_lair.flagCreatureLairs");
}

/**
 * received when the NPC LAIR TARGET (if any) is destroyed
 */
messageHandler handleTargetDestroyed()
{
	poiComplete(POI_SUCCESS);
	return SCRIPT_CONTINUE;
}

/*
this moves all important npc lair elements into the appropriate location within the theater.
it will move all mobs to allowable spawn locations, and the objectives to the correct destination.

*/
messageHandler handleTheaterComplete()
{
	PROFILER_START("npc_lair.handleTheaterComplete.Start");
	obj_id objTheater = params.getObjId("master");

	if(!isIdValid(objTheater))
	{
		//LOG("theater", "params is "+params.toString());
		PROFILER_STOP("npc_lair.handleTheaterComplete.Start");
		return SCRIPT_CONTINUE;
	}

	PROFILER_START("npc_lair.handleTheaterComplete.ObjVars");
	setObjVar(self, "theater.objTheater", objTheater);
	PROFILER_STOP("npc_lair.handleTheaterComplete.Start");

	return SCRIPT_CONTINUE;
}

/**
 * Creates the main/central building around which the POI is instantiated
 *
 * If a building is specified in objvar npc_lair.buildingType, then this recreates it
 * Otherwise if chooses a building based on the string diff, from the lairType datatable
 *
 * @param	poiBaseObject	the obj_id of the main POI object
 * @param	lair			the string name of the lair type
 * @param	diff			the string difficulty level ("veryEasy" "easy" "medium" "hard" "veryHard")
 */
void createTheater(obj_id poiBaseObject, string lairType, string diff)
{

	PROFILER_START("npc_lair.script.createTheatre");

	string buildingToSpawn = null;

	if(hasObjVar(poiBaseObject, "spawning.buildingType"))
	{
		buildingToSpawn = getStringObjVar(poiBaseObject, "spawning.buildingType");
	}
	else
	{
		string lairDatatable = "datatables/npc_lair/" + lairType + ".iff";

		string[] buildings = dataTableGetStringColumnNoDefaults(lairDatatable, diff);

		if(buildings == null)
		{
			PROFILER_STOP("npc_lair.script.createTheatre");
			return;
		}
		if(buildings.length == 0)
		{
			PROFILER_STOP("npc_lair.script.createTheatre");
			return;
		}

		buildingToSpawn = buildings[rand(0, buildings.length - 1)];
		setObjVar(poiBaseObject, "spawning.buildingType", buildingToSpawn);
	}

	// NOT IDEAL, BUT WE'RE IN A HURRY. 
	if(buildingToSpawn.startsWith("object/building/poi"))
	{
		buildingToSpawn = "none";	// NO BUILDINGS, STOP IT
	}
	if(buildingToSpawn.startsWith("object/static/structure/naboo/gungan_relic_s01.iff"))
	{
		buildingToSpawn = "none";	// NO BUILDINGS, STOP IT
	}

	if(buildingToSpawn != "none")
	{
		obj_id mainBuilding = poiCreateObject(buildingToSpawn, 0f, 0f);
		int intIndex = lairType.indexOf("theater");

		if(intIndex < 0)
		{
			if(isIdValid(mainBuilding))
			{
				poiSetDestroyMessage(mainBuilding, "handleBuildingDestruction", 1);
				setYaw(mainBuilding, rand(0.0f, 360.0f));
				setObjVar(poiBaseObject, "npc_lair.target", mainBuilding);
				setHpAndXpValues(poiBaseObject, mainBuilding);
			}
		}
		else
		{
			setObjVar(poiBaseObject, "theater.objTheater", mainBuilding);
		}
	}

	PROFILER_STOP("npc_lair.script.createTheatre");
}

/**
 * One the main building is destroyed, flag the POI base object so that it
 * won't ever respawn
 */
messageHandler handleBuildingDestruction()
{
	setObjVar(self, "npc_lair.buildingType", "none");
	poiComplete(POI_SUCCESS);
	return SCRIPT_CONTINUE;
}

float getAverageDifficulty(float[] fltDifficulties)
{
	float fltAverage = 0;

	for(int intI = 0; intI < fltDifficulties.length; intI++)
	{
		fltAverage = fltAverage + fltDifficulties[intI];
	}
	fltAverage = fltAverage / fltDifficulties.length;
	return fltAverage;

}

float getMaxDifficulty(float[] fltDifficulties)
{
	float fltMaxDifficulty = 0;

	for(int intI = 0; intI < fltDifficulties.length; intI++)
	{
		if(fltDifficulties[intI] > fltMaxDifficulty)
		{
			fltMaxDifficulty = fltDifficulties[intI];
		}
	}

	return fltMaxDifficulty;
}

/**
 * Spawns all the mobiles for this lair by "spending" the lairLevel as points
 * to "buy" mobiles from the lairType datatable.
 *
 * As the mobiles are spawned, the mobile "name" is stored in a list of objvars
 * on the poi base object so they can be recreated later if the poi is unloaded/reloaded.
 *
 * @param	poiBaseObject		the obj_id of the base poi object
 * @param	lairType			the name of datatable containing info about what to spawn
 * @param	lairLevel			the difficulty level this lair should be
 */
void spawnNpcLairMobiles(obj_id poiBaseObject, string lairType, int lairLevel, int groupSize)
{
	PROFILER_START("npc_lair.spawnNpcLairMobiles.setup");

	if(utils.hasScriptVar(poiBaseObject, "npc_lair.mobile.0"))
	{
		respawnAllMobiles(poiBaseObject);
		PROFILER_STOP("npc_lair.spawnNpcLairMobiles.setup");
		return;
	}

	string lairDatatable = "datatables/npc_lair/" + lairType + ".iff";
	string[] creatureList = dataTableGetStringColumnNoDefaults(lairDatatable, "mobiles");

	if(creatureList == null)
	{
		LOG("DESIGNER_FATAL", "WARNING: " + lairDatatable + " has no mobiles column.");
		PROFILER_STOP("npc_lair.spawnNpcLairMobiles.setup");
		destroyObject(getSelf());
		return;
	}

	int[] spawnLimit = getSpawnLimit(lairDatatable, creatureList);

	if(spawnLimit == null)
	{
		debugServerConsoleMsg(null, "WARNING: " + lairDatatable + " has no spawn Limit");
		LOG("DESIGNER_FATAL", "WARNING: " + lairDatatable + " has no spawn Limit");
		PROFILER_STOP("npc_lair.spawnNpcLairMobiles.setup");
		destroyObject(getSelf());
		return;
	}

	dictionary[] dctCreatureInfo = new dictionary[creatureList.length];

	for(int intI = 0; intI < creatureList.length; intI++)
	{
		dctCreatureInfo[intI] = dataTableGetRow(CREATURE_TABLE, creatureList[intI]);

		if(dctCreatureInfo[intI] == null)
		{
			PROFILER_STOP("npc_lair.spawnNpcLairMobiles.setup");
			LOG("DESIGNER_FATAL", "For lairType " + lairType + " and creature " + creatureList[intI] + " there is no creatures.tab entry!");
			destroyObject(getSelf());
			return;
		}
	}

	int[] numSpawned = new int[creatureList.length];

	/*
	   spawnLimit[intI] = number of spawns (-1 means no limt)
	   numSpawned[i] is how many of a thing we've got
	   it's synchronized woth creatureList[intI];
	   fltLairLevel is our difficulty levey at a givem time

	   mobileNumber is how many things we've made so far
	 */

	int mobileNumber = 0;
	int intI = 0;

	//debugServerConsoleMsg(null, "npc_lair: Outer Interating "+intMaxIterations);

	PROFILER_STOP("npc_lair.spawnNpcLairMobiles.setup");

	int creatureListLength = creatureList.length;

	if(creatureListLength != spawnLimit.length || creatureListLength != numSpawned.length)
	{
		LOG("DESIGNER_FATAL", "Mis aligned arrays for lair type " + lairType);
		destroyObject(getSelf());
		return;
	}

	PROFILER_START("npc_lair.spawnNpcLairMobiles.makeMobs");

	int intArrayLength = creatureList.length - 1;

	if(intArrayLength < 0)
	{
		intArrayLength = 0;
	}

      	//LOG("lairs", "starting creation loop");
	int xpValue = 0;
	int hpValue = 1500;

	int minSpawn = (int) ((groupSize * 1.5f) + 0.5f);
	int maxSpawn = (int) ((groupSize * 2.5f) + 0.5f);
	int spawnAmount = rand(minSpawn, maxSpawn);

	for(int intTotalCount = 0; intTotalCount < spawnAmount; intTotalCount++)
	{
		PROFILER_START("npc_lair.spawnNpcLairMobiles.makeMobs.innerLoop");

		//LOG("lairs", "starting loop");
		//LOG("lairs", "spawnAmount is "+spawnAmount);
		//LOG("lairs", "intArrayLength is "+intArrayLength);
		//LOG("lairs", "lairLevel is "+lairLevel);

		if(intArrayLength < 0)
		{
			PROFILER_STOP("npc_lair.spawnNpcLairMobiles.makeMobs.innerLoop");
			break;
		}

		// we spawn until we hit 1 of 3 conditions
		// no more spawnlimits
		// max iterations is hit

		// we spawn something
		// we check our spawnlimits
		// we remove from the elements
		// creatureList, spawnLimit, numSpawned

		int intIndex = rand(0, intArrayLength);

		PROFILER_START("npc_lair.spawnNpcLairMobiles.makeMobs.getting");
		int creatureXpValue = xp.getLevelBasedXP(lairLevel);

		xpValue += (int) (CREATURE_LAIR_EXCHANGE * creatureXpValue);
		utils.setScriptVar(poiBaseObject, "npc_lair.mobile." + mobileNumber, creatureList[intIndex]);
		
		numSpawned[intIndex]++;
		mobileNumber++;
		boolean boolSpawnLimit = false;

		if(spawnLimit[intIndex] > 0)
		{
			if(numSpawned[intIndex] >= spawnLimit[intIndex])
			{
				boolSpawnLimit = true;
			}

		}
		PROFILER_STOP("npc_lair.spawnNpcLairMobiles.makeMobs.getting");
		PROFILER_START("npc_lair.spawnNpcLairMobiles.makeMobs.swap");

		// TOO MANY
		if(boolSpawnLimit)
		{
			string strSwapString = "";
			int intSwapInt = 0;
			float fltSwapFloat = 0;

			// we move end element into current, and move current to end

			dictionary dctSwapThing = new dictionary();

			dctSwapThing = dctCreatureInfo[intArrayLength];
			dctCreatureInfo[intIndex] = dctSwapThing;

			strSwapString = creatureList[intArrayLength];
			creatureList[intArrayLength] = creatureList[intIndex];
			creatureList[intIndex] = strSwapString;

			intSwapInt = spawnLimit[intArrayLength];
			spawnLimit[intArrayLength] = spawnLimit[intIndex];
			spawnLimit[intIndex] = intSwapInt;

			intSwapInt = numSpawned[intArrayLength];
			numSpawned[intArrayLength] = numSpawned[intIndex];
			numSpawned[intIndex] = intSwapInt;

			intArrayLength = intArrayLength - 1;
		}

		PROFILER_STOP("npc_lair.spawnNpcLairMobiles.makeMobs.swap");
		PROFILER_STOP("npc_lair.spawnNpcLairMobiles.makeMobs.innerLoop");
	}

	obj_id target = getObjIdObjVar(getSelf(), "npc_lair.target");

	if(mobileNumber <= 0)
	{
		PROFILER_START("npc_lair.spawnNpcLairMobiles.makeMobs.badDifficulty");
		int intJ = 0;

		while(intJ < 3)
		{
			int intRoll = rand(0, creatureList.length - 1);
			obj_id mobile = null;

			mobile = spawnMobile(creatureList[intRoll], target, lairLevel);

			if(isIdValid(mobile))
			{
				int creatureXpValue = xp.getLevelBasedXP(lairLevel);

				xpValue += (int) (CREATURE_LAIR_EXCHANGE * creatureXpValue);
				utils.setScriptVar(poiBaseObject, "npc_lair.mobile." + mobileNumber, creatureList[intRoll]);
				numSpawned[intRoll]++;
				mobileNumber++;
			}
			intJ = intJ + 1;
		}
		LOG("DESIGNER_FATAL", "BAD MOJO WARNING: object id: " + poiBaseObject);
		LOG("DESIGNER_FATAL", "BAD MOJO WARNING: lairType: " + lairType);
		LOG("DESIGNER_FATAL", "BAD MOJO WARNING: mobileNumber: " + mobileNumber);
		PROFILER_STOP("npc_lair.spawnNpcLairMobiles.makeMobs.badDifficulty");
	}
	
	//increase health since NGE world
	//moving the lair HP calculation outside the loop, lets hope this doesnt break the lair system
	
	//LOG("lairs", "lairLevel is "+lairLevel);
	//lets make sure we aren't making busted high or low level lairs
	if(lairLevel < 5)
		lairLevel = 5;
	if (lairLevel > 90)
		lairLevel = 90;
	
	//base lair health on mission difficulty referenced to creature stats of that level
	int avgAttrib = dataTableGetInt(create.STAT_BALANCE_TABLE, lairLevel - 1, "HP");
	
	//LOG("lairs","avgAttrib " +avgAttrib);
	//LOG("lairs","groupSize " +groupSize);

	int intMinHP = (int) (avgAttrib * 0.9f);
	int intMaxHP = (int) (avgAttrib * 1.1f);
			
	hpValue += 6 * (rand(intMinHP, intMaxHP));
	
	//scale up the lair health based on groupsize
	if(groupSize > 1)
		hpValue = hpValue * groupSize;
		
	//LOG("lairs","spawnNpcLairMobiles:hpValue after loop " +hpValue);
	
	if(hpValue > MAX_LAIR_HEALTH)
		hpValue = MAX_LAIR_HEALTH;

	setObjVar(poiBaseObject, "npc_lair.targetHps", hpValue);
	setObjVar(poiBaseObject, "npc_lair.targetXps", xpValue);
	setObjVar(poiBaseObject, "npc_lair.lairDifficulty", lairLevel);	// Suppress linting - The lint script incorrectly catches this

	if(isIdValid(target))
	{
		setObjVar(target, "intCombatDifficulty", lairLevel);	// Suppress linting - The lint script incorrectly catches this
		setMaxHitpoints(target, hpValue);
		setHitpoints(target, hpValue);
	}
	else
	{
		dictionary params = new dictionary();

		params.put("hpValue", hpValue);

		params.put("intCombatDifficulty", lairLevel);
		messageTo(poiBaseObject, "handleDelayedTargetSetup", params, 2, false);
	}

	setObjVar(poiBaseObject, "npc_lair.numberOfMobiles", mobileNumber);
	respawnAllMobiles(poiBaseObject);
	PROFILER_STOP("npc_lair.spawnNpcLairMobiles.makeMobs");
}

messageHandler handleDelayedTargetSetup()
{
	obj_id target = getObjIdObjVar(self, "npc_lair.target");

	if(!isIdValid(target))
		return SCRIPT_CONTINUE;

	int hpValue = params.getInt("hpValue");
	int intCombatDifficulty = params.getInt("intCombatDifficulty");

	setObjVar(target, "intCombatDifficulty", intCombatDifficulty);

	if(hpValue > MAX_LAIR_HEALTH)
		hpValue = MAX_LAIR_HEALTH;

	setMaxHitpoints(target, hpValue);
	setHitpoints(target, hpValue);
	return SCRIPT_CONTINUE;
}

/**
 * gets the spawn limit list
 *
 * @params lairDatatable	the string name of the lair datatable
 * @params creatureList		the string[]  of creature types in this lair
 *
 * @returns an int array of the spawn limits for each creature in the creatureList
 */
int[] getSpawnLimit(string lairDatatable, string[] creatureList)
{
	if(creatureList == null)
		return null;

	int[] entireSpawnLimit = dataTableGetIntColumn(lairDatatable, "spawnLimit");

	if(entireSpawnLimit == null)
	{
		debugServerConsoleMsg(null, "WARNING: " + lairDatatable + " has no spawnLimit column.");
		return null;
	}

	if(entireSpawnLimit.length < creatureList.length)
	{
		debugServerConsoleMsg(null, "WARNING: " + lairDatatable + " has mismatched creature, spawnLimit columns.");
		return null;
	}

	int[] spawnLimitList = new int[creatureList.length];

	for(int i = 0; i < creatureList.length; i++)
		spawnLimitList[i] = entireSpawnLimit[i];

	return spawnLimitList;
}

/**
 * Looks up the difficulty values of all the creatures in the List to spawn
 *
 * @param int[] creatureList
 *
 * @returns int[] difficulty list
 */
float[] getDifficultyList(dictionary[] dctCreatureInfo)
{
	float diffArray[] = new float[dctCreatureInfo.length];

	for(int i = 0; i < dctCreatureInfo.length; i++)
	{
		if(dctCreatureInfo[i] != null)
		{
			diffArray[i] = (float) dctCreatureInfo[i].getInt("level");
		}
		else
		{
			diffArray[i] = 0;
		}
	}

	return diffArray;
}

/**
 * Get the lowest difficulty level of creatures in the spawn List which can still be spawned
 *
 * @param 	difficultyList		The list of difficulty levels in the spawn List
 * @param 	spawnLimit			A parallel list of spawnLimits for each creature in the spawn List
 * @param	numSpawned			A parallel list of the # of each creature spawned so far
 *
 * @return	The lowest difficulty level of a creature not yet spawned to the limit
 */
float getLowestLevel(obj_id poiBaseObj, float[] difficultyList, int[] spawnLimit, int[] numSpawned)
{
	float lowestLevel = 999;

	for(int i = 0; i < difficultyList.length; i++)
	{
		if(spawnLimit[i] == -1 || numSpawned[i] < spawnLimit[i])
		{
			if((difficultyList[i] < lowestLevel) && (difficultyList[i] > 0))
				lowestLevel = difficultyList[i];
		}
	}

	return lowestLevel;
}

messageHandler spawnCreatures()
{
	int mobSpawnLoopNumber = params.getInt("mobSpawnLoopNumber");
	int storedMobSpawnLoopNumber = utils.getIntScriptVar(self, "mobSpawnLoopNumber");

	if(storedMobSpawnLoopNumber != mobSpawnLoopNumber)
		return SCRIPT_CONTINUE;

	obj_id poiBaseObject = self;
	int mobileNumber = params.getInt("mobileNumber");
	obj_id target = null;

	//LOG("npclair", "making some creatures");

	if(!hasObjVar(poiBaseObject, "npc_lair.target"))
	{
		string lairType = getStringObjVar(poiBaseObject, "spawning.lairType");
		string strFaction = utils.getFactionSubString(lairType);

		if(hasObjVar(poiBaseObject, "spawning.target"))
		{
			location locSpawnLocation = getLocation(poiBaseObject);

			if(hasObjVar(poiBaseObject, "theater.objTheater"))
			{
				obj_id objTheater = getObjIdObjVar(poiBaseObject, "theater.objTheater");

				obj_id[] objObjectiveSpawners = getObjIdArrayObjVar(objTheater, "theater.objObjectiveSpawners");

				if(objObjectiveSpawners != null)
				{
					if(objObjectiveSpawners.length > 0)
					{
						locSpawnLocation = getLocation(objObjectiveSpawners[rand(0, objObjectiveSpawners.length - 1)]);
					}
				}
			}

			target = poiCreateObject(poiBaseObject, getStringObjVar(poiBaseObject, "spawning.target"), locSpawnLocation);

			if(isIdValid(target))
			{
				if(strFaction != null)
				{
					factions.setFaction(target, strFaction);	// declare the whatzit!
				}

				setYaw(target, rand(0.0f, 360.0f));
				PROFILER_STOP("npc_lair.setYaw");
				string_id strLairName = new string_id("lair_n", lairType);
				string strTest = getString(strLairName);

				if(strTest != null && strTest != "")
					setName(target, strLairName);

				poiSetDestroyMessage(target, "handleTargetDestroyed");
				setObjVar(poiBaseObject, "npc_lair.target", target);	//used by AI to defend the poi target
				setHpAndXpValues(poiBaseObject, target);
			}
		}
	}
	else
	{
		target = getObjIdObjVar(poiBaseObject, "npc_lair.target");	//used by AI to defend the poi target
	}

	int lairLevel = getIntObjVar(poiBaseObject, "spawning.intDifficultyLevel");

	boolean isCreatureLair = (hasObjVar(poiBaseObject, "npc_lair.isCreatureLair"));

	if(!isIdValid(target))
		isCreatureLair = false;

	int xpValue = xp.getLevelBasedXP(lairLevel);

	string mobileName = utils.getStringScriptVar(poiBaseObject, "npc_lair.mobile." + mobileNumber);

	if(mobileName != null)
	{
		obj_id mobile = null;

		if(lairLevel < 1)
		{
			lairLevel = 1;
		}
		
		if(lairLevel > 90)
		{
			lairLevel = 90;
		}

		// Boss creature?
		if(utils.dataTableGetInt(CREATURE_TABLE, mobileName, "difficultyClass") != 2)
			mobile = spawnMobile(mobileName, target, lairLevel);
		else
		{
			int baseLevel = utils.dataTableGetInt(CREATURE_TABLE, mobileName, "BaseLevel");
			
			// If the boss is a lower level than the lair, then bump its level up.
			if(baseLevel < lairLevel)
				mobile = spawnMobile(mobileName, target, lairLevel);
			else
				mobile = spawnMobile(mobileName, target, false);
		}

		if(isIdValid(mobile))
		{
			if(!ai_lib.isMonster(mobile))
			{
				setObjVar(self, "npc_lair.isNotCreatureLair", true);
			}

			attachNPCLairAiScript(mobile, mobileNumber);

			if(isCreatureLair)
			{
				int creatureXpValue = getIntObjVar(mobile, "combat.intCombatXP");

				//xpValue += (int)(CREATURE_LAIR_EXCHANGE * creatureXpValue);
				xpValue = xpValue + creatureXpValue;
			}
		}
	}

	mobileNumber = mobileNumber + 1;

	if(utils.hasScriptVar(self, "npc_lair.mobile." + mobileNumber))
	{
		params.put("mobileNumber", mobileNumber);
		// NOT DONE AT ALL
		messageTo(self, "spawnCreatures", params, .50f, false);
	}
	else
	{
		if(isIdValid(target))
		{
			xpValue = (int) (xpValue * CREATURE_LAIR_EXCHANGE);
			attachScript(target, "systems.combat.credit_for_kills");
			flagCreatureLairs(self);
		}
	}

	if(isIdValid(target))
	{
		setObjVar(target, "combat.intCombatXP", xpValue);
	}

	return SCRIPT_CONTINUE;
}

/**
 * Recreates all the mobiles for the lair, by reading the objvar list created
 * by spawnNpcLairMobiles(), above
 *
 * param	poiBaseObject	the base poi object
 */
void respawnAllMobiles(obj_id poiBaseObject)
{
	obj_id self = getSelf();
	int mobSpawnLoopNumber = utils.getIntScriptVar(self, "mobSpawnLoopNumber");

	++mobSpawnLoopNumber;
	utils.setScriptVar(self, "mobSpawnLoopNumber", mobSpawnLoopNumber);

	dictionary dctParams = new dictionary();

	dctParams.put("mobileNumber", 0);
	dctParams.put("mobSpawnLoopNumber", mobSpawnLoopNumber);
	messageTo(poiBaseObject, "spawnCreatures", dctParams, 4, false);
	return;
}

/**
 * This messageHandler is received from lair_destruct for creature-lairs
 * when it's time to spawn a wave of defenders.
 *
 */
messageHandler handleSpawnWaveOfDefenders()
{
	params.put("mobileNumber", 0);
	messageTo(self, "handleSpawnNextDefender", params, rand(1, 10), false);
	return SCRIPT_CONTINUE;
}

messageHandler handleSpawnNextDefender()
{
	int mobileNumber = params.getInt("mobileNumber");
	obj_id poiBaseObject = self;
	obj_id target = getObjIdObjVar(poiBaseObject, "npc_lair.target");	//used by AI to defend the poi target

	int lairLevel = getIntObjVar(poiBaseObject, "spawning.intDifficultyLevel");
	int xpValue = xp.getLevelBasedXP(lairLevel);

	boolean isCreatureLair = hasObjVar(poiBaseObject, "npc_lair.isCreatureLair");

	if(!isIdValid(target))
		isCreatureLair = false;

	string mobileName = utils.getStringScriptVar(poiBaseObject, "npc_lair.mobile." + mobileNumber);

	if(mobileName == null)
		return SCRIPT_CONTINUE;

	obj_id lair = params.getObjId("spawningFor");

	if(!isIdValid(lair))
		return SCRIPT_CONTINUE;

	int maxHP = getMaxHitpoints(lair);
	int curHP = getHitpoints(lair);

	int numSpawned = getIntObjVar(self, "npc_lair.numberOfMobiles");
	int costPerMobile = maxHP / (numSpawned * 5);

	if(costPerMobile > curHP)
		return SCRIPT_CONTINUE;

	curHP -= costPerMobile;
	setHitpoints(lair, curHP);

	//spawn the mobile with no random location:
	obj_id mobile = null;

	
	mobile = spawnMobile(mobileName, target, lairLevel, false);

	if(isIdValid(mobile))
	{
		int creatureXpValue = getIntObjVar(mobile, "combat.intCombatXP");

		xpValue += (int) (CREATURE_LAIR_EXCHANGE * creatureXpValue);
		attachNPCLairAiScript(mobile, mobileNumber);
		ai_lib.setDefaultCalmBehavior(mobile, ai_lib.BEHAVIOR_LOITER);
	}
	else
	{
		//couldn't create whatever the hell that was supposed to be, so just
		// quit trying:
		debugServerConsoleMsg(self, "designer WARNING: NPC LAIR handleSpawnNextDefender: I couldn't spawn a defender called " + mobileName);
		return SCRIPT_CONTINUE;
	}

	setObjVar(target, "combat.intCombatXP", xpValue);

	//see if there's another creature in the list to spawn, and setup a callback if there is:
	// Unless we've already spawned 20 mobiles, in which case don't, because I mean GEEZ.
	mobileNumber++;

	if(utils.hasScriptVar(poiBaseObject, "npc_lair.mobile." + mobileNumber) && (mobileNumber < 20))
	{
		params.put("mobileNumber", mobileNumber);

		int numAttackers = getIntObjVar(self, "npc_lair.numAttackers");
		int delay = rand(15, 20);

		if(numAttackers > 15)
			delay = 1;
		else if(numAttackers > 10)
			delay = rand(5, 10);
		else if(numAttackers > 5)
			delay = rand(10, 15);

		messageTo(self, "handleSpawnNextDefender", params, delay, false);
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleSpawnBossMonster()
{
	string lairType = getStringObjVar(self, "spawning.lairType");

	if(lairType == null)
		return SCRIPT_CONTINUE;

	string lairDatatable = "datatables/npc_lair/" + lairType + ".iff";

	if(!dataTableHasColumn(lairDatatable, "bossMonster"))
		return SCRIPT_CONTINUE;

	string[] bossMonsters = dataTableGetStringColumnNoDefaults(lairDatatable, "bossMonster");

	if(bossMonsters == null || bossMonsters.length < 1)
		return SCRIPT_CONTINUE;

	location spawnLoc = getLocation(self);

	obj_id target = params.getObjId("npc_lair");
	int lairLevel = getIntObjVar(self, "spawning.intDifficultyLevel");

	for(int i = 0; i < bossMonsters.length; i++)
	{
		int baseLevel = utils.dataTableGetInt(CREATURE_TABLE, bossMonsters[i], "BaseLevel");
		
		obj_id mobile = null;

		// If the boss is a lower level than the lair, then bump its level up.
		if(baseLevel < lairLevel)
			mobile = create.object(bossMonsters[i], spawnLoc, lairLevel);
		else
			mobile = create.object(bossMonsters[i], spawnLoc);

		setObjVar(mobile, "npc_lair.target", target);	//my lair
		stopFloating(mobile);

		//jack players:
		obj_id[] enemies = getPlayerCreaturesInRange(self, 65.0f);

		if(enemies != null && enemies.length > 0)
		{
			obj_id victim = enemies[rand(0, (enemies.length - 1))];

			startCombat(mobile, victim);
		}
	}

	return SCRIPT_CONTINUE;
}

/**
 * This messageHandler is received the second a creature dies
 * So it checks the npc_lair wincondition and completes the POI
 * if necessary
 *
 */
messageHandler handleCreatureDeath()
{
	int numRespawned = getIntObjVar(self, "npc_lair.numRespawned");

	numRespawned++;
	int population = getIntObjVar(self, "npc_lair.numberOfMobiles");
	int maxPopulation = population;

	if(hasObjVar(self, "npc_lair.isCreatureLair"))
		maxPopulation *= 3;

	//sendSystemMessageTestingOnly(obj_id.getObjId(10235263), "numRespawned="+numRespawned);
	//sendSystemMessageTestingOnly(obj_id.getObjId(10235263), "population="+population);

	if(numRespawned >= maxPopulation)
	{
		if(!hasObjVar(self, "npc_lair.target"))
		{
			poiComplete(self, POI_SUCCESS);
		}
		else
		{
			obj_id objTarget = getObjIdObjVar(self, "npc_lair.target");

			if(isIdValid(objTarget))
			{
				setObjVar(objTarget, "fltDamageModifier", 5.0f);

			}
		}
		messageTo(self, "handlePoiTimeOutDestruction", null, 14400f, false);	//no need to persist this message
		return SCRIPT_CONTINUE;
	}
	else
		setObjVar(self, "npc_lair.numRespawned", numRespawned);

	//If this is a mission target, then don't respawn anything - just increment the counter, above.
	if(hasObjVar(self, "objMission"))
		return SCRIPT_CONTINUE;

	string name = params.getString("creatureName");

	if(name == null)
		return SCRIPT_CONTINUE;

	messageTo(self, "handleRespawnCreature", params, rand(120, 240), false);

	return SCRIPT_CONTINUE;
}

/**
 * This message handler is received 5 to 10 miuntes after a mobile has been killed
 * So it respawns the mobile.
 *
 * @param	params	a dictionary containing string "name", which is the creatureName to respawn
 */
messageHandler handleRespawnCreature()
{
	if(poiIsCompleted(self))
	{
		return SCRIPT_CONTINUE;
	}

	int lairLevel = getIntObjVar(self, "spawning.intDifficultyLevel");

	obj_id target = getObjIdObjVar(self, "npc_lair.target");	//used by AI to defend the poi target
	string name = params.getString("name");

	if(name != null)
	{
		spawnMobile(name, target, lairLevel);
	}
	else
	{
		name = params.getString("creatureName");

		if(name != null)
		{
			spawnMobile(name, target, lairLevel);
		}
	}

	return SCRIPT_CONTINUE;
}

//spawn a mobile with a random locaiton:
obj_id spawnMobile(string name, obj_id target)
{
	return spawnMobile(name, target, -1);
}

obj_id spawnMobile(string name, obj_id target, int level)
{
	return spawnMobile(name, target, level, true);
}

//spawn a mobile with a random location if randomLoc, else spawn it
// right on the POI base object:
obj_id spawnMobile(string name, obj_id target, boolean randomLoc)
{
	return spawnMobile(name, target, -1, randomLoc);
}

obj_id spawnMobile(string name, obj_id target, int level, boolean randomLoc)
{
	boolean boolMobSpawners = false;

	obj_id mobile = null;
	obj_id objBase = poiGetBaseObject(target);

	if(isIdValid(objBase))
	{
		obj_id objTheater = getObjIdObjVar(objBase, "theater.objTheater");

		if(isIdValid(objTheater))
		{
			obj_id[] objMobSpawners = getObjIdArrayObjVar(objTheater, "theater.objMobSpawners");

			if(objMobSpawners != null && objMobSpawners.length > 0)
			{
				location locSpawnLocation = getLocation(objMobSpawners[rand(0, objMobSpawners.length - 1)]);

				if(locSpawnLocation != null)
				{
					boolMobSpawners = true;
					mobile = poiCreateObject(objBase, name, locSpawnLocation, level);
					stopFloating(mobile);
				}
			}
		}
	}
	
	if(!boolMobSpawners)
	{
		float x = 0.0f;
		float y = 0.0f;

		if(randomLoc)
		{
			x = rand(-25f, 25f);
			y = rand(-25f, 25f);
		}
		else
		{
			x = rand(-15f, 15f);
			y = rand(-15f, 15f);
		}

		mobile = poiCreateObject(name, x, y, level);
		stopFloating(mobile);
	}

	boolean tamable = (utils.dataTableGetFloat(CREATURE_TABLE, name, "canTame") > 0.0f);
	boolean npcLair = hasObjVar(getSelf(), "npc_lair.isNotCreatureLair");

	if(hasObjVar(getSelf(), "npc_lair.isCreatureLair"))
		npcLair = false;

	// Mission lairs can no longer spawn babies
	if(hasObjVar(objBase, "objMission"))
		tamable = false;

	if(isIdValid(mobile))
	{
		if((!randomLoc) && (!boolMobSpawners))
		{
			location homeLoc = getLocation(mobile);

			homeLoc.x += rand(-10, 10);
			homeLoc.z += rand(-10, 10);
			setHomeLocation(mobile, homeLoc);
		}

		string faction = factions.getFaction(mobile);

		if(faction != null)
		{
			//these MUST be aggro:
			if(!factions.isAggro(mobile))
			{
				if(!isPlayer(mobile))
					pvpMakeNeutral(mobile);	//removes old FEF's, if any.
				removeObjVar(mobile, "ai.faction.nonAggro");
			}
		}

		//if this is not a mission-target, then we want to maintain population:
		//if (!hasObjVar(objBase, "objMission") )
		// BUT WE MUST SEND THIS MESSAGE ALWAYS, TO INCREMENT THE POPULATION COUNT:
		poiSetDestroyMessage(mobile, "handleCreatureDeath", 1);

		if(isIdValid(target))
			setObjVar(mobile, "npc_lair.target", target);	//my lair

		if(!ai_lib.isMonster(mobile))
			tamable = false;

		//if we spawn anything that isn't a monster, then this isn't a creature-lair:

		if(!ai_lib.isMonster(mobile))
		{
			setObjVar(getSelf(), "npc_lair.isNotCreatureLair", true);
			npcLair = true;

		}

		return mobile;
	}

	return null;
}

/**
 * After 1 week, flag the POI as complete whether it was completed or not
 *
 * Setup a callback to destroy the POI in 4 hours, if it's still around
 */
messageHandler handleNpcLairDecay()
{
	poiComplete(POI_INCOMPLETE);
	messageTo(self, "handlePoiTimeOutDestruction", null, 14400f, false);	//no need to persist this message
	return SCRIPT_CONTINUE;
}

/**
 * This poi has decayed, been flagged as deleted, and is still around 4 hours later
 * So destroy it.
 */
messageHandler handlePoiTimeOutDestruction()
{
	destroyObject(self);
	return SCRIPT_CONTINUE;
}

void makeBaby(obj_id mobile)
{
	obj_id baseObj = poiGetBaseObject();

	string name = ai_lib.getCreatureName(mobile);

	if(name == null || name == "")
		return;

	float tameChance = utils.dataTableGetFloat(CREATURE_TABLE, name, "canTame");

	if(rand(0.0f, 1.0f) > tameChance)
		return;

	int numBabiesSpawned = utils.getIntScriptVar(baseObj, "npc_lair.numbabies");

	if(numBabiesSpawned > 2 && (rand(1, 100) > 25))
		return;		//75% of the time don't spawn more than 2 baby reatures per lair

	numBabiesSpawned++;
	utils.setScriptVar(baseObj, "npc_lair.numbabies", numBabiesSpawned);
	attachScript(mobile, "ai.pet_advance");	//makes it tamable
}

messageHandler handleNpcAiManagement()
{
	if(hasObjVar(self, "npc_lair.isCreatureLair"))
		doCreatureLairAiManagement(self);
	else
		doNPCLairAiManagement(self);

	return SCRIPT_CONTINUE;
}

void attachNPCLairAiScript(obj_id mobile, int mobileNumber)
{
	if(hasScript(mobile, "ai.pet_advance"))
		return;		//babies do thier own thing
	else if(hasScript(mobile, "ai.tusken_raider"))
		return;		//tuskens do thier own thing
	else if(hasScript(mobile, "ai.soldier"))
		return;		//soldiers do thier own thing

	setObjVar(mobile, "npc_lair.mobileNumber", mobileNumber);
	attachScript(mobile, "systems.npc_lair.npc_lair_ai");	//babies ignore this stuff
}

const int JOB_NONE = 0;		//just do default behavior
const int JOB_LOITER = 1;	//loiter around the lair
const int JOB_SCOUT = 2;	//wander around the lair, return for lair-defense
const int JOB_REST = 3;		//sentinel at the lair, sit or lie down
const int JOB_DEFEND = 4;	//a scout is reporting an attack
const int JOB_HEAL = 5;		//lair is asking for healing
const int JOB_CONVERSE = 6;	//chat
const int JOB_DANCE = 7;	//dance

messageHandler handleScoutAlarm()
{
	//debugSpeakMsg( self, "sending alarm");
	params.put("job", JOB_DEFEND);
	broadcastMessage("handleNpcLairCustomAi", params);
	return SCRIPT_CONTINUE;
}

messageHandler handleCallForHealing()
{
	////debugSpeakMsg( self, "Handle Call for healing received!" );
	if(!hasObjVar(self, "npc_lair.isCreatureLair"))
	{
		////debugSpeakMsg( self, "NOT A CREATURE LAIR" );
		return SCRIPT_CONTINUE;	//only creature lairs do this
	}

	////debugSpeakMsg( self, "sending Handle Npc Lair Custom AI commant" );
	params.put("job", JOB_HEAL);
	broadcastMessage("handleNpcLairCustomAi", params);
	return SCRIPT_CONTINUE;
}

void doCreatureLairAiManagement(obj_id poiBaseObject)
{
	int numMobiles = getIntObjVar(poiBaseObject, "npc_lair.numberOfMobiles");

	if(numMobiles < 2 || numMobiles > 20)
		return;

	int[] jobAssignment = new int[numMobiles];

	for(int currentMob = 0; currentMob < numMobiles; currentMob++)
	{
		if(currentMob < (numMobiles / 5) * 2)
			jobAssignment[currentMob] = JOB_LOITER;
		else if(currentMob < ((numMobiles / 5) * 3))
			jobAssignment[currentMob] = JOB_SCOUT;
		else if(currentMob < ((numMobiles / 5) * 4))
			jobAssignment[currentMob] = JOB_REST;
		else
			jobAssignment[currentMob] = JOB_NONE;
	}

	dictionary params = new dictionary();

	params.put("jobAssignments", jobAssignment);
	params.put("baseObj", poiBaseObject);

	broadcastMessage("handleNpcLairCustomAi", params);

	return;
}

void doNPCLairAiManagement(obj_id poiBaseObject)
{
	int numMobiles = getIntObjVar(poiBaseObject, "npc_lair.numberOfMobiles");

	if(numMobiles < 2 || numMobiles > 20)
		return;

	location danceLoc = new location(getLocation(poiBaseObject));

	switch (rand(1, 4))
	{
	case 1:
		danceLoc.x += rand(7, 10);
		danceLoc.z += rand(7, 10);
		break;
	case 2:
		danceLoc.x -= rand(7, 10);
		danceLoc.z += rand(7, 10);
		break;
	case 3:
		danceLoc.x += rand(7, 10);
		danceLoc.z -= rand(7, 10);
		break;
	case 4:
		danceLoc.x -= rand(7, 10);
		danceLoc.z -= rand(7, 10);
		break;
	}
	setObjVar(poiBaseObject, "npc_lair.danceLoc", danceLoc);

	int[] jobAssignment = new int[numMobiles];

	for(int currentMob = 0; currentMob < numMobiles; currentMob++)
	{
		switch (currentMob)
		{
		case 0:
		case 1:
			jobAssignment[currentMob] = JOB_CONVERSE;
			break;
		case 2:
			jobAssignment[currentMob] = JOB_DANCE;
			break;
		case 3:
		case 4:
			jobAssignment[currentMob] = JOB_REST;
			break;
		default:
			jobAssignment[currentMob] = JOB_NONE;
			break;
		}
	}

	dictionary params = new dictionary();

	params.put("jobAssignments", jobAssignment);
	params.put("baseObj", poiBaseObject);

	broadcastMessage("handleNpcLairCustomAi", params);

	return;
}

void setHpAndXpValues(obj_id poiBaseObject, obj_id target)
{
	if(hasObjVar(poiBaseObject, "npc_lair.targetHps"))
	{
		int hpValue = getIntObjVar(poiBaseObject, "npc_lair.targetHps");

		setMaxHitpoints(target, hpValue);
		setHitpoints(target, hpValue);
	}
	if(hasObjVar(poiBaseObject, "npc_lair.targetXps"))
	{
		int xpValue = getIntObjVar(poiBaseObject, "npc_lair.targetXps");

		setObjVar(target, "combat.intCombatXP", xpValue);
	}
	if(hasObjVar(poiBaseObject, "npc_lair.lairDifficulty"))
	{
		int diff = getIntObjVar(poiBaseObject, "npc_lair.lairDifficulty");

		if(diff < 4)
			diff = 4;
		setObjVar(target, "intCombatDifficulty", diff);
	}

}

boolean canOfferMission(obj_id mobile)
{
	if(rand(1, 10) > 5)
		return false;

	string creatureName = ai_lib.getCreatureName(mobile);

	if(creatureName == null)
		return false;

	return (dataTableGetInt(CREATURE_TABLE, creatureName, "canOfferMission") == 1);
}
