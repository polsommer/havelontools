// -----------------------------------------------------------------------
// Copyright (c) ©2000,2001 Sony Online Entertainment Inc.
// All Rights Reserved
// -----------------------------------------------------------------------
// This is the base library for all dynamic missions. Anything that is used for dynamic missions only goes here

include library.regions;
include library.utils;
include library.battlefield;
include library.create;
include library.ai_lib;
include library.locations;
include library.money;
include library.create;
include library.chat;
include library.ai_lib;
include library.anims;
include library.jedi;
include library.factions;
include library.missions;
include library.group;

inherits systems.missions.base.mission_base;

const float MIN_DESTROY_DISTANCE				= 350f;

const int FACTION_DELIVER_REWARD_VALUE				= 150;
const int FACTION_REWARD_VALUE					= 100;

const int INFORMANT_EASY					= 1;
const int INFORMANT_MEDIUM					= 2;
const int INFORMANT_HARD					= 3;

const int MAX_SPAWN_ATTEMPTS					= 3;
const int MIN_DISTANCE_FOR_RETRY				= 400;
const int MAX_DISTANCE_FOR_RETRY				= 600;

const int DESTRUCTION_REWARD_MODIFIER				= 100;
const int BOUNTY_REWARD_MODIFIER				= 150;

// we use the below for contextualzizaton
const int MISSION_DIFFICULTY_EASY				= 1;
const int MISSION_DIFFICULTY_MEDIUM				= 2;
const int MISSION_DIFFICULTY_HARD				= 3;
const int MISSION_BOUNTY_DIFFICULTY_JEDI			= 4;
const int MISSION_DIFFICULTY_BOSS				= 5;

const int STRING_ID_QUANTITY					= 5;

const string[] PLAYER_SPECIES					= { "wookiee", "human", "bothan", "trandoshan", "zabrak", "rodian", "moncal", "twilek" };
const float DELIVER_DIFFICULTY_MODIFIER				= .5f;

const float FETCH_DIFFICULTY_MODIFIER				= .5f;
const float ESCORT_DIFFICULTY_MODIFIER				= .5f;

const float MULTI_PLANET_MODIFIER				= 4f;
const float RANGE_MODIFIER					= 25f;	// how far from the start point based on difficulty
const float MIN_DESTRUCTION_DISTANCE				= 0f;
const float MAX_DESTRUCTION_DISTANCE				= 4000f;

const int LOCATION_CHECKS					= 10;
const float DEFAULT_OBJECTIVE_SIZE				= 30f;
const float PLAYER_INTEREST_RANGE				= 200f;
const float ITEM_CHECK_RANGE					= 25f;

const float MIN_REWARD_VARIANCE					= -10;
const float MAX_REWARD_VARIANCE					= 10;	// 10% variance in difficulty/reward payout

const string SUCCESS_MESSAGE_TYPE				= "s";
const string FAILURE_MESSAGE_TYPE				= "f";
const string DESCRIPTION_MESSAGE_TYPE				= "d";
const string INCOMPLETE_MESSAGE_TYPE				= "t";

const int MISSION_EXPIRE_TIME					= 24 * 60 * 60 * 2;	// 2 days

const int MISSION_DELIVER_DIFFICULTY_EASY			= 10;
const int MISSION_DELIVER_DIFFICULTY_MEDIUM			= 18;
const int MISSION_DELIVER_DIFFICULTY_HARD			= 25;

const int MIN_EASY_DELIVER_DISTANCE				= 100;
const int MAX_EASY_DELIVER_DISTANCE				= 900;

const int MISSION_DESTROY_DIFFICULTY_EASY			= 12;
const int MISSION_DESTROY_DIFFICULTY_MEDIUM			= 24;
const int MISSION_DESTROY_DIFFICULTY_HARD			= 30;

const string[] CITY_PLANETS					= { "tatooine", "naboo", "talus", "corellia", "yavin4", "dantooine", "dathomir", "lok", "rori", "endor" };	// add more later

const string[] PLANETS						= { "tatooine", "naboo", "talus", "corellia", "yavin4", "dantooine", "dathomir", "lok", "rori", "endor" };	// all planets in the game

const int DELIVERY_INTEREST_MIN_DELAY				= 15;
const int DELIVERY_INTEREST_MAX_DELAY				= 30;

const float DELIVER_REWARD_RATIO				= 7;
const float RECON_REWARD_RATIO					= 6;
const float CRAFTING_REWARD_RATIO				= 4;

// NPC MISSION CRAP BELOW!
//const string[] NPC_PERSISTENT_MISSION_OBJVAR_NAMES		= {"mission.objDestroyMission","mission.objDeliverMission", "mission.objReconMission", "mission.objEscortMission"}; // add more when we get more types
const string[] NPC_NONPERSISTENT_MISSION_OBJVAR_NAMES		= { "mission.objDestroyMission", "mission.objDeliverMission", "mission.objSurveyMission", "mission.objDancerMission", "mission.objMusicianMission", "mission.objCraftingMission", "mission.objSurveyMission", "mission.objDancerMission", "mission.objMusicianMission", "mission.objCraftingMission", "mission.objHuntingMission" };	// add more when we get more types

//const string[] NPC_NONPERSISTENT_MISSION_OBJVAR_NAMES		= {"mission.objCraftingMission"};
//const string[] NPC_NONPERSISTENT_MISSION_OBJVAR_NAMES		= {"mission.objSurveyMission"};

//const string[] NPC_PERSISTENT_MISSION_OBJVAR_NAMES		= {"mission.objReconMission"};
//const string[] NPC_PERSISTENT_MISSION_OBJVAR_NAMES		= {"mission.objDestroyMission"};
const string[] NPC_PERSISTENT_MISSION_OBJVAR_NAMES		= { "mission.objDestroyMission", "mission.objDeliverMission", "mission.objReconMission" };	//, "mission.objReconMission", "mission.o

const float MIN_RECON_DISTANCE					= 0f;	// should be less than search size because it could otherwise go back into a city
const float MAX_RECON_DISTANCE					= 5000f;

const float RECON_EASY_DISTANCE					= 1000;
const float RECON_MEDIUM_DISTANCE				= 2000;
const float RECON_HARD_DISTANCE					= 5000;

const int RECON_OFF_PLANET_THRESHOLD				= 100000;	// above 8 and you can get an off planet mission

const string[] RECON_PLANETS					= { "tatooine", "naboo" };	//, "naboo"};  UNCOMMENT LATER
const int[] RECON_DIFFICULTY_MODIFIER				= { 1, 1 };	// reward modifier for this planet MAKE SURE THAT THSI STAYS THE SAME LENGTH AS ABOVE
const float RECON_OFF_PLANET_BASE_MODIFIER			= 2;

// escort npc missions
const int ESCORT_DIFFICULTY_EASY				= 5;
const int ESCORT_DIFFICULTY_MEDIUM				= 8;
const int ESCORT_DIFFICULTY_HARD				= 20;

const string[] NPC_TYPES					= { "artisan", "bodyguard", "businessman", "bothan_diplomat", "entertainer", "explorer", "farmer", "gambler", "info_broker", "miner", "medic", "noble", "pilot", "scientist" };

const string OBJVAR_SURVEY_MISSION_EFFECIENCY			= "intEffeciency";
const string OBJVAR_SURVEY_MISSION_RESOURCE			= "strResource";

const string SID_SURVEY_RESOURCE_NAMES_TABLE			= "mission/survey/survey_resource_names";

const string_id SID_MISSION_TARGET_UPDATED			= new string_id("mission/mission_generic", "mission_target_updated");
const string_id SID_MISSION_TARGET_UPDATED_EXACT		= new string_id("mission/mission_generic", "mission_target_updated_exact");
const string_id SID_MISSION_TATOOINE				= new string_id("spam", "mission_wrong_planet_tatooine");
const string_id SID_MISSION_TATOOINE_NABOO_CORELIA		= new string_id("spam", "mission_wrong_planet_tatooine_naboo_corelia");
const string_id SID_MISSION_NABOO_CORELIA			= new string_id("spam", "mission_wrong_planet_naboo_corelia");
const string_id SID_MISSION_RORI_TALUS				= new string_id("spam", "mission_wrong_planet_rori_talus");
const string_id SID_MISSION_RORI_TALUS_DANTOOINE_LOK		= new string_id("spam", "mission_wrong_planet_rori_talus_dantooine_lok");
const string_id SID_MISSION_DANTOOINE_LOK			= new string_id("spam", "mission_wrong_planet_dantooine_lok");
const string_id SID_MISSION_YAVIN_ENDOR				= new string_id("spam", "mission_wrong_planet_yavin_endor");
const string_id SID_MISSION_YAVIN_ENDOR_DATHOMIR		= new string_id("spam", "mission_wrong_planet_yavin_endor_dathomir");
const string_id SID_MISSION_TARGET_IN_WATER			= new string_id("spam", "target_in_water");

const string[] CITIES_WITH_STARPORTS 				= {
								"bestine", 
								"mos_eisley",
								"mos_entha",
								"mos_espa",
								"theed",
								"keren",
								"moenia",
								"kaadara",
								"coronet", 
								"tyrena",
								"kor_vella",
								"doaba_guerfel",
								"restuss",
								"narmle",
								"lok_nyms_stronghold",
								"yavin4_labor_outpost",
								"yavin4_mining_outpost",
								"endor_neutral_outpost",
								"dantooine_mining_outpost",
								"dantooine_pirate_outpost",
								"dathomir_trade_outpost",
								"dathomir_survey_outpost"
								};

const float PREFERRED_DISTANCE					= 1000.0f;

/*******************************************************************************/

obj_id createMissionDataInContainer(obj_id objCreator, float fltEffeciencyRequirement, int intExpireTime, obj_id objCreatorToken, string strMissionType, string strScript)
{
	obj_id objContainer;

	////LOG("missions", "OBJCREATOR ID IS "+objCreator);
	if(isPlayer(objCreator))
	{
		////LOG("missions", "OBJCREATOR IS A PLAYER");
		objContainer = utils.getMissionBag(objCreator);
	}
	else if(isMob(objCreator))
	{
		objContainer = utils.getMissionBag(objCreator);
	}
	else
	{
		objContainer = objCreator;
	}

	if(!isIdValid(objContainer))
	{
		////LOG("DESIGNER_FATAL", "NULL MISSION BAG FOR "+objCreatorToken);
		return null;
	}

	////LOG("missions", "OBJCONTAINER ID IS "+objContainer);
	obj_id objMissionData = createObject("object/mission/base_mission_data.iff", objContainer, "");

	if(!isIdValid(objMissionData))
	{
		////LOG("DESIGNER_FATAL", "No mission object created in mission bag"+" owner was "+objCreator+" bag was "+objContainer);
		////LOG("DESIGNER_FATAL", "Template of bad object is "+getTemplateName(objCreator));
		////LOG("DESIGNER_FATAL", "Location of object was "+getLocation(objCreator));
		// we'll clean out the contents of the mission bag now, and document what we have
		obj_id[] objContents = utils.getContents(objContainer);

		for(int intI = 0; intI < objContents.length; intI++)
		{
			////LOG("DESIGNER_FATAL", "Destroying "+objContents[intI]+"in mission bag "+objContainer+" owned by "+objCreatorToken);
			////LOG("DESIGNER_FATAL", "Object was "+getTemplateName(objContents[intI]));
			destroyObject(objContents[intI]);
		}

		return null;
	}

	////LOG("missions", "mission type is "+strMissionType);
	setMissionType(objMissionData, strMissionType);
	setMissionRootScriptName(objMissionData, strScript);

	return objMissionData;
}

// **************************************************MISSION CREATION FUNCTIONS*****************************************************

obj_id getMissionData(obj_id objMission)
{
	return objMission;
}

// this initializes the misison data object for a destruction mission.
// this function will probably go away once we get full dynamic creation working
obj_id createDestructionMissionDataFromLocation(obj_id objMissionData, obj_id objCreator, location locMissionStart, int intDifficulty, string strPlanet, string strFaction, float fltRewardModifier)
{
	//LOG("missions", "Making destroy mission");
	//PROFILER_START("Block1");
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_destruction");
	setMissionType(objMissionData, "destroy");

	int intI = 0;
	string strSpawnType = "";
	region rgnSpawnRegion = null;
	location locMissionDestination = new location();
	float fltRange;
	location locGoodLocation = new location();

	// we need to do this until we get a good one or hit 10 cycles
	//PROFILER_START("getRegions");
	region[] rgnCities = getRegionsWithMunicipalAtPoint(locMissionStart, regions.MUNI_TRUE);

	if(rgnCities == null)
		rgnCities = getRegionsWithGeographicalAtPoint(locMissionStart, regions.GEO_CITY);

	//PROFILER_STOP("getRegions");
	//PROFILER_STOP("Block1");

	//PROFILER_START("Block2");
	for(int i = 0; i < LOCATION_CHECKS; i++)
	{
		if(intDifficulty < 7)
			fltRange = intDifficulty * RANGE_MODIFIER;
		else
			fltRange = rand(500, 1500);

		if(rgnCities != null)
		{
			locGoodLocation = locations.getGoodLocationOutsideOfRegion(rgnCities[0], DEFAULT_OBJECTIVE_SIZE, DEFAULT_OBJECTIVE_SIZE, fltRange, false, true);
		}
		else
		{
			location locNewLocation = utils.getRandomLocationInRing(locMissionStart, fltRange, fltRange + 200);

			locGoodLocation = locations.getGoodLocationAroundLocation(locNewLocation, 30, 30, 150, 150, false, true);
		}

		if(locGoodLocation != null)
		{
			float fltDistance = getDistance(locMissionStart, locGoodLocation);

			if(fltDistance < MIN_DESTROY_DISTANCE)
			{
				fltRange = MIN_DESTROY_DISTANCE + rand(20, 100);
				location locNewLocation = utils.getRandomLocationInRing(locMissionStart, fltRange, fltRange + 200);

				locGoodLocation = locations.getGoodLocationAroundLocation(locNewLocation, 30, 30, 150, 150, false, true);
			}
		}

		if(locGoodLocation != null)
		{
			locMissionDestination = locGoodLocation;	// we can mangle now that its a good loc

			rgnCities = getRegionsWithMunicipalAtPoint(locMissionDestination, regions.MUNI_TRUE);	// check the destination
			region[] rgnCities2 = getRegionsWithGeographicalAtPoint(locMissionDestination, regions.GEO_CITY);

			if(rgnCities == null && rgnCities2 == null)
			{
				region rgnBattlefield = battlefield.getBattlefield(locMissionDestination);

				if(rgnBattlefield == null)
				{
					region[] rgnMissionListing = getRegionsWithMissionAtPoint(locMissionDestination, regions.MISSION_OTHER);	// gimme a list of destroy mission
					if(rgnMissionListing != null && rgnMissionListing.length != 0)
					{
						rgnSpawnRegion = locations.getSmallestRegion(rgnMissionListing);
						strSpawnType = regions.translateGeoToString(rgnSpawnRegion.getGeographicalType());
					}
					else
					{
						strSpawnType = "default";	// NPC LAIRS
					}
					break;
				}
			}
		}
	}
	//PROFILER_STOP("Block2");

	if(locGoodLocation == null)
	{
		//LOG("missions", "Returning null due to good location failure");
		return null;
	}

	if(strSpawnType == null || strSpawnType == "")
	{
		//LOG("missions", "Returning null due to SPAWN TYPE FAILURE");
		return null;	// that location was fucked so we can't help you!
	}

	//PROFILER_START("Block3");

	if(locations.getMinMissionDifficultyAtLocation(locMissionStart) > intDifficulty)
	{
		return null;
	}

	//sendSystemMessageTestingOnly(objCreator, "Min Region Difficulty="+locations.getMinDifficultyForLocation(locMissionStart));
	//sendSystemMessageTestingOnly(objCreator, "Max Region Difficulty="+locations.getMaxDifficultyForLocation(locMissionStart));
	//sendSystemMessageTestingOnly(objCreator, "Capped Mission Difficulty="+intDifficulty);

	//LOG("mission", "strSpawntype is "+strSpawnType);

	dictionary dctSpawnList = new dictionary();

	//PROFILER_STOP("Block3");

	//LOG("mission_spam", "Making destruction Mission Spawn List");
	//PROFILER_START("Block4");
	//LOG("missions", "spawnType si "+strSpawnType);

	// This function has been modified during optimization
	//
	// Instead of returning a dictionary with arrays of all possible missions, the function now chooses a random
	// mission and returns only the data for that one

	dctSpawnList = getDestructionMissionSpawnList(objCreator, intDifficulty, strPlanet, strSpawnType, strFaction);

	//PROFILER_STOP("Block4");

	if(dctSpawnList == null)
	{
		return null;
	}

	string strGoal = dctSpawnList.getString("strTemplate");

	if(strGoal == null || strGoal.equals(""))
		return null;

	//PROFILER_START("Block6");
	int intMinReward = dctSpawnList.getInt("intMinReward");
	int intMaxReward = dctSpawnList.getInt("intMaxReward");
	string strLairType = dctSpawnList.getString("strLairType");
	string strBuildingType = dctSpawnList.getString("strBuildingType");
	string strObjective = dctSpawnList.getString("strObjective");
	string strObjectiveTarget = dctSpawnList.getString("strObjectiveTarget");
	string strTargetType = dctSpawnList.getString("strTargetType");
	float fltKillPercentage = dctSpawnList.getFloat("fltKillPercentage");
	int intMinDifficulty = dctSpawnList.getInt("intMinDifficulty");
	int intMaxDifficulty = dctSpawnList.getInt("intMaxDifficulty");
	int intSize = dctSpawnList.getInt("intSize");
	int intGCWPoints = dctSpawnList.getInt("intGCWPoints");

	int intTest = utils.getTheaterSize(strLairType);

	if(intTest > 0)
		intSize = intTest;

	string strTemplateToSpawn = dctSpawnList.getString("strTemplateToSpawn");
	int intNumToSpawn = dctSpawnList.getInt("intNumToSpawn");

	string strDetailTemplate = dctSpawnList.getString("strDetailTemplate");
	string strIdFileName = dctSpawnList.getString("strIdFileName");
	int intStringId = dctSpawnList.getInt("intStringId");

	setObjVar(objMissionData, "fltKillPercentage", fltKillPercentage);	// Suppress linting - Lint script incorrectly catching this
	setObjVar(objMissionData, "strLairType", strLairType);	// Suppress linting - Lint script incorrectly catching this
	setObjVar(objMissionData, "strBuildingType", strBuildingType);	// Suppress linting - Lint script incorrectly catching this
	setObjVar(objMissionData, "strObjective", strObjective);	// Suppress linting - Lint script incorrectly catching this
	setObjVar(objMissionData, "strObjectiveTarget", strObjectiveTarget);	// Suppress linting - Lint script incorrectly catching this
	setObjVar(objMissionData, "strTargetType", strTargetType);	// Suppress linting - Lint script incorrectly catching this
	setObjVar(objMissionData, "intPlayerDifficulty", intDifficulty);	// ALL OF THIS IS DATA FOR THE CREATION FUNCS. WE JUST PASS IT ALONG
	setObjVar(objMissionData, "intMinDifficulty", intMinDifficulty);
	setObjVar(objMissionData, "intMaxDifficulty", intMaxDifficulty);

	//PROFILER_STOP("Block6");
	//PROFILER_START("Block7");
	//LOG("missions", "objvars set");
	string strLairDifficulty = create.getLairDifficulty(intMinDifficulty, intMaxDifficulty, intDifficulty);

	//LOG("missions", "strLairDifficulty is "+strLairDifficulty);
	setObjVar(objMissionData, "strLairDifficulty", strLairDifficulty);

	setObjVar(objMissionData, "intSize", intSize);	// Suppress linting - Lint script incorrectly catching this
	setObjVar(objMissionData, "strTemplateToSpawn", strTemplateToSpawn);	// Suppress linting - Lint script incorrectly catching this
	//LOG("mission", "objMissionData is "+objMissionData);
	setObjVar(objMissionData, "intNumToSpawn", intNumToSpawn);	// Suppress linting - Lint script incorrectly catching this

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}
	else
		setObjVar(objMissionData, "originalGroupSize", 1);

	//PROFILER_START("token making");
	location locTest = new location();	// dummy location for token

	//LOG("names", "strDEtailTemplate is "+strDetailTemplates[intRandomNumber]);
	if(strDetailTemplate.equals(""))
	{

		string_id strTokenName = new string_id("lair_n", strLairType);

		setMissionTargetName(objMissionData, utils.packStringId(strTokenName));
		setMissionTargetAppearance(objMissionData, strGoal);
	}
	else
	{
		//LOG("names", "strDetailTemplate is "+strDetailTemplate);
		string_id strTokenName = new string_id("lair_n", strLairType);

		// we overload the details view and so on
		setObjVar(objMissionData, "strGoal", strGoal);
		setMissionTargetAppearance(objMissionData, strDetailTemplate);
		setMissionTargetName(objMissionData, utils.packStringId(strTokenName));

	}

	//PROFILER_STOP("token making");
	//PROFILER_STOP("Block7");
	//PROFILER_START("Block8");
	//LOG("missions", "locMissionStart is "+locMissionStart);
	//LOG("missions", "locMissionEnd is "+locMissionDestination);
	float fltDistance = utils.getDistance(locMissionStart, locMissionDestination);

	//LOG("missions", "fltDistance is "+fltDistance);
	int intReward = getDestroyReward(intMinReward, intMaxReward, fltDistance);

	intReward = (int) (intReward * fltRewardModifier);	// for slicing bonus

	//LOG("missions", "strFaction is "+strFaction);
	if(strFaction != "" && strFaction != null)
	{

		string strActualFaction = utils.getFactionSubString(strFaction);	// since we get wacky factions like "rebel_military"

		//LOG("missions", "strActualFaction is "+strActualFaction);
		if(strActualFaction != null)
		{
			int intFactionReward = getFactionReward(intReward);

			setObjVar(objMissionData, "intFactionReward", intFactionReward);
			setObjVar(objMissionData, "strFaction", strActualFaction);
			setObjVar(objMissionData, "intGCWPoints", intGCWPoints);
		}
	}

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	//LOG("mission_spam", "Transferred credits, we should get a callback any minute now");

	location locSpawnLocation = locMissionDestination;

	setMissionStartLocation(objMissionData, locSpawnLocation);

	setMissionDifficulty(objMissionData, intDifficulty);

	int intMissionDifficulty = 0;

	if(intDifficulty < MISSION_DESTROY_DIFFICULTY_EASY)
	{
		intMissionDifficulty = MISSION_DIFFICULTY_EASY;
	}
	else if(intDifficulty < MISSION_DESTROY_DIFFICULTY_MEDIUM)
	{
		intMissionDifficulty = MISSION_DIFFICULTY_MEDIUM;
	}
	else
	{

		intMissionDifficulty = MISSION_DIFFICULTY_HARD;
	}
	//PROFILER_STOP("Block8");

	//PROFILER_START("Block9");
	if(!strIdFileName.equals(""))
	{
		setObjVar(objMissionData, "intStringId", intStringId);	// Suppress linting - Lint script incorrectly catching this
		setObjVar(objMissionData, "strIdFileName", strIdFileName);	// Suppress linting - Lint script incorrectly catching this
	}
	else
	{
		setupContextualizationStrings(objMissionData, intMissionDifficulty, objCreator, strFaction);
	}
	//PROFILER_STOP("Block9");
	//PROFILER_START("Block10");
	if(ai_lib.aiGetNiche(objCreator) == NICHE_NPC)
	{
		location locCreatorLocation = getMissionLocation(objCreator);

		setObjVar(objMissionData, "locCreatorLocation", locCreatorLocation);

	}

	//LOG("mission_general","SET MISSION TYPE");
	//LOG("mission_general","mission type is "+getMissionType(objMissionData));
	//LOG("mission_general","objMissionData is "+objMissionData.toString());

	//PROFILER_STOP("Block10");

	setObjVar(objMissionData, "location.locMissionStart", locMissionStart);
	return objMissionData;

}

obj_id createDeliverMissionFromLocation(obj_id objMissionData, obj_id objCreator, location locMissionStart, int intDifficulty, string strPlanet, string strFaction, float fltRewardModifier)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_deliver");
	setMissionType(objMissionData, "deliver");

	location locPickupLocation = new location();
	location locDropoffLocation = new location();
	int intVariance;

	string strPickupNPC = NPC_TYPES[rand(0, NPC_TYPES.length - 1)];
	string strDropoffNPC = NPC_TYPES[rand(0, NPC_TYPES.length - 1)];
	string strDeliveryItem = "object/tangible/mission/mission_datadisk.iff";	// fix this later!
	location locStartLocation = new location();
	location locEndLocation = new location();

	setObjVar(objMissionData, "strPickupNPC", strPickupNPC);
	setObjVar(objMissionData, "strDropoffNPC", strDropoffNPC);

	region[] rgnCities = getRegionsWithMunicipalAtPoint(locMissionStart, regions.MUNI_TRUE);

	if(rgnCities == null)
	{
		rgnCities = getRegionsAtPoint(locStartLocation);	// not really cities

		if(rgnCities == null)
		{
			return null;	// no regions on this goddamned forsaken planet!
		}
	}

	region rgnStartRegion = rgnCities[0];
	boolean boolIsCity = false;

	if(locations.isCityRegion(rgnStartRegion))
	{
		locStartLocation = locations.getGoodCityRegionLocation(rgnStartRegion, strPlanet);
		boolIsCity = true;
	}
	else
	{
		region closestCity = locations.getClosestCityRegion(rgnStartRegion);

		locStartLocation = locations.getGoodCityRegionLocation(closestCity, strPlanet);
		boolIsCity = true;
	}

	if(locStartLocation == null)
	{
		return null;
	}

	int intMissionDifficulty = 1;

	if(boolIsCity)
	{
		int intRoll = rand(1, 100);

		if(intRoll < 50)
		{
			locEndLocation = locations.getDifferentGoodCityRegionLocation(locStartLocation);
			intMissionDifficulty = MISSION_DIFFICULTY_EASY;
		}
		else
		{
			region rgnEndRegion = locations.getDeliverCityRegion(rgnStartRegion);	// could be any region that's not the start region
			string strName = rgnEndRegion.getName();

			if(intRoll > 75)
			{
				intMissionDifficulty = MISSION_DIFFICULTY_MEDIUM;
			}
			else
			{
				intMissionDifficulty = MISSION_DIFFICULTY_HARD;
			}

			string strNewPlanet = rgnEndRegion.getPlanetName();

			if(strPlanet != strNewPlanet)
			{
				strPlanet = strNewPlanet;
			}

			locEndLocation = locations.getGoodCityRegionLocation(rgnEndRegion, strPlanet);
		}
	}
	else
	{
		region rgnEndRegion = locations.getClosestCityRegion(rgnStartRegion);
		string strName = rgnEndRegion.getName();

		locEndLocation = locations.getGoodCityRegionLocation(rgnEndRegion, strPlanet);
	}

	setObjVar(objMissionData, "intMissionDifficulty", intMissionDifficulty);

	if(locEndLocation == null)
	{
		return null;
	}

	setMissionDifficulty(objMissionData, getIntObjVar(objMissionData, "intMissionDifficulty"));
	setMissionTargetAppearance(objMissionData, strDeliveryItem);

	if(ai_lib.aiGetNiche(objCreator) == NICHE_NPC)
	{
		setMissionStartLocation(objMissionData, locEndLocation);
		setMissionEndLocation(objMissionData, getMissionLocation(objCreator));
		setObjVar(objMissionData, "objEndNPC", objCreator);

	}
	else
	{
		setMissionStartLocation(objMissionData, locStartLocation);
		////LOG("mission_spam", "Set mission Start Location");
		setMissionEndLocation(objMissionData, locEndLocation);
	}

	setMissionType(objMissionData, "deliver");
	int intReward = getDeliverReward(locStartLocation, locEndLocation, DELIVER_REWARD_RATIO, 1);

	intReward = (int) (intReward * fltRewardModifier);	// for slicing bonus
	if(intReward < 5)
	{
		intReward = 5;
	}
	if(strFaction != "")
	{
		int intFactionReward = getFactionReward(intReward);

		setObjVar(objMissionData, "intFactionReward", intFactionReward);
		setObjVar(objMissionData, "strFaction", strFaction);

	}

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	setupContextualizationStrings(objMissionData, intMissionDifficulty, objCreator, strFaction);
	return objMissionData;
}

location getGoodBountyDestination(string strPlanet)
{
	location locMissionDestination = null;

	region[] rgnMissionRegions = getRegionsWithMission(strPlanet, regions.MISSION_OTHER);

	if(rgnMissionRegions == null)
	{
		return null;

	}

	region rgnMissionRegion = rgnMissionRegions[rand(0, rgnMissionRegions.length - 1)];

	if(rgnMissionRegion.getMunicipalType() == regions.MUNI_TRUE)
	{
		// we gotta get a good location in the region
		locMissionDestination = locations.getGoodCityLocation(rgnMissionRegion, strPlanet);
		if(locMissionDestination == null)
		{
			return null;	// no locations for the city region
		}
	}
	else
	{
		location[] locExtents = getRegionExtent(rgnMissionRegion);
		location locLowerLeft = locExtents[0];
		location locUpperRight = locExtents[1];

		float minimum = -8192f + 512f;
		float maximum = 8192f - 512f;

		if(locLowerLeft.x < minimum)
			locLowerLeft.x = minimum;
		if(locLowerLeft.z < minimum)
			locLowerLeft.z = minimum;
		if(locUpperRight.x < maximum)
			locUpperRight.x = maximum;
		if(locUpperRight.z < maximum)
			locUpperRight.z = maximum;

		locMissionDestination = locLowerLeft;

		locMissionDestination.x = rand(locLowerLeft.x, locUpperRight.x);
		locMissionDestination.z = rand(locLowerLeft.z, locUpperRight.z);

		// we gotta getpoint in region
		// then getgoodlocation around location in region
		// we can do that a few times
	}
	return locMissionDestination;
}

obj_id createDynamicBountyMission(obj_id objMissionData, obj_id objCreator, int intBountyDifficulty, int intDifficulty, string strStartPlanet, string strFaction)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_bounty");
	setMissionType(objMissionData, "bounty");
	// okay so we do the following:

	// check difficulty
	// if it's easy, 10% chance of off planet
	// movement speed is slower
	// reward is smaller
	// uses easy informants
	//  structure is going to be : location, string for target

	float fltMovementTime = 0;
	location locMissionDestination = new location();
	region rgnMissionRegion;
	string strPlanet = new string();
	string strTargetName;

	// we've got 2 difficulties to work with

	// 1 is the type of bounty mission (as in mobility)
	// the 2nd is the difficulty of the npc

	//give easy if player level is below 42
	//setup some string data here too
	int intMissionDifficulty = MISSION_DIFFICULTY_EASY;
	string strColumnName = new string();

	if(intDifficulty < 42 || intBountyDifficulty < 2)
	{
		strColumnName = "strEasy";
	}
	//give medium if player level is below 82
	else if(intDifficulty < 82 || intBountyDifficulty < 3)
	{
		strColumnName = "strMedium";
		intMissionDifficulty = MISSION_DIFFICULTY_MEDIUM;
	}
	else
	{
		strColumnName = "strHard";
		intMissionDifficulty = MISSION_DIFFICULTY_HARD;
		
		if((intDifficulty == 90) && (21 > rand(1, 100)))
		{
			strColumnName = "strBoss";
			intMissionDifficulty = MISSION_DIFFICULTY_BOSS;
		}
	}

	if(strFaction != "")
	{
		if(strFaction == "imperial")
		{
			strColumnName = strColumnName + strFaction;
		}
	}

	float fltDifficultyModifier = 1;

	if(intBountyDifficulty == BOUNTY_DIFFICULTY_BASIC)
	{
		// easy difficulty
		// 10% chance of offplanet
		// never leaves planet
		int intRoll = rand(1, 100);

		strPlanet = strStartPlanet;

		// what kind of regions do we want.. do we start in a city?
		// i'm inclined to say that we start in a random region and go from there..
		// if it's a city we'll plunk down in the correct region
		// otherwise we'll roll with it
	}
	else if(intBountyDifficulty == BOUNTY_DIFFICULTY_ADVANCED)
	{
		fltDifficultyModifier = 1.5f;
		strPlanet = PLANETS[rand(0, PLANETS.length - 1)];
		//strPlanet = PLANETS[rand(0,PLANETS.length-1)];
		// 25% chance of off planet
		// if in city, 10% chance of leaving planet
		// medium difficulty

	}
	else if(intBountyDifficulty == BOUNTY_DIFFICULTY_EXPERT)
	{
		fltDifficultyModifier = 2.0f;
		strPlanet = PLANETS[rand(0, PLANETS.length - 1)];
		// 75% of off planet
		// if in city, 25% of leaving planet
		// hard difficulty
	}
	else
	{
		return null;
	}

	locMissionDestination = getGoodBountyDestination(strPlanet);

	if(locMissionDestination == null)
	{
		return null;
	}

	setObjVar(objMissionData, "locSpawnLocation", locMissionDestination);
	setObjVar(objMissionData, "intInformantLevel", intBountyDifficulty);
	string strSpecies = "";
	string strSex = "";

	string[] strBountyTypes = dataTableGetStringColumnNoDefaults("datatables/missions/bounty/bounty.iff", strColumnName);

	if(strBountyTypes == null)
	{
		return null;
	}

	string strTarget = strBountyTypes[rand(0, strBountyTypes.length - 1)];

	setObjVar(objMissionData, "strTarget", strTarget);

	int intRoll = rand(1, 2);

	if(intRoll == 1)
	{
		// pick a species
		strSpecies = PLAYER_SPECIES[rand(0, PLAYER_SPECIES.length - 1)];
		intRoll = rand(1, 2);
		if(intRoll == 1)
		{
			strSex == "male";
		}
		else
		{
			strSex == "female";
		}
	}
	else
	{
		strSpecies = "alien";
		strSex = "other";
		// no sex, so we can use a random name
	}

	setObjVar(objMissionData, "intBountyDifficulty", intBountyDifficulty);

	strTargetName = getRandomSpeciesName(strSpecies);
	if (intMissionDifficulty == MISSION_DIFFICULTY_BOSS)
		strTargetName = getRandomSpeciesName(strSpecies) + " (Extremely Dangerous)";

	setObjVar(objMissionData, "strTargetName", strTargetName);
	setObjVar(objMissionData, "strSpecies", strSpecies);

	float fltVariance = rand(MIN_REWARD_VARIANCE, MAX_REWARD_VARIANCE);

	fltVariance = fltVariance / 100;
	intDifficulty = intDifficulty + (int) (intDifficulty * fltVariance);

	location locTest = new location();	// dummy location for token
	string strGoal = "object/tangible/mission/mission_bounty_target.iff";	// dummy value

	setMissionTargetAppearance(objMissionData, strGoal);
	setMissionTargetName(objMissionData, strTargetName);
	////LOG("missions", "intBountyDifficulty is "+intBountyDifficulty);
	////LOG("missions", "intDifficulty is "+intDifficulty);

	int intReward = 0;

	////LOG("missions", "intReward is "+intReward);
	if(intBountyDifficulty > 1)
	{
		intReward = (intBountyDifficulty * 40) + intDifficulty;
	}
	else
	{
		intReward = 20 + intDifficulty;
	}

	intReward = intReward * 150 + rand(-100, 300);

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	location locSpawnLocation = locMissionDestination;

	setObjVar(objMissionData, "locSpawnLocation", locSpawnLocation);

	//setMissionStartLocation(objMissionData, locSpawnLocation);

	//cap NPC bounty difficulty at 90
	if(intDifficulty > 90)
		intDifficulty = 90;
	//setup difficulty for NPC Bounties
	int intCombatDifficulty = intDifficulty + rand(1, 2);

	//cap NPC's at 90
	if(intCombatDifficulty > 90)
		intCombatDifficulty = 90;

	//store the level of the NPC for use in spawning
	setObjVar(objMissionData, "intCombatDifficulty", intCombatDifficulty);
	setMissionDifficulty(objMissionData, intDifficulty);

	// HACK UNTIL WE GET MORE STRINGS
	//intMissionDifficulty = MISSION_DIFFICULTY_EASY;
	setupContextualizationStrings(objMissionData, intMissionDifficulty, objCreator, strFaction);

	//string_id strTest = new string_id("Bounty_Mission", "Bounty Mission");
	//setMissionTitle(objMissionData, strTest); // HACK
	return objMissionData;
}

obj_id createJediBountyMission(obj_id objMissionData, obj_id objCreator, string strFaction, int hunterLevel, obj_id bountyHunterId)
{
	return createJediBountyMission(objMissionData, objCreator, strFaction, hunterLevel, bountyHunterId, missions.BOUNTY_FLAG_NONE);
}

obj_id createJediBountyMission(obj_id objMissionData, obj_id objCreator, string strFaction, int hunterLevel, obj_id bountyHunterId, int flag)	// re-purposed for PvP Bounties 04/2006 -- EJ
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_bounty");
	setMissionType(objMissionData, "bounty");
	int bhMin = 20;
	int bhMax = 90;

	if(hunterLevel < 22)
	{
		return null;
	}
	else
	{
		bhMin = (int) (hunterLevel * 0.75);	//Constrains to 75% of the BH's level
		bhMax = (int) (hunterLevel * 1.5);	// Constrains to 150% of the BH's level
	}

	//dctJediInfo contains the list of missions that qualify for the jedi table lookup for pvp bounties
	//We will be constraining this initial list by Visibility (arbitrarily determined), Faction (strFaction passed), and Level range (min, max) (hunterLevel is passed)
	dictionary dctJediInfo = requestJedi(IGNORE_JEDI_STAT, 15000, bhMin, bhMax, IGNORE_JEDI_STAT, -3);

	if(dctJediInfo == null)
	{
		LIVE_LOG("bh_jedi_mission", "mission_dynamic_base.createJediBountyMission: No PvP target found (null)");
		LOG("PvP_Bounty", "No missions.");
		return null;
	}

	obj_id objTarget = null;
	string strTargetName = null;
	int jediBountyValue = 0;
	int intFaction = 0;

	strFaction = toLower(strFaction);

	if(strFaction != null)
		intFaction = getStringCrc(strFaction);	//hash the faction string

	obj_id[] objJedis = dctJediInfo.getObjIdArray("id");
	boolean[]boolOnline = dctJediInfo.getBooleanArray("online");
	int[] jediFaction = dctJediInfo.getIntArray("faction");

	string[] jediPlanet = dctJediInfo.getStringArray("scene");
	location bountyHunterLocation = getLocation(bountyHunterId);

	location[] jediLocation = dctJediInfo.getLocationArray("location");

	int[] smugglerFlags = dctJediInfo.getIntArray("smuggler");

	//LOG("LOG_CHANNEL", "objJedis ->" + objJedis.length);
	if(objJedis == null || objJedis.length == 0)
	{
		LIVE_LOG("bh_jedi_mission", "mission_dynamic_base.createJediBountyMission: No PvP bounty found (no data)");
		return null;
	}

	LIVE_LOG("bh_jedi_mission", "mission_dynamic_base.createJediBountyMission: found " + objJedis.length + " qualifying PvP Bounties");

	int intRoll = -1;

	resizeable obj_id[]  jediList = new Vector();
	resizeable int[] jediIdx = new Vector();

	for(int i = 0; i < objJedis.length; i++)
	{
		jediIdx = utils.addElement(jediIdx, i);
	}

	jediList = utils.concatArrays(jediList, objJedis);

	obj_id[] SamePlanetObjId = new obj_id[jediList.size()];
	int SamePlanetCounter = 0;
	int[] SamePlanetInt = new int[jediList.size()];

	while(jediList.size() > 0)
	{
		intRoll = rand(0, jediList.size() - 1);

		if(!isIdValid(jediList[intRoll]) || !boolOnline[((Integer) (jediIdx.get(intRoll))).intValue()])	// Remove when preprocessor is fixed
			//if (!isIdValid(jediList[intRoll]) || !boolOnline[jediIdx[intRoll]]) // This is the good one
		{
			jediList = utils.removeElementAt(jediList, intRoll);
			jediIdx = utils.removeElementAt(jediIdx, intRoll);
		}
		//id same as bh id and match factions
		else if((jediList[intRoll] == bountyHunterId) || ((intFaction != 0) && (jediFaction[((Integer) (jediIdx.get(intRoll))).intValue()] != intFaction)))
		{
			jediList = utils.removeElementAt(jediList, intRoll);
			jediIdx = utils.removeElementAt(jediIdx, intRoll);
		}
		//check to see if we match the flags passed in
		else if(flag == missions.BOUNTY_FLAG_SMUGGLER && ((smugglerFlags == null) || (smugglerFlags.length < (((Integer) (jediIdx.get(intRoll))).intValue() + 1)) || (smugglerFlags[((Integer) (jediIdx.get(intRoll))).intValue()] != 1)))
		{
			jediList = utils.removeElementAt(jediList, intRoll);
			jediIdx = utils.removeElementAt(jediIdx, intRoll);
		}
		// Check to see if the target is on the same planet, if so, remove them from the list
		else if(jediPlanet[((Integer) (jediIdx.get(intRoll))).intValue()] == bountyHunterLocation.area)
		{
			//save off obj_id of target, in case we have no targets off planet
			SamePlanetObjId[SamePlanetCounter] = jediList[intRoll];
			SamePlanetInt[SamePlanetCounter] = jediIdx[intRoll];
			++SamePlanetCounter;
			jediList = utils.removeElementAt(jediList, intRoll);
			jediIdx = utils.removeElementAt(jediIdx, intRoll);
		}
		else
		{
			intRoll = jediIdx[intRoll];

			string[] strNames = dctJediInfo.getStringArray("name");
			strTargetName = strNames[intRoll];

			int[] bountyValue = dctJediInfo.getIntArray("bountyValue");

			jediBountyValue = bountyValue[intRoll];

			objTarget = objJedis[intRoll];
			if(!isIdValid(objTarget))
			{
				LIVE_LOG("bh_jedi_mission", "WARNING mission_dynamic_base.createJediBountyMission: target " + intRoll + " was invalid");
			}
			break;
		}

	}

	//check to see if we came up with no targets because they were off planet.
	if(jediList.size() <= 0 && SamePlanetCounter > 0)
	{
		int randomChoice = rand(0, SamePlanetObjId.length - 1);
		obj_id farthestBounty = null;
		int farthestBountyIndex = -1;

		for(int i = 0; i <= 100; ++i)
		{
			//debugSpeakMsg(bountyHunterId, "i is " + i);

			if(!isIdNull(SamePlanetObjId[randomChoice]))
			{
				//get the distance to the mark.
				float distance = getDistance(bountyHunterLocation, jediLocation[SamePlanetInt[randomChoice]]);

				//check to see if they are far enough away.
				if(distance > PREFERRED_DISTANCE)
				{
					//This is our prefered Bounty.
					farthestBounty = SamePlanetObjId[randomChoice];
					farthestBountyIndex = SamePlanetInt[randomChoice];
					break;
				}
			}
			//if we have tried 100 times and still couldnt find a mark the prefered distance
			//randomly choose one and move on.
			randomChoice = rand(0, SamePlanetObjId.length - 1);
			if(i >= 100)
			{
				farthestBounty = SamePlanetObjId[randomChoice];
				farthestBountyIndex = SamePlanetInt[randomChoice];
			}
		}

		intRoll = farthestBountyIndex;

		string[] strNames = dctJediInfo.getStringArray("name");
		strTargetName = strNames[intRoll];

		int[] bountyValue = dctJediInfo.getIntArray("bountyValue");

		jediBountyValue = bountyValue[intRoll];

		objTarget = objJedis[intRoll];
		if(!isIdValid(objTarget))
		{
			LIVE_LOG("bh_jedi_mission", "WARNING mission_dynamic_base.createJediBountyMission: target " + intRoll + " was invalid");
		}
	}

	if(strTargetName == null)
	{
		LIVE_LOG("bh_jedi_mission", "mission_dynamic_base.createJediBountyMission: No PvP Bounty found (bad data)");
		return null;	// no PvP Bounties around.. no missions!
	}

	LIVE_LOG("bh_jedi_mission", "mission_dynamic_base.createJediBountyMission: creating mission on Jedi " + strTargetName);

	setObjVar(objMissionData, "objTarget", objTarget);
	setObjVar(objMissionData, "intInformantLevel", 3);
	setObjVar(objMissionData, "intBountyDifficulty", 3);
	setObjVar(objMissionData, "strTargetName", strTargetName);
	string strGoal = "object/tangible/mission/mission_bounty_jedi_target.iff";	// dummy value

	setMissionTargetAppearance(objMissionData, strGoal);

	if(flag == missions.BOUNTY_FLAG_SMUGGLER)
	{
		if(jediFaction[intRoll] == ##"Rebel")
		{
			setMissionTargetName(objMissionData, utils.packStringId(new string_id("mission/mission_bounty_jedi", "rebel_smuggler")));
		}
		else
		{
			if(jediFaction[intRoll] == ##"Imperial")
			{
				setMissionTargetName(objMissionData, utils.packStringId(new string_id("mission/mission_bounty_jedi", "imperial_smuggler")));
			}
			else
			{
				setMissionTargetName(objMissionData, utils.packStringId(new string_id("mission/mission_bounty_jedi", "neutral_smuggler")));
			}
		}
	}
	else
	{
		if(jediFaction[intRoll] == ##"Rebel")
		{
			setMissionTargetName(objMissionData, utils.packStringId(new string_id("mission/mission_bounty_jedi", "rebel_jedi")));
		}
		else
		{
			if(jediFaction[intRoll] == ##"Imperial")
			{
				setMissionTargetName(objMissionData, utils.packStringId(new string_id("mission/mission_bounty_jedi", "imperial_jedi")));
			}
			else
			{
				setMissionTargetName(objMissionData, utils.packStringId(new string_id("mission/mission_bounty_jedi", "neutral_jedi")));
			}
		}
	}

	setMissionReward(objMissionData, jediBountyValue);
	setMissionDifficulty(objMissionData, 100);
	//LOG("PVP_Bounty", "passed faction is " + strFaction);

	string factionName = factions.getFactionNameByHashCode(jediFaction[intRoll]);

	if(factionName != null)
	{
		factionName = toLower(factionName);

		if(factionName.equals("imperial"))
			factionName = "rebel";
		else if(factionName.equals("rebel"))
			factionName = "imperial";
	}

	setupContextualizationStrings(objMissionData, MISSION_BOUNTY_DIFFICULTY_JEDI, objCreator, factionName, flag);
	//LOG("mission", "Returning "+objMissionData);
	return objMissionData;
}

obj_id createBountyTarget(obj_id objMission)
{
	obj_id objMissionData = getMissionData(objMission);

	string strSpecies = getStringObjVar(objMissionData, "strSpecies");
	obj_id objPlayer = getMissionHolder(objMission);

	////LOG("mission_spam", "objMissionData of "+objMissionData);

	//int intSize = getIntObjVar(objMissionData, "intSize");
	location locSpawnLocation = getLocationObjVar(objMission, "locSpawnLocation");

	location locGoodLocation = new location();

	if(!(locations.isInCity(locSpawnLocation)))
	{
		locGoodLocation = locations.getGoodLocationAroundLocationAvoidCollidables(locSpawnLocation, 1, 1, 64, 64, false, true, 10.0f);
	}
	else
	{
		region rgnCityRegion = locations.getCityRegion(locSpawnLocation);

		locGoodLocation = locations.getGoodCityLocation(rgnCityRegion, locSpawnLocation.area);
	}

	if(locGoodLocation == null)
	{
		return null;
	}

	int npcLevel = getIntObjVar(objMissionData, "intCombatDifficulty");

	string strNPCType = getStringObjVar(objMissionData, "strTarget");
	obj_id objTargetNPC;

	////LOG("missions", "creating a "+strNPCType);
	// we make our npc here

	locSpawnLocation.y = getHeightAtLocation(locSpawnLocation.x, locSpawnLocation.z);
	objTargetNPC = create.object(strNPCType, locSpawnLocation, npcLevel);

	stopFloating(objTargetNPC);

	if(!isIdValid(objTargetNPC))
	{
		////LOG("DESIGNER_FATAL", "For type "+strNPCType+" and location "+locSpawnLocation+" bounty target was null");

		objTargetNPC = create.object(NPC_TYPES[rand(0, NPC_TYPES.length - 1)], locSpawnLocation, npcLevel);
		stopFloating(objTargetNPC);

		if(!isIdValid(objTargetNPC))
		{
			return null;
		}
		////LOG("mission_spam", "Bad npc created in bounty mission, falsing");
	}

	// now we update the waypoint
	string strName = getStringObjVar(objMissionData, "strTargetName");

	setName(objTargetNPC, strName);

	setMissionStartLocation(objMissionData, locGoodLocation);	// updating the mission data to match the actual location
	pvpSetAlignedFaction(objTargetNPC, ##"bountytarget");
	pvpSetPermanentPersonalEnemyFlag(objTargetNPC, objPlayer);

	setObjVar(objMissionData, "intTargetCreated", 1);	// NO RETURN!, NO MURE uPDATES TO LOCATIONS!
	setObjVar(objTargetNPC, "objHunter", objPlayer);

	setObjVar(objTargetNPC, "objMission", objMission);
	persistAndRegisterObject(objTargetNPC, objMission);

	int intBool = attachScript(objTargetNPC, "systems.missions.dynamic.mission_bounty_target");

	dictionary dctParams = new dictionary();

	messageTo(objTargetNPC, "handle_Spawn_Setup_Complete", dctParams, 0, true);	//w'ere done with teh object setup
	setObjVar(objMission, "intTargetSpawned", 1);

	return objTargetNPC;	// we recreated it all

}

//*********************************BASE DYNAMIC FUNCTIONS***********************

boolean transferDeliveryItem(obj_id objItem, obj_id objTarget)
{
	obj_id objInventory = getObjectInSlot(objTarget, "inventory");
	boolean boolTransfer = putIn(objItem, objInventory);

	if(boolTransfer == true)
	{
		return true;

	}

	return false;
}

void missionArrival(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "onArrivedAtLocation", dctParams, 0, true);
	return;
}

void cleanupLocationTargets(obj_id objMission)
{
	////LOG("mission", "Cleaning up location targets");
	dictionary dctParams = new dictionary();

	dctParams.put("strLocationTarget", objMission.toString());
	messageTo(getMissionHolder(objMission), "cleanupLocationTarget", dctParams, 0, true);
}

// this sets up the triggers for the target player.
void setupSpawn(obj_id objMission, location locSpawnLocation)
{
	obj_id objPlayer = getMissionHolder(objMission);
	dictionary dctParams = new dictionary();

	////LOG("mission_general", "SETTING UP SPAWN STUFF");

	dctParams.put("objMission", objMission);
	dctParams.put("locSpawnLocation", locSpawnLocation);
	messageTo(objPlayer, "setupSpawn", dctParams, 0, true);
}

// this sets up the triggers for the target player. its for use when things unload to prevent crashes
void setupUnloadedSpawn(obj_id objMission, obj_id objMissionHolder, location locSpawnLocation)
{
	dictionary dctParams = new dictionary();

	////LOG("mission", "objMissionHolder is "+objMissionHolder);
	////LOG("mission", "locSpawnLocation is "+locSpawnLocation);
	////LOG("mission", "objMission is "+objMission);

	////LOG("mission_general", "SETTING UP SPAWN STUFF");

	dctParams.put("objMission", objMission);
	dctParams.put("locSpawnLocation", locSpawnLocation);

	messageTo(objMissionHolder, "setupSpawn", dctParams, 0, true);
}

location getGoodMissionLocation(obj_id objMission, obj_id objPlayer)
{
	int intSize = getIntObjVar(objMission, "intSize");

	if(intSize < 1)
	{
		intSize = 64;
	}

	location locSpawnLocation = getMissionStartLocation(objMission);

	location locGoodLocation = locations.getGoodLocationAroundLocation(locSpawnLocation, intSize, intSize, 300, 300, false, true);

	if(locGoodLocation == null)
	{
		locGoodLocation = locations.getGoodLocationAroundLocation(getLocation(objPlayer), intSize, intSize, 400, 400, false, true);
		if(locGoodLocation == null)
		{
			////LOG("DESIGNER_FATAL", "location "+locSpawnLocation+" and size "+intSize+" generated a null good location so we're returning false");
			return null;
		}
	}

	if(locations.isInMissionCity(locGoodLocation))
	{
		locGoodLocation = locations.getGoodLocationAroundLocation(getLocation(objPlayer), intSize, intSize, 400, 400, false, true);
		if(locGoodLocation == null)
		{
			////LOG("DESIGNER_FATAL", "location "+locSpawnLocation+" and size "+intSize+" generated a null good location so we're returning false");
			return null;
		}
		if(locations.isInMissionCity(locGoodLocation))
		{
			return null;
		}
	}

	region rgnBattlefield = battlefield.getBattlefield(locGoodLocation);

	if(rgnBattlefield != null)
	{
		return null;
	}

	if(locations.isInMissionCity(locGoodLocation))
	{
		return null;
	}

	float fltHeight = getHeightAtLocation(locGoodLocation.x, locGoodLocation.z);

	locGoodLocation.y = fltHeight;
	return locGoodLocation;
}

//*****************************DESTRUCTION FUNCTIONS

// sets up the mission object for a destruction mission. We don't spawn it because of the delayed creation routines
boolean setupDestructionMissionObject(obj_id objMission)
{
	return true;
}

void sendMissionStartMovementSpam(obj_id objMission)
{
	obj_id objPlayer = getMissionHolder(objMission);

	sendSystemMessage(objPlayer, SID_MISSION_TARGET_UPDATED);

}

void moveMissionStartLocation(obj_id objMission)
{
	location locSpawnLocation = getMissionStartLocation(objMission);

	location locStartLocation = getLocationObjVar(objMission, "location.locMissionStart");
	int intDistance = rand(MIN_DISTANCE_FOR_RETRY, MAX_DISTANCE_FOR_RETRY);
	location locNewLocation = locSpawnLocation;

	locNewLocation.x = locSpawnLocation.x - locStartLocation.x;
	locNewLocation.z = locSpawnLocation.z - locStartLocation.z;
	////LOG("missions", "locNewLocation is "+locNewLocation);

	float fltDistance = utils.getDistance(locStartLocation, locSpawnLocation);

	////LOG("missions", "fltDistance is "+fltDistance);
	locNewLocation.x = locNewLocation.x / fltDistance;
	locNewLocation.z = locNewLocation.z / fltDistance;

	////LOG("missions", "locNewLocation2 is "+locNewLocation);

	location locFinalLocation = locSpawnLocation;

	locFinalLocation.x = locSpawnLocation.x + (float) (locNewLocation.x * intDistance);
	locFinalLocation.z = locSpawnLocation.z + (float) (locNewLocation.z * intDistance);
	////LOG("missions", "locFinalLocation is "+locFinalLocation);
	setMissionStartLocation(objMission, locFinalLocation);

	updateMissionWaypoint(objMission, locFinalLocation);
	sendMissionStartMovementSpam(objMission);
	setupSpawn(objMission, locFinalLocation);

	return;
}

// this spawns the actual destruction target.
boolean createDestructionTarget(obj_id objMission, obj_id objPlayer)
{
	int intAttempts = 0;

	if(hasObjVar(objMission, "intAttempts"))
		intAttempts = getIntObjVar(objMission, "intAttempts");
	else
		setObjVar(objMission, "intAttempts", intAttempts);

	string strTemplate;

	obj_id objMissionData = getMissionData(objMission);

	if(hasObjVar(objMissionData, "strGoal"))
	{
		strTemplate = getStringObjVar(objMissionData, "strGoal");
	}
	else
	{
		////LOG("DESIGNER_FATAL", "No goal object set on destroy object");
		return false;
	}
	location locGoodLocation = getGoodMissionLocation(objMission, objPlayer);

	if(locGoodLocation == null)
	{
		if(intAttempts >= MAX_SPAWN_ATTEMPTS)
		{
			return false;
		}
		else
		{
			intAttempts = intAttempts + 1;
			setObjVar(objMission, "intAttempts", intAttempts);
			moveMissionStartLocation(objMission);
			return true;
		}
	}

	obj_id objDestructionTarget = createObject(strTemplate, locGoodLocation);

	if(!isIdValid(objDestructionTarget))
	{
		////LOG("DESIGNER_FATAL", "strTempalte of "+strTemplate+" and location of "+locGoodLocation +" made a null mission destination");
		return false;
	}

	persistAndRegisterObject(objDestructionTarget, objMission);
	float fltKillPercentage = getFloatObjVar(objMissionData, "fltKillPercentage");
	string strLairType = getStringObjVar(objMissionData, "strLairType");
	string strBuildingType = getStringObjVar(objMissionData, "strBuildingType");
	string strObjective = getStringObjVar(objMissionData, "strObjective");	// UNUSUED FOR NOW
	string strObjectiveTarget = getStringObjVar(objMissionData, "strObjectiveTarget");
	string strLairDifficulty = getStringObjVar(objMissionData, "strLairDifficulty");
	int intPlayerDifficulty = getIntObjVar(objMissionData, "intPlayerDifficulty");
	int groupSize = getIntObjVar(objMissionData, "originalGroupSize");

	if(strLairType != "")
	{
		// we're a new type of lair.. we need to copy everything
		setObjVar(objDestructionTarget, "spawning.lairType", strLairType);
		setObjVar(objDestructionTarget, "spawning.lairDifficulty", strLairDifficulty);
		setObjVar(objDestructionTarget, "spawning.intDifficultyLevel", intPlayerDifficulty);
		setObjVar(objDestructionTarget, "spawning.groupSize", groupSize);

		if(strBuildingType != "")
		{
			setObjVar(objDestructionTarget, "spawning.buildingType", strBuildingType);	// none if this is a lair mission
		}

		if(strObjectiveTarget != "")
		{
			setObjVar(objDestructionTarget, "spawning.target", strObjectiveTarget);	// what to explode
		}
		else
		{
			setObjVar(objDestructionTarget, "spawning.killPercent", fltKillPercentage);
		}
	}
	else
	{

		int intNumToSpawn = getIntObjVar(objMissionData, "intNumToSpawn");
		string strTemplateToSpawn = getStringObjVar(objMissionData, "strTemplateToSpawn");

		if(intNumToSpawn > 0)
		{
			setObjVar(objDestructionTarget, "numToSpawn", intNumToSpawn);
		}

		if(strTemplateToSpawn != null && strTemplateToSpawn != "")
		{
			setObjVar(objDestructionTarget, "creatureTemplate", strTemplateToSpawn);
		}

		int intBool = attachScript(objDestructionTarget, "systems.missions.dynamic.mission_destruction_target");
	}

	updateMissionWaypoint(objMission, locGoodLocation);

	sendSystemMessage(objPlayer, SID_MISSION_TARGET_UPDATED_EXACT);

	setMissionStartLocation(objMissionData, locGoodLocation);	// updating the mission data to match the actual location

	setObjVar(objDestructionTarget, "objDestroyer", objPlayer);	// who will destroy me
	setObjVar(objDestructionTarget, "objMission", objMission);
	setObjVar(objDestructionTarget, "locSpawnLocation", locGoodLocation);
	setObjVar(objDestructionTarget, "objMissionHolder", objPlayer);	// to prevent race conditions;

	////LOG("mission_general", "Everything is peachy keen, ObjDestructionTarget was made just fine");

	dictionary dctParams = new dictionary();
	messageTo(objDestructionTarget, "handle_Spawn_Setup_Complete", dctParams, 0, true);	//w'ere done with teh object setup

	return true;		// we recreated it all
}

// wrapper messageto function if the mission failed. You pass it the id of the destruction target
void sendDestructionFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "destructionFail", dctParams, 0, true);
}

// wrapper messageto function if the mission succeeded. You pass it the id of the destruction target
void sendDestructionSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "destructionSuccess", dctParams, 0, false);
}

// wrapper messageto function if the mission becomes incompletable. You pass it the id of the destruction target
void sendDestructionIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "destructionIncomplete", dctParams, 0, true);

}

// wrapper messageto function if the mission failed.
void sendEscortFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "escortFail", dctParams, 0, true);
}

// wrapper messageto function if the mission succeeded.
void sendEscortSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "escortSuccess", dctParams, 0, true);
}

// wrapper messageto function if the mission becomes incompletable.
void sendEscortIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "escortIncomplete", dctParams, 0, true);
}

boolean createEscortTarget(obj_id objMission)
{
// we've gotta make the escort mission NPC
	obj_id objMissionData = getMissionData(objMission);
	location locSpawnLocation = getMissionStartLocation(objMissionData);
	location locEscortFinish = getMissionEndLocation(objMissionData);
	region[] rgnCities = getRegionsWithMunicipalAtPoint(locSpawnLocation, regions.MUNI_TRUE);

	if(rgnCities != null)
	{
		locSpawnLocation = locations.getGoodCityLocation(rgnCities[0], locSpawnLocation.area);
	}
	else
	{
		locSpawnLocation = locations.getGoodLocationAroundLocation(locSpawnLocation, 1, 1, 128, 128, false, true);
		rgnCities = getRegionsWithMunicipalAtPoint(locSpawnLocation, regions.MUNI_TRUE);

		if(rgnCities != null)
		{
			locSpawnLocation = locations.getGoodCityLocation(rgnCities[0], locSpawnLocation.area);
		}
	}

	if(locSpawnLocation == null)
	{
		return false;
	}

	string strNPCType = getStringObjVar(objMissionData, "strNPCType");
	strNPCType = "townsperson";	// HACK
	obj_id objEscortTarget = create.object(NPC_TYPES[rand(0, NPC_TYPES.length - 1)], locSpawnLocation);
	obj_id objPlayer = getMissionHolder(objMission);

	if(!isIdValid(objEscortTarget))
	{
		return false;
	}
	else
	{
		updateMissionWaypoint(objMission, locSpawnLocation);
		setObjVar(objMission, "objEscortTarget", objEscortTarget);
		setObjVar(objEscortTarget, "objMission", objMission);
		setObjVar(objEscortTarget, "objEscorter", objPlayer);
		setObjVar(objEscortTarget, "locEscortFinish", locEscortFinish);
		attachScript(objEscortTarget, "systems.missions.dynamic.mission_escort_target");
		persistAndRegisterObject(objEscortTarget, objMission);
	}

	return true;
}

// escort fail wrapper function
void escortFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "escortFailure", dctParams, 0, true);	// spawner timer has started
}

// success wrapper function
void escortSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "escortSuccess", dctParams, 0, true);	// spawner timer has started
}

// incomplete wrapper function
void escortIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "escortIncomplete", dctParams, 0, true);	// spawner timer has started
}

//*********************************************Fetch/Deliver Functions**********************************************

boolean setupFetchMissionObject(obj_id objMission)
{
	////LOG("mission_general", "In setupFetchMissionObject");
	////LOG("mission_general", "objMission Id is "+objMission.toString());

	obj_id objMissionData = getMissionData(objMission);

	location locPickupLocation = getMissionStartLocation(objMissionData);
	location locDropoffLocation = getMissionEndLocation(objMissionData);

	////LOG("mission_general", "Got all Locations");

	////LOG("mission_general", "locPickupLocation =  "+locPickupLocation.toString());
	////LOG("mission_general", "locDropoffLocation =  "+locDropoffLocation.toString());

	return true;
}

boolean createFetchPickupNPC(obj_id objMission)
{
	return true;
}

boolean createFetchDropoffNPC(obj_id objMission)
{
	obj_id objMissionData = getMissionData(objMission);

	location locDropoffLocation = getMissionEndLocation(objMissionData);

	string strDropoffNPC = getStringObjVar(objMissionData, "strDropoffNPC");
	obj_id objDropoffNPC = create.object(NPC_TYPES[rand(0, NPC_TYPES.length - 1)], locDropoffLocation);

	if(!isIdValid(objDropoffNPC))
	{
		return false;	// bad instantiation, fail out
	}
	else
	{
		attachScript(objDropoffNPC, "systems.missions.dynamic.mission_fetch_dropoff");
		setObjVar(objDropoffNPC, "objMission", objMission);
		setObjVar(objDropoffNPC, "locSpawnLocation", locDropoffLocation);
	}

	return true;
}

// fail wrapper function
void fetchFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "fetchFailure", dctParams, 0, true);	// spawner timer has started
}

// success wrapper function
void fetchSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "fetchSuccess", dctParams, 0, true);	// spawner timer has started
}

// incomplete wrapper function
void fetchIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "fetchIncomplete", dctParams, 0, true);	// spawner timer has started
}

boolean verifyDeliveryItem(obj_id objPlayer, obj_id objDeliveryItem)
{
	obj_id objInventory = getObjectInSlot(objPlayer, "inventory");
	obj_id[] objContents = getContents(objInventory);

	if(objContents == null)
	{
		return false;

	}
	else
	{
		int intI = 0;

		while(intI < objContents.length)
		{
			if(objContents[intI] == objDeliveryItem)
			{
				return true;

			}

			intI = intI + 1;
		}

	}

	return false;		// NO ITEM FOUND!

}

// fail wrapper function
void sendDeliverFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "deliverFailure", dctParams, 0, true);	// spawner timer has started
}

// success wrapper function
void sendDeliverSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "deliverSuccess", dctParams, 0, true);	// spawner timer has started
}

// incomplete wrapper function
void sendDeliverIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "deliverIncomplete", dctParams, 0, true);	// spawner timer has started
}

boolean createDeliverPickupNPC(obj_id objMission)
{
	obj_id objPlayer = getMissionHolder(objMission);
	obj_id objMissionData = getMissionData(objMission);
	string strPickupNPC = getStringObjVar(objMissionData, "strPickupNPC");

	// since this is the start npc, use start location
	location locSpawnLocation = getMissionStartLocation(objMissionData);
	obj_id objPickupNPC = create.object(strPickupNPC, locSpawnLocation);

	if(!isIdValid(objPickupNPC))
	{
		////LOG("DESIGNER_FATAL", "NPC of type "+strPickupNPC+"created a null npc for mission");
		return false;	// mission did not instantiate. Incomplete!
	}
	else
	{
		updateMissionWaypoint(objMission, locSpawnLocation);
		attachScript(objPickupNPC, "systems.missions.dynamic.mission_deliver_pickup");
		setObjVar(objPickupNPC, "objMission", objMission);
		setObjVar(objPickupNPC, "locSpawnLocation", locSpawnLocation);
		setObjVar(objPickupNPC, "objPlayer", objPlayer);
		persistAndRegisterObject(objPickupNPC, objMission);
		setWantSawAttackTriggers(objPickupNPC, false);
	}
	return true;
}

boolean createDeliverDropoffNPC(obj_id objMission)
{
	obj_id objMissionData = getMissionData(objMission);
	string strDropoffNPC = getStringObjVar(objMissionData, "strDropoffNPC");
	location locSpawnLocation = getMissionEndLocation(objMissionData);
	obj_id objDropoffNPC = create.object(strDropoffNPC, locSpawnLocation);
	obj_id objPlayer = getMissionHolder(objMission);

	if(!isIdValid(objDropoffNPC))
	{
		////LOG("DESIGNER_FATAL", "Mission of type "+strDropoffNPC+"created a null npc for mission");
		return false;	// bad instantiation, fail out
	}
	else
	{
		persistAndRegisterObject(objDropoffNPC, objMission);
		updateMissionWaypoint(objMission, locSpawnLocation);
		attachScript(objDropoffNPC, "systems.missions.dynamic.mission_deliver_dropoff");
		setObjVar(objDropoffNPC, "objMission", objMission);
		setObjVar(objDropoffNPC, "locSpawnLocation", locSpawnLocation);
		setObjVar(objDropoffNPC, "objPlayer", objPlayer);
		setWantSawAttackTriggers(objDropoffNPC, false);
	}

	return true;
}

dictionary getDestructionMissionSpawnList(obj_id objCreator, int intDifficulty, string strPlanet, string strSpawnType, string strFaction)
{
	strFaction = toLower(strFaction);
	string strFileName;

	if(strFaction == "")
	{
		strFileName = "datatables/missions/" + strPlanet + "/" + strPlanet + "_destroy_" + strSpawnType + ".iff";
	}
	else
	{
		strFileName = "datatables/missions/faction/" + strFaction + "_destroy" + ".iff";
	}

	int intOverrideMissionIndex = -1;

	if(hasObjVar(objCreator, "missionTerminalOverrideDestroyMissionFileName") && hasObjVar(objCreator, "missionTerminalOverrideDestroyMissionIndex"))
	{
		string strOverrideFileName = getStringObjVar(objCreator, "missionTerminalOverrideDestroyMissionFileName");

		intOverrideMissionIndex = getIntObjVar(objCreator, "missionTerminalOverrideDestroyMissionIndex");

		sendSystemMessageTestingOnly(objCreator, "using mission #" + intOverrideMissionIndex + " from " + strOverrideFileName + " instead of " + strFileName);

		strFileName = strOverrideFileName;
		intOverrideMissionIndex -= 3;
	}

	int[] intMinDifficulty = dataTableGetIntColumn(strFileName, "intMinDifficulty");
	int[] intMaxDifficulty = dataTableGetIntColumn(strFileName, "intMaxDifficulty");

	int maxLength = intMinDifficulty.length;

	resizeable int[] okRows = new int[0];

	if(intOverrideMissionIndex >= 0)
	{
		okRows = utils.addElement(okRows, intOverrideMissionIndex);
	}
	else
	{
		for(int j = 0; j < maxLength; j++)
		{
			if((intMinDifficulty[j] <= intDifficulty) && (intMaxDifficulty[j] >= intDifficulty))
			{
				okRows = utils.addElement(okRows, j);
			}
		}
	}

	dictionary row = null;

	if(okRows.length > 0)
	{
		int randRow = rand(0, (okRows.length - 1));
		randRow = okRows[randRow];
		row = dataTableGetRow(strFileName, randRow);
		string strRewardFileName = "datatables/missions/destroy/destroy_rewards.iff";
		int minReward = dataTableGetInt(strRewardFileName, intDifficulty, "intMinReward");
		int maxReward = dataTableGetInt(strRewardFileName, intDifficulty, "intMaxReward");
		int intGCWPoints = 0;
		
		if(strFaction != "" && strFaction.length() > 0)
		{
			intGCWPoints = dataTableGetInt(strRewardFileName, intDifficulty, "intGCWPoints");
		}

		row.put("intMinReward", minReward);
		row.put("intMaxReward", maxReward);
		row.put("intGCWPoints", intGCWPoints);
	}

	return row;
}

string getOverloadTemplate(int intDifficulty, string strFaction, int intFaction)
{
	string strFileName = "datatables/spawning/spawn_lists/overloads/spawn_overloads.iff";
	int intI = 1;

	dictionary dctSpawnInformation = new dictionary();

	int[] intDifficulties = dataTableGetIntColumn(strFileName, "intMinDifficulty");
	string[] strTemplates = new string[intDifficulties.length];
	int intArrayIndex = 0;

	while(intI < intDifficulties.length)	// we subtract 3 because of some extra tracking info);
	{
		dctSpawnInformation = dataTableGetRow(strFileName, intI);

		int intMinTemplateDifficulty = dctSpawnInformation.getInt("intMinDifficulty");
		int intMaxTemplateDifficulty = dctSpawnInformation.getInt("intMaxDifficulty");

		string strTemplateFaction = dctSpawnInformation.getString("strFaction");
		int intTemplateFaction = dctSpawnInformation.getInt("intFaction");

		int intMinTemplateFaction = intTemplateFaction - 250;
		int intMaxTemplateFaction = intTemplateFaction + 250;

		if(intMinTemplateFaction < 0)
		{
			intMinTemplateFaction = 0;
		}

		if(intMaxTemplateFaction > 1000)
		{
			intMaxTemplateFaction = 1000;
		}

		if((intMinTemplateDifficulty < intDifficulty) && (intMaxTemplateDifficulty > intDifficulty))
		{
			if(strTemplateFaction != "neutral")
			{
				if(strTemplateFaction != strFaction)
				{
					if((intMinTemplateFaction < intFaction) && (intMaxTemplateFaction > intFaction))
					{
						strTemplates[intArrayIndex] = dctSpawnInformation.getString("strTemplate");
						intArrayIndex = intArrayIndex + 1;
					}
				}
			}
			else
			{
				strTemplates[intArrayIndex] = dctSpawnInformation.getString("strTemplate");
				intArrayIndex = intArrayIndex + 1;
			}
		}

		intI = intI + 1;
	}

	if(intArrayIndex > 0)
	{
		int intId = rand(0, intArrayIndex);

		return strTemplates[intId];	// random element of the appropriate value
	}

	return null;
}

void setupContextualizationStrings(obj_id objMissionData, int intMissionDifficulty, obj_id objCreator, string strMissionFaction)
{
	setupContextualizationStrings(objMissionData, intMissionDifficulty, objCreator, strMissionFaction, missions.BOUNTY_FLAG_NONE);
}

void setupContextualizationStrings(obj_id objMissionData, int intMissionDifficulty, obj_id objCreator, string strMissionFaction, int flag)
{
	// check faction
	// check difficulty
	// check template type
	// get the string id
	// set the objvar

	////LOG("missions", "objCreator is "+objCreator);
	if(strMissionFaction == null)
		strMissionFaction = "";

	strMissionFaction = toLower(strMissionFaction);

	////LOG("mission_general","objMissionData is "+objMissionData.toString());
	////LOG("missions", "mission type is "+getMissionType(objMissionData));

	string strTemplate;

	////LOG("mission_general","Setting up CONTEXTUALIATIIOOION");
	string strMissionType = getMissionType(objMissionData);

	if(strMissionType == null)
	{
		////LOG("mission_general","No mission type defined, nulling mission data");
		return;
	}

	boolean boolNPC = false;
	string strIdFileName = "mission_";

	//PROFILER_START("getting fileNames");
	////LOG("objCreator", "objCreator is "+objCreator);
	if(ai_lib.aiGetNiche(objCreator) == NICHE_NPC)
	{
		////LOG("creator", "objCreator niche is npc");

		boolNPC = true;
	}
	else
	{
		////LOG("creator", "objCreator niche is NOT an npc");
		////LOG("creator", "niche is "+ai_lib.aiGetNiche(objCreator));
	}

	// secondary check.. this is more of a hack to make the new terminal stuff work
	boolean boolRandomName = false;

	if(hasObjVar(objCreator, "intScout"))
	{
		boolNPC = true;
		boolRandomName = true;
	}
	else if(hasObjVar(objCreator, "intArtisan"))
	{
		boolNPC = true;
		boolRandomName = true;
	}
	else if(hasObjVar(objCreator, "intEntertainer"))
	{
		boolNPC = true;
		boolRandomName = true;
	}

	// end secondary hack

	if(boolNPC)
	{
		strIdFileName = strIdFileName + "npc_";
	}
	if(strMissionFaction != "")
	{
		strIdFileName = strIdFileName + strMissionType + "_" + strMissionFaction + "_";
	}
	else
	{
		strIdFileName = strIdFileName + strMissionType + "_neutral_";	// hardcode this for now
	}

	////LOG("mission_general","StrIdFileNaem is "+strIdFileName);

	////LOG("mission_spam", "Mission Difficulty is "+intMissionDifficulty);
	////LOG("mission_general","strIdFileName is "+strIdFileName);

	if(intMissionDifficulty == MISSION_DIFFICULTY_EASY)
	{
		strIdFileName = strIdFileName + "easy";
	}
	else if(intMissionDifficulty == MISSION_DIFFICULTY_MEDIUM)
	{
		strIdFileName = strIdFileName + "medium";
	}
	else if(intMissionDifficulty == MISSION_DIFFICULTY_HARD)
	{
		strIdFileName = strIdFileName + "hard";
	}
	else if(intMissionDifficulty == MISSION_DIFFICULTY_BOSS)
	{
		strIdFileName = strIdFileName + "hard";
	}
	else if(intMissionDifficulty == MISSION_BOUNTY_DIFFICULTY_JEDI)
	{
		strIdFileName = "mission_bounty_jedi";
	}
	else
	{
		////LOG("mission_general","You're mission difficulty is so out of whack it isn't even funny. intMissionDifficulty is "+intMissionDifficulty);
		strIdFileName = strIdFileName + "easy";
		return;
	}

	////LOG("mission_general","strIdFileName is "+strIdFileName);

	if(hasObjVar(objMissionData, "strGoal"))
	{
		strTemplate = getStringObjVar(objMissionData, "strGoal");
	}

	if(strMissionType == "destroy")
	{
		if(strMissionFaction == "")
		{
			string strTargetType = getStringObjVar(objMissionData, "strTargetType");

			strIdFileName = strIdFileName + "_" + strTargetType;
			location locMissionStartLocation = getMissionStartLocation(objMissionData);

			////LOG("mission_spam", "Location is "+locMissionStartLocation);
			string strPlanet = locMissionStartLocation.area;

			////LOG("mission_spam", "Location target area is "+strPlanet);
			if(strPlanet == "tatooine")
			{
				if(!boolNPC)
				{
					strIdFileName = strIdFileName + "_tatooine";
				}
				////LOG("mission_spam", "Tattooine Location contextualization selected");
			}
			else if(strPlanet == "naboo")
			{
				if(!boolNPC)
				{
					strIdFileName = strIdFileName + "_naboo";
				}
				////LOG("mission_spam", "naboo Location contextualization selected");
			}
			else if(strPlanet == "corellia")
			{
				if(!boolNPC)
				{
					strIdFileName = strIdFileName + "_corellia";
				}
				////LOG("mission_spam", "corellia Location contextualization selected");
			}
		}
	}

	//PROFILER_STOP("getting fileNames");
	strIdFileName = "mission/" + strIdFileName;
	////LOG("mission", "final filename is "+strIdFileName);
	int intStringQuantity = 1;
	string_id strEntryId = new string_id(strIdFileName, "number_of_entries");

	string strNumberOfEntries = getString(strEntryId);

	//PROFILER_START("try/catch");
	if(strNumberOfEntries != null)
	{
		if(strNumberOfEntries == null)
		{
			intStringQuantity = 0;
		}
		else if(strNumberOfEntries != "")
		{
			Integer intTest = new Integer(0);
			boolean boolError = false;

			try
			{
				intTest = new Integer(strNumberOfEntries);
			}
			catch(NumberFormatException err)
			{
				boolError = true;
			}

			if(!boolError)
			{
				intStringQuantity = intTest.intValue();
				if(intStringQuantity < 0)
				{
					intStringQuantity = 1;
				}
			}
		}
	}

	int intId = rand(1, intStringQuantity);

	if(intMissionDifficulty == MISSION_BOUNTY_DIFFICULTY_JEDI)
	{
		//LOG("PVP_Bounty", "faction of mission = " + strMissionFaction);
		if(strMissionFaction == "imperial")
			intId = 2;
		else if(strMissionFaction == "rebel")
			intId = 1;
		else
			intId = 3;
	}

	//PROFILER_STOP("try/catch");
	//PROFILER_START("setup of mission object");
	setObjVar(objMissionData, "intStringId", intId);
	setObjVar(objMissionData, "strIdFileName", strIdFileName);
	location locTest = new location();

	int intStringId = intId;

	string flagChar = "";

	if(flag == missions.BOUNTY_FLAG_SMUGGLER)
		flagChar = "s";

	////LOG("mission", "Filename is "+strIdFileName);
	//PROFILER_START("boolnpc grabbing");
	string_id strTitleId = new string_id(strIdFileName, "m" + intStringId + "t" + flagChar);

	////LOG("mission", "Title id is "+strTitleId);
	string strDescription;

	if(boolNPC)
	{
		////LOG("missions", "boolNPC is true");
		if(isObjectPersisted(objCreator))
		{
			strDescription = "m" + intStringId + "o";
		}
		else
		{
			strDescription = "m" + intStringId + "d" + flagChar;	// nonperisted missions are identical to terminal contextualization formatting
		}

		string strTest = getMissionType(objMissionData);

		if(strTest == "survey")
		{
			strDescription = "m" + intStringId + "o";
		}
		else if(strTest == "crafting")	// bug with == with preprocessor
		{
			// safety valve. Crafting missions on persistent npc's use non-persistent formatting.
			strDescription = "m" + intStringId + "d" + flagChar;
		}
		else if(strTest == "dancer")
		{
			strDescription = "m" + intStringId + "o";
		}
		else if(strTest == "musician")
		{
			strDescription = "m" + intStringId + "o";
		}
	}
	else
	{
		strDescription = "m" + intStringId + "d" + flagChar;
	}

	//PROFILER_STOP("boolnpc grabbing");
	//PROFILER_START("description id");

	string_id strDescriptionId = new string_id(strIdFileName, strDescription);

	////LOG("mission", "Description id is "+strDescriptionId);

	string strName = "";

	if(ai_lib.aiGetNiche(objCreator) != NICHE_NPC)
	{
		//PROFILER_START("Token creation");
		// overload the creator crap!
		if(intMissionDifficulty == MISSION_BOUNTY_DIFFICULTY_JEDI)
		{
			if(strMissionFaction == "imperial")
				strName = "The Galactic Empire";
			else if(strMissionFaction == "rebel")
				strName = "The Alliance";
			else
				strName = "Corporate Sector Authority";
		}
		else if(!boolRandomName)
		{
			string_id strCreator = new string_id(strIdFileName, "m" + intStringId + "o");

			//PROFILER_STOP("Token creation");
			//PROFILER_START("getString");
			string strText = getString(strCreator);

			//PROFILER_STOP("getString");
			//PROFILER_START("getName");
			if(strText != null)
			{
				if(strText == "")
				{
					strName = getRandomMissionCreatorName();
					////LOG("mission_name", "strName is "+strName);
					setObjVar(objMissionData, "strCreatorName", strName);
				}
				else
				{
					strName = getString(strCreator);
				}
			}
			else
			{
				strName = getString(strCreator);
			}
			//PROFILER_STOP("getName");
			//PROFILER_START("set/Destroy");
		}
		else
		{
			strName = getRandomMissionCreatorName();
		}

		setMissionCreator(objMissionData, strName);
		//PROFILER_STOP("set/Destroy");
	}
	else
	{
		strName = getName(objCreator);
		setMissionCreator(objMissionData, strName);
	}

	//PROFILER_STOP("description id");
	////LOG("missions", "setting mission title ti "+strTitleId);
	setMissionTitle(objMissionData, strTitleId);

	setMissionDescription(objMissionData, strDescriptionId);
	////LOG("missions", "set mission desc to "+strDescriptionId);

	//PROFILER_STOP("setup of mission object");

	////LOG("mission_general","SETTING STRING_ID OBJVARS");
	return;
}

void sendMissionPersistentMessage(obj_id objMission, string strType)
{
	return;
}

// make sinterest npc's
void createDeliverInterestNPC(obj_id objMission)
{
	obj_id objMissionData = getMissionData(objMission);
	obj_id objPlayer = getMissionHolder(objMission);
	location locGoodLocation = new location();

	// intInterest is  anumber
	// that contains what we're going to generate
	// if we're medium difficulty we do the following

	int intMissionDifficulty = getIntObjVar(objMissionData, "intMissionDifficulty");

	if(hasObjVar(objMission, "intInterestActive"))
	{
		////LOG("mission", "Mission already interesting, retruning notning");
		return;
	}

	locGoodLocation = locations.getGoodLocationAroundLocation(getMissionLocation(objPlayer), 1, 1, 200, 200, false, true);

	if(locGoodLocation == null)
	{
		////LOG("mission", "Null location gotten in createDeliverGuy thing");

		return;
	}

	// what are we going to make
	if(intMissionDifficulty == MISSION_DIFFICULTY_MEDIUM)
	{
		obj_id objNPC = create.object(NPC_TYPES[rand(0, NPC_TYPES.length - 1)], locGoodLocation);

		if(!isIdValid(objNPC))
		{
			////LOG("mission", "null npc");
			return;
		}

		// now we decide..
		// is he an attacker
		// an escortee
		// or a buyer/attacker
		setObjVar(objNPC, "objPlayer", objPlayer);
		setObjVar(objNPC, "objMission", objMission);
		setObjVar(objMission, "intInterestActive", 1);
		setObjVar(objNPC, "objMissionData", objMissionData);
		persistAndRegisterObject(objNPC, objMission);
		int intInterest = getIntObjVar(objMission, "intInterest");

		intInterest = intInterest - 1;

		if(intInterest < 1)
		{
			removeObjVar(objMission, "intInterest");	// so we do nothing else
		}
		else
		{
			setObjVar(objMission, "intInterest", intInterest);
		}

		int intRoll = rand(1, 10);

		if(intRoll < 1)
		{
			attachScript(objNPC, "systems.missions.dynamic.mission_deliver_interest_npc_demand");
		}
		else if(intRoll < 10)
		{
			attachScript(objNPC, "systems.missions.dynamic.mission_deliver_interest_npc_escort");
		}
		else if(intRoll < 10)
		{
			attachScript(objNPC, "systems.missions.dynamic.mission_deliver_interest_npc_single_attacker");
		}
	}

	return;
}

void cleanUpInterestNPC(obj_id objNPC)
{
	obj_id objMission = getObjIdObjVar(objNPC, "objMission");

	destroyObject(objNPC);

	return;
}

void removeSpawnedTemplateElement(obj_id objMissionData, obj_id objTemplate)
{
	int intI = 0;

	if(hasObjVar(objMissionData, "objSpawnedTemplates"))
	{
		resizeable obj_id[]  objSpawnedTemplates = getResizeableObjIdArrayObjVar(objMissionData, "objSpawnedTemplates");

		while(intI < objSpawnedTemplates.length)
		{
			if(objSpawnedTemplates[intI] == objTemplate)
			{
				objSpawnedTemplates = utils.removeElementAt(objSpawnedTemplates, intI);
				return;
			}

			intI = intI + 1;
		}
	}
}

string getRandomMissionCreatorName()
{
	string strTemplate = "object/creature/player/human_male.iff";
	int intRoll = rand(1, 8);

	switch (intRoll)
	{
		case 1:
			strTemplate = "object/creature/player/bothan_male.iff";
		case 2:
			strTemplate = "object/creature/player/moncal_male.iff";
		case 3:
			strTemplate = "object/creature/player/trandoshan_male.iff";
		case 4:
			strTemplate = "object/creature/player/twilek_male.iff";
		case 5:
			strTemplate = "object/creature/player/rodian_male.iff";
		case 6:
			strTemplate = "object/creature/player/zabrak_male.iff";
		case 7:
			strTemplate = "object/creature/player/wookiee_male.iff";
		case 8:
			strTemplate = "object/creature/player/human_male.iff";
	}

	//PROFILER_START("Actual name call");
	string strName = generateRandomName(strTemplate);

	//PROFILER_STOP("Actual name call");

	return strName;
}

string getRandomSpeciesName(string strSpecies)
{
	string strTemplate = "";

	if(strSpecies == "alien")
	{
		int intRoll = rand(1, 8);

		switch (intRoll)
		{
			case 1:
				strTemplate = "object/creature/player/bothan_male.iff";
			case 2:
				strTemplate = "object/creature/player/moncal_male.iff";
			case 3:
				strTemplate = "object/creature/player/trandoshan_male.iff";
			case 4:
				strTemplate = "object/creature/player/twilek_male.iff";
			case 5:
				strTemplate = "object/creature/player/rodian_male.iff";
			case 6:
				strTemplate = "object/creature/player/zabrak_male.iff";
			case 7:
				strTemplate = "object/creature/player/wookiee_male.iff";
			case 8:
				strTemplate = "object/creature/player/human_male.iff";
		}

	}
	else
	{
		if(strSpecies == "bothan")
		{
			strTemplate = "object/creature/player/bothan_male.iff";
		}
		else if(strSpecies == "moncal")
		{
			strTemplate = "object/creature/player/moncal_male.iff";
		}
		else if(strSpecies == "wookiee")
		{
			strTemplate = "object/creature/player/wookiee_male.iff";
		}
		else if(strSpecies == "trandoshan")
		{
			strTemplate = "object/creature/player/trandoshan_male.iff";
		}
		else if(strSpecies == "twilek")
		{
			strTemplate = "object/creature/player/twilek_male.iff";
		}
		else if(strSpecies == "human")
		{
			strTemplate = "object/creature/player/human_male.iff";
		}
		else if(strSpecies == "zabrak")
		{
			strTemplate = "object/creature/player/zabrak_male.iff";
		}
		else if(strSpecies == "rodian")
		{
			strTemplate = "object/creature/player/rodian_male.iff";
		}
		else
		{
			strTemplate = "object/creature/player/human_male.iff";
		}
	}

	string strName = generateRandomName(strTemplate);

	return strName;
}

void preLoadDestructionDataTables(obj_id objMissionBoard, string strPlanet)
{
	return;
}

void registerBountyInformant(obj_id objInformant)
{
	location locCurrentLocation = getMissionLocation(objInformant);
	obj_id objPlanetObject = getPlanetByName(locCurrentLocation.area);

	int intInformantLevel = getIntObjVar(objInformant, "intInformantLevel");
	string strInformantLevel = "informant_level_" + intInformantLevel;
	string strPlanetName = locCurrentLocation.area;

	deltadictionary dctMissionInformation = objPlanetObject.getScriptVars();

	/*
	   string strCityName = locations.getCityName(locCurrentLocation);
	   strCityName = strCityName+strInformantLevel;
	 */
	string strArrayName = strPlanetName + "_" + strInformantLevel;
	resizeable obj_id[]  objInformants = dctMissionInformation.getResizeableObjIdArray(strArrayName);

	objInformants = utils.addElement(objInformants, objInformant);
	dctMissionInformation.put(strArrayName, objInformants);

	return;
}

void removeBountyInformant(obj_id objInformant)
{
	location locCurrentLocation = getMissionLocation(objInformant);
	obj_id objPlanetObject = getPlanetByName(locCurrentLocation.area);
	int intInformantLevel = getIntObjVar(objInformant, "intInformantLevel");
	string strInformantLevel = "informant_level_" + intInformantLevel;
	deltadictionary dctMissionInformation = objPlanetObject.getScriptVars();
	string strPlanetName = locCurrentLocation.area;
	string strArrayName = strPlanetName + "_" + strInformantLevel;
	resizeable obj_id[]  objInformants = dctMissionInformation.getResizeableObjIdArray(strArrayName);
	resizeable string[] strInformantNames = dctMissionInformation.getResizeableStringArray(strArrayName + "names");

	if(objInformants != null)
	{
		int intIndex = utils.getElementPositionInArray(objInformants, objInformant);

		if(intIndex != -1)
		{
			objInformants = utils.removeElementAt(objInformants, intIndex);
			strInformantNames = utils.removeElementAt(strInformantNames, intIndex);
			//strInformantLocations
		}

		dctMissionInformation.put(strArrayName, objInformants);
	}

	return;
}

void setupInvisibleWaypoint(obj_id objMission)
{
	location locSpawnLocation = getLocation(objMission);
	obj_id objTargetWaypoint = createWaypointInMissionObject(objMission, locSpawnLocation);

	if(isIdValid(objTargetWaypoint))
	{
		setObjVar(objMission, "objTargetWaypoint", objTargetWaypoint);
		setWaypointColor(objTargetWaypoint, "invisible");
		string_id strWaypointName = getMissionTitle(objMission);
		string strString = utils.packStringId(strWaypointName);

		setWaypointName(objTargetWaypoint, strString);
		setName(objMission, strWaypointName);
	}
}

boolean updateMissionWaypoint(obj_id objMission, location locSpawnLocation)
{
	if(!isIdValid(objMission))
	{
		return false;
	}

	obj_id objMissionData = getMissionData(objMission);

	if(locSpawnLocation == null)
	{
		return false;
	}

	obj_id objTargetWaypoint;

	if(!hasObjVar(objMission, "objTargetWaypoint"))
	{
		objTargetWaypoint = createWaypointInMissionObject(objMission, locSpawnLocation);
		if(isIdValid(objTargetWaypoint))
		{
			setObjVar(objMission, "objTargetWaypoint", objTargetWaypoint);
			string_id strWaypointName = getMissionTitle(objMissionData);

			////LOG("name", "name is "+strWaypointName);
			string strString = utils.packStringId(strWaypointName);

			setWaypointName(objTargetWaypoint, strString);
			setName(objMission, strWaypointName);
		}
	}
	else
	{
		objTargetWaypoint = getObjIdObjVar(objMission, "objTargetWaypoint");
	}

	if(!isIdValid(objTargetWaypoint))
	{
		return false;
	}
	//We don't want to give a waypoint if a probot is used.
	////LOG("missions", "updating m ission waypoint "+objTargetWaypoint+" to location "+locSpawnLocation);
	setWaypointColor(objTargetWaypoint, "orange");
	setWaypointLocation(objTargetWaypoint, locSpawnLocation);
	setWaypointActive(objTargetWaypoint, true);
	setWaypointVisible(objTargetWaypoint, true);

	obj_id player = getMissionHolder(objMission);

	if(isIdValid(player))
	{
		dictionary msgData = new dictionary();

		msgData.put("missionId", objMission);
		messageTo(player, "missionWaypointUpdated", msgData, 0, false);
	}

	return true;
}

void activateMissionWaypoint(obj_id objMission)
{
	if(hasObjVar(objMission, "objTargetWaypoint"))
	{
		obj_id objTargetWaypoint = getObjIdObjVar(objMission, "objTargetWaypoint");

		setWaypointActive(objTargetWaypoint, true);
	}

	return;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//      NPC MISSION CRAP GOES DOWN HERE, THESE ARE SPECIAL CASE FUNCTIONS AND STUFF!
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

obj_id generateNPCMissions(obj_id objNPC)
{

	obj_id objMissionData = createMissionObjectInCreatureMissionBag(objNPC);

	// this function makes npc missions
	// it'll fill out the npc with all applicable mission types

	// the format is going to be

	// mission.objMissionType

	// when one is given to a player, the npc puts themselves back on a queueu
	// etcetera

	// we get to make a single mission
	string[] strMissionTypes = getStringArrayObjVar(objNPC, "mission.strMissionTypes");

	if(strMissionTypes == null)
	{
		////LOG("DESIGNER_FATAL", "=================================");
		////LOG("DESIGNER_FATAL",  "BAD NPC MADE WITH MISSIONS, OBJ_ID OF "+objNPC);
		////LOG("DESIGNER_FATAL",  "=================================");
		////LOG("DESIGNER_FATAL", "NPC Type is "+ getCreatureName(objNPC));
		////LOG("DESIGNER_FATAL", "NPC Location is "+getLocation(objNPC));
		return null;
	}

	int intDifficulty;

	int intMinDifficulty = getIntObjVar(objNPC, "mission.intMinDifficulty");
	int intMaxDifficulty = getIntObjVar(objNPC, "mission.intMaxDifficulty");

	if(intMinDifficulty == 0)
	{
		intMinDifficulty = 1;
	}

	if(intMaxDifficulty == 0)
	{
		intMaxDifficulty = intMinDifficulty + 10;

		if(intMaxDifficulty > 20)
		{
			intMaxDifficulty = 20;
		}
	}

	intDifficulty = rand(intMinDifficulty, intMaxDifficulty);

	// we got the difficulty!

	string strNPCType = getStringObjVar(objNPC, "strNPCType");
	location locCurrentLocation = getLocation(objNPC);

	////LOG("mission", "We have an npc at " + locCurrentLocation);
	obj_id foo = getTopMostContainer(objNPC);

	if(!isIdValid(foo))
	{
		////LOG("mission", "foo is null");
	}
	else
	{
		locCurrentLocation = getLocation(foo);
		////LOG("mission", "We have a foo at " + locCurrentLocation);
	}

	string strPlanet = locCurrentLocation.area;
	string strFaction = "";

	if(hasObjVar(objNPC, factions.FACTION))
	{
		strFaction = factions.getFaction(objNPC);

		if(strFaction != "Imperial" && strFaction != "Rebel")
		{
			strFaction = "";
		}
	}

	obj_id objCreator = null;

	if(hasObjVar(objNPC, "mission.intPersistent"))
	{
		objCreator = objNPC;
	}
	else
	{
		objCreator = utils.getMissionBag(objNPC);
	}

	int intI = 0;

	while(intI < strMissionTypes.length)
	{
		if(!hasObjVar(objNPC, strMissionTypes[intI]))
		{
			string strMissionType = strMissionTypes[intI];

			if(strMissionType == "mission.objReconMission")
			{
				objMissionData = createReconMission(objMissionData, objNPC, locCurrentLocation, intDifficulty, strPlanet, "");
			}
			else if(strMissionType == "mission.objHuntingMission")
			{
				objMissionData = createHuntingMission(objMissionData, objNPC, intDifficulty, "");

			}
			else if(strMissionType == "mission.objDestroyMission")
			{
				boolean boolDeclaredOnly = false;

				if(strFaction != "")
				{
					if(hasObjVar(objNPC, "mission.intDeclaredOnly"))
					{
						boolDeclaredOnly = true;
						// only declared missions are allowed for this guy
						strFaction = strFaction + "_military";
					}
					else
					{
						strFaction = strFaction + "_non_military";
					}
				}

				objMissionData = createDestructionMissionDataFromLocation(objMissionData, objCreator, locCurrentLocation, intDifficulty, strPlanet, strFaction, 1.0f);

				if(isIdValid(objMissionData))
				{
					if(boolDeclaredOnly)
					{
						setObjVar(objMissionData, "boolDeclaredOnly", true);
					}

					if(!hasObjVar(objNPC, "mission.intPersistent"))
					{
						reContextualizationTerminalToNPCMission(objMissionData, objNPC);
					}

					if(hasObjVar(objNPC, "mission.strNPCName"))
					{
						objMissionData = dynamicDestroyToThemePark(objMissionData, objNPC);
					}
				}
			}
			else if(strMissionType == "mission.objDeliverMission")
			{
				objMissionData = createDeliverMissionFromLocation(objMissionData, objCreator, locCurrentLocation, intDifficulty, strPlanet, strFaction, 1.0f);

				if(isIdValid(objMissionData))
				{
					if(!hasObjVar(objNPC, "mission.intPersistent"))
					{
						reContextualizationTerminalToNPCMission(objMissionData, objNPC);
					}

					if(hasObjVar(objNPC, "mission.strNPCName"))
					{
						objMissionData = dynamicDeliverToThemePark(objMissionData, objNPC);
					}
				}
			}
			else if(strMissionType == "mission.objEscortMission")
			{
				objMissionData = createEscortToCreatorMission(objMissionData, objNPC, locCurrentLocation, intDifficulty, strPlanet, strFaction);

				if(isIdValid(objMissionData))
				{
					if(hasObjVar(objNPC, "mission.strNPCName"))
					{
						objMissionData = dynamicEscortToCreatorToThemePark(objMissionData, objNPC);
					}
				}
			}
			else if(strMissionType == "mission.objDancerMission")
			{
				objMissionData = createDancerMission(objMissionData, objNPC, 0, strFaction);
			}
			else if(strMissionType == "mission.objMusicianMission")
			{
				objMissionData = createMusicianMission(objMissionData, objNPC, 0, strFaction);
			}
			else if(strMissionType == "mission.objSurveyMission")
			{
				objMissionData = createSurveyMission(objMissionData, objNPC, intDifficulty, strFaction);
			}
			else if(strMissionType == "mission.objCraftingMission")
			{
				objMissionData = createCraftingMission(objMissionData, objNPC, locCurrentLocation, intDifficulty, strFaction);
			}
			else
			{
				////LOG("missions", "Bad npc mission type in the array. stopping mission generation");
				return null;
			}

			if(!isIdValid(objMissionData))
			{
				return null;
			}
			else
			{
				setObjVar(objMissionData, "objCreator", objNPC);
				return objMissionData;
			}
		}

		intI = intI + 1;
	}

	return null;
}

void cleanUpMissions(obj_id objNPC)
{
	int intI = 0;

	string[] strMissionTypes = getStringArrayObjVar(objNPC, "mission.strMissionTypes");

	while(intI < strMissionTypes.length)
	{
		if(hasObjVar(objNPC, strMissionTypes[intI]))
		{
			obj_id objMissionData = getObjIdObjVar(objNPC, strMissionTypes[intI]);

			removeObjVar(objNPC, strMissionTypes[intI]);
		}

		intI = intI + 1;
	}

	return;
}

boolean hasMissionFromNPC(obj_id objPlayer, obj_id objNPC)
{
	obj_id[] objMissionArray = getMissionObjects(objPlayer);
	int intI = 0;

	if(objMissionArray == null)
	{
		return false;
	}

	while(intI < objMissionArray.length)
	{
		obj_id objMissionData = getMissionData(objMissionArray[intI]);
		obj_id objMissionCreator = getObjIdObjVar(objMissionData, "objCreator");

		if(objMissionCreator == objNPC)
		{
			return true;
		}

		intI = intI + 1;
	}

	return false;
}

obj_id getMissionObjectFromNPC(obj_id objNPC, int intPlayerDifficulty)
{
	obj_id objMissionData = generateNPCMissions(objNPC);	// generate them when we need them

	if(!isIdValid(objMissionData))
	{
		return null;
	}

	return objMissionData;
}

void removeMissionObjectFromNPC(obj_id objNPC, obj_id objMissionData)
{
	int intI = 0;

	string[] strMissionTypes = getStringArrayObjVar(objNPC, "mission.strMissionTypes");

	while(intI < strMissionTypes.length)
	{
		if(hasObjVar(objNPC, strMissionTypes[intI]))
		{
			if(objMissionData == getObjIdObjVar(objNPC, strMissionTypes[intI]))
			{
				removeObjVar(objNPC, strMissionTypes[intI]);
				return;
			}
		}

		intI = intI + 1;
	}
}

void assignNPCMissionToPlayer(obj_id objNPC, obj_id objMissionData, obj_id objPlayer)
{
	////LOG("missions", "objMissionData is "+objMissionData);
	assignMission(objMissionData, objPlayer);
	removeMissionObjectFromNPC(objNPC, objMissionData);

	return;
}

// gets the mission for the player created by the npc
obj_id getAssignedNPCMission(obj_id objNPC, obj_id objPlayer)
{
	obj_id[] objMissionArray = getMissionObjects(objPlayer);

	int intI = 0;

	if(objMissionArray == null)
	{
		return null;
	}

	while(intI < objMissionArray.length)
	{
		obj_id objMissionData = getMissionData(objMissionArray[intI]);
		obj_id objMissionCreator = getObjIdObjVar(objMissionData, "objCreator");

		if(objMissionCreator == objNPC)
		{
			return objMissionArray[intI];
		}

		intI = intI + 1;
	}

	return null;
}

string_id sendNPCMissionSuccess(obj_id objMission, obj_id objNPC)
{
	obj_id objMissionData = getMissionData(objMission);
	string strMissionType = getMissionType(objMissionData);

	if(strMissionType == "destroy")
	{
		sendDestructionSuccess(objMission);
	}

	if(strMissionType == "deliver")
	{
		sendDeliverSuccess(objMission);
	}

	if(strMissionType == "recon")
	{
		sendReconSuccess(objMission);
	}

	string_id strResponse = getNPCMissionSuccessId(objMissionData);

	return strResponse;
}

string_id getNPCMissionSuccessId(obj_id objMissionData)
{
	int intStringId = getIntObjVar(objMissionData, "intStringId");
	string strIdFileName = getStringObjVar(objMissionData, "strIdFileName");
	string_id strMissionDescription = new string_id(strIdFileName, "m" + intStringId + "c");

	return strMissionDescription;
}

string_id getNPCEscortPickupId(obj_id objMissionData)
{
	int intStringId = getIntObjVar(objMissionData, "intStringId");
	string strIdFileName = getStringObjVar(objMissionData, "strIdFileName");
	string_id strPickupId = new string_id(strIdFileName, "m" + intStringId + "p");

	return strPickupId;
}

string_id getNPCEscortDropoffId(obj_id objMissionData)
{
	int intStringId = getIntObjVar(objMissionData, "intStringId");
	string strIdFileName = getStringObjVar(objMissionData, "strIdFileName");
	string_id strPickupId = new string_id(strIdFileName, "m" + intStringId + "e");

	return strPickupId;
}

string_id getNPCMissionDescriptionId(obj_id objMissionData)
{
	int intStringId = getIntObjVar(objMissionData, "intStringId");
	string strIdFileName = getStringObjVar(objMissionData, "strIdFileName");

	// UNLESS ITS A NON PERSISTENT ONE.. then it's like a terminal mission!
	int intIndex = strIdFileName.indexOf("persistent");	// is it a recontextualized terminal mission
	string_id strMissionDescription;
	string strMissionType = getMissionType(objMissionData);

	if(strMissionType != "crafting")
	{
		if(intIndex < 0)
		{
			strMissionDescription = new string_id(strIdFileName, "m" + intStringId + "o");
		}
		else
		{
			strMissionDescription = new string_id(strIdFileName, "m" + intStringId + "d");
		}
	}
	else
	{
		// crafting contextualization sucks. sorry
		strMissionDescription = new string_id(strIdFileName, "m" + intStringId + "d");
	}

	return strMissionDescription;
}

// NPC MISSION ONLY HERE. DON'T USE THIS ANYWHERE ELSE
obj_id createReconMission(obj_id objMissionData, obj_id objCreator, location locMissionStart, int intDifficulty, string strPlanet, string strFaction)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_recon");
	setMissionType(objMissionData, "recon");

	if(hasObjVar(objCreator, "intScout"))
	{
		setObjVar(objMissionData, "intTerminal", 1);
	}

	int intI = 0;
	string strSpawnType = "";
	region rgnSpawnRegion;
	location locMissionDestination = new location();
	float fltCityRegionExtent = 0;
	float fltRange;
	location locGoodLocation = null;

	float fltRewardModifier = 1;

	region[] rgnCities = new region[0];

	if(intDifficulty > RECON_OFF_PLANET_THRESHOLD)
	{
		int intRoll = rand(0, RECON_PLANETS.length - 1);
		string strEndPlanet = RECON_PLANETS[intRoll];
		string strStartPlanet = locMissionStart.area;

		if(strEndPlanet != strStartPlanet)
		{
			fltRewardModifier = RECON_OFF_PLANET_BASE_MODIFIER;
			fltRewardModifier = fltRewardModifier + RECON_DIFFICULTY_MODIFIER[intRoll];
		}

		boolean boolInCity = false;

		rgnCities = getRegionsWithMunicipal(strEndPlanet, regions.MUNI_TRUE);

		if(rgnCities == null)
		{
			rgnCities = getRegionsWithMission(strEndPlanet, regions.MISSION_OTHER);

			if(rgnCities == null)
			{
				return null;
			}

			fltCityRegionExtent = 0;	// not a city
		}
		else
		{
			boolInCity = true;
			fltCityRegionExtent = locations.getRegionExtents(rgnCities[0]);
		}
	}
	else
	{
		rgnCities = getRegionsWithMunicipalAtPoint(locMissionStart, regions.MUNI_TRUE);

		if(rgnCities != null)
		{
			fltCityRegionExtent = locations.getRegionExtents(rgnCities[0]);
			////LOG("missions", "getRegionsWithMunicipalAtPoint returned somthing with an extent " + fltCityRegionExtent);
		}
		else
		{
			////LOG("missions", "getRegionsWithMunicipalAtPoint returned null in createReconMission");
			fltCityRegionExtent = 0;
		}
	}

	// we need to do this until we get a good one or hit 10 cycles

	while(intI < LOCATION_CHECKS)
	{
		fltRange = fltCityRegionExtent + rand(MIN_RECON_DISTANCE, MAX_RECON_DISTANCE);

		if(fltRange < MIN_RECON_DISTANCE)
		{
			fltRange = MIN_RECON_DISTANCE;
		}

		////LOG("missions", "rgnCities is null, so we're going to get a location in a ring");
		location locNewLocation = utils.getRandomLocationInRing(locMissionStart, fltRange, fltRange + 200);

		////LOG("missions", "locNewLocation is now "+locNewLocation);
		locGoodLocation = locations.getGoodLocationAroundLocation(locNewLocation, 30, 30, 200, 200, false, true);

		////LOG("mission", "getGoodLocation returned "+locGoodLocation);
		if(locGoodLocation != null)
		{
			////LOG("missions", "I got a good location for my recon mission, validating the location");
			locMissionDestination = locGoodLocation;	// we can mangle now that its a good loc
			// am i in a city? if not, we're good to go
			////LOG("mission", "checking for point we generated. Are we in a city?");
			rgnCities = getRegionsWithMunicipalAtPoint(locMissionDestination, regions.MUNI_TRUE);	// check the destination

			if((rgnCities != null))
			{
				////LOG("missions", "my good location was inside of a city.. this is bad, getting a new location");
				// we made a bad location
				continue;
			}
			else
			{
				////LOG("missions", "checking battlefieldS");
				region rgnBattlefield = battlefield.getBattlefield(locGoodLocation);

				if(rgnBattlefield != null)
				{
					continue;
				}
				////LOG("missions", "no battlefield");
			}

			//We have a good location at this point...so break out of the while loop.
			break;
		}
		else
		{
			////LOG("missions", "I got a null good location from recon mission location stuff.. bad ");
		}

		intI = intI + 1;
	}

	if(intI >= LOCATION_CHECKS)
	{
		////LOG("missions", "not a good location anywhere on this stupid planet");
		return null;
	}

	if(locGoodLocation == null)
	{
		return null;
	}

	location locSpawnLocation = locMissionDestination;
	location locCreator = getMissionLocation(objCreator);
	float fltDistance = 0;

	fltDistance = utils.getDistance(locCreator, locSpawnLocation);
	setObjVar(objMissionData, "locCreatorLocation", locCreator);	// for finishing the frigging mission

	if(locSpawnLocation.area != locCreator.area)
	{
		if(fltDistance < 3000)
		{
			fltDistance = rand(3000, 4000);
		}
	}

	int intMissionDifficulty = 1;

	if(fltDistance < RECON_EASY_DISTANCE)
	{
		intMissionDifficulty = MISSION_DIFFICULTY_EASY;
	}
	else if(fltDistance < RECON_MEDIUM_DISTANCE)
	{
		intMissionDifficulty = MISSION_DIFFICULTY_MEDIUM;
	}
	else
	{
		intMissionDifficulty = MISSION_DIFFICULTY_HARD;
	}

	//intMissionDifficulty = MISSION_DIFFICULTY_EASY;

	location locTest = new location();	// dummy location for token
	string strTest = "object/tangible/mission/mission_recon_target.iff";	// dummy value

	setMissionTargetAppearance(objMissionData, strTest);

	setupContextualizationStrings(objMissionData, intMissionDifficulty, objCreator, strFaction);
	dictionary dctReconList = getReconSpawnList(objMissionData, locGoodLocation, intDifficulty);

	if(dctReconList == null)
	{
		return null;
	}

	int[] intSizes = dctReconList.getIntArray("intSizes");

	string[] strTemplates = dctReconList.getStringArray("strTemplates");
	string[] strLairTypes = dctReconList.getStringArray("strLairTypes");
	string[] strBuildingTypes = dctReconList.getStringArray("strBuildingTypes");
	int[] intMinDifficulties = dctReconList.getIntArray("intMinDifficulties");
	int[] intMaxDifficulties = dctReconList.getIntArray("intMaxDifficulties");

	int intRandomNumber = rand(0, strTemplates.length - 1);
	string strGoal = strTemplates[intRandomNumber];
	string strBuildingType = strBuildingTypes[intRandomNumber];
	string strLairType = strLairTypes[intRandomNumber];
	int intMinDifficulty = intMinDifficulties[intRandomNumber];
	int intMaxDifficulty = intMaxDifficulties[intRandomNumber];

	setObjVar(objMissionData, "strGoal", strGoal);

	setObjVar(objMissionData, "strLairType", strLairType);
	setObjVar(objMissionData, "strBuildingType", strBuildingType);
	setObjVar(objMissionData, "intMinDifficulty", intMinDifficulty);
	setObjVar(objMissionData, "intMaxDifficulty", intMaxDifficulty);
	setObjVar(objMissionData, "intPlayerDifficulty", intDifficulty);

	int intSize = intSizes[intRandomNumber];

	setObjVar(objMissionData, "intSize", intSize);

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}
	else
		setObjVar(objMissionData, "originalGroupSize", 1);

	int intReward = getDeliverReward(locMissionStart, locSpawnLocation, RECON_REWARD_RATIO, 4);

	intReward = (int) (intReward * fltRewardModifier);
	intReward = intReward + rand(-100, 100);

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	////LOG("mission_spam", "Transferred credits, we should get a callback any minute now");

	setMissionStartLocation(objMissionData, locSpawnLocation);

	setMissionDifficulty(objMissionData, intDifficulty);

	return objMissionData;
}

dictionary getReconSpawnList(obj_id objMissionData, location locMissionLocation, int intPlayerDifficulty)
{
	if(locMissionLocation == null)
	{
		////LOG("missions", "NULL LOCATION PASSED TO GETRECONSPAWNLIST");
		return null;
	}

	dictionary dctReturn = new dictionary();
	int intStringId = getIntObjVar(objMissionData, "intStringId");
	string strIdFileName = getStringObjVar(objMissionData, "strIdFileName");
	string_id strReconFile = new string_id(strIdFileName, "m" + intStringId + "d");
	string strFileName = getString(strReconFile);

	if(strFileName != null)
	{
		strFileName = toLower(strFileName);
		strFileName = "datatables/missions/recon/recon_" + strFileName + ".iff";

		if(!dataTableOpen(strFileName))
		{
			////LOG("DESIGNER_FATAL", "Filename of "+strFileName+" does not exist");
			////LOG("DESIGNER_FATAL", "String file is "+strIdFileName+" and entry is "+strReconFile);
			strFileName = "datatables/missions/recon/recon_npc.iff";
		}
	}
	else
	{
		strFileName = "datatables/missions/recon/recon_npc.iff";
	}
	////LOG("recon", "REcon list is "+strFileName);

	int[] intSizes = dataTableGetIntColumn(strFileName, "intSize");
	string[] strTemplates = dataTableGetStringColumn(strFileName, "strTemplate");
	string[] strLairTypes = dataTableGetStringColumn(strFileName, "strLairType");
	string[] strBuildingTypes = dataTableGetStringColumn(strFileName, "strBuildingType");
	int[] intMinDifficulties = dataTableGetIntColumn(strFileName, "intMinDifficulty");
	int[] intMaxDifficulties = dataTableGetIntColumn(strFileName, "intMaxDifficulty");

	if(strTemplates == null)
	{
		////LOG("missions", "RECON SPAWN LIST FOR FILE "+strIdFileName+" is null");
		return null;
	}

	////LOG("recon", "intsizes length is "+intSizes);
	////LOG("recon", "strTemplates length is "+strTemplates.length);
	////LOG("recon", "strLairTypes length is "+strLairTypes.length);
	////LOG("recon", "strBuildingTypes length is "+strBuildingTypes.length);

	dctReturn.put("intSizes", intSizes);
	dctReturn.put("strTemplates", strTemplates);
	dctReturn.put("strLairTypes", strLairTypes);
	dctReturn.put("strBuildingTypes", strBuildingTypes);
	dctReturn.put("intMinDifficulties", intMinDifficulties);
	dctReturn.put("intMaxDifficulties", intMaxDifficulties);

	return dctReturn;
}

void sendReconFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "reconFail", dctParams, 0, true);
}

// wrapper messageto function if the mission succeeded. You pass it the id of the recon target
void sendReconSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "reconSuccess", dctParams, 0, true);
}

// wrapper messageto function if the mission becomes incompletable. You pass it the id of the recon target
void sendReconIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	messageTo(objMission, "reconIncomplete", dctParams, 0, true);
}

void setupArrivedAtLocation(obj_id objTarget, obj_id objMission, location locTargetLocation, float fltDistance)
{
	dictionary dctParams = new dictionary();

	dctParams.put("locTargetLocation", locTargetLocation);
	dctParams.put("objMission", objMission);
	dctParams.put("fltDistance", fltDistance);
	messageTo(objTarget, "setupArrivedAtLocation", dctParams, 0, true);

	return;
}

boolean createReconTarget(obj_id objMission, obj_id objPlayer)
{
	obj_id objMissionData = getMissionData(objMission);
	string strTemplate = getStringObjVar(objMissionData, "strGoal");
	string strLairType = getStringObjVar(objMissionData, "strLairType");
	string strBuildingType = getStringObjVar(objMissionData, "strBuildingType");
	int intMinDifficulty = getIntObjVar(objMissionData, "intMinDifficulty");
	int intMaxDifficulty = getIntObjVar(objMissionData, "intMaxDifficulty");
	int intPlayerDifficulty = getIntObjVar(objMissionData, "intPlayerDifficulty");
	int intSize = getIntObjVar(objMissionData, "intSize");
	location locGoodLocation = getGoodMissionLocation(objMission, objPlayer);

	if(locGoodLocation == null)
	{
		return false;
	}

	if(strTemplate == null || strTemplate.equals(""))
		return false;

	obj_id objReconTarget = createObject(strTemplate, locGoodLocation);

	if(!isIdValid(objReconTarget))
	{
		////LOG("mission_general", "CREATERECONMADE A NULL OBJECT, goal was "+strTemplate);
		return false;
	}

	if(strLairType != "")
	{
		setObjVar(objReconTarget, "spawning.lairType", strLairType);
		string strLairDifficulty = create.getLairDifficulty(intMinDifficulty, intMaxDifficulty, intPlayerDifficulty);

		setObjVar(objReconTarget, "spawning.lairDifficulty", strLairDifficulty);
		setObjVar(objReconTarget, "spawning.intDifficultyLevel", intPlayerDifficulty);

		if(strBuildingType != "")
		{
			setObjVar(objReconTarget, "spawning.buildingType", strBuildingType);
		}
	}

	sendSystemMessage(objPlayer, SID_MISSION_TARGET_UPDATED_EXACT);

	updateMissionWaypoint(objMission, locGoodLocation);
	setObjVar(objReconTarget, "objMission", objMission);
	persistAndRegisterObject(objReconTarget, objMission);
	dictionary dctParams = new dictionary();

	messageTo(objReconTarget, "handle_Spawn_Setup_Complete", dctParams, 0, true);	//w'ere done with teh object setup
	setObjVar(objMission, "intTargetCreated", 1);

	setupArrivedAtLocation(objPlayer, objMission, locGoodLocation, 32);	// GO CLOSER!

	return true;
}

obj_id createEscortToCreatorMission(obj_id objMissionData, obj_id objCreator, location locMissionStart, int intDifficulty, string strPlanet, string strFaction)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_escort");
	setMissionType(objMissionData, "escorttocreator");
	// 2 types
	// easy
	// medium
	// hard
	// easy is same region, small reward, no attackers
	// medium is 2 regions, sometimes attackers, not a lot
	// hard is 2 regions, lots of attackers,

	setObjVar(objMissionData, "intReturnToCreator", 1);

	location locPickupLocation = new location();
	location locDropoffLocation = new location();
	int intVariance;

	//string strPickupFileName = "datatables/missions/"+strPickupPlanet+"/"+strPickupPlanet+"_npc.iff";
	//string strDropoffFileName = "datatables/missions/"+strDropoffPlanet+"/"+strDropoffPlanet+"_npc.iff";

	//string[] strPickupTypes = dataTableGetStringColumn(strPickupFileName, "strPickupNPC");
	//string[] strDropoffTypes = dataTableGetStringColumn(strDropoffFileName, "strDropoffNPC");
	//string[] strDeliverItems = dataTableGetStringColumn(strPickupFileName, "strItem");

	string strPickupNPC = NPC_TYPES[rand(0, NPC_TYPES.length - 1)];

	location locStartLocation = new location();
	location locEndLocation = new location();

	setObjVar(objMissionData, "strPickupNPC", strPickupNPC);

	// we need a pickup location

	// we'll use :

	// random point outside of the city for easy
	// closest city for medium
	// random city for hard
	// we've already got our fixed return location.. so we're good

	region[] rgnCities = getRegionsWithMunicipalAtPoint(locMissionStart, regions.MUNI_TRUE);

	if(rgnCities == null)
	{
		rgnCities = getRegionsAtPoint(locStartLocation);	// not really cities

		if(rgnCities == null)
		{
			return null;	// no regions on this goddamned forsaken planet!
		}
		////LOG("mission", "No cities found at "+locMissionStart+" returing null");
	}

	location locCreatorLocation = getMissionLocation(objCreator);

	locEndLocation = locCreatorLocation;

	if(intDifficulty < ESCORT_DIFFICULTY_EASY)
	{
		region rgnEndRegion = rgnCities[0];

		if(locations.isCityRegion(rgnEndRegion))
		{
			locStartLocation = locations.getGoodLocationOutsideOfRegion(rgnEndRegion, 1, 1, 200, false, true);
		}
		else
		{
			// we get a random point in a ring
			locStartLocation = utils.getRandomLocationInRing(locCreatorLocation, 128, 200);
			locStartLocation = locations.getGoodLocationAroundLocation(locStartLocation, 1, 1, 150, 150, false, true);

			if(locStartLocation == null)
			{
				return null;	// bad object
			}

			rgnCities = getRegionsWithMunicipalAtPoint(locEndLocation, regions.MUNI_TRUE);

			if(rgnCities != null)
			{
				locStartLocation = locations.getGoodCityLocation(rgnCities[0], strPlanet);
			}
		}
		// easy, point outside of city to creator
	}
	else if(intDifficulty < ESCORT_DIFFICULTY_MEDIUM)
	{
		// medium mission, closest city to creator
		region rgnCity = locations.getClosestCityRegion(rgnCities[0]);
		locStartLocation = locations.getGoodCityLocation(rgnCity, strPlanet);

		if(locStartLocation == null)
		{
			return null;
		}
	}
	else
	{
		// hard mission, random City region to creator location
		region rgnCity = locations.getCityRegion(rgnCities[0]);
		locStartLocation = locations.getGoodCityLocation(rgnCity, strPlanet);

		if(locStartLocation == null)
		{
			return null;
		}
	}

	setObjVar(objMissionData, "intMissionDifficulty", intDifficulty);

	////LOG("mission_spam", "setting difficulty, locStartLocation, and modifiers");
	setMissionDifficulty(objMissionData, intDifficulty);
	setMissionStartLocation(objMissionData, locStartLocation);
	setMissionEndLocation(objMissionData, locEndLocation);
	setMissionType(objMissionData, "escorttocreator");

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}

	int intReward = getDeliverReward(locStartLocation, locEndLocation, DELIVER_REWARD_RATIO, 2);

	if(intReward < 25)
	{
		intReward = 25;
	}

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	////LOG("mission_spam", "Transferred Money");
	setupContextualizationStrings(objMissionData, intDifficulty, objCreator, strFaction);

	return objMissionData;
}

obj_id createEscortTargetMission(obj_id objMissionData, obj_id objCreator, location locMissionStart, int intDifficulty, string strPlanet, string strFaction)
{
	// 2 types
	// easy
	// medium
	// hard
	// easy is same region, small reward, no attackers
	// medium is 2 regions, sometimes attackers, not a lot
	// hard is 2 regions, lots of attackers,

	setMissionType(objMissionData, "escort");

	setObjVar(objMissionData, "intTargetPickedUp", 1);

	location locDropoffLocation = new location();
	int intVariance;
	string strPickupNPC = NPC_TYPES[rand(0, NPC_TYPES.length - 1)];
	location locStartLocation = new location();
	location locEndLocation = new location();

	// we need a pickup location

	// we'll use :

	// random point outside of the city for easy
	// closest city for medium
	// random city for hard
	// we've already got our fixed return location.. so we're good

	region[] rgnCities = getRegionsWithMunicipalAtPoint(locMissionStart, regions.MUNI_TRUE);

	if(rgnCities == null)
	{
		rgnCities = getRegionsAtPoint(locStartLocation);	// not really cities

		if(rgnCities == null)
		{
			return null;	// no regions on this goddamned forsaken planet!
		}

		////LOG("mission", "No cities found at "+locMissionStart+" returing null");
	}

	location locCreatorLocation = getMissionLocation(objCreator);

	locEndLocation = locCreatorLocation;

	if(intDifficulty < ESCORT_DIFFICULTY_EASY)
	{
		region rgnEndRegion = rgnCities[0];

		if(locations.isCityRegion(rgnEndRegion))
		{
			locStartLocation = locations.getGoodLocationOutsideOfRegion(rgnEndRegion, 1, 1, 200, false, true);
		}
		else
		{
			// we get a random point in a ring
			locStartLocation = utils.getRandomLocationInRing(locCreatorLocation, 128, 200);
			locStartLocation = locations.getGoodLocationAroundLocation(locStartLocation, 1, 1, 150, 150, false, true);

			if(locStartLocation == null)
			{
				return null;	// bad object
			}

			rgnCities = getRegionsWithMunicipalAtPoint(locEndLocation, regions.MUNI_TRUE);

			if(rgnCities != null)
			{
				locStartLocation = locations.getGoodCityLocation(rgnCities[0], strPlanet);
			}
		}
		// easy, point outside of city to creator
	}
	else if(intDifficulty < ESCORT_DIFFICULTY_MEDIUM)
	{
		// medium mission, closest city to creator
		region rgnCity = locations.getClosestCityRegion(rgnCities[0]);

		locStartLocation = locations.getGoodCityLocation(rgnCity, strPlanet);
		if(locStartLocation == null)
		{
			return null;
		}
	}
	else
	{
		// hard mission, random City region to creator location
		region rgnCity = locations.getCityRegion(rgnCities[0]);
		locStartLocation = locations.getGoodCityLocation(rgnCity, strPlanet);

		if(locStartLocation == null)
		{
			return null;
		}
	}

	setObjVar(objMissionData, "intMissionDifficulty", intDifficulty);

	////LOG("mission_spam", "setting difficulty");

	setMissionEndLocation(objMissionData, locStartLocation);	// we alreayd have a start location, now we need an end
	////LOG("mission_spam", "Set mission Start Location");

	////LOG("mission_spam", "Got planetary modifiers");
	setMissionType(objMissionData, "escort");

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}

	int intReward = getDeliverReward(locStartLocation, locEndLocation, DELIVER_REWARD_RATIO, 2);

	if(intReward < 25)
	{
		intReward = 25;
	}

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	////LOG("mission_spam", "Transferred Money");
	setupContextualizationStrings(objMissionData, intDifficulty, objCreator, strFaction);

	return objMissionData;
}

int getDeliverReward(location locStartLocation, location locEndLocation, float fltDistanceModifier, float fltRewardModifier)
{
	float fltReward = 0;
	float fltDistance = 0;
	string strStartPlanet = locStartLocation.area;
	string strEndPlanet = locEndLocation.area;

	if(strStartPlanet == strEndPlanet)
	{
		fltDistance = utils.getDistance(locStartLocation, locEndLocation);
		fltReward = fltDistance / fltDistanceModifier;
		////LOG("missions", "fltDistance is "+fltDistance);
		////LOG("missions", "fltDistanceModifier is "+fltDistanceModifier);
	}
	else
	{
		fltDistance = 1;
		fltReward = 1000;
	}

	fltReward = fltReward * fltRewardModifier;
	fltReward = fltReward / 2;

	if(fltReward > 1500)
	{
		fltReward = 650 + rand(-200, 150);
	}

	if(fltReward < 25)
	{
		fltReward = fltReward + rand(25, 50);
	}

	int intReward = 20 + (int)(fltReward);

	intReward = intReward + rand(-10, 10);

	return intReward;
}

int getDestroyReward(int intMinReward, int intMaxReward, float fltDistance)
{
	const int minRangeReward = 500;
	const int maxRangeReward = 1500;

	if(fltDistance < minRangeReward)
		fltDistance = minRangeReward;

	if(fltDistance > maxRangeReward)
		fltDistance = maxRangeReward;

	float fltRewardPercentage = (fltDistance - minRangeReward) / (float) (maxRangeReward - minRangeReward);

	int intRewardDifference = intMaxReward - intMinReward;
	int intReward = intMinReward + (int) (intRewardDifference * fltRewardPercentage);

	return intReward;
}

void persistAndRegisterObject(obj_id objObject, obj_id objMission)
{
	persistObject(objObject);
	dictionary dctParams = new dictionary();

	dctParams.put("objObject", objObject);
	messageTo(objMission, "objectCreated", dctParams, 0, true);
	return;
}

void cleanupObjects(obj_id objMission)
{
	obj_id[] objObjects = getObjIdArrayObjVar(objMission, "objObjects");

	int intI = 0;

	if(objObjects != null)
	{
		while(intI < objObjects.length)
		{
			messageTo(objObjects[intI], "destroySelf", null, rand(30, 120), true);
			intI = intI + 1;
		}
	}

	return;
}

location getGoodTheaterLocation(obj_id objMissionData, location locSpawnLocation)
{
	int intSize = getIntObjVar(objMissionData, "intSize");
	location locGoodLocation = locations.getGoodLocationAroundLocation(locSpawnLocation, intSize, intSize, 200, 200, false, true);

	if(locGoodLocation == null)
	{
		////LOG("mission", "getGoodLocation failed in createdestructiontarget");
		return null;
	}

	obj_id[] objTheaters = getAllObjectsWithObjVar(locGoodLocation, 80, "theater.stamp");	// look for parent objects

	if(objTheaters != null)
	{
		if(objTheaters.length > 0)
		{
			locSpawnLocation.x = locSpawnLocation.x + rand(-200, 200);
			locSpawnLocation.z = locSpawnLocation.z + rand(-200, 200);
			locGoodLocation = locations.getGoodLocationAroundLocation(locSpawnLocation, intSize, intSize, 200, 200, false, true);
			objTheaters = getAllObjectsWithObjVar(locGoodLocation, 80, "theater.stamp");	// look for parent objects
			if(locGoodLocation != null)
			{
				if(objTheaters != null)
				{
					if(objTheaters.length > 0)
					{
						return null;
					}
				}
				else
				{
					return locGoodLocation;
				}

			}
			else
			{
				return null;
			}
		}
	}

	return locGoodLocation;
}

// resource mission stuff.. phear
obj_id createSurveyMission(obj_id objMissionData, obj_id objCreator, int intDifficulty, string strFaction)
{
	const int MIN_SURVEY_EFFECIENCY = 50;
	const int MAX_SURVEY_EFFECIENCY = 70;
	const int MIN_SURVEY_REWARD = 150;
	const int SURVEY_BONUS_PER_POINT = 15;

	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_survey");
	setMissionType(objMissionData, "survey");
	int intEffeciency = rand(MIN_SURVEY_EFFECIENCY, MAX_SURVEY_EFFECIENCY);
	int intDifference = intEffeciency - MIN_SURVEY_EFFECIENCY;

	intDifference = intDifference * SURVEY_BONUS_PER_POINT;
	int intReward = MIN_SURVEY_REWARD + intDifference;

	intReward = intReward * 2;

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}

	// 60-80 for efficiency
	string[] strResources = new string[0];
	string[] strDetailTemplates = new string[0];
	string strFileName = "datatables/missions/survey/survey.iff";
	int intRewardMultiplier = 0;

	if(intDifficulty < 10)
	{
		// EASY DIFFICULTY
		intRewardMultiplier = 1;
		strResources = dataTableGetStringColumnNoDefaults(strFileName, "strResourceEasy");
		strDetailTemplates = dataTableGetStringColumnNoDefaults(strFileName, "strDetailTemplateEasy");
	}
	else
	{
		intRewardMultiplier = 2;
		strResources = dataTableGetStringColumnNoDefaults(strFileName, "strResourceHard");
		strDetailTemplates = dataTableGetStringColumnNoDefaults(strFileName, "strDetailTemplateHard");
	}

	intReward = intReward * intRewardMultiplier;

	int intRandomNumber = rand(0, strResources.length - 1);
	string strDetailTemplate = strDetailTemplates[intRandomNumber];
	string strResource = strResources[intRandomNumber];
	location locTest = new location();

	string_id strTokenName = new string_id(SID_SURVEY_RESOURCE_NAMES_TABLE, strResource);

	setMissionTargetAppearance(objMissionData, strDetailTemplate);
	setMissionTargetName(objMissionData, utils.packStringId(strTokenName));

	setMissionDifficulty(objMissionData, intEffeciency);

	setObjVar(objMissionData, OBJVAR_SURVEY_MISSION_EFFECIENCY, intEffeciency);
	setObjVar(objMissionData, OBJVAR_SURVEY_MISSION_RESOURCE, strResource);	// FOOM

	if(strFaction != "")
	{
		int intFactionReward = getFactionReward(intReward);

		setObjVar(objMissionData, "intFactionReward", intFactionReward);
		setObjVar(objMissionData, "strFaction", strFaction);
	}

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	setupContextualizationStrings(objMissionData, 1, objCreator, strFaction);
	setObjVar(objMissionData, "locStartLocation", getLocation(objCreator));

	return objMissionData;
}

// fail wrapper function
void sendSurveyFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "surveyFailure", dctParams, 0, true);	// spawner timer has started
}

// success wrapper function
void sendSurveySuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "surveySuccess", dctParams, 0, true);	// spawner timer has started
}

// incomplete wrapper function
void sendSurveyIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "surveyIncomplete", dctParams, 0, true);	// spawner timer has started
}

// resource mission stuff.. phear
obj_id createDancerMission(obj_id objMissionData, obj_id objCreator, int intDifficulty, string strFaction)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_entertainer");
	setMissionType(objMissionData, "dancer");

	string strDetailTemplate = "object/tangible/instrument/organ_max_rebo.iff";

	location locTest = new location();

	string_id strTokenName = new string_id("mission/mission_generic", "dancer");

	////LOG("names", "strTokenname is "+strTokenName);

	setMissionTargetAppearance(objMissionData, strDetailTemplate);
	setMissionTargetName(objMissionData, utils.packStringId(strTokenName));

	string strPlanet = locTest.area;

	if(!setupEntertainerMissionTarget(objMissionData, strPlanet))
	{
		////LOG("DESIGNER_FATAL", "unable to setup entertainer mission for dancers");

		return null;
	}

	int intTime = 600;

	// reward will scale based on time with a little variance tossed in to break the predictability
	int intReward = (intTime * 2) + rand(-100, 100);

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}

	setObjVar(objMissionData, "intTime", intTime);

	if(strFaction != "")
	{
		int intFactionReward = getFactionReward(intReward);

		setObjVar(objMissionData, "intFactionReward", intFactionReward);
		setObjVar(objMissionData, "strFaction", strFaction);
	}

	// where ya gotta go!
	// Cantina
	// Hotel

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	////LOG("mission_spam", "Transferred Money");
	setupContextualizationStrings(objMissionData, 1, objCreator, strFaction);
	return objMissionData;
}

obj_id createMusicianMission(obj_id objMissionData, obj_id objCreator, int intDifficulty, string strFaction)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_entertainer");
	setMissionType(objMissionData, "musician");

	string strDetailTemplate = "object/tangible/instrument/organ_max_rebo.iff";

	location locTest = new location();

	string_id strTokenName = new string_id("mission/mission_generic", "dancer");

	////LOG("names", "strTokenname is "+strTokenName);

	setMissionTargetAppearance(objMissionData, strDetailTemplate);
	setMissionTargetName(objMissionData, utils.packStringId(strTokenName));

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}

	int intTime = 600;

	// reward will scale based on time with a little variance tossed in to break the predictability
	int intReward = (intTime * 2) + rand(-100, 100);

	setObjVar(objMissionData, "intTime", intTime);

	locTest = getMissionLocation(objCreator);

	string strPlanet = locTest.area;

	if(!setupEntertainerMissionTarget(objMissionData, strPlanet))
	{
		////LOG("DESIGNER_FATAL", "unable to setup entertainer mission for musicians");

		return null;
	}

	if(strFaction != "")
	{
		int intFactionReward = getFactionReward(intReward);

		setObjVar(objMissionData, "intFactionReward", intFactionReward);
		setObjVar(objMissionData, "strFaction", strFaction);
	}

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	////LOG("mission_spam", "Transferred Money");
	setupContextualizationStrings(objMissionData, 1, objCreator, strFaction);
	return objMissionData;
}

boolean setupEntertainerMissionTarget(obj_id objMissionData, string strPlanet)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_entertainer");
	const string[] ENTERTAINER_TARGET_CATEGORY = { "cantina", "hotel", "tavern", "barracks", "theater" };
	//-- can no longer access planetary map data from other planets

	resizeable string[] strCategories = new string[0];

	for(int intI = 0; intI < ENTERTAINER_TARGET_CATEGORY.length - 1; intI++)
	{
		map_location[] locTargets = getPlanetaryMapLocations(ENTERTAINER_TARGET_CATEGORY[intI], "");

		if(locTargets != null && locTargets.length > 0)
		{
			strCategories = utils.addElement(strCategories, ENTERTAINER_TARGET_CATEGORY[intI]);
		}
	}

	if(strCategories.length == 0)
	{
		////LOG("DESIGNER_FATAL", "no map_locations for planet "+strPlanet);
		return true;	// BAD DATA, BUT IT KEEPS THE GAME FROM BREAKING
	}

	string strCategory = strCategories[rand(0, strCategories.length - 1)];

	map_location[] locTargets = getPlanetaryMapLocations(strCategory, "");

	if(locTargets == null)
	{
		////LOG("DESIGNER_FATAL", "No planetary map locations for category "+strCategory+" and planet "+strPlanet);
		return false;
	}

	if(locTargets.length == 0)
	{
		////LOG("DESIGNER_FATAL", "No planetary map locations for category "+strCategory+" and planet "+strPlanet);
		return false;
	}

	location locDestination = new location();

	locDestination.area = strPlanet;
	int intRoll = rand(0, locTargets.length - 1);

	////LOG("missions", "x is "+locTargets[intRoll].getX());
	////LOG("missions", "y is "+locTargets[intRoll].getY());
	////LOG("missions", "obj_id iis "+locTargets[intRoll].getLocationId());
	locDestination.x = locTargets[intRoll].getX();
	locDestination.z = locTargets[intRoll].getY();
	obj_id objTarget = locTargets[intRoll].getLocationId();

	setObjVar(objMissionData, "objBuilding", objTarget);
	setMissionStartLocation(objMissionData, locDestination);
	// we;re setup!
	return true;
}

// fail wrapper function
void sendEntertainerFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "entertainerFailure", dctParams, 0, true);	// spawner timer has started
}

// success wrapper function
void sendEntertainerSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "entertainerSuccess", dctParams, 0, true);	// spawner timer has started
}

// incomplete wrapper function
void sendEntertainerIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "entertainerIncomplete", dctParams, 0, true);	// spawner timer has started
}

obj_id createCraftingMission(obj_id objMissionData, obj_id objCreator, location locMissionStart, int intDifficulty, string strFaction)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_crafting");
	setMissionType(objMissionData, "crafting");

	string strPlanet = locMissionStart.area;
	location locPickupLocation = new location();
	location locDropoffLocation = new location();
	int intVariance;

	string strFileName = "datatables/missions/crafting/crafting.iff";
	string[] strSchematics = dataTableGetStringColumn(strFileName, "strSchematic");
	int intRoll = rand(0, strSchematics.length - 1);
	dictionary dctCraftingStats = dataTableGetRow(strFileName, intRoll);

	int intI = 0;
	string strSchematic = dctCraftingStats.getString("strSchematic");
	string strDetailTemplate = dctCraftingStats.getString("strDetailTemplate");
	resizeable string[] strComponents = new string[0];

	while(intI < 4)		// we get our components
	{
		string strLookupName = "strComponent" + (intI + 1);
		string strComponent = dctCraftingStats.getString(strLookupName);

		if(strComponent != "")
		{
			strComponents = utils.addElement(strComponents, strComponent);
		}

		intI = intI + 1;
	}

	string strAscii = dctCraftingStats.getString("strName");
	string_id strItemName = new string_id("item_n", strAscii);

	setMissionTargetName(objMissionData, utils.packStringId(strItemName));
	setObjVar(objMissionData, "strSchematic", strSchematic);
	setObjVar(objMissionData, "strComponents", strComponents);
	setObjVar(objMissionData, "strItemToMake", strDetailTemplate);
	string strPickupNPC = NPC_TYPES[rand(0, NPC_TYPES.length - 1)];
	string strDropoffNPC = NPC_TYPES[rand(0, NPC_TYPES.length - 1)];

	location locStartLocation = new location();
	location locEndLocation = new location();

	setObjVar(objMissionData, "strPickupNPC", strPickupNPC);
	setObjVar(objMissionData, "strDropoffNPC", strDropoffNPC);

	region[] rgnCities = getRegionsWithMunicipalAtPoint(locMissionStart, regions.MUNI_TRUE);

	if(rgnCities == null)
	{
		rgnCities = getRegionsAtPoint(locStartLocation);	// not really cities
		if(rgnCities == null)
		{
			return null;	// no regions on this goddamned forsaken planet!
		}
		////LOG("mission", "No cities found at "+locMissionStart+" returing null");
	}

	region rgnStartRegion = rgnCities[0];
	boolean boolIsCity = false;

	if(locations.isCityRegion(rgnStartRegion))
	{
		locStartLocation = locations.getGoodCityRegionLocation(rgnStartRegion, strPlanet);
		boolIsCity = true;
	}
	else
	{
		region closestCity = locations.getClosestCityRegion(rgnStartRegion);
		locStartLocation = locations.getGoodCityRegionLocation(closestCity, strPlanet);
		boolIsCity = true;
	}

	if(locStartLocation == null)
	{
		return null;
	}

	int intMissionDifficulty;

	if(intDifficulty < MISSION_DELIVER_DIFFICULTY_EASY)
	{
		if(boolIsCity)
		{
			intRoll = rand(1, 100);

			if(intRoll < 40)
			{
				locEndLocation = locations.getDifferentGoodCityLocation(locStartLocation);
			}
			else
			{
				region rgnEndRegion = locations.getClosestCityRegion(rgnStartRegion);
				string strName = rgnEndRegion.getName();

				locEndLocation = locations.getGoodCityLocation(rgnEndRegion, strPlanet);
			}
		}
		else
		{
			region rgnEndRegion = locations.getClosestCityRegion(rgnStartRegion);
			string strName = rgnEndRegion.getName();

			locEndLocation = locations.getGoodCityRegionLocation(rgnEndRegion, strPlanet);
		}

		intMissionDifficulty = MISSION_DIFFICULTY_EASY;
		setObjVar(objMissionData, "intMissionDifficulty", intMissionDifficulty);
	}
	else			//if(intDifficulty<MISSION_DELIVER_DIFFICULTY_MEDIUM)
	{
		region rgnEndRegion = locations.getCityRegion(rgnStartRegion);	// could be any region that's not the start region

		if(rgnEndRegion == null)
		{
			return null;
		}

		locEndLocation = locations.getGoodCityRegionLocation(rgnEndRegion, strPlanet);
		intMissionDifficulty = MISSION_DIFFICULTY_EASY;	// HACK TO GET THIS WORKING WITH CURRENT CONTEXTUALIZAITON
		setObjVar(objMissionData, "intMissionDifficulty", intMissionDifficulty);
	}

	if(locEndLocation == null)
	{
		return null;
	}

	setMissionDifficulty(objMissionData, getIntObjVar(objMissionData, "intMissionDifficulty"));
	setMissionTargetAppearance(objMissionData, strDetailTemplate);
	setMissionStartLocation(objMissionData, locStartLocation);
	setMissionEndLocation(objMissionData, locEndLocation);

	int intReward = getDeliverReward(locStartLocation, locEndLocation, CRAFTING_REWARD_RATIO, 3);

	if(intReward < 5)
	{
		intReward = 5;
	}

	if(strFaction != "")
	{
		int intFactionReward = getFactionReward(intReward);

		setObjVar(objMissionData, "intFactionReward", intFactionReward);
		setObjVar(objMissionData, "strFaction", strFaction);
	}

	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	setupContextualizationStrings(objMissionData, intMissionDifficulty, objCreator, strFaction);

	return objMissionData;
}

void sendCraftingFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "craftingFailure", dctParams, 0, true);	// spawner timer has started
}

// success wrapper function
void sendCraftingSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "craftingSuccess", dctParams, 0, true);	// spawner timer has started
}

// incomplete wrapper function
void sendCraftingIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "craftingIncomplete", dctParams, 0, true);	// spawner timer has started
}

boolean createCraftingPickupNPC(obj_id objMission)
{
	obj_id objPlayer = getMissionHolder(objMission);
	obj_id objMissionData = getMissionData(objMission);
	string strPickupNPC = getStringObjVar(objMissionData, "strPickupNPC");

	// since this is the start npc, use start location
	location locSpawnLocation = getMissionStartLocation(objMissionData);
	obj_id objPickupNPC = create.object(strPickupNPC, locSpawnLocation);

	if(!isIdValid(objPickupNPC))
	{
		return false;	// mission did not instantiate. Incomplete!
	}
	else
	{
		attachScript(objPickupNPC, "systems.missions.dynamic.mission_crafting_pickup");
		setObjVar(objPickupNPC, "objMission", objMission);
		setObjVar(objPickupNPC, "locSpawnLocation", locSpawnLocation);
		setObjVar(objPickupNPC, "objPlayer", objPlayer);
		persistAndRegisterObject(objPickupNPC, objMission);
		setWantSawAttackTriggers(objPickupNPC, false);
	}

	return true;
}

boolean createCraftingDropoffNPC(obj_id objMission)
{
	obj_id objMissionData = getMissionData(objMission);

	string strDropoffNPC = getStringObjVar(objMissionData, "strDropoffNPC");

	location locSpawnLocation = getMissionEndLocation(objMissionData);

	obj_id objDropoffNPC = create.object(strDropoffNPC, locSpawnLocation);
	obj_id objPlayer = getMissionHolder(objMission);

	if(!isIdValid(objDropoffNPC))
	{
		////LOG("mission", "dropoff npc failed to create. Type was "+strDropoffNPC);
		////LOG("DESIGNER_FATAL", "NPC of type "+strDropoffNPC+"created a null npc for mission");
		return false;	// bad instantiation, fail out
	}
	else
	{
		attachScript(objDropoffNPC, "systems.missions.dynamic.mission_crafting_dropoff");
		setObjVar(objDropoffNPC, "objMission", objMission);
		setObjVar(objDropoffNPC, "locSpawnLocation", locSpawnLocation);
		setObjVar(objDropoffNPC, "objPlayer", objPlayer);
		persistAndRegisterObject(objDropoffNPC, objMission);
		setWantSawAttackTriggers(objDropoffNPC, false);
	}

	return true;
}

void grantMissionSchematic(obj_id objPlayer, obj_id objMission)
{
	// we need to track how many missions need a given schematic, not a big deal now, but if we increae the number of msns
	// this will become an issue.. better to address it early.

	obj_id objMissionData = getMissionData(objMission);

	string strSchematic = getStringObjVar(objMissionData, "strSchematic");

	// grantblah
	grantSchematic(objPlayer, strSchematic);
	int intNumGranted = getIntObjVar(objPlayer, "mission." + strSchematic);

	intNumGranted = intNumGranted + 1;
	setObjVar(objPlayer, "mission." + strSchematic, intNumGranted);

	return;
}

void revokeMissionSchematic(obj_id objPlayer, obj_id objMission)
{
	if(!hasObjVar(objMission, "strSchematic"))
	{
		// already removed
		return;
	}

	obj_id objMissionData = getMissionData(objMission);
	string strSchematic = getStringObjVar(objMissionData, "strSchematic");
	int intNumGranted = getIntObjVar(objPlayer, "mission." + strSchematic);
	intNumGranted = intNumGranted - 1;

	if(intNumGranted < 1)
	{
		removeObjVar(objPlayer, "mission." + strSchematic);

		// revoke schematic here
		revokeSchematic(objPlayer, strSchematic);
		removeObjVar(objMission, "strSchematic");
	}
	else
	{
		setObjVar(objPlayer, "mission." + strSchematic, intNumGranted);
		return;
	}

	return;
}

void reContextualizationTerminalToNPCMission(obj_id objMissionData, obj_id objCreator)
{
	string strIdFileName = getStringObjVar(objMissionData, "strIdFileName");

	if(strIdFileName == null)
	{
		////LOG("DESIGNER_FATAL", "NULL Filename for creator "+objCreator+" and mission data "+objMissionData);
		if(isIdValid(objMissionData))
		{
			string strMissionType = getMissionType(objMissionData);

			////LOG("DESIGNER_FATAL", "Mission type is "+strMissionType);
		}
		else
		{
			////LOG("DESIGNER_FATAL", "NULL mission data");
		}

		return;
	}

	////LOG("missions", "strIdFileName is "+strIdFileName);
	// we need to check for "tatooine", "naboo" and "corellia"
	// if we find it, we nuke the string from intIndex-1, to the end of the string
	int intIndex = strIdFileName.indexOf("tatooine");

	if(intIndex > 0)
	{
		string strTest = strIdFileName.substring(0, intIndex - 1);

		strIdFileName = strTest;
	}

	intIndex = strIdFileName.indexOf("corellia");

	if(intIndex > 0)
	{
		string strTest = strIdFileName.substring(0, intIndex - 1);

		strIdFileName = strTest;
	}

	intIndex = strIdFileName.indexOf("naboo");

	if(intIndex > 0)
	{
		string strTest = strIdFileName.substring(0, intIndex - 1);

		strIdFileName = strTest;
	}

	strIdFileName = strIdFileName + "_non_persistent_from_npc";

	int intStringQuantity = 1;
	string_id strEntryId = new string_id(strIdFileName, "number_of_entries");
	string strNumberOfEntries = getString(strEntryId);

	if(strNumberOfEntries != null)
	{
		if(strNumberOfEntries == null)
		{
			intStringQuantity = 0;
		}
		else if(strNumberOfEntries != "")
		{
			Integer intTest = new Integer(0);
			boolean boolError = false;

			try
			{
				intTest = new Integer(strNumberOfEntries);
			}
			catch(NumberFormatException err)
			{
				boolError = true;
			}

			if(!boolError)
			{
				intStringQuantity = intTest.intValue();
				if(intStringQuantity < 0)
				{
					intStringQuantity = 1;
				}
			}
		}
	}

	int intId = rand(1, intStringQuantity);

	setObjVar(objMissionData, "intStringId", intId);
	setObjVar(objMissionData, "strIdFileName", strIdFileName);

	int intStringId = intId;

	////LOG("mission", "Filename is "+strIdFileName);
	string_id strTitleId = new string_id(strIdFileName, "m" + intStringId + "t");

	////LOG("mission", "Title id is "+strTitleId);

	string strDescription;

	strDescription = "m" + intStringId + "d";

	string_id strDescriptionId = new string_id(strIdFileName, strDescription);

	////LOG("mission", "Description id is "+strDescriptionId);

	location locTest = getMissionLocation(objCreator);

	setMissionCreator(objMissionData, getName(objCreator));
	setMissionTitle(objMissionData, strTitleId);

	setMissionDescription(objMissionData, strDescriptionId);

	////LOG("missions", "set mission desc to "+strDescriptionId);
	////LOG("mission_general","SETTING STRING_ID OBJVARS");
	//string_id strMissionContextStringId = new string_id(strIdFileName, strStringReference);
	//setObjVar(objMissionData, "strMissionContextStringId", strMissionContextStringId);
	////LOG("mission_general","SET STRING_ID OBJVARS");
	return;
}

obj_id dynamicDestroyToThemePark(obj_id objMissionData, obj_id objCreator)
{
	int intDifficulty = getIntObjVar(objMissionData, "intDifficulty");

	string strNPCType = getStringObjVar(objCreator, "mission.strNPCName");
	string strFileName = "mission/theme_park/mission_destroy_" + strNPCType;

	string_id strId = new string_id(strFileName, "number_of_entries");
	string strNumEntries = getString(strId);
	int intNumEntries = utils.stringToInt(strNumEntries);
	int intRoll = rand(1, intNumEntries);

	string strTag = "m" + intRoll + "reward";

	strId = new string_id(strFileName, strTag);
	string strString = getString(strId);
	int intReward = utils.stringToInt(strString);

	strTag = "m" + intRoll + "lairtype";
	strId = new string_id(strFileName, strTag);
	string strLairType = getString(strId);

	strTag = "m" + intRoll + "buildingtype";
	strId = new string_id(strFileName, strTag);
	string strBuildingType = getString(strId);

	strTag = "m" + intRoll + "objective";
	strId = new string_id(strFileName, strTag);
	string strObjective = getString(strId);

	strTag = "m" + intRoll + "objectivetarget";
	strId = new string_id(strFileName, strTag);
	string strObjectiveTarget = getString(strId);

//      strTag = "m"+intRoll+"targetType";
//      strId = new string_id(strFileName, strTag);
//      string strTargetType= getString(strId);

	strTag = "m" + intRoll + "killpercentage";
	strId = new string_id(strFileName, strTag);
	strString = getString(strId);
	float fltKillPercentage = utils.stringToFloat(strString);

	strTag = "m" + intRoll + "mindifficulty";
	strId = new string_id(strFileName, strTag);
	strString = getString(strId);
	int intMinDifficulty = utils.stringToInt(strString);

	strTag = "m" + intRoll + "maxdifficulty";
	strId = new string_id(strFileName, strTag);
	strString = getString(strId);
	int intMaxDifficulty = utils.stringToInt(strString);

	strTag = "m" + intRoll + "size";
	strId = new string_id(strFileName, strTag);
	strString = getString(strId);
	int intSize = utils.stringToInt(strString);

	strTag = "m" + intRoll + "detailtemplate";
	strId = new string_id(strFileName, strTag);
	string strDetailTemplate = getString(strId);

	setObjVar(objMissionData, "fltKillPercentage", fltKillPercentage);
	setObjVar(objMissionData, "strLairType", strLairType);
	setObjVar(objMissionData, "strBuildingType", strBuildingType);
	setObjVar(objMissionData, "strObjective", strObjective);
	setObjVar(objMissionData, "strObjectiveTarget", strObjectiveTarget);
	setObjVar(objMissionData, "intPlayerDifficulty", intDifficulty);	// ALL OF THIS IS DATA FOR THE CREATION FUNCS. wE JUST PASS IT ALONG
	setObjVar(objMissionData, "intMinDifficulty", intMinDifficulty);
	setObjVar(objMissionData, "intMaxDifficulty", intMaxDifficulty);

	string strLairDifficulty = create.getLairDifficulty(intMinDifficulty, intMaxDifficulty, intDifficulty);

	setObjVar(objMissionData, "strLairDifficulty", strLairDifficulty);
	setObjVar(objMissionData, "intSize", intSize);
	setObjVar(objMissionData, "strTemplateToSpawn", "");
	setObjVar(objMissionData, "intNumToSpawn", 0);

	setMissionTargetAppearance(objMissionData, strDetailTemplate);

	if(strLairType != "")
	{
		string_id strTokenName = new string_id("lair_n", strLairType);

		////LOG("names", "strTokenname is "+strTokenName);
		setMissionTargetName(objMissionData, utils.packStringId(strTokenName));
	}

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}
	else
	{
		setObjVar(objMissionData, "originalGroupSize", 1);
	}

	intReward = intReward + rand(-10, 10);
	setMissionReward(objMissionData, intReward);
	dictionary dctParams = new dictionary();

	convertDynamicContextualizationToThemePark(objMissionData, strFileName, intRoll);

	return objMissionData;
}

obj_id dynamicDeliverToThemePark(obj_id objMissionData, obj_id objCreator)
{
	string strNPCType = getStringObjVar(objCreator, "mission.strNPCName");
	string strFileName = "mission/theme_park/mission_deliver_" + strNPCType;

	string_id strId = new string_id(strFileName, "number_of_entries");
	string strNumEntries = getString(strId);
	int intNumEntries = utils.stringToInt(strNumEntries);
	int intRoll = rand(1, intNumEntries);

	string strTag = "m" + intRoll + "pickupNPC";

	strId = new string_id(strFileName, strTag);
	string strPickupNPC = getString(strId);

	strTag = "m" + intRoll + "dropoffNPC";
	strId = new string_id(strFileName, strTag);
	string strDropoffNPC = getString(strId);

	strTag = "m" + intRoll + "deliveryItem";
	strId = new string_id(strFileName, strTag);
	string strDeliveryItem = getString(strId);

	setObjVar(objMissionData, "strPickupNPC", strPickupNPC);
	setObjVar(objMissionData, "strDropoffNPC", strDropoffNPC);

	setMissionTargetAppearance(objMissionData, strDeliveryItem);
	convertDynamicContextualizationToThemePark(objMissionData, strFileName, intRoll);
	return objMissionData;
}

void convertDynamicContextualizationToThemePark(obj_id objMissionData, string strFileName, int intId)
{
	setObjVar(objMissionData, "intStringId", intId);
	setObjVar(objMissionData, "strIdFileName", strFileName);

	int intStringId = intId;

	string_id strTitleId = new string_id(strFileName, "m" + intStringId + "t");

	////LOG("mission", "Title id is "+strTitleId);
	string strDescription;

	strDescription = "m" + intStringId + "d";

	string_id strDescriptionId = new string_id(strFileName, strDescription);

	setMissionTitle(objMissionData, strTitleId);
	setMissionDescription(objMissionData, strDescriptionId);
	////LOG("missions", "set mission desc to "+strDescriptionId);
	return;
}

obj_id dynamicEscortToCreatorToThemePark(obj_id objMissionData, obj_id objCreator)
{
	string strNPCType = getStringObjVar(objCreator, "mission.strNPCName");
	string strFileName = "mission/theme_park/mission_escorttocreator" + strNPCType;

	string_id strId = new string_id(strFileName, "number_of_entries");
	string strNumEntries = getString(strId);
	int intNumEntries = utils.stringToInt(strNumEntries);
	int intRoll = rand(1, intNumEntries);

	string strTag = "m" + intRoll + "pickupNPC";

	strId = new string_id(strFileName, strTag);
	string strPickupNPC = getString(strId);

	setObjVar(objMissionData, "strPickupNPC", strPickupNPC);

	convertDynamicContextualizationToThemePark(objMissionData, strFileName, intRoll);

	return objMissionData;
}

location getMissionLocation(obj_id objTarget)
{
	obj_id objTopMostContainer = getTopMostContainer(objTarget);

	if(!isIdValid(objTopMostContainer))
	{
		location locTest = getLocation(objTarget);

		return locTest;
	}
	else
	{
		location locTest = getLocation(objTopMostContainer);

		return locTest;
	}
}

boolean areMissionsAllowed(location locTest)
{
	if(locTest == null || locTest.area == null)
	{
		return false;
	}

	const string[] MISSIONS_NOT_ALLOWED = { "tutorial" };
	int intI = 0;
	string strTest = locTest.area;

	for(intI = 0; intI < MISSIONS_NOT_ALLOWED.length; intI++)
	{
		if(strTest == MISSIONS_NOT_ALLOWED[intI])
		{
			return false;
		}
	}

	return true;
}

void doIncorrectPlayerBlurb(obj_id objNPC)
{
	int lastBlurb = utils.getIntScriptVar(objNPC, "mission.blurbTime");

	int gameTime = getGameTime();
	
	if(gameTime - lastBlurb < 6)
	{
		return;
	}

	utils.setScriptVar(objNPC, "mission.blurbTime", gameTime);	

	const int NUMBER_OF_RESPONSES = 4;
	const string[] ANIMATIONS = { anims.PLAYER_POINT_TO_SELF, anims.PLAYER_REFUSE_OFFER_FORMAL, anims.PLAYER_RUB_CHIN_THOUGHTFUL, anims.PLAYER_SHAKE_HEAD_DISGUST, anims.PLAYER_SHUSH };
	string strId = "deliver_incorrect_player_";

	int intId = rand(0, NUMBER_OF_RESPONSES);

	doAnimationAction(objNPC, ANIMATIONS[intId]);
	strId = strId + intId;
	string_id strSpam = new string_id("mission/mission_generic", strId);

	chat.chat(objNPC, strSpam);

	return;
}

boolean validateNPCMissionForPlayer(obj_id objNPC, obj_id objMissionData, obj_id objPlayer)
{
	// is it null?
	// is it factional, if so, is it military, if so are you on the right side?
	// is it gig, if so do you have any aentertainer skills
	// is it out of your difficulty range?
	if(!isIdValid(objMissionData))
	{
		return false;
	}

	if(hasObjVar(objMissionData, "boolDeclaredOnly"))
	{
		if(!factions.isCovert(objPlayer))
		{
			return false;	// NO MISSION FOR YOU! GO DELCARE
		}

		string strPlayerFaction = factions.getFaction(objPlayer);
		string strMissionFaction = getStringObjVar(objMissionData, "strFaction");

		if(strPlayerFaction != strMissionFaction)
		{
			return false;
		}
	}

	string strMissionType = getMissionType(objMissionData);

	if(strMissionType == "musician")
	{
		if(!utils.isProfession(objPlayer, utils.ENTERTAINER))
		{
			return false;
		}
	}

	if(strMissionType == "dancer")
	{
		if(!utils.isProfession(objPlayer, utils.ENTERTAINER))
		{
			return false;
		}
	}

	return true;
}

boolean hasStarPort(location locTestLocation)
{
	string strName = locations.getCityName(locTestLocation);

	if(strName == null)
	{
		return false;
	}

	for(int intI = 0; intI < CITIES_WITH_STARPORTS.length; intI++)
	{
		if(strName == CITIES_WITH_STARPORTS[intI])
		{
			return true;
		}
	}

	return false;
}

int getFactionReward(int intReward)
{
	int intBaseReward = 5 + intReward / FACTION_REWARD_VALUE;

	return intBaseReward;
}

obj_id getBountyMission(obj_id objPlayer)
{
	if(isIdValid(objPlayer))
	{
		obj_id[] objMissionArray = getMissionObjects(objPlayer);

		if(objMissionArray != null)
		{
			for(int intI = 0; intI < objMissionArray.length; intI++)
			{
				string strType = getMissionType(objMissionArray[intI]);

				if(strType == "bounty")
				{
					return objMissionArray[intI];
				}
			}
		}
	}

	return null;
}

boolean hasCraftingMissionItem(obj_id objPlayer, string strTemplate)
{
	obj_id objInventory = utils.getInventoryContainer(objPlayer);

	if(!isIdValid(objInventory))
	{
		return false;
	}

	obj_id[] objContents = getContents(objInventory);

	if(objContents == null)
	{
		return false;
	}

	for(int intI = 0; intI < objContents.length; intI++)
	{
		string strItemTemplate = getTemplateName(objContents[intI]);

		if(strItemTemplate == strTemplate)
		{
			destroyObject(objContents[intI]);
			return true;
		}
	}

	return false;
}

// fail wrapper function
void sendHuntingFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "huntingFailure", dctParams, 0, true);	// spawner timer has started
}

// success wrapper function
void sendHuntingSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "huntingSuccess", dctParams, 0, true);	// spawner timer has started
}

// incomplete wrapper function
void sendHuntingIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "huntingIncomplete", dctParams, 0, true);	// spawner timer has started
}

obj_id createHuntingMission(obj_id objMissionData, obj_id objCreator, int intDifficulty, string strFaction)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_hunting");
	setMissionType(objMissionData, "hunting");

	int intMissionDifficulty = rand(1, 3);
	const int[] HUNTING_QUANTITIES = { 15, 30, 45 };
	const int[] REWARD_MULTIPLIER = { 4, 6, 8 };

	// for the time being we'll ignore the faction.
	location locStartLocation = getLocation(objCreator);

	string strFileName = "datatables/missions/hunting/hunting_";

	strFileName = strFileName + locStartLocation.area + ".iff";

	string[] strCreatureTypes = dataTableGetStringColumn(strFileName, "strCreatureType");
	string[] strDetailTemplates = dataTableGetStringColumn(strFileName, "strDetailTemplate");
	int[] intMinDifficulties = dataTableGetIntColumn(strFileName, "intMinDifficulty");
	int[] intMaxDifficulties = dataTableGetIntColumn(strFileName, "intMaxDifficulty");
	int[] intRewardsPerKill = dataTableGetIntColumn(strFileName, "intRewardPerKill");

	int intLength = strCreatureTypes.length;
	int intArrayIndex = 0;

	string[] strCreatureType = new string[intLength];
	string[] strDetailTemplate = new string[intLength];
	int[] intRewardPerKill = new int[intLength];

	obj_id groupObject = getGroupObject(objCreator);
	
	int maximumDifficultyInColumn = 0;

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}

	for(int intI = 0; intI < strCreatureTypes.length; intI++)
	{
		LOG("missions", "intDifficulty is " + intDifficulty);
		LOG("missions", "intMinDifficulties[intI] is " + intMinDifficulties[intI]);
		LOG("missions", "intMaxDifficulties[intI] is " + intMaxDifficulties[intI]);
		//ADD IT!
		strCreatureType[intArrayIndex] = strCreatureTypes[intI];
		LOG("missions", "adding " + strCreatureTypes[intI]);
		strDetailTemplate[intArrayIndex] = strDetailTemplates[intI];
		intRewardPerKill[intArrayIndex] = intRewardsPerKill[intI];
		intArrayIndex = intArrayIndex + 1;

	}

	if(strCreatureType == null || strCreatureType.length == 0)
	{
		return null;
	}

	int intRoll = rand(0, intArrayIndex - 1);

	// now we've got everything we need
	string strAppearance = "object/mobile/" + strDetailTemplate[intRoll];

	LOG("missions", "strAppearance is " + strAppearance);
	setMissionTargetAppearance(objMissionData, strAppearance);
	string_id strTokenName = new string_id("mob/creature_names", strCreatureType[intRoll]);

	LOG("missions", "setting strCreatureType to " + strCreatureType[intRoll]);
	setMissionTargetName(objMissionData, utils.packStringId(strTokenName));

	setObjVar(objMissionData, "strCreatureToKill", strCreatureType[intRoll]);
	int intQuantityToKill = HUNTING_QUANTITIES[intMissionDifficulty - 1];

	setObjVar(objMissionData, "intQuantityToKill", intQuantityToKill);
	int intMultiplier = REWARD_MULTIPLIER[intMissionDifficulty - 1];
	int intReward = rand(300, 500) + intMultiplier * (intQuantityToKill * intRewardPerKill[intRoll]);

	setMissionReward(objMissionData, intReward);
	LOG("missions", "Hunting difficulty is " + intMissionDifficulty);
	setupContextualizationStrings(objMissionData, intMissionDifficulty, objCreator, strFaction);

	setMissionDifficulty(objMissionData, intDifficulty);

	return objMissionData;
}

// fail wrapper function
void sendAssassinFail(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "assassinFailure", dctParams, 0, true);	// spawner timer has started
}

// success wrapper function
void sendAssassinSuccess(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "assassinSuccess", dctParams, 0, true);	// spawner timer has started
}

// incomplete wrapper function
void sendAssassinIncomplete(obj_id objMission)
{
	dictionary dctParams = new dictionary();

	setObjVar(objMission, "intState", missions.STATE_MISSION_COMPLETE);
	messageTo(objMission, "assassinIncomplete", dctParams, 0, true);	// spawner timer has started
}

obj_id createAssassinMission(obj_id objMissionData, obj_id objCreator, int intDifficulty, string strFaction)
{
	setMissionRootScriptName(objMissionData, "systems.missions.dynamic.mission_assassin");
	setMissionType(objMissionData, "assassin");

	// for the time being we'll ignore the faction.

	location[] locMissionLocations = getAssassinMissionLocation();
	location locStartLocation = locMissionLocations[0];
	location locSpawnLocation = locMissionLocations[1];

	setMissionStartLocation(objMissionData, locStartLocation);

	setObjVar(objMissionData, "locSpawnLocation", locSpawnLocation);	// so we know where to put the npc;

	string strGoal = "object/tangible/mission/mission_bounty_target.iff";	// dummy value

	setMissionTargetAppearance(objMissionData, strGoal);
	string_id strName = new string_id("mission/mission_generic", "unknown");

	setMissionTargetName(objMissionData, utils.packStringId(strName));

	obj_id groupObject = getGroupObject(objCreator);

	if(isIdValid(groupObject))
	{
		setObjVar(objMissionData, "originalGroupSize", getPCGroupSize(groupObject));
	}

	int intReward = 2000;

	setMissionReward(objMissionData, intReward);
	////LOG("missions", "Hunting difficulty is "+intMissionDifficulty);
	setupContextualizationStrings(objMissionData, 1, objCreator, strFaction);
	setMissionDifficulty(objMissionData, intDifficulty);

	return objMissionData;
}

location[] getAssassinMissionLocation()
{
	// array. 1st locaation is mission loc for player, 2nd is actual spawn location
	location[] locMissionLocations = new location[2];
	string strPlanet = CITY_PLANETS[rand(0, CITY_PLANETS.length - 1)];
	region[] rgnCities = getRegionsWithMunicipal(strPlanet, regions.MUNI_TRUE);
	region rgnStartRegion = rgnCities[rand(0, rgnCities.length - 1)];
	location locStartLocation = locations.getRegionCenter(rgnStartRegion);
	location locSpawnLocation = locations.getGoodCityLocation(rgnStartRegion, strPlanet);
	locMissionLocations[0] = locStartLocation;
	locMissionLocations[1] = locSpawnLocation;

	return locMissionLocations;
}

boolean createAssassinTarget(obj_id objMission)
{
	string strNPC = NPC_TYPES[rand(0, NPC_TYPES.length - 1)];
	location locSpawnLocation = getLocationObjVar(objMission, "locSpawnLocation");
	obj_id objNPC = create.object(strNPC, locSpawnLocation);

	if(!isIdValid(objNPC))
	{
		return false;
	}

	setObjVar(objNPC, "objMission", objMission);
	setObjVar(objNPC, "objKiller", getMissionHolder(objMission));

	attachScript(objNPC, "systems.missions.dynamic.mission_assassin_target");
	persistAndRegisterObject(objNPC, objMission);
	setObjVar(objMission, "objNPC", objNPC);

	return true;
}

obj_id getAssassinMission(obj_id objPlayer)
{
	if(isIdValid(objPlayer))
	{
		obj_id[] objMissionArray = getMissionObjects(objPlayer);

		if(objMissionArray != null)
		{
			for(int intI = 0; intI < objMissionArray.length; intI++)
			{
				string strType = getMissionType(objMissionArray[intI]);

				if(strType == "assassin")
				{
					return objMissionArray[intI];
				}
			}
		}
	}

	return null;
}

boolean isPlanetHuntingViable(obj_id player, string area)
{
	int playerLevel = getLevel(player);

	if(area.equals("tatooine") && playerLevel > 30)
	{
		return false;
	}
	
	if((area.equals("naboo") || area.equals("corelia")) && (playerLevel < 20 || playerLevel > 40))
	{
		return false;
	}
	
	if((area.equals("rori") || area.equals("talus")) && (playerLevel < 40 || playerLevel > 60))
	{
		return false;
	}
	
	if((area.equals("dantooine") || area.equals("lok")) && (playerLevel < 50 || playerLevel > 70))
	{
		return false;
	}
	
	if((area.equals("yavin4") || area.equals("endor")) && (playerLevel < 70))
	{
		return false;
	}
	
	if(area.equals("dathomir") && playerLevel < 80)
	{
		return false;
	}

	return true;
}

void msgWrongHuntingPlanet(obj_id player)
{
	int playerLevel = getLevel(player);
	int msgIndex = playerLevel / 10;

	string_id[] missionPlanets = 	{ SID_MISSION_TATOOINE,				// Level 0-9
					SID_MISSION_TATOOINE,				// Level 10-19
					SID_MISSION_TATOOINE_NABOO_CORELIA,		// Level 20-29
					SID_MISSION_NABOO_CORELIA,			// Level 30-39
					SID_MISSION_RORI_TALUS,				// Level 40-49
					SID_MISSION_RORI_TALUS_DANTOOINE_LOK,		// Level 50-59
					SID_MISSION_DANTOOINE_LOK,			// Level 60-69
					SID_MISSION_YAVIN_ENDOR,			// Level 70-79
					SID_MISSION_YAVIN_ENDOR_DATHOMIR,		// Level 80-89
					SID_MISSION_YAVIN_ENDOR_DATHOMIR };		// Level 90

	if(msgIndex > missionPlanets.length)
		return;

	sendSystemMessage(player, missionPlanets[msgIndex]);
}