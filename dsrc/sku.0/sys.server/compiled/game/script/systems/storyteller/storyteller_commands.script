
/**********************************************************************
 * Copyright (c)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        terminal_character_builder.script
 * Description:  Script that drives the Character Builder Terminals
 * @author       Thomas Blair
 * @version      1.0
 **********************************************************************/


/***** INCLUDES ********************************************************/

include library.chat;
include library.guild;
include library.loot;
include library.pgc_quests;
include library.prose;
include library.skill_template;
include library.storyteller;
include library.sui;
include library.target_dummy;
include library.utils;


/********* CONSTANTS *****************************************/
const string_id SID_STORYTELLER_HELP		= new string_id ("storyteller", "storyteller_help");
const string_id SID_STORYTELLER_TITLE		= new string_id ("storyteller", "storyteller_title");
const string_id SID_STORYTELLER_MENU_CMDS	= new string_id ("storyteller", "storyteller_menu_commands");
const string_id SID_STORYTELLER_MENU_PROPS	= new string_id ("storyteller", "storyteller_menu_props");
const string_id SID_STORYTELLER_MENU_NPCS	= new string_id ("storyteller", "storyteller_menu_npcs");
const string_id SID_STORYTELLER_MENU_FXS	= new string_id ("storyteller", "storyteller_menu_effects");
const string_id SID_STORYTELLER_HELP_CMDS	= new string_id ("storyteller", "storyteller_help_commands");
const string_id SID_STORYTELLER_HELP_PROPS	= new string_id ("storyteller", "storyteller_help_props");
const string_id SID_STORYTELLER_HELP_NPCS	= new string_id ("storyteller", "storyteller_help_npcs");
const string_id SID_STORYTELLER_HELP_FXS	= new string_id ("storyteller", "storyteller_help_effects");


const string_id SID_CANNOT_INVITE_ASSISTANTS	= new string_id ("storyteller", "assistant_cannot_invite_assistants");
const string_id SID_ASSISTANT_ADD_INVALID		= new string_id ("storyteller", "assistant_add_target_invalid");
const string_id SID_ASSISTANT_ADD_NOT_A_PLAYER	= new string_id ("storyteller", "assistant_add_not_a_player");
const string_id SID_ALREADY_YOUR_ASSISTANT		= new string_id ("storyteller", "assistant_add_already_yours");
const string_id SID_ALREADY_AN_ASSISTANT		= new string_id ("storyteller", "assistant_add_already_one");
const string_id SID_DECLINED_ASSISTANT			= new string_id ("storyteller", "assistant_add_declined");
const string_id SID_ASSISTANT_ADDED				= new string_id ("storyteller", "assistant_added");
const string_id SID_YOU_QUIT_STORY_ASSISTANT	= new string_id ("storyteller", "assistant_you_quit");
const string_id SID_YOU_NOT_A_STORY_ASSISTANT	= new string_id ("storyteller", "assistant_you_not_one");
const string_id SID_ASSISTANT_REMOVE_INVALID	= new string_id ("storyteller", "assistant_remove_target_invalid");
const string_id SID_ASSISTANT_REMOVE_NOT_PLAYER	= new string_id ("storyteller", "assistant_remove_not_a_player");
const string_id SID_SOMEONE_ELSES_ASSISTANT		= new string_id ("storyteller", "assistant_someone_elses");
const string_id SID_NOT_STORYTELLER_ASSISTANT	= new string_id ("storyteller", "assistant_not_one");
const string_id SID_ASSISTANT_REMOVED			= new string_id ("storyteller", "assistant_removed");
const string_id SID_ASSISTANT_ADDED_PLAYER		= new string_id ("storyteller", "assistant_added_player");
const string_id SID_ASSISTANT_ALREADY_STORY		= new string_id ("storyteller", "assistant_already_your_story");

const string_id SID_NOT_STORYTELLER_STORY	= new string_id ("storyteller", "not_storyteller_story");
const string_id SID_LEAVING_STORYTELLER		= new string_id ("storyteller", "leaving_storyteller");
const string_id SID_CANNOT_INVITE			= new string_id ("storyteller", "cannot_invite");
const string_id SID_INVITE_AREA_INVITE_COMPLETE	= new string_id ("storyteller", "area_invite_complete");
const string_id SID_INVITE_NOT_IN_A_GUILD	= new string_id ("storyteller", "invite_not_in_a_guild");
const string_id SID_INVITE_TARGET_INVALID	= new string_id ("storyteller", "invite_target_invalid");
const string_id SID_INVITE_NOT_A_PLAYER		= new string_id ("storyteller", "invite_target_not_a_player");
const string_id SID_ADDED_PLAYER			= new string_id ("storyteller", "storyteller_added_player");
const string_id SID_REMOVE_TARGET_INVALID	= new string_id ("storyteller", "remove_target_invalid");
const string_id SID_REMOVE_NOT_A_PLAYER		= new string_id ("storyteller", "remove_target_not_a_player");
const string_id SID_REMOVED_PLAYER			= new string_id ("storyteller", "storyteller_removed_player");
const string_id SID_ALREADY_STORY			= new string_id ("storyteller", "already_story");
const string_id SID_ALREADY_YOUR_STORY		= new string_id ("storyteller", "already_your_story");
const string_id SID_DECLINED_INVITE			= new string_id ("storyteller", "invite_add_declined");
const string_id SID_YOU_LEFT_STORY			= new string_id ("storyteller", "you_left_story");
const string_id SID_YOU_NOT_IN_A_STORY		= new string_id ("storyteller", "you_not_in_a_story");

const string INCLUDE_ALL_STORYTELLERS 		= "all_storytellers";

const string_id SID_PGC_RATING_TARGET_INVALID	= new string_id ("saga_system", "pgc_rating_target_invalid");
const string_id SID_PGC_RATING_TARGET_NOT_A_PLAYER		= new string_id ("saga_system", "pgc_rating_target_not_a_player");

/****************************************************************/

trigger OnNewbieTutorialResponse(string action)
{
    if ( action.equals("clientReady") )
    {
    	obj_id storytellerId = self;
    	if ( utils.hasScriptVar(self, "storytellerid") )
    	{
    		obj_id tempStorytellerId = utils.getObjIdScriptVar(self, "storytellerid");
    		if ( isIdValid(tempStorytellerId) )
    		{
    			storytellerId = tempStorytellerId;
    		}
    	}
    	storyteller.showStorytellerEffectsInAreaToPlayer(self, storytellerId);
    }
	return SCRIPT_CONTINUE;
}

/****************************************************************/

// Storyteller help
commandHandler storytellerMode()
{
	string title = utils.packStringId(SID_STORYTELLER_TITLE);
	string prompt = utils.packStringId(SID_STORYTELLER_HELP);
	
	int pid = sui.listbox(self, self, prompt, sui.OK_CANCEL, title, getHelpTypeArray(), "msgStorytellerHelpOptionSelected");

	if ( pid > -1 )
	{
		utils.setScriptVar(self, "storytellerHelp.pid", pid);
	}
	
	return SCRIPT_CONTINUE;
}

string[] getHelpTypeArray()
{
	string_id[] sid_storyteller_help_options = { SID_STORYTELLER_MENU_CMDS, 
												SID_STORYTELLER_MENU_PROPS, 
												SID_STORYTELLER_MENU_NPCS, 
												SID_STORYTELLER_MENU_FXS };
	
	resizeable string[] storytellerHelpTypes = new string[0];
	
	for ( int i=0; i < sid_storyteller_help_options.length; i++ )
	{
		string tokenType = utils.packStringId(sid_storyteller_help_options[i]);
		storytellerHelpTypes = utils.addElement(storytellerHelpTypes, tokenType);
	}
	
	return storytellerHelpTypes;
}

messageHandler msgStorytellerHelpOptionSelected()
{
	
	if ( (params == null) || (params.isEmpty()) )
	{
		return SCRIPT_CONTINUE;
	}

	obj_id player = sui.getPlayerId(params);

	int btn = sui.getIntButtonPressed(params);
	int idx = sui.getListboxSelectedRow(params);

	// clean up string vars
	if ( utils.hasScriptVar(self, "storytellerHelp.pid" ) )
	{
		utils.removeScriptVar(self, "storytellerHelp.pid");
	}

	if(btn == sui.BP_CANCEL)
	{
		return SCRIPT_CONTINUE;
	}

	string prompt = utils.packStringId(SID_STORYTELLER_HELP);
	switch(idx)
	{
		case 0:
			// Storyteller commands
			prompt = utils.packStringId(SID_STORYTELLER_HELP_CMDS);
			break;
		case 1:
			// Storyteller props
			prompt = utils.packStringId(SID_STORYTELLER_HELP_PROPS);
			break;
		case 2:
			// Storyteller npcs
			prompt = utils.packStringId(SID_STORYTELLER_HELP_NPCS);
			break;
		case 3:
			// Storyteller effects
			prompt = utils.packStringId(SID_STORYTELLER_HELP_FXS);
			break;
	}
	
	string title = utils.packStringId(SID_STORYTELLER_TITLE);	
	int pid = sui.listbox(self, self, prompt, sui.OK_CANCEL, title, getHelpTypeArray(), "msgStorytellerHelpOptionSelected");

	if ( pid > -1 )
	{
		utils.setScriptVar(self, "storytellerHelp.pid", pid);
	}

	return SCRIPT_CONTINUE;
}

/****************************************************************/
// Auto-decline Storyteller Invites

commandHandler storyAutoDeclineInvites()
{
	if( hasObjVar(self, storyteller.VAR_AUTODECLINE_STORY_INVITES) )
	{
		removeObjVar(self, storyteller.VAR_AUTODECLINE_STORY_INVITES);
		sendSystemMessage(self, new string_id("storyteller", "autodecline_story_invites_off"));
	}
	else
	{
		setObjVar(self, storyteller.VAR_AUTODECLINE_STORY_INVITES, 1);
		sendSystemMessage(self, new string_id("storyteller", "autodecline_story_invites_on"));
	}

	return SCRIPT_CONTINUE;
}

/****************************************************************/
// Storyteller Assistant

commandHandler makeStoryAssistant()
{
	if ( utils.hasScriptVar(self, "storytellerAssistant") )
	{
		sendSystemMessage(self, SID_CANNOT_INVITE_ASSISTANTS);
		return SCRIPT_CONTINUE;	
	}
	
	target = null;
	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if (st.countTokens() > 0)
	{
		string invitee = st.nextToken().toLowerCase();
		target = getPlayerIdFromFirstName(invitee);
	}
	
	if ( !isIdValid(target) )
	{
		obj_id intendedTarget = getIntendedTarget(self);
		if( !isIdValid(intendedTarget) )
		{
			target = getLookAtTarget(self);
		}
		else
		{
			target = intendedTarget;
		}
		
		// still no valid target?
		if ( !isIdValid(target) )
		{
			sendSystemMessage(self, SID_ASSISTANT_ADD_INVALID);
			return SCRIPT_CONTINUE;		
		}
		else if ( !isPlayer(target) )
		{
			prose_package pp = prose.getPackage(SID_ASSISTANT_ADD_NOT_A_PLAYER, self, self);
			prose.setTO(pp, getEncodedName(target));
			sendSystemMessageProse(self, pp);
			return SCRIPT_CONTINUE;		
		}
	}	

	dictionary webster = new dictionary();
	webster.put("storytellerPlayer", self);
	webster.put("storytellerName", getName(self));
	messageTo(target, "handleStoryTellerAssistantRequest", webster, 0, false);	
	
	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerAlreadyAnAssistant()
{
	boolean alreadyAStorytellersAssistant = params.getBoolean("alreadyAStorytellersAssistant");
	string targetName = params.getString("targetName");
	
	prose_package pp = prose.getPackage(SID_ALREADY_AN_ASSISTANT, self, self);
	prose.setTO(pp, targetName);
	
	if( alreadyAStorytellersAssistant )
	{
		pp = prose.getPackage(SID_ALREADY_YOUR_ASSISTANT, self, self);
		prose.setTO(pp, targetName);
	}
	
	sendSystemMessageProse(self, pp);
	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerAssistantDeclined()
{
	string targetName = params.getString("targetName");
	
	prose_package pp = prose.getPackage(SID_DECLINED_ASSISTANT, self, self);
	prose.setTO(pp, targetName);	
	sendSystemMessageProse(self, pp);
	return SCRIPT_CONTINUE;
}

messageHandler storyAssistantHandler()
{
	obj_id player = sui.getPlayerId(params);
	int btn = sui.getIntButtonPressed(params);
	if ( !isIdValid(player) )
	{
		return SCRIPT_CONTINUE;
	}
	
	dictionary webster = new dictionary();
	webster.put("storytellerPlayer", self);
	webster.put("storytellerName", getName(self));
	
	if ( btn == sui.BP_CANCEL )
	{
		messageTo(player, "handleTellStorytellerIDeclinedAssistant", webster, 0, false);
		return SCRIPT_CONTINUE;
	}

	messageTo(player, "handleStoryTellerAssistantAccepted", webster, 0, false);

	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerAssistantHasBeenAdded()
{
	string addedPlayerName = params.getString("assistantPlayerName");
	
	if ( addedPlayerName != null && addedPlayerName.length() > 0 )
	{
		prose_package pp = prose.getPackage(SID_ASSISTANT_ADDED, self, self);
		prose.setTO(pp, addedPlayerName);
		sendSystemMessageProse(self, pp);
	}
	
	return SCRIPT_CONTINUE;
}

commandHandler quitStoryAssistant()
{
	if (utils.hasScriptVar(self, "storytellerAssistant"))
	{
		utils.removeScriptVar(self, "storytellerAssistant");
		utils.removeScriptVar(self, "storytellerAssistantName");
		sendSystemMessage(self, SID_YOU_QUIT_STORY_ASSISTANT);
	}
	else
	{
		sendSystemMessage(self, SID_YOU_NOT_A_STORY_ASSISTANT);
	}
	return SCRIPT_CONTINUE;
}

commandHandler removeStoryAssistant()
{
	target = null;
	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if (st.countTokens() > 0)
	{
		string invitee = st.nextToken().toLowerCase();
		target = getPlayerIdFromFirstName(invitee);
	}
	
	if ( !isIdValid(target) )
	{
		obj_id intendedTarget = getIntendedTarget(self);
		if( !isIdValid(intendedTarget) )
		{
			target = getLookAtTarget(self);
		}
		else
		{
			target = intendedTarget;
		}
		
		if ( !isIdValid(target) )
		{
			sendSystemMessage(self, SID_ASSISTANT_REMOVE_INVALID);
			return SCRIPT_CONTINUE;		
		}
		else if ( !isPlayer(target) )
		{
			sendSystemMessage(self, SID_ASSISTANT_REMOVE_NOT_PLAYER);
			return SCRIPT_CONTINUE;		
		}
	}
	
	
	dictionary webster = new dictionary();
	webster.put("storytellerPlayer", self);
	webster.put("storytellerName", getName(self));
	messageTo(target, "handleStoryTellerRemoveAssistant", webster, 0, false);
	
	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerRemovePlayerNotAssistant()
{
	string targetName = params.getString("targetName");
	
	prose_package pp = prose.getPackage(SID_NOT_STORYTELLER_ASSISTANT, self, self);
	prose.setTO(pp, targetName);
	
	sendSystemMessageProse(self, pp);
	
	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerAssistantHasBeenRemoved()
{
	string removedPlayerName = params.getString("removedPlayerName");
	
	if ( removedPlayerName != null && removedPlayerName.length() > 0 )
	{
		prose_package pp = prose.getPackage(SID_ASSISTANT_REMOVED, self, self);
		prose.setTO(pp, removedPlayerName);
		sendSystemMessageProse(self, pp);
	}
	
	return SCRIPT_CONTINUE;
}

/****************************************************************/
// Storyteller story invites, removal, etc.

commandHandler inviteToStory()
{
	obj_id storytellerId = self;
	string storytellerName = getName(self);
	obj_id storytellerAssistant = null;
	if ( utils.hasScriptVar(self, "storytellerAssistant") )
	{
		storytellerId = utils.getObjIdScriptVar(self, "storytellerAssistant");
		storytellerName = utils.getStringScriptVar(self, "storytellerAssistantName");
		storytellerAssistant = self;
	}
	
	target = null;
	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if (st.countTokens() > 0)
	{
		string invitee = st.nextToken().toLowerCase();
		if ( invitee.equals("myself") || invitee.equals("self") )
		{
			target = self;
		}
		else if ( invitee.equals("area_invite") && isGod(self) )
		{
			obj_id[] playersInRange = getAllPlayers(getLocation(self), 120f);
			if ( playersInRange != null && playersInRange.length > 0 )
			{
				for ( int i = 0; i < playersInRange.length; i++ )
				{
					obj_id playerToInvite = playersInRange[i];
					if ( isIdValid(playerToInvite) && playerToInvite != self )
					{
						dictionary webster = new dictionary();
						webster.put("storytellerPlayer", storytellerId);
						webster.put("storytellerName", storytellerName);
						messageTo(playerToInvite, "handleStoryTellerInviteRequest", webster, 0, false);		
					}
				}
			}
			sendSystemMessage(self, SID_INVITE_AREA_INVITE_COMPLETE);
			return SCRIPT_CONTINUE;
		}
		else if ( invitee.equals("guild") )
		{
			// storytellers can invite their guild to their story.
			int guildId = getGuildId(self);
			
			// *********************************************
			// event support: in godmode can invite guilds they are not a part of
			// *********************************************
			if ( isGod(self) && st.countTokens() > 0 )
			{
				string guildInvited = "";
				int numTokensRemaining = st.countTokens();
				for ( int i = 0; i < numTokensRemaining; i++  )
				{
					if ( guildInvited.equals("") )
					{
						guildInvited = guildInvited + st.nextToken();
					}
					else
					{
						guildInvited = guildInvited + " " + st.nextToken();
					}
				}
				
				guildId = findGuild(guildInvited);
				if ( guildId < 1 )
				{
					string_id message = new string_id ("storyteller", "invite_god_only_bad_guild");
					prose_package pp = prose.getPackage(message, self, self);
					prose.setTO(pp, guildInvited);
					sendSystemMessageProse(self, pp);
				}
				else
				{
					string_id message = new string_id ("storyteller", "invite_god_only_other_guild");
					prose_package pp = prose.getPackage(message, self, self);
					prose.setTO(pp, guildInvited);
					sendSystemMessageProse(self, pp);
				}
			}
			// *********************************************
			
			if ( guildId > 0 )
			{
				obj_id[] guildMembers = guild.getMemberIds(guildId, false, true);
				if ( guildMembers != null && guildMembers.length > 0 )
				{
					for ( int i = 0; i < guildMembers.length; i++ )
					{
						obj_id guildMember = guildMembers[i];
						if ( isIdValid(guildMember) && guildMember != self )
						{
							dictionary webster = new dictionary();
							webster.put("storytellerPlayer", storytellerId);
							webster.put("storytellerName", storytellerName);
							messageTo(guildMember, "handleStoryTellerInviteRequest", webster, 0, false);		
						}
					}
				}
			}
			else
			{
				sendSystemMessage(self, SID_INVITE_NOT_IN_A_GUILD);
			}
			
			return SCRIPT_CONTINUE;
		}
		else
		{
			target = getPlayerIdFromFirstName(invitee);
		}
	}
	
	if ( !isIdValid(target) )
	{
		obj_id intendedTarget = getIntendedTarget(self);
		if( !isIdValid(intendedTarget) )
		{
			target = getLookAtTarget(self);
		}
		else
		{
			target = intendedTarget;
		}
		
		// still no valid target?
		if ( !isIdValid(target) )
		{
			sendSystemMessage(self, SID_INVITE_TARGET_INVALID);
			return SCRIPT_CONTINUE;		
		}
		else if ( !isPlayer(target) )
		{
			prose_package pp = prose.getPackage(SID_INVITE_NOT_A_PLAYER, self, self);
			prose.setTO(pp, getEncodedName(target));
			sendSystemMessageProse(self, pp);
			return SCRIPT_CONTINUE;		
		}
	}	

	dictionary webster = new dictionary();
	webster.put("storytellerPlayer", storytellerId);
	webster.put("storytellerName", storytellerName);
	if ( isIdValid(storytellerAssistant) )
	{
		webster.put("storytellerAssistant", storytellerAssistant);
	}
	messageTo(target, "handleStoryTellerInviteRequest", webster, 0, false);	
	
	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerInviteDeclined()
{
	string targetName = params.getString("targetName");
	
	prose_package pp = prose.getPackage(SID_DECLINED_INVITE, self, self);
	prose.setTO(pp, targetName);	
	sendSystemMessageProse(self, pp);
	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerInviteAlreadyInAStory()
{
	boolean alreadyInStorytellersStory = params.getBoolean("alreadyInStorytellersStory");
	string targetName = params.getString("targetName");
	string storytellerName = params.getString("storytellerName");
	
	prose_package pp = prose.getPackage(SID_ALREADY_STORY, self, self);
	prose.setTO(pp, targetName);
	
	if( alreadyInStorytellersStory )
	{
		pp = prose.getPackage(SID_ALREADY_YOUR_STORY, self, self);
		prose.setTO(pp, targetName);
		
		if ( utils.hasScriptVar(self, "storytellerAssistant") )
		{			
			pp = prose.getPackage(SID_ASSISTANT_ALREADY_STORY, self, self);
			prose.setTO(pp, targetName);
			prose.setTT(pp, storytellerName);
		}
	}
	
	sendSystemMessageProse(self, pp);
	return SCRIPT_CONTINUE;
}

messageHandler storyInviteHandler()
{
	obj_id storytellerId = self;
	string storytellerName = getName(self);
	obj_id storytellerAssistant = null;
	if ( utils.hasScriptVar(self, "storytellerAssistant") )
	{
		storytellerId = utils.getObjIdScriptVar(self, "storytellerAssistant");
		storytellerName = utils.getStringScriptVar(self, "storytellerAssistantName");
		storytellerAssistant = self;
	}
	
	obj_id player = sui.getPlayerId(params);
	int btn = sui.getIntButtonPressed(params);
	if ( !isIdValid(player) )
	{
		return SCRIPT_CONTINUE;
	}
	
	dictionary webster = new dictionary();
	webster.put("storytellerPlayer", storytellerId);
	webster.put("storytellerName", storytellerName);
	
	if ( btn == sui.BP_CANCEL )
	{
		messageTo(player, "handleTellStorytellerIDeclinedInvite", webster, 0, false);
		return SCRIPT_CONTINUE;
	}

	if ( isIdValid(storytellerAssistant) )
	{
		webster.put("storytellerAssistant", storytellerAssistant);
	}
	messageTo(player, "handleStoryTellerInviteAccepted", webster, 0, false);

	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerPlayerHasBeenAdded()
{
	string addedPlayerName = params.getString("addedPlayerName");
	string storytellerName = params.getString("storytellerName");
	
	if ( addedPlayerName != null && addedPlayerName.length() > 0 )
	{
		prose_package pp = prose.getPackage(SID_ADDED_PLAYER, self, self);
		prose.setTO(pp, addedPlayerName);
		
		if ( utils.hasScriptVar(self, "storytellerAssistant") )
		{			
			pp = prose.getPackage(SID_ASSISTANT_ADDED_PLAYER, self, self);
			prose.setTO(pp, addedPlayerName);
			prose.setTT(pp, storytellerName);
		}
		
		sendSystemMessageProse(self, pp);
	}
	
	return SCRIPT_CONTINUE;
}

commandHandler leaveStory()
{
	obj_id storytellerPlayer = obj_id.NULL_ID;
	if (utils.hasScriptVar(self, "storytellerid"))
	{
		storytellerPlayer = utils.getObjIdScriptVar(self, "storytellerid");
		
		utils.removeScriptVar(self, "storytellerid");
		utils.removeScriptVar(self, "storytellerName");
		sendSystemMessage(self, SID_YOU_LEFT_STORY);
		
		if ( isIdValid(storytellerPlayer) )
		{
			storyteller.stopStorytellerEffectsInAreaToPlayer(self, storytellerPlayer);
		}
	}
	else
	{
		sendSystemMessage(self, SID_YOU_NOT_IN_A_STORY);
	}
	return SCRIPT_CONTINUE;
}

commandHandler removeFromStory()
{
	target = null;
	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if (st.countTokens() > 0)
	{
		string invitee = st.nextToken().toLowerCase();
		if ( invitee.equals("myself") || invitee.equals("self") )
		{
			target = self;
		}
		else
		{
			target = getPlayerIdFromFirstName(invitee);
		}
	}
	
	if ( !isIdValid(target) )
	{
		obj_id intendedTarget = getIntendedTarget(self);
		if( !isIdValid(intendedTarget) )
		{
			target = getLookAtTarget(self);
		}
		else
		{
			target = intendedTarget;
		}

		if ( !isIdValid(target) )
		{
			sendSystemMessage(self, SID_REMOVE_TARGET_INVALID);
			return SCRIPT_CONTINUE;		
		}
		else if ( !isPlayer(target) )
		{
			sendSystemMessage(self, SID_REMOVE_NOT_A_PLAYER);
			return SCRIPT_CONTINUE;		
		}
	}
		
	dictionary webster = new dictionary();
	webster.put("storytellerPlayer", self);
	webster.put("storytellerName", getName(self));
	messageTo(target, "handleStoryTellerRemovedFromStory", webster, 0, false);
	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerRemovePlayerNotInStory()
{
	string targetName = params.getString("targetName");
	
	prose_package pp = prose.getPackage(SID_NOT_STORYTELLER_STORY, self, self);
	prose.setTO(pp, targetName);
	
	sendSystemMessageProse(self, pp);
	return SCRIPT_CONTINUE;
}

messageHandler handleStorytellerPlayerHasBeenRemoved()
{
	string removedPlayerName = params.getString("removedPlayerName");
	
	if ( removedPlayerName != null && removedPlayerName.length() > 0 )
	{
		prose_package pp = prose.getPackage(SID_REMOVED_PLAYER, self, self);
		prose.setTO(pp, removedPlayerName);
		sendSystemMessageProse(self, pp);
	}
	
	return SCRIPT_CONTINUE;
}

/****************************************************************/
// Storyteller CSR commands

commandHandler storytellerDestroyNpcs()
{
	if ( !isGod(self) )
	{
		return SCRIPT_CONTINUE;
	}

	dictionary webster = getDestroyStorytellerObjectParams(params);
	
	obj_id storytellerId = obj_id.NULL_ID;
	if ( webster.containsKey("storytellerId") )
	{
		storytellerId = webster.getObjId("storytellerId");
	}
	string storytellerName = webster.getString("storytellerName");

	if ( storytellerName == null || storytellerName.length() < 1 )
	{
		sendSystemMessage(self, "GodMode Message: -> Format: /csStorytellerDestroyNpcs <storyteller_name> (use all_storytellers for all inclusive storyteller NPC destruction)", "");
	}
	
	
	if ( !isIdValid(storytellerId) )
	{
		sendSystemMessage(self, "GodMode Message: Unable to find a valid storyteller Id.", "");
	}

	boolean npcDestroyed = false;
	resizeable obj_id[] elligibleStorytellerObjects = getElligibleStorytellerObjectsInRange(self, storytellerId, storytellerName);
	if ( elligibleStorytellerObjects != null && elligibleStorytellerObjects.length > 0 )
	{
		for ( int i = 0; i < elligibleStorytellerObjects.length; i++ )
		{
			obj_id elligibleStorytellerObject = elligibleStorytellerObjects[i];
			if( isIdValid(elligibleStorytellerObject) )
			{
				// if a mob, then the storyteller object is an npc
				if ( isMob(elligibleStorytellerObject) )
				{
					destroyObject(elligibleStorytellerObject);
					npcDestroyed = true;
				}
			}
		}
		
		if ( npcDestroyed )
		{
			sendSystemMessage(self, "GodMode Message: All of "+storytellerName+"'s storyteller NPCs destroyed!", "");
			
			string logMsg = "("+self+")"+getName(self)+" has removed storyteller NPCs belonging to: "+storytellerName+"("+storytellerId+")";
			CustomerServiceLog("storyteller", logMsg);
		}
		else
		{
			sendSystemMessage(self, "GodMode Message: No storyteller NPCs were found belonging to " + storytellerName + ".", "");
		}
	}
	else
	{
		sendSystemMessage(self, "GodMode Message: No storyteller objects were found that belong to " + storytellerName + ".", "");
	}
	
	return SCRIPT_CONTINUE;
}

commandHandler storytellerDestroyProps()
{
	if ( !isGod(self) )
	{
		return SCRIPT_CONTINUE;
	}
	
	dictionary webster = getDestroyStorytellerObjectParams(params);
	
	obj_id storytellerId = obj_id.NULL_ID;
	if ( webster.containsKey("storytellerId") )
	{
		storytellerId = webster.getObjId("storytellerId");
	}
	string storytellerName = webster.getString("storytellerName");

	if ( storytellerName == null || storytellerName.length() < 1 )
	{
		sendSystemMessage(self, "GodMode Message: -> Format: /csStorytellerDestroyProps <storyteller_name> (use all_storytellers for all inclusive storyteller prop destruction)", "");
	}
	
	
	if ( !isIdValid(storytellerId) )
	{
		sendSystemMessage(self, "GodMode Message: Unable to find a valid storyteller Id.", "");
	}

	boolean propDestroyed = false;
	resizeable obj_id[] elligibleStorytellerObjects = getElligibleStorytellerObjectsInRange(self, storytellerId, storytellerName);
	if ( elligibleStorytellerObjects != null && elligibleStorytellerObjects.length > 0 )
	{
		for ( int i = 0; i < elligibleStorytellerObjects.length; i++ )
		{
			obj_id elligibleStorytellerObject = elligibleStorytellerObjects[i];
			if( isIdValid(elligibleStorytellerObject) )
			{
				// if not a mob, then the storyteller object must be a prop or an effect controller
				if ( !isMob(elligibleStorytellerObject) )
				{
					destroyObject(elligibleStorytellerObject);
					propDestroyed = true;
				}
			}
		}
		
		if ( propDestroyed )
		{
			sendSystemMessage(self, "GodMode Message: All of "+storytellerName+"'s storyteller props destroyed!", "");
			
			string logMsg = "("+self+")"+getName(self)+" has removed storyteller props belonging to: "+storytellerName+"("+storytellerId+")";
			CustomerServiceLog("storyteller", logMsg);
		}
		else
		{
			sendSystemMessage(self, "GodMode Message: No storyteller PROPS were found belonging to " + storytellerName + ".", "");
		}
	}
	else
	{
		sendSystemMessage(self, "GodMode Message: No storyteller objects were found that belong to " + storytellerName + ".", "");
	}
	
	return SCRIPT_CONTINUE;
}

commandHandler storytellerDestroyParticles()
{
	if ( !isGod(self) )
	{
		return SCRIPT_CONTINUE;
	}
	
	dictionary webster = getDestroyStorytellerObjectParams(params);
	
	obj_id storytellerId = obj_id.NULL_ID;
	if ( webster.containsKey("storytellerId") )
	{
		storytellerId = webster.getObjId("storytellerId");
	}
	string storytellerName = webster.getString("storytellerName");
	
	if ( storytellerName == null || storytellerName.length() < 1 )
	{
		sendSystemMessage(self, "GodMode Message: -> Format: /csStorytellerDestroyParticles <storyteller_name> (use all_storytellers for all inclusive storyteller particle destruction)", "");
	}
	
	
	if ( !isIdValid(storytellerId) )
	{
		sendSystemMessage(self, "GodMode Message: Unable to find a valid storyteller Id.", "");
	}
	
	boolean particleDestroyed = false;
	resizeable obj_id[] elligibleStorytellerObjects = getElligibleStorytellerObjectsInRange(self, storytellerId, storytellerName);
	if ( elligibleStorytellerObjects != null && elligibleStorytellerObjects.length > 0 )
	{
		for ( int i = 0; i < elligibleStorytellerObjects.length; i++ )
		{
			obj_id elligibleStorytellerObject = elligibleStorytellerObjects[i];
			if( isIdValid(elligibleStorytellerObject) )
			{
				// does the storyteller object have a persisted effect on it?
				if ( hasObjVar(elligibleStorytellerObject, "storytellerPersistedEffectActive"))
				{
					messageTo(elligibleStorytellerObject, "handleRemoveStorytellerPersistedEffect", null, 1, false);
					particleDestroyed = true;
				}
			}
		}
		
		if ( particleDestroyed )
		{
			sendSystemMessage(self, "GodMode Message: All of "+storytellerName+"'s storyteller particles destroyed!", "");
			
			string logMsg = "("+self+")"+getName(self)+" has removed storyteller particles belonging to: "+storytellerName+"("+storytellerId+")";
			CustomerServiceLog("storyteller", logMsg);
		}
		else
		{
			sendSystemMessage(self, "GodMode Message: No storyteller PARTICLES were found belonging to " + storytellerName + ".", "");
		}
	}
	else
	{
		sendSystemMessage(self, "GodMode Message: No storyteller objects were found that belong to " + storytellerName + ".", "");
	}

	return SCRIPT_CONTINUE;
}

commandHandler storytellerDestroyAllObjects()
{
	if ( !isGod(self) )
	{
		return SCRIPT_CONTINUE;
	}
	
	dictionary webster = getDestroyStorytellerObjectParams(params);
	
	obj_id storytellerId = obj_id.NULL_ID;
	if ( webster.containsKey("storytellerId") )
	{
		storytellerId = webster.getObjId("storytellerId");
	}
	string storytellerName = webster.getString("storytellerName");

	if ( storytellerName == null || storytellerName.length() < 1 )
	{
		sendSystemMessage(self, "GodMode Message: -> Format: /csStorytellerDestroyAllObjects <storyteller_name> (use all_storytellers for all inclusive storyteller object destruction)", "");
	}
	
	
	if ( !isIdValid(storytellerId) )
	{
		sendSystemMessage(self, "GodMode Message: Unable to find a valid storyteller Id.", "");
	}

	resizeable obj_id[] elligibleStorytellerObjects = getElligibleStorytellerObjectsInRange(self, storytellerId, storytellerName);
	if ( elligibleStorytellerObjects != null && elligibleStorytellerObjects.length > 0 )
	{
		for ( int i = 0; i < elligibleStorytellerObjects.length; i++ )
		{
			obj_id elligibleStorytellerObject = elligibleStorytellerObjects[i];
			if( isIdValid(elligibleStorytellerObject) )
			{
				destroyObject(elligibleStorytellerObject);
			}
		}
		sendSystemMessage(self, "GodMode Message: All of "+storytellerName+"'s storyteller objects destroyed!", "");
		
		string logMsg = "("+self+")"+getName(self)+" has removed storyteller objects belonging to: "+storytellerName+"("+storytellerId+")";
		CustomerServiceLog("storyteller", logMsg);
	}
	else
	{
		sendSystemMessage(self, "GodMode Message: No storyteller objects were found belonging to " + storytellerName + ".", "");
	}

	return SCRIPT_CONTINUE;
}

dictionary getDestroyStorytellerObjectParams(string params)
{
	dictionary webster = new dictionary();
	obj_id storytellerId = obj_id.NULL_ID;
	string storytellerName = "";
	
	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if (st.countTokens() > 0)
	{
		storytellerName = st.nextToken().toLowerCase();
		if( st.hasMoreTokens() )
		{
			storytellerName = storytellerName + " " + st.nextToken().toLowerCase();
		}
		
		if ( storytellerName != null && storytellerName.length() > 0 && !storytellerName.equals(INCLUDE_ALL_STORYTELLERS) )
		{
			storytellerId = getPlayerIdFromFirstName(storytellerName);
		}
	}
	if ( isValidId(storytellerId) )
	{
		webster.put("storytellerId", storytellerId);
	}
	webster.put("storytellerName", storytellerName);
		
	return webster;
}

resizeable obj_id[] getElligibleStorytellerObjectsInRange(obj_id self, obj_id storytellerId, string storytellerName)
{
	resizeable obj_id[] elligibleObjects = new obj_id[0];
	
	obj_id[] storytellerObjects = getAllObjectsWithObjVar(getLocation(self), 250f, "storytellerid");
	if ( storytellerObjects != null && storytellerObjects.length > 0 )
	{
		for ( int i = 0; i < storytellerObjects.length; i++ )
		{
			obj_id storytellerObject = storytellerObjects[i];
			if ( isIdValid(storytellerObject) )
			{
				if ( storytellerName.equals(INCLUDE_ALL_STORYTELLERS) )
				{
					utils.addElement(elligibleObjects, storytellerObject);
				}
				else
				{
					obj_id storytellerObjectOwner = getObjIdObjVar(storytellerObject, "storytellerid");
					string storytellerObjectOwnerName = getStringObjVar(storytellerObject, "storytellerName");

					if ( isIdValid(storytellerId) )
					{
						if ( isIdValid(storytellerObjectOwner) && storytellerId == storytellerObjectOwner )
						{
							utils.addElement(elligibleObjects, storytellerObject);
						}
					}
					else
					{
						if ( storytellerObjectOwnerName.length() > 0 && storytellerName.equals(storytellerObjectOwnerName.toLowerCase()) )
						{
							utils.addElement(elligibleObjects, storytellerObject);
						}
					}
				}
			}
		}
	}
	
	return elligibleObjects;
}

/****************************************************************/
// Chronicles Commands

commandHandler chroniclerVentriloquism()
{
	target = getIntendedTarget(self);
	if( !isIdValid(target) )
	{
		target = getLookAtTarget(self);
	}
	
	if ( isIdValid(target) )
	{
		if ( isMob(target) && storyteller.isStorytellerNpc(target) )
		{
			if ( storyteller.allowedToUseStorytellerObject(target, self) )
			{
				chat.chat(target, pgc_quests.useFilteredQuestText(params));
			}
		}
	}
	return SCRIPT_CONTINUE;
}

commandHandler chroniclerGetRating()
{
	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if (st.countTokens() > 0)
	{
		string name = st.nextToken().toLowerCase();
		if ( name.equals("myself") || name.equals("self") )
		{
			obj_id[] chroniclers = { self };
			string firstName = getFirstName(self);
			pgc_quests.showChroniclerRatingTable(self, firstName, chroniclers);
		}
		else
		{
			obj_id[] chroniclers = pgcGetChroniclerId(name);
			pgc_quests.showChroniclerRatingTable(self, name, chroniclers);
		}
	}
	else 
	{
		target = null;
		obj_id intendedTarget = getIntendedTarget(self);
		if( !isIdValid(intendedTarget) )
		{
			target = getLookAtTarget(self);
			
		}
		else
		{
			target = intendedTarget;
		}

		if ( !isIdValid(target) )
		{
			sendSystemMessage(self, SID_PGC_RATING_TARGET_INVALID);
			return SCRIPT_CONTINUE;		
		}
		else if ( !isPlayer(target) )
		{
			sendSystemMessage(self, SID_PGC_RATING_TARGET_NOT_A_PLAYER);
			return SCRIPT_CONTINUE;		
		}
		else
		{
			obj_id[] chroniclers = { target };
			string firstName = getFirstName(target);
			pgc_quests.showChroniclerRatingTable(self, firstName, chroniclers);
		}
	}
	return SCRIPT_CONTINUE;
}

commandHandler chroniclerGetStoredXp()
{
	if ( sui.hasPid(self, "commandPid_chroniclerGetStoredXp") )
	{
		int oldPid = sui.getPid(self, "commandPid_chroniclerGetStoredXp");
		forceCloseSUIPage(oldPid);
	}
	
	int storedXp = 0;
	int storedSilverTokens = 0;
	int storedGoldTokens = 0;
	
	int[] pgcRatingData = pgcGetRatingData(self);
	if ( pgcRatingData != null && pgcRatingData.length > 0 )
	{
		storedXp = pgcRatingData[pgc_quests.PGC_STORED_CHRONICLE_XP_INDEX];
		storedXp = pgc_quests.getConfigModifiedChroniclesXPAmount(storedXp);

		storedSilverTokens = pgcRatingData[pgc_quests.PGC_STORED_CHRONICLE_SILVER_TOKENS_INDEX];

		storedGoldTokens = pgcRatingData[pgc_quests.PGC_STORED_CHRONICLE_GOLD_TOKENS_INDEX];
	}
	
	string storedXp_str = "" + storedXp;
	string storedSilverTokens_str = "" + storedSilverTokens;
	string storedGoldTokens_str = "" + storedGoldTokens;
	
	string[] templateSkills = skill_template.getSkillTemplateSkillsByTemplateName(pgc_quests.PGC_CHRONICLES_XP_TYPE);
	if ( templateSkills != null && templateSkills.length > 0 )
	{
		string finalChronicleSkill = templateSkills[templateSkills.length - 1];
		if ( hasSkill(self, finalChronicleSkill) )
		{
			storedXp_str = "Chronicle Master";
		}
	}

	// Create the dialog page
	int pid = sui.createSUIPage(sui.SUI_MSGBOX, self, self, "handleChroniclerGetStoredXp");

	// Add elements text
	string title = utils.packStringId(new string_id("saga_system", "chronicles_stored_data_title"));
	
	string prompt = utils.packStringId(new string_id("saga_system", "chronicles_stored_data_prompt")) + target_dummy.addLineBreaks(2);
	prompt += target_dummy.GREEN + utils.packStringId(new string_id("saga_system", "chronicles_stored_xp")) + target_dummy.WHITE + storedXp_str + target_dummy.addLineBreaks(1);
	prompt += target_dummy.GREEN + utils.packStringId(new string_id("saga_system", "chronicles_stored_silver_tokens")) + target_dummy.WHITE + storedSilverTokens_str + target_dummy.addLineBreaks(1);
	
	if ( storedGoldTokens > 0 )
	{
		prompt += target_dummy.GREEN + utils.packStringId(new string_id("saga_system", "chronicles_stored_gold_tokens")) + target_dummy.WHITE + storedGoldTokens_str + target_dummy.addLineBreaks(1);
	}
	
	setSUIProperty(pid, sui.MSGBOX_TITLE, sui.PROP_TEXT, title );
	setSUIProperty(pid, sui.MSGBOX_PROMPT, sui.PROP_TEXT, prompt);

	// Add buttons
	string OK_BUTTON = utils.packStringId(new string_id("saga_system", "chronicles_stored_data_claim"));
	string CANCEL_BUTTON = utils.packStringId(new string_id("saga_system", "chronicles_stored_data_cancel"));

	sui.msgboxButtonSetup(pid, sui.YES_NO);
	setSUIProperty(pid, sui.MSGBOX_BTN_OK, sui.PROP_TEXT, OK_BUTTON);
	setSUIProperty(pid, sui.MSGBOX_BTN_CANCEL, sui.PROP_TEXT, CANCEL_BUTTON);

	// Show dialog
	sui.showSUIPage( pid );
	
	sui.setPid(self, pid, "commandPid_chroniclerGetStoredXp");

	return SCRIPT_CONTINUE;
}

messageHandler handleChroniclerGetStoredXp()
{
	//check params
	if( params == null || params.isEmpty() )
	{
		return SCRIPT_CONTINUE;
	}
	
	//get players id
	obj_id player = sui.getPlayerId(params);
	
	if( !isIdValid(player) )
	{
		return SCRIPT_CONTINUE;
	}
	
	if( !sui.hasPid(player, "commandPid_chroniclerGetStoredXp") )
	{
		return SCRIPT_CONTINUE;
	}
	
	int playerPid = sui.getPid(player, "commandPid_chroniclerGetStoredXp");
	int suiPid = params.getInt("pageId");
	if ( playerPid != suiPid )
	{
		sui.removePid(player, "commandPid_chroniclerGetStoredXp");
		return SCRIPT_CONTINUE;
	}
	
	//get button pressed
	int bp = sui.getIntButtonPressed(params);
	
	//if they pressed cancel then we bail out and do nothing
	if ( bp == sui.BP_CANCEL )
	{
		sui.removePid(player, "commandPid_chroniclerGetStoredXp");
		return SCRIPT_CONTINUE;
	}
	
	string playerName = getName(player);
	
	int storedXp = 0;
	int storedSilverTokens = 0;
	int storedGoldTokens = 0;

	// Claim Chronicle XP and Tokens
	int[] pgcRatingData = pgcGetRatingData(player);
	if ( pgcRatingData != null && pgcRatingData.length > 0 )
	{
		storedXp = pgcRatingData[pgc_quests.PGC_STORED_CHRONICLE_XP_INDEX];	
		storedSilverTokens = pgcRatingData[pgc_quests.PGC_STORED_CHRONICLE_SILVER_TOKENS_INDEX];
		storedGoldTokens = pgcRatingData[pgc_quests.PGC_STORED_CHRONICLE_GOLD_TOKENS_INDEX];
	}
	
	boolean doneWithChronicleXP = false;
	string[] templateSkills = skill_template.getSkillTemplateSkillsByTemplateName(pgc_quests.PGC_CHRONICLES_XP_TYPE);
	if ( templateSkills != null && templateSkills.length > 0 )
	{
		string finalChronicleSkill = templateSkills[templateSkills.length - 1];
		if ( hasSkill(self, finalChronicleSkill) )
		{
			if ( storedXp > 0 )
			{
				pgcAdjustRatingData(player, playerName, pgc_quests.PGC_STORED_CHRONICLE_XP_INDEX, storedXp * -1);
			}
			
			storedXp = 0;
			doneWithChronicleXP = true;
		}
	}
	
	if ( storedXp > 0 )
	{
		pgc_quests.grantChronicleXp(player, storedXp);
		pgcAdjustRatingData(player, playerName, pgc_quests.PGC_STORED_CHRONICLE_XP_INDEX, storedXp * -1);
		
		// CS Log
		pgc_quests.logProgression(player, null, "Reserved Chronicle XP claimed = "+storedXp);

	}
	else
	{	// if they are still leveling Chronicles and have no xp stored, let them know.
		if ( !doneWithChronicleXP )
		{
			sendSystemMessage(self, new string_id("saga_system", "chronicles_stored_data_no_xp"));
		}
	}
		
	if ( storedSilverTokens > 0 )
	{
		pgc_quests.grantSilverChroniclesRewardTokens(player, storedSilverTokens);
		pgcAdjustRatingData(player, playerName, pgc_quests.PGC_STORED_CHRONICLE_SILVER_TOKENS_INDEX, storedSilverTokens * -1);
		
		// CS Log
		pgc_quests.logProgression(player, null, "Reserved Silver Chronicles Tokens claimed = "+storedSilverTokens);
	}
	if ( storedGoldTokens > 0 )
	{
		pgc_quests.grantGoldChroniclesRewardTokens(player, storedGoldTokens);
		pgcAdjustRatingData(player, playerName, pgc_quests.PGC_STORED_CHRONICLE_GOLD_TOKENS_INDEX, storedGoldTokens * -1);
		
		// CS Log
		pgc_quests.logProgression(player, null, "Reserved Gold Chronicles Tokens claimed = "+storedGoldTokens);
	}
	if ( storedSilverTokens <= 0 && storedGoldTokens <= 0 )
	{
		sendSystemMessage(self, new string_id("saga_system", "chronicles_stored_data_no_tokens"));
	}
	
	return SCRIPT_CONTINUE;
}

commandHandler chroniclesLootToggle()
{
	if ( sui.hasPid(self, "chroniclesLootToggle") )
	{
		int pid = sui.getPid(self, "chroniclesLootToggle");
		forceCloseSUIPage(pid);
		sui.removePid(self, "chroniclesLootToggle");
	}
	
	string okButton = "Disable Loot";
	string cancelButton = "Cancel";
	string currentStatus = "Enabled";
	
	if ( loot.hasToggledChroniclesLootOff(self) )
	{
		okButton = "Enable Loot";
		currentStatus = "Disabled";
	}
	
	string title = "Chronicles Loot Toggle";
	string textMsg = "Current Chronicles Loot Status: "+currentStatus;
	textMsg += target_dummy.addLineBreaks(2);
	textMsg += "Would you like to "+okButton+"?";

	int pid = sui.createSUIPage(sui.SUI_MSGBOX, self, self, "handleChroniclesLootToggleConfirmation");

	setSUIProperty(pid, sui.MSGBOX_TITLE, sui.PROP_TEXT, title );
	setSUIProperty(pid, sui.MSGBOX_PROMPT, sui.PROP_TEXT, textMsg);

	sui.msgboxButtonSetup(pid, sui.YES_NO);
	setSUIProperty(pid, sui.MSGBOX_BTN_OK, sui.PROP_TEXT, okButton);
	setSUIProperty(pid, sui.MSGBOX_BTN_CANCEL, sui.PROP_TEXT, cancelButton);

	sui.showSUIPage( pid );
	sui.setPid(self, pid, "chroniclesLootToggle");
	
	return SCRIPT_CONTINUE;
}

messageHandler handleChroniclesLootToggleConfirmation()
{
	if(params == null || params.isEmpty())
		return SCRIPT_CONTINUE;

	int bp = sui.getIntButtonPressed(params);
	if ( bp == sui.BP_CANCEL )
	{
		return SCRIPT_CONTINUE;
	}

	if(!sui.hasPid(self, "chroniclesLootToggle"))
		return SCRIPT_CONTINUE;
		
	sui.removePid(self, "chroniclesLootToggle");
	
	// if chronicles loot is currently off, turn it back on.
	// otherwise, turn it off.
	string message = "";
	if ( loot.hasToggledChroniclesLootOff(self) )
	{
		loot.enableChroniclesLoot(self);
		message = "chronicles_loot_back_on";
	}
	else
	{
		loot.disableChroniclesLoot(self);
		message = "chronicles_loot_now_off";
	}
	
	if ( message.length() > 0 )
	{
		sendSystemMessage(self, new string_id("saga_system", message));
	}
	return SCRIPT_CONTINUE;
}


/****************************************************************/
