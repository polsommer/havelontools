// -----------------------------------------------------------------------
// Base script that all other scripts derive from. Prints out debug info.
// -----------------------------------------------------------------------

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
//
//
//  DO NOT ADD TRIGGERS TO THE BOTTOM OF THIS SCRIPT UNLESS THEY ACTUALLY DO SOMETHING!!!
//  PUT SIMPLE TRIGGER PROTOTYPES IN THE "#ifdef SPAM" BLOCK!!!
//  AND COMMENT YOUR TRIGGERS SO THE DESIGNERS WILL KNOW HOW THEY ARE USED!!!
//
//
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/


include java.util.ArrayList;
include java.util.Iterator;
include java.util.Map;
include java.util.TreeMap;

#ifdef SPAM

trigger OnAttach()
{
	return SCRIPT_CONTINUE;
}

trigger OnDetach()
{
	return SCRIPT_CONTINUE;
}

trigger OnSpeaking(string text)
{
	return SCRIPT_CONTINUE;
}

trigger OnInitialize()
{
	return SCRIPT_CONTINUE;
}

trigger OnHearSpeech(obj_id speaker, string text)
{
	return SCRIPT_CONTINUE;
}

trigger OnHearSpeech(obj_id speaker, string_id text)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player performs an emote.
 *
 * @param self 		the player performing the emote
 * @param emote     the emote's name
 *
 * @return SCRIPT_CONTINUE to let the player perform the emote, SCRIPT_OVERRIDE to prevent the emote from happening
 */
trigger OnPerformEmote(string emote)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a creature sees another creature perform an emote nearby.
 *
 * @param self			the creature seeing the emote
 * @param performer		the creature performing the emote
 * @param emote			the emote string
 */
trigger OnSawEmote(obj_id performer, string emote)
{
	return SCRIPT_CONTINUE;
}

trigger OnInspected(obj_id inspector, string_id CONTINUETextId)
{
	return SCRIPT_CONTINUE;
}

trigger OnLogout()
{
 	return SCRIPT_CONTINUE;
}

trigger OnLogin()
{
 	return SCRIPT_CONTINUE;
}

trigger OnItemEquip(obj_id target, slot_data[] slots)
{
 	return SCRIPT_CONTINUE;
}

trigger OnItemUnequip(obj_id target, slot_data[] slots)
{
 	return SCRIPT_CONTINUE;
}

trigger OnTargetEquipsItem(obj_id item, slot_data[] slots)
{
 	return SCRIPT_CONTINUE;
}

trigger OnTargetUnequipsItem(obj_id item, slot_data[] slots)
{
 	return SCRIPT_CONTINUE;
}

trigger OnAboutToReceiveItem(obj_id srcContainer, obj_id transferer, obj_id item)
{
 	return SCRIPT_CONTINUE;
}

trigger OnReceivedItem(obj_id srcContainer, obj_id transferer, obj_id item)
{
	return SCRIPT_CONTINUE;
}

trigger OnAboutToBeTransferred(obj_id destContainer, obj_id transferer)
{
 	return SCRIPT_CONTINUE;
}

trigger OnTransferred(obj_id sourceContainer, obj_id destContainer, obj_id transferer)
{
 	return SCRIPT_CONTINUE;
}

trigger OnAboutToLoseItem(obj_id destContainer, obj_id transferer, obj_id item)
{
 	return SCRIPT_CONTINUE;
}

trigger OnLostItem(obj_id destContainer, obj_id transferer, obj_id item)
{
 	return SCRIPT_CONTINUE;
}

trigger OnLoadedFromDb()
{
 	return SCRIPT_CONTINUE;
}

trigger OnUnloadedFromMemory()
{
 	return SCRIPT_CONTINUE;
}

/**
 * Called when an object is disabled due to too much damage.
 *
 * @param self		the object that was just disabled
 * @param killer	who caused the object to be disabled
 *
 * @return ignored
 */
trigger OnObjectDisabled(obj_id killer)
{
	return SCRIPT_CONTINUE;
}

trigger OnDestroy()
{
 	return SCRIPT_CONTINUE;
}

trigger OnMadeAuthoritative()
{
 	return SCRIPT_CONTINUE;
}

/**
 * Called when a creature is incapacitated due to too much damage.
 *
 * @param self		the creature that was just incapacitated
 * @param killer	who caused the creature to be incapacitated
 *
 * @return ignored
 */
trigger OnIncapacitated(obj_id killer)
{
 	return SCRIPT_CONTINUE;
}

/**
 * Called when a creature is about to be incapacitated due to too much damage.
 *
 * @param self		the creature that is going to be incapacitated
 * @param killer	who caused the creature to be incapacitated
 *
 * @return SCRIPT_CONTINUE to allow the creature to become incapacitated, SCRIPT_OVERRIDE to prevent incapacitation
 */
trigger OnAboutToBeIncapacitated(obj_id killer)
{
 	return SCRIPT_CONTINUE;
}

trigger OnAboutToDie(obj_id killer)
{
 	return SCRIPT_CONTINUE;
}

trigger OnRecapacitated()
{
	return SCRIPT_CONTINUE;
}

trigger OnDeath(obj_id killer, obj_id corpseId)
{
 	return SCRIPT_CONTINUE;
}

trigger OnAddedToWorld()
{
	return SCRIPT_CONTINUE;
}

trigger OnRemovingFromWorld()
{
	return SCRIPT_CONTINUE;
}

trigger OnPreloadComplete()
{
	return SCRIPT_CONTINUE;
}

trigger OnBehaviorChange(int newBehavior, int oldBehavior, int[] changedTargetListsByBehavior)
{
	return SCRIPT_CONTINUE;
}

trigger OnBehaviorTargetChange(int currentBehavior, int[] changedTargetListsByBehavior)
{
	return SCRIPT_CONTINUE;
}

/*** Called on the npc when a conversation is initiated
*/
trigger OnStartNpcConversation(obj_id conversant)
{
	return SCRIPT_CONTINUE;
}

/*** Called on the npc when a conversation is completed
*/
trigger OnEndNpcConversation(obj_id conversant)
{
	return SCRIPT_CONTINUE;
}

trigger OnNpcConversationResponse(string conversationName, obj_id conversant, string_id response)
{
	return SCRIPT_CONTINUE;
}

/*** Called on the player when a conversation is initiated
*/
trigger OnStartConversation(obj_id conversant)
{
	return SCRIPT_CONTINUE;
}

/*** Called on the player when a conversation is completed
*/
trigger OnEndConversation(obj_id conversant)
{
	return SCRIPT_CONTINUE;
}

trigger OnResourceHarvesterSetActive(obj_id bogus, int active)
{
	return SCRIPT_CONTINUE;
}

trigger OnResourceHarvesterRequestActive(obj_id bogus)
{
	return SCRIPT_CONTINUE;
}

trigger OnResourceHarvesterRequestResourceData(obj_id bogus)
{
	return SCRIPT_CONTINUE;
}

trigger OnObjectMenuSelect(obj_id player, int item)
{
	return SCRIPT_CONTINUE;
}

trigger OnObjectMenuRequest(obj_id player, menu_info item)
{
	return SCRIPT_CONTINUE;
}

trigger GetStateDescription(modifiable_string_id name, modifiable_string_id description)
{
	return SCRIPT_CONTINUE;
}

trigger OnWanderMoving()
{
	return SCRIPT_CONTINUE;
}

trigger OnWanderWaypoint()
{
	return SCRIPT_CONTINUE;
}

trigger OnWanderWaiting(modifiable_float time)
{
	return SCRIPT_CONTINUE;
}

trigger OnWanderPathNotFound()
{
	return SCRIPT_CONTINUE;
}

trigger OnLoiterMoving()
{
	return SCRIPT_CONTINUE;
}

trigger OnLoiterWaypoint()
{
	return SCRIPT_CONTINUE;
}

trigger OnLoiterWaiting(modifiable_float time)
{
	return SCRIPT_CONTINUE;
}

trigger OnFollowTargetLost(obj_id oldTarget)
{
	return SCRIPT_CONTINUE;
}

trigger OnFollowWaiting(obj_id target)
{
	return SCRIPT_CONTINUE;
}

trigger OnFollowMoving(obj_id target)
{
	return SCRIPT_CONTINUE;
}

trigger OnFollowPathNotFound(obj_id target)
{
	return SCRIPT_CONTINUE;
}

trigger OnFleeTargetLost(obj_id oldTarget)
{
	return SCRIPT_CONTINUE;
}

trigger OnFleeWaypoint(obj_id target)
{
	return SCRIPT_CONTINUE;
}

trigger OnFleePathNotFound(obj_id oldTarget)
{
	return SCRIPT_CONTINUE;
}

trigger OnMovePathComplete()
{
	return SCRIPT_CONTINUE;
}

trigger OnMoveMoving()
{
	return SCRIPT_CONTINUE;
}

trigger OnMovePathNotFound()
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a creature changes posture.
 *
 * @param before		the posture before the change
 * @param after			the posture after the change
 *
 * @return ignored
 **/
trigger OnChangedPosture(int before, int after)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a creature enters deep enough water to start swimming.
 *
 * @param self		the creature swimming
 *
 * @return ignored
 **/
trigger OnEnterSwimming()
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a creature exits deep water and stops swimming.
 *
 * @param self		the creature that was swimming
 *
 * @return ignored
 **/
trigger OnExitSwimming()
{
	return SCRIPT_CONTINUE;
}

/******************************************************************************/

/**
 * \defgroup combat Combat system triggers
 * @{ */

/**
 * Called when an object is targeted for combat.
 *
 * @param self			the object being targeted
 * @param attacker		the object targeting
 *
 * @return ignored
 */
trigger OnTargeted(obj_id attacker)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when an object stops being targeted for combat.
 *
 * @param self			the object being untargeted
 * @param attacker		the object untargeting
 *
 * @return ignored
 */
trigger OnUntargeted(obj_id attacker)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when an loses it's current combat target
 *
 * @param self			the object that lost it's target
 * @param oldTarget		the object <self> was targeting before it lost the target
 *
 * @return ignored
 */
trigger OnLostTarget(obj_id oldTarget)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when an object enters combat.
 *
 * @param self			the object entering combat
 *
 * @return ignored
 */
trigger OnEnteredCombat()
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when an object exits combat.
 *
 * @param self			the object exits combat
 *
 * @return ignored
 */
trigger OnExitedCombat()
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when one object is being attacked by another.
 *
 * @param self 			the defender
 * @param attacker		the attacker id
 * @param weapon        the attacker's weapon id
 * @param combatResult  result of the attack, as given in the result member of the defender_results class
 *
 * @return if SCRIPT_OVERRIDE, the action will not take place
 */
trigger OnDefenderCombatAction( obj_id attacker, obj_id weapon, int combatResult )
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when one object has attacked another.
 *
 * @param self 			the attacker
 * @param weapon		the attacker's weapon id
 * @param defender		the defender id
 * @param hit			true if the attacker hit the defender
 * @param where			combat skeleton location where the defender was hit
 * @param fumble		true if the attacker fumbled
 * @param damage		damage done
 *
 * @return if SCRIPT_OVERRIDE, the action will not take place
 */
trigger OnAttackerCombatAction( obj_id weapon, obj_id defender, boolean hit, int where, boolean fumble, attrib_mod[] damage )
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a weapon is used in combat.
 *
 * @param self 			the weapon
 * @param attacker		the attacker id
 * @param defender		the defender id
 *
 * @return if SCRIPT_OVERRIDE, the action will not take place
 */
trigger OnWeaponCombatAction( obj_id attacker, obj_id defender )
{
	return SCRIPT_CONTINUE;
}

trigger OnIncapacitateTarget(obj_id victim)
{
 	return SCRIPT_CONTINUE;
}

/**
 * Called when an attacker's weapon runs out of ammo.
 *
 * @param self			the attacker
 * @param weapon		the attacker's weapon
 *
 * @return ignored
 **/
trigger OnOutOfAmmo(obj_id weapon)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a creature is damaged due to combat.
 *
 * @param self			the object being damaged
 * @param attacker		the object that caused the damage
 * @param weapon        the attacker's weapon id
 * @param damage		the damage amount
 *
 * @return ignored
 **/
trigger OnCreatureDamaged(obj_id attacker, obj_id weapon, int[] damage)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when an object is damaged due to combat.
 *
 * @param self			the object being damaged
 * @param attacker		the object that caused the damage
 * @param weapon        the attacker's weapon id
 * @param damage		the damage amount
 *
 * @return ignored
 **/
trigger OnObjectDamaged(obj_id attacker, obj_id weapon, int damage)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when an object has changed it's pvp type.
 * Pvp types are PVPTYPE_NEUTRAL, PVPTYPE_COVERT, and PVPTYPE_DECLARED.
 *
 * @param self			the object changing pvp type
 * @param oldState		the object's old pvp type
 * @param newState		the object's new pvp type
 *
 * @return ignored
 **/
trigger OnPvpTypeChanged(int oldType, int newType)
{
	return SCRIPT_CONTINUE;
}
/**
 * Called when an object has changed it's pvp faction.
 *
 * @param self			the object changing pvp faction
 * @param oldFaction		the object's old pvp faction
 * @param newFaction		the object's new pvp faction
 *
 * @return ignored
 **/
trigger OnPvpFactionChanged(int oldFaction, int newFaction)
{
	return SCRIPT_CONTINUE;
}
/**
 * Called when a player enters or leaves a player city.
 *
 * @param self  the player changing cities
 * @param oldCityId  the id of the city they were previously in
 * @param newCityId  the id of the city they are now in
 *
 * @return ignored
 **/
trigger OnCityChanged(int oldCityId, int newCityId)
{
	return SCRIPT_CONTINUE;
}

/*@}*/

/******************************************************************************/

/**
 * \defgroup crafting Crafting system triggers
 * @{ */

/**
 *	Determines which drafting schematics the player has can be used in the station.
 *	Must call sendUseableDraftSchematics() with a valid list of schematics.
 *
 * @param self 			crafting station
 * @param player		player wanting to craft
 * @param schematics	list of schematic template names the player has; these have already been filtered for station type
 *
 * @return SCRIPT_CONTINUE if the player is allowed to craft, SCRIPT_OVERRIDE if the player may not use this station
 **/
trigger OnRequestDraftSchematics(obj_id player, int[] schematics, float[] complexities)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player tries to add a resource to a slot during crafting. The trigger must determine if the player can place that
 * resource and how much of the resource is required. The resource will have already been checked to make sure it is a valid
 * type for the slot.
 *
 * @param player				the player crafting
 * @param resource				the resource the player is trying to add
 * @param ingredientSlot		info about the slot, including any resources that might already be in it
 * @param resourceAmount		the current number of resources for each resource. This will be filled with the current
 *                              amounts of each resource, plus an additinal entry for the new resource. The script
 *                              must set the new values of each resource. Note that you can only reduce the amount for
 *                              currently existing resources, increasing them will result as if SCRIPT_OVERRIDE was returned
 *
 * @return SCRIPT_CONTINUE if the resource can be added and resourceAmount has been set correctly, SCRIPT_OVERRIDE if the
 * resource can't be added
 */
trigger OnCraftingAddResource(obj_id player, obj_id resource, draft_schematic.slot ingredientSlot, modifiable_int[] resourceAmount)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when going from the assembly to the experimentation phase. Should determine the initial attributes
 * for the object being crafted and call setSchematicAttributes(). Should also set experimentPoints with the
 * initial experimentation points available to the crafter.
 *
 * @param self 					manufacturing schematic
 * @param player				player crafting
 * @param prototype				id of a test prototype object whose attributes can be changed and viewed by the player
 * @param schematic				data about the draft schematic and ingredients used in crafting
 * @param experimentPoints		to be filled in with the initial experiment points available to the player
 *
 * @return ignored
 **/
trigger OnManufacturingSchematicCreation(obj_id player, obj_id prototype, draft_schematic schematic, modifiable_int experimentPoints)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player tries experimenting with an object's attributes.
 *
 * @param self 				   	manufacturing schematic
 * @param player			   	player crafting
 * @param prototype			   	id of a test prototype object whose attributes can be changed and viewed by the player
 * @param attributes		   	experimental attribute names
 * @param experimentPoints	   	experiment points assigned to each attribute
 * @param totalPoints		   	total experiment points used
 * @param experimentResult		enum value giving the type of result for the experimentation
 * @param coreLevel                     Level of the core used in experimentation (weaponsmith only)
 *
 * @return ignored
 **/
trigger OnCraftingExperiment(obj_id player, obj_id prototype, string_id[] attributes, int[] experimentPoints, int totalPoints, modifiable_int experimentResult, int coreLevel)
{
	return SCRIPT_CONTINUE;
}

/**
 * Writes the final attibutes out to the manf scematic.
 *
 * @param self 			manufacturing schematic
 * @param player		player making the object (may or may not be the original crafter)
 * @param prototype		object being created
 * @param schematic     current schematic info
 *
 * @return ignored
 */
trigger OnFinalizeSchematic(obj_id player, obj_id newObject, draft_schematic schematic)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a object is being created from a manufacturing schematic. Should set the attributes of the object.
 *
 * @param self 			manufacturing schematic
 * @param player		player making the object (may or may not be the original crafter)
 * @param newObject		object being created
 * @param schematic     manf schematic data used to make the object
 * @param isPrototype   flag that the object being made is a prototype object or not
 *
 * @return SCRIPT_CONTINUE if the item is manufactured successfully, SCRIPT_OVERRIDE if the item should be destroyed
 **/
trigger OnManufactureObject(obj_id player, obj_id newObject, draft_schematic schematic, boolean isPrototype)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when we are creating a "fake" crafted item.
 *
 * @param self 					manufacturing schematic
 * @param prototype				id of a test prototype object whose attributes can be changed and viewed by the player
 * @param schematic				data about the draft schematic and ingredients used in crafting
 * @param qualityPercent		how good the item should be, 0 = worst, 100 = best
 *
 * @return ignored
 **/
trigger OnMakeCraftedItem(obj_id prototype, draft_schematic schematic, float qualityPercent)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called at the end of a crafting session.
 *
 * @param self 				crafting tool being used
 * @param player			player crafting
 * @param schematicName		the name of the draft schematic that was being used
 * @param craftingStage		the stage that the crafting session was in when it ended (see group craftingStages in base_class.java)
 * @param normalExit		flag that the crafting session ended normally or not
 *
 * @return ignored
 **/
trigger OnCraftingDone(obj_id player, string schematicName, int craftingStage, boolean normalExit)
{
	return SCRIPT_CONTINUE;
}

/**
 * This function is called when a request for resource weight information by a player is received.
 * It is not associated with any object, and is ok for self to be 0.
 *
 * @param player		   the player the data will be sent to
 * @param desiredAttribs   array of attrib names from the schematic
 * @param attribs		   array to be filled in with schematic attribute names - first for the assembly weights, and
 *               		   then for the resource max weights
 * @param counts		   array to be filled in with the number of resource attributes associated with each schematic attribute
 * @param data			   array to be filled in with the resource types and weights
 *
 * @return ignored
 */
trigger OnRequestResourceWeights(obj_id player, string[] desiredAttribs, string[] attribs, int[] counts, int[] data)
{
	return SCRIPT_CONTINUE;
}

/*@}*/

/** \defgroup missionMethods Mission system methods
	@{ */

/** 	@brief Invoked when a mission is granted to a player

	@param newMissionHolder  The obj_id of the player character receiving the mission

	@author Justin Randall
*/
trigger OnGrantMission(obj_id newMissionHolder)
{
	return SCRIPT_CONTINUE;
}

/** @brief This trigger is invoked when the player's
	temporary list of dynamic missions needs to be updated.

	This will be invoked when a player is first created, and
	each time the player requests a new mission list from the mission
	board. The player will see the old list first, which is then
	discarded for the new list after the old list has been
	displayed.

	@see addMissionToPlayerListRequest

	@author Justin Randall
*/
trigger OnPlayerRequestMissionBoard(obj_id player, obj_id missionTerminal, obj_id[] missionObjects)
{
	return SCRIPT_CONTINUE;
}

/* 	@} */



/**
 * This trigger is called when a location target set with addLocationTarget is reached.
 *
 * @see addLocationTarget
 * @param location The name of the location target
 * @return ignored
 */
trigger OnArrivedAtLocation(string location)
{
	return SCRIPT_CONTINUE;
}

/**
 * This trigger is called when a location target set with addLocationTarget is reached and then exited.
 * After this is called, the location target is removed.
 *
 * @see addLocationTarget
 * @param location The name of the location target
 * @return ignored
 */
trigger OnExitedLocation(string location)
{
	return SCRIPT_CONTINUE;
}

trigger OnMonitoredCreatureMoved(obj_id target, location observerDelta, location targetDelta, float time)
{
	return SCRIPT_CONTINUE;
}

trigger OnTriggerVolumeEntered(string volumeName, obj_id whoTriggeredMe)
{
	return SCRIPT_CONTINUE;
}

trigger OnTriggerVolumeExited(string volumeName, obj_id whoTriggeredMe)
{
	return SCRIPT_CONTINUE;
}

trigger OnAboutToOpenContainer(obj_id whoIsOpeningMe)
{
	return SCRIPT_CONTINUE;
}

trigger OnOpenedContainer(obj_id whoOpenedMe)
{
	return SCRIPT_CONTINUE;
}

trigger OnClosedContainer(obj_id whoClosedMe)
{
	return SCRIPT_CONTINUE;
}

trigger OnPlaceStructure(obj_id player, obj_id deed, location position, int rotation)
{
	return SCRIPT_CONTINUE;
}

trigger OnPermissionListModify(string name, string listName, string action)
{
	return SCRIPT_CONTINUE;
}

trigger OnPurchaseTicket(obj_id player, string departPlanetName, string departTravelPointName, string arrivePlanetName, string arriveTravelPointName, boolean roundTrip)
{
	return SCRIPT_CONTINUE;
}

trigger OnPurchaseTicketInstantTravel(obj_id player, string departPlanetName, string departTravelPointName, string arrivePlanetName, string arriveTravelPointName, boolean roundTrip)
{
	return SCRIPT_CONTINUE;
}

trigger OnGroupLeaderChanged(obj_id group, obj_id newLeader, obj_id oldLeader)
{
	return SCRIPT_CONTINUE;
}

trigger OnRemovedFromGroup(obj_id group)
{
	return SCRIPT_CONTINUE;
}

trigger OnGroupDisbanded(obj_id group)
{
	return SCRIPT_CONTINUE;
}

trigger OnAddedToGroup(obj_id group)
{
	return SCRIPT_CONTINUE;
}

trigger OnGroupFormed(obj_id group)
{
	return SCRIPT_CONTINUE;
}

trigger OnGroupMembersChanged(obj_id group, obj_id[] groupMembers, obj_id[] addedMembers, obj_id[] removedMembers)
{
	return SCRIPT_CONTINUE;
}

trigger OnLootLotterySelected(obj_id player_id, obj_id[] selection_ids)
{
	return SCRIPT_CONTINUE;
}

trigger OnUniverseComplete()
{
	return SCRIPT_CONTINUE;
}

trigger OnAuctionItem(obj_id item, modifiable_int errorCode)
{
	return SCRIPT_CONTINUE;
}

trigger OnQueryAuctions(obj_id who, obj_id location)
{
	return SCRIPT_CONTINUE;
}

trigger OnRequestAuctionFee(obj_id who, obj_id location, obj_id item, boolean premium, modifiable_int amount)
{
	return SCRIPT_CONTINUE;
}

trigger OnNewbieTutorialResponse(string response)
{
	return SCRIPT_CONTINUE;
}

trigger OnImmediateLogout()
{
	return SCRIPT_CONTINUE;
}

trigger OnSawAttack(obj_id defender, obj_id[] attackers)
{
	return SCRIPT_CONTINUE;
}

trigger OnGiveItem(obj_id item, obj_id player)
{
	return SCRIPT_CONTINUE;
}

trigger OnSurveyDataReceived(float[] xVals, float[] zVals, float[] efficiencies)
{
	return SCRIPT_CONTINUE;
}

trigger OnApplyPowerup (obj_id player, obj_id target)
{
	return SCRIPT_CONTINUE;
}

trigger OnImageDesignValidate(obj_id designerId, obj_id recipientId, obj_id terminalId, int startingTime, int designType, boolean newHairSet, String newHairAsset, String hairCustomizationData, int designerRequiredCredits, int recipientPaidCredits, boolean accepted, boolean doStatMigration, String[] morphChangesKeys, float[] morphChangesValues, String[] indexChangesKeys, int[] indexChangesValues, String holoEmote)
{
 	return SCRIPT_CONTINUE;
}

trigger OnImageDesignCompleted(obj_id designerId, obj_id recipientId, obj_id terminalId, int startingTime, int designType, boolean newHairSet, String newHairAsset, String hairCustomizationData, int designerRequiredCredits, int recipientPaidCredits, boolean accepted, boolean doStatMigration, String[] morphChangesKeys, float[] morphChangesValues, String[] indexChangesKeys, int[] indexChangesValues, String holoEmote)
{
 	return SCRIPT_CONTINUE;
}

trigger OnImageDesignCanceled()
{
 	return SCRIPT_CONTINUE;
}

trigger OnHibernateBegin()
{
 	return SCRIPT_CONTINUE;
}

trigger OnHibernateEnd()
{
 	return SCRIPT_CONTINUE;
}

/**
 * Called when a "magic" object's socket filled by a "gem". Note that this function is called after the socket has
 * been filled, so the socket count will have been reduced by 1, and the bonuses will have been applied. Also note
 * that the params skillModNames and bonuses are parallel arrays.
 *
 * @param self				the socketed object
 * @param skillModNames		names of the skill mods that were afffected by the "gem"
 * @param bonuses			the bonuses to each skill mod added by the "gem"
 *
 * @return ignored
 **/
trigger OnSocketUsed(string[] skillModNames, int[] bonuses)
{
	return SCRIPT_CONTINUE;
}

/**
 * Special trigger that should be attached to cloning facilities. This is used to tell the server
 * which tube the player should be respawned in.
 *
 * @param tubeIndex		to be filled with the index of the tube to respawn in
 *
 * @return ignored
 */
trigger OnGetRespawnLocation(modifyable_int tubeIndex)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a skill is about to be granted to a creature. Return script_override to prevent it from being granted.
 *
 * @param self		the creature the skill has been revoked from
 * @param skill		name of the skill that was revoked
 *
 * @return continue to allow the skill to be granted.  override to prevent it.
 */
trigger OnSkillAboutToBeGranted(string skill)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a skill has been granted to a creature. Note that this is called after the skill
 * has already been granted, the trigger cannot prevent the skill from being granted.
 *
 * @param self		the creature that has been granted the skill
 * @param skill		name of the skill that was granted
 *
 * @return ignored
 */
trigger OnSkillGranted(string skill)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called Called when a skill is about to be revoked from a creature. Return script_override to prevent it from being revoked.
 *
 * @param self		the creature the skill has been revoked from
 * @param skill		name of the skill that was revoked
 *
 * @return continue to allow the skill to be granted.  override to prevent it.
 */
trigger OnSkillAboutToBeRevoked(string skill)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a skill has been revoked from a creature. Note that this is called after the skill
 * has already been revoked, the trigger cannot prevent the skill from being revoked.
 *
 * @param self		the creature the skill has been revoked from
 * @param skill		name of the skill that was revoked
 *
 * @return ignored
 */
trigger OnSkillRevoked(string skill)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a named attrib mod times out, if addAttribModifier was called with the triggerOnDone flag set.
 *
 * @param self		the creature the mod is attached to
 * @param modName	the name of the attrib mod
 * @param isDead    flag that the mod ended due to the creature dying. Note that even if the flag is true the
 *                  function isDead() may return false on the creature if called in this function. This is not an error.
 *
 * @return ignored
 */
trigger OnAttribModDone(string modName, boolean isDead)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a named skillmod mod times out, if addSkillModModifier was called with the triggerOnDone flag set.
 *
 * @param self		the creature the mod is attached to
 * @param modName	the name of the skillmod mod
 * @param isDead    flag that the mod ended due to the creature dying. Note that even if the flag is true the
 *                  function isDead() may return false on the creature if called in this function. This is not an error.
 *
 * @return ignored
 */
trigger OnSkillModDone(string modName, boolean isDead)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when skillmods are added/removed from a player (or creature) due to equipping or unequipping an item.
 *
 * @param self			the creature the mods will be applied to
 * @param modNames		array of skillmod names that were changed by the item
 * @param modValues		array of values that were added to the creature (if the item is being removed, the values will be opposite of what they were when added)
 *
 * @return ignored
 */
trigger OnSkillModsChanged(string[] modNames, int[] modValues)
{
	return SCRIPT_CONTINUE;
}

trigger OnLocationReceived (string locationId, obj_id locationObject, location locationLocation, float locationRadius)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipWasHit (obj_id attacker, int weaponIndex, boolean isMissile, int missileType, int chassisSlot, boolean isPlayerAutoTurret, float hitLocationX_o, float hitLocationY_o, float hitLocationZ_o)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipFiredMissile(int missileId, int weaponIndex, int missileType, obj_id sourcePlayer, obj_id targetShip, int targetComponent)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipFiredCountermeasure(int weaponIndex, obj_id sourcePlayer)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipTargetedByMissile(int missileId, int weaponIndex, int missileType, obj_id sourceShip, obj_id sourcePlayer, int targetComponent)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipIsHitting (obj_id target, int weaponIndex, int chassisSlot)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipBehaviorChanged (int oldBehavior, int newBehavior)
{
	return SCRIPT_CONTINUE;
}

trigger OnFormCreateObject (string templateName, float xLoc, float yLoc, float zLoc, obj_id cellId, string[] keys, string[] values)
{
	return SCRIPT_CONTINUE;
}

trigger OnFormEditObject (obj_id editObject, string[] keys, string[] values)
{
	return SCRIPT_CONTINUE;
}

trigger OnFormRequestEditObject (obj_id objectToEdit, string keys[])
{
	return SCRIPT_CONTINUE;
}

trigger OnShipComponentPowerSufficient (int chassisSlot, float powerReceived)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipComponentPowerInsufficient (int chassisSlot, float powerRequired, float powerReceived)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipComponentInstalling (obj_id installerId, obj_id componentId, int slot)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipComponentInstalled (obj_id installerId, int slot)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipComponentUninstalling (obj_id uninstallerId, int slot, obj_id targetContainer)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipComponentUninstalled (obj_id uninstallerId, obj_id componentId, int slot, obj_id targetContainer)
{
	return SCRIPT_CONTINUE;
}

trigger OnDroppedItemOntoShipComponent (int slot, obj_id droppedItem, obj_id dropper)
{
	return SCRIPT_CONTINUE;
}

trigger OnTryToEquipDroidControlDeviceInShip (obj_id actor, obj_id droidControlDevice)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipHitByLightning(int frontBack, float damage)
{
	return SCRIPT_CONTINUE;
}

trigger OnShipHitByEnvironment(int frontBack, float damage)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when the player opens the character sheet and is to be used to force a recalculation of the food, drink, and meds.
 *
 * @param self		the player who opened their character sheet
 *
 * @return ignored
 */
trigger OnStomachUpdate()
{
 	return SCRIPT_CONTINUE;
}

trigger OnLocationReceived (string locationId, obj_id locationObject, location locationLocation, float locationRadius)
{
	return SCRIPT_CONTINUE;
}

trigger OnClusterWideDataResponse(string strManagerName, string strElementNameRegex, int requestID, string[] elementNameList, dictionary[] dictionaryList, int lockKey)
{
	return SCRIPT_CONTINUE;
}

trigger OnReceiveCharacterTransferStatusMessage(string message)
{
	return SCRIPT_CONTINUE;
}

trigger OnDownloadCharacter(byte[] targetData)
{
	return SCRIPT_CONTINUE;
}

trigger OnUploadCharacter(dictionary targetData)
{
	return SCRIPT_CONTINUE;
}

trigger OnWaypointCreated(obj_id waypoint)
{
	return SCRIPT_CONTINUE;
}

trigger OnWaypointDestroyed(obj_id waypoint)
{
	return SCRIPT_CONTINUE;
}

trigger OnWaypointGetAttributes(obj_id waypoint, obj_id player, string[] names, string[] attribs)
{
	return SCRIPT_CONTINUE;
}

trigger OnStartCharacterUpload(byte[] results, modifiable_int resultSize)
{
	return SCRIPT_CONTINUE;
}

trigger OnChatLogin()
{
	return SCRIPT_CONTINUE;
}

trigger OnContainerChildGainItem(obj_id item, obj_id source, obj_id transferer)
{
	return SCRIPT_CONTINUE;
}

trigger OnContainerChildLostItem(obj_id item, obj_id source, obj_id transferer, obj_id destination)
{
	return SCRIPT_CONTINUE;
}

trigger OnQuestActivated(int questRow)
{
	return SCRIPT_CONTINUE;
}

trigger OnTaskActivated(int questCrc, int taskId)
{
	return SCRIPT_CONTINUE;
}

trigger OnTaskCompleted(int questCrc, int taskId)
{
	return SCRIPT_CONTINUE;
}

trigger OnTaskFailed(int questCrc, int taskId)
{
	return SCRIPT_CONTINUE;
}

trigger OnTaskCleared(int questCrc, int taskId)
{
	return SCRIPT_CONTINUE;
}

trigger OnSomeTaskActivated(int questCrc, int taskId)
{
	return SCRIPT_CONTINUE;
}

trigger OnSomeTaskCompleted(int questCrc, int taskId)
{
	return SCRIPT_CONTINUE;
}

trigger OnSomeTaskFailed(int questCrc, int taskId)
{
	return SCRIPT_CONTINUE;
}

trigger OnSomeTaskCleared(int questCrc, int taskId)
{
	return SCRIPT_CONTINUE;
}

trigger OnCraftedPrototype(obj_id prototype,  draft_schematic schematic)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when all the objects of a theater have been created.
 *
 * @param self		the master theater object
 * @param objects	the ids of the objects that have been created
 * @param player	the player the theater was created for. This will be an invalid
 *              	id if the theater wasn't created to spawn for a specific player.
 * @param creator   the id of the object that created the theater
 *
 * @return ignored
 */
trigger OnTheaterCreated(obj_id[] objects, obj_id player, obj_id creator)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player theater fails to get created.
 *
 * @param self			the player the theater was being created for
 * @param datatable     the datatable the theater was going to be created from
 * @param name			the theater's name, if one was given
 *
 * @return ignored
 */
trigger OnPlayerTheaterFail(string datatable, string name)
{
	return SCRIPT_CONTINUE;
}

trigger OnEnterRegion(string planetName, string regionName)
{
	return SCRIPT_CONTINUE;
}

trigger OnExitRegion(string planetName, string regionName)
{
	return SCRIPT_CONTINUE;
}

//When the commodities server sends a message to a game server telling it how many items
//a given vendor has, this is called on the vendor.  Item count is how many items the vendor has
trigger OnVendorItemCountReply(int itemCount)
{
	return SCRIPT_CONTINUE;
}

//When a vendor changes status from active, empty, inactive, or endangered, this is called
trigger OnVendorStatusChange(int newStatus)
{
	return SCRIPT_CONTINUE;
}

//When a player wants to create a new vendor, this is called
trigger OnPlayerVendorCountReply(int vendorCount)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player has been given a schematic. NOTE: we don't persist schematic data between sessions,
 * so this trigger will get called for every schematic a player has when they log in.
 *
 * @param self				the player
 * @param schematicCrc      the schematic template crc value
 * @param fromSkill			flag that the schematic was granted via a skill the player has
 *
 * @return ignored
 */
trigger OnGrantedSchematic(int schematicCrc, boolean fromSkill)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player has had a schematic revoked.
 *
 * @param self				the player
 * @param schematicCrc      the schematic template crc value
 * @param fromSkill			flag that the schematic was revoked due to a player losing a skill
 *
 * @return ignored
 */
trigger OnRevokedSchematic(int schematicCrc, boolean fromSkill)
{
	return SCRIPT_CONTINUE;
}

trigger OnForceSensitiveQuestCompleted(String questName, boolean succeeded)
{
	// this is a special trigger called by quests.scriptlib
	return SCRIPT_CONTINUE;
}

trigger OnQuestCompleted(int questCrc)
{
	return SCRIPT_CONTINUE;
}

trigger OnQuestReceivedReward(int questCrc, String exclusiveLootChoice)
{
	return SCRIPT_CONTINUE;
}

trigger OnQuestCleared(int questCrc)
{
	return SCRIPT_CONTINUE;
}

trigger OnSpaceUnitMoveToComplete()
{
	return SCRIPT_CONTINUE;
}

trigger OnSpaceUnitBehaviorChanged(int oldBehavior, int newBehavior)
{
	return SCRIPT_CONTINUE;
}

trigger OnSpaceUnitFollowLost(obj_id followedUnit)
{
	return SCRIPT_CONTINUE;
}

trigger OnSpaceUnitDocked(obj_id dockTarget)
{
	return SCRIPT_CONTINUE;
}

trigger OnSpaceUnitUnDocked(obj_id dockTarget, boolean dockSuccessful)
{
	return SCRIPT_CONTINUE;
}

trigger OnSpaceUnitEnterCombat(obj_id attackTarget)
{
	return SCRIPT_CONTINUE;
}

trigger OnAboutToLaunchIntoSpace(obj_id player, obj_id shipControlDevice, obj_id[] membersApprovedByShipOwner, string destinationGroundPlanet, string destinationGroundTravelPoint)
{
	return SCRIPT_CONTINUE;
}

trigger OnSpaceUnitStartUnDock(obj_id dockTarget)
{
	return SCRIPT_CONTINUE;
}

trigger OnAiPrimaryWeaponEquipped(obj_id primaryWeapon)
{
	return SCRIPT_CONTINUE;
}

trigger OnAiSecondaryWeaponEquipped(obj_id secondaryWeapon)
{
	return SCRIPT_CONTINUE;
}

trigger OnAiTetherStart()
{
	return SCRIPT_CONTINUE;
}

trigger OnAiTetherComplete()
{
	return SCRIPT_CONTINUE;
}

trigger OnHateTargetChanged(obj_id target)
{
	return SCRIPT_CONTINUE;
}

trigger OnHateTargetAdded(obj_id target)
{
	return SCRIPT_CONTINUE;
}

trigger OnHateTargetRemoved(obj_id target)
{
	return SCRIPT_CONTINUE;
}

trigger OnInvulnerableChanged(boolean invulnerable)
{
	return SCRIPT_CONTINUE;
}

trigger OnAiCombatFrame()
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player needs to be ejected from a ship.
 * The actual responsibility of ejecting a player is handled by script!!!
 *
 * @param self				the player
 *
 * @return ignored
 */
trigger OnSpaceEjectPlayerFromShip()
{
	return SCRIPT_CONTINUE;
}

trigger OnCommitDroidProgramCommands(obj_id droidControlDevice, string[] commands, obj_id[] chipsToAdd, obj_id[] chipsToRemove)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player needs to be ejected from a ship.
 * The actual responsibility of ejecting a player is handled by script!!!
 *
 * @param self				the player
 *
 * @return ignored
 */
trigger OnSpaceEjectPlayerFromShip()
{
	return SCRIPT_CONTINUE;
}

trigger OnCommitDroidProgramCommands(obj_id droidControlDevice, string[] commands, obj_id[] chipsToAdd, obj_id[] chipsToRemove)
{
	return SCRIPT_CONTINUE;
}

/**
*/

trigger OnShipInternalDamageOverTimeRemoved(int chassisSlot, float damageRate, float damageThreshold)
{
	return SCRIPT_CONTINUE;
}

/**
*/

trigger OnShipDamagedByInternalDamageOverTime(int chassisSlot, float damageRate, float damageThreshold, float damageThisTick)
{
	return SCRIPT_CONTINUE;
}

/**
*/

trigger OnBeginWarmup( string command, int group, int group2, float[] times, string params, obj_id target )
{
	return SCRIPT_CONTINUE;
}

/**
*/

trigger OnBuildoutObjectRegisterWithController(obj_id registeringObject)
{
	return SCRIPT_CONTINUE;
}

trigger OnCyberneticChangeRequest(obj_id player, int changeType, obj_id cyberneticPiece)
{
	return SCRIPT_CONTINUE;
}

trigger OnSpaceMiningSellResource(obj_id player, obj_id ship, obj_id station, obj_id resourceId, int amount)
{
	return SCRIPT_CONTINUE;
}

trigger OnDoStructureRollup(obj_id playerOwner, boolean warnOnly)
{
	return SCRIPT_CONTINUE;
}

trigger OnUnsticking()
{
	return SCRIPT_CONTINUE;
}

trigger OnRequestStaticItemData(string lootItemName)
{
	return SCRIPT_CONTINUE;
}

/**
 * Triggered when the player's skill template is changed.
 *
 * @param skillTemplateName        - A template from skill_template.tab
 * @param clientSelected           - Did the player select this value on the client.
 *
 * @return SCRIPT_CONTINUE         - Allow/ignore the change.
 * @return SCRIPT_DEFAULT          - Do not allow this change.
 * @return SCRIPT_OVERRIDE         - The trigger modified the skill template.
  */

trigger OnSkillTemplateChanged(string skillTemplateName, boolean clientSelected)
{
	return SCRIPT_CONTINUE;
}

/**
 * Triggered when the player's working skill is changed.
 *
 * @param workingSkillName         - A skill from skill_template.tab
 * @param clientSelected           - Did the player select this value on the client.
 *
 * @return SCRIPT_CONTINUE         - Allow/ignore the change.
 * @return SCRIPT_DEFAULT          - Do not allow this change.
 * @return SCRIPT_OVERRIDE         - The trigger modified the working skill.
  */

trigger OnWorkingSkillChanged(string workingSkillName, boolean clientSelected)
{
	return SCRIPT_CONTINUE;
}


trigger OnCombatLevelChanged(int oldCombatLevel, int newCombatLevel)
{
    	return SCRIPT_CONTINUE;
}


trigger OnReceiveCharacterTransferStatusMessage(string message)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player's locomotion state changes
 * the values that the parameters map to are in Locomotions.def
 */
trigger OnLocomotionChanged(int newLocomotion, int oldLocomotion)
{
	return SCRIPT_CONTINUE;
}

trigger OnEnvironmentalDamage()
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player requests info about a static loot item name. The trigger should fill
 * in a localization name and attribute value for each attribute it wants
 * the player to know about.
 *
 * @param self				the player requesting the attributes
 * @param staticItemName	the player requesting the attributes
 * @param names				localization name of the attributes
 * @param attribs			value of the attributes
 */
trigger OnGetStaticItemsAttributes(string staticItemName, string[] names, string[] attribs)
{
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player has requested to be sent to his home location
 * from space. Gets called after all countdowns, etc have happened, and 
 * starts the actual hyperspace warp
*/

trigger OnHyperspaceToHomeLocation()
{
	return SCRIPT_CONTINUE;
}

trigger OnCSCreateItem(obj_id object, string staticItemName)
{
	return SCRIPT_CONTINUE;
}

trigger OnCustomizeFinished(obj_id object, string params)
{
	return SCRIPT_CONTINUE;
}

trigger OnPvpRankingChanged(int oldRank, int newRank)
{
	return SCRIPT_CONTINUE;
}


/**
 * buff builder related
*/

trigger OnBuffBuilderValidate(obj_id bufferId, obj_id recipientId, int startingTime, int bufferRequiredCredits, int recipientPaidCredits, boolean accepted, String[] buffComponentKeys, int[] buffComponentValues)
{
 	return SCRIPT_CONTINUE;
}

trigger OnBuffBuilderCompleted(obj_id bufferId, obj_id recipientId, int startingTime, int bufferRequiredCredits, int recipientPaidCredits, boolean accepted, String[] buffComponentKeys, int[] buffComponentValues)
{
 	return SCRIPT_CONTINUE;
}

trigger OnBuffBuilderCanceled()
{
 	return SCRIPT_CONTINUE;
}

/**
 * @param self player requesting pack
 * @param building building to be packed
 */
trigger OnContentsLoadedForBuildingToBePacked(obj_id building)
{
	return SCRIPT_CONTINUE;
}

/**
 *incubator related
 */ 
 
trigger OnIncubatorCommitted(
	obj_id playerId, 
	obj_id terminalId,
	obj_id slot1Id,
	obj_id slot2Id,
	obj_id slot3Id,
	obj_id slot4Id,
	int initialPointsSurvival, 
	int initialPointsBeastialResilience,
	int initialPointsCunning,
	int initialPointsIntelligence,
	int initialPointsAggression,
	int initialPointsHuntersInstinct,
	int totalPointsSurvival,
	int totalPointsBeastialResilience,
	int totalPointsCunning,
	int totalPointsIntelligence,
	int totalPointsAggression,
	int totalPointsHuntersInstinct,
	int temperatureGauge,
	int nutrientGauge,
	int newCreatureColorIndex
)
{
	return SCRIPT_CONTINUE;
}

trigger OnIncubatorCancelled(obj_id playerId, obj_id terminalId)
{
	return SCRIPT_CONTINUE;
}

trigger OnCollectionSlotModified(string bookName, string pageName, string collectionName, string slotName, boolean isCounterTypeSlot, int previousValue, int currentValue, int maxSlotValue, boolean slotCompleted)
{
	return SCRIPT_CONTINUE;
}

trigger OnCollectionServerFirst(string bookName, string pageName, string collectionName)
{
	return SCRIPT_CONTINUE;
}

trigger DoCreateVeteranReward(string[] rewardItemName)
{
	return SCRIPT_CONTINUE;
}

trigger OnGroundTargetLoc(obj_id playerId, int menuItem, float x, float y, float z)
{
	return SCRIPT_CONTINUE;
}

/*
OnDuelRequest - Triggered anytime you either request or accept a duel with another player

Returning SCRIPT_OVERRIDE will cause the duel request/acceptance to terminate.
*/
trigger OnDuelRequest(obj_id actor, obj_id target)
{
	return SCRIPT_CONTINUE;
}

/*
OnDuelStart - Triggered when a duel is started.

Return type currently is ignored.
*/
trigger OnDuelStart(obj_id actor, obj_id target)
{
	return SCRIPT_CONTINUE;
}

/*
OnAboutToChangeAppearance - Triggered when a user's appearance is about to change via a buff or admin command.

Returning SCRIPT_OVERRIDE will prevent the change from occuring.
*/
trigger OnAboutToChangeAppearance(obj_id actor, string appearance)
{

	return SCRIPT_CONTINUE;
}
/*
OnAboutToRevertAppearance - Triggered when a user's appearance is about to revert to it's original appearance(i.e. back to normal)

Returning SCRIPT_OVERRIDE will prevent the change from occuring.
*/
trigger OnAboutToRevertAppearance(obj_id actor)
{
	return SCRIPT_CONTINUE;
}

trigger OnAboutToTravelToGroupPickupPoint()
{
	return SCRIPT_CONTINUE;
}

trigger OnTravelToGroupPickupPoint(string planetName, string travelPointName)
{
	return SCRIPT_CONTINUE;
}

trigger OnChangedAppearance(obj_id actor)
{
	return SCRIPT_CONTINUE;
}

trigger OnRevertedAppearance(obj_id actor)
{
	return SCRIPT_CONTINUE;
}

trigger OnDynamicSpawnRegionCreated(obj_id regionObject, string spawnDatatable, float x, float y, float z)
{
	return SCRIPT_CONTINUE;
}

trigger DoRestoreItemDecorationLayout(obj_id item, obj_id cell, location loc, boolean restoreRotation, float qw, float qx, float qy, float qz)
{
	return SCRIPT_CONTINUE;
}

trigger DoRestoreItemDecorationLayoutRotationOnly(obj_id item, float qw, float qx, float qy, float qz)
{
	return SCRIPT_CONTINUE;
}

trigger OnRatingFinished(int rating)
{
	return SCRIPT_CONTINUE;
}

trigger OnAbandonPlayerQuest(obj_id playerQuest)
{
	return SCRIPT_CONTINUE;
}

trigger OnGcwScoreCategoryPercentileChange(string gcwScoreCategory, int previousImperialScorePercentile, int currentImperialScorePercentile)
{
	return SCRIPT_CONTINUE;
}

#endif // SPAM

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
//
//
//  DO NOT ADD TRIGGERS TO THE BOTTOM OF THIS SCRIPT UNLESS THEY ACTUALLY DO SOMETHING!!!
//  PUT SIMPLE TRIGGER PROTOTYPES IN THE "#ifdef SPAM" BLOCK!!!
//  AND COMMENT YOUR TRIGGERS SO THE DESIGNERS WILL KNOW HOW THEY ARE USED!!!
//
//
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

messageHandler OnLocateObject()
{
	location l = getLocation(self);
	obj_id requestor = params.getObjId("requestor");
	if(requestor != null)
	{
		String callbackMethod = params.getString("callback");
		if(callbackMethod != null)
		{
			params.put("location", l);
			messageTo(requestor, callbackMethod, params, 0, false);
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler OnSetWaypointActive()
{
	obj_id waypoint = params.getObjId("waypoint");
	if(waypoint != null)
	{
		boolean isActive = params.getBoolean("isActive");
		_setWaypointActiveNative(waypoint, isActive);
	}
	return SCRIPT_CONTINUE;
}

messageHandler OnSetWaypointLocation()
{
	obj_id waypoint = params.getObjId("waypoint");
	if(waypoint != null)
	{
		location loc = params.getLocation("loc");
		if(loc != null)
		{
			_setWaypointLocationNative(waypoint, loc);
		}
	}
	return SCRIPT_CONTINUE;
}

int getFirstFreeIndex(string[] array)
{
	if ( array != null )
	{
		for (int i = 0; i < array.length; i++)
		{
			if (array[i] == null || array[i].length() == 0)
				return i;
		}
	}
	return -1;
}

void dumpObjvars(obj_id s, obj_var_list objvars, string[] names, string[] attribs)
{
	if (s == null || objvars == null || names == null || attribs == null || names.length != attribs.length)
		return;

	int count = objvars.getNumItems();
	int elem = getFirstFreeIndex(names);
	for (int i = 0; i < count && elem >= 0 && elem < names.length; ++i)
	{
		obj_var o = objvars.getObjVar(i);
		if (o != null)
		{
			if (o instanceof obj_var_list)
			{
				dumpObjvars(s, (obj_var_list)o, names, attribs);
				elem = getFirstFreeIndex(names);
			}
			else
			{
				string name = "\"" + o.getName();
				Object v = o.getData();
				if (v != null)
				{
					string val = v.toString();
					names[elem] = name;
					attribs[elem] = val;
					elem++;
				}
			}
		}
	}
}

void dumpScriptvars(string[] names, string[] attribs)
{
	if ((names == null) || (attribs == null) || (names.length != attribs.length))
		return;

	int i = getFirstFreeIndex(names);
	if (i != -1 && i < names.length)
	{
		const obj_id self = getSelf();
		deltadictionary scriptvars = self.getScriptVars();
		java.util.Enumeration keys = scriptvars.keys();
		names[i] = "\"***SCRIPTVARS***";
		attribs[i] = "******";
		i++;

		Map sortedValues = new TreeMap();
		while (keys.hasMoreElements() && i < names.length)
		{
			Object k = keys.nextElement();
			String oldname = "\"" + k.toString();
			String name = oldname.replace('.', '+');
			debugServerConsoleMsg(self, "scriptvar name: " + name);
			Object v = scriptvars.getObject(k);
			String attrib = v.toString();

			sortedValues.put(name, attrib);
		}

		Iterator keysSet = sortedValues.keySet().iterator();

		while(keysSet.hasNext() && i < names.length)
		{
			names[i] = (String)keysSet.next();
			attribs[i] = (String)sortedValues.get((String)names[i]);
			++i;
		}
	}
}

trigger OnGetScriptvars(obj_id player, string[] names, string[] attribs)
{
	// if the player is an admin/gm, list object variabls and scriptvars
	// as well
	if (player != null)
	{
		// we only want this function to do stuff if we are the last script attached
		ArrayList scripts = self.getScriptArrayList();
		if ( scripts == null || scripts.size() == 0)
			return SCRIPT_CONTINUE;

		string lastScript = (string)(scripts.get(scripts.size()-1));
		if ( lastScript == null )
			return SCRIPT_CONTINUE;

		if ( !lastScript.equals(getClass().getName()) )
			return SCRIPT_CONTINUE;

		if (isGod(player))
		{
			dumpScriptvars(names, attribs);
		}
	}
	return SCRIPT_CONTINUE;
}

/**
 * Called when a player requests info about an object. The trigger should fill
 * in a localization name and attribute value for each attribute it wants
 * the player to know about.
 *
 * @param self		the object being queried
 * @param player    the player requesting the attributes
 * @param names		localization name of the attributes
 * @param attribs	value of the attributes
 */
trigger OnGetAttributes(obj_id player, string[] names, string[] attribs)
{
	if ((names == null) || (attribs == null) || (names.length != attribs.length))
		return SCRIPT_CONTINUE;

	// if the player is an admin/gm, list object variabls and scriptvars
	// as well
	if (player != null)
	{
		// we only want this function to do stuff if we are the last script attached
		ArrayList scripts = self.getScriptArrayList();
		if ( scripts == null || scripts.size() == 0)
			return SCRIPT_CONTINUE;

		string lastScript = (string)(scripts.get(scripts.size()-1));
		if ( lastScript == null )
			return SCRIPT_CONTINUE;

		if ( !lastScript.equals(getClass().getName()) )
			return SCRIPT_CONTINUE;

		if (isGod(player))
		{
			dumpScriptvars(names, attribs);

			const int firstFreeIndex = getFirstFreeIndex(names);

			if (   (firstFreeIndex >= 0)
			    && (firstFreeIndex < names.length))
			{
				names[firstFreeIndex] = "\"***OBJVARS***";
				attribs[firstFreeIndex] = "******";
			}

			obj_var_list rootList = getObjVarList(self, "");
			if (rootList != null)
			{
				dumpObjvars(self, rootList, names, attribs);
			}
		}
	}
	return SCRIPT_CONTINUE;
}

string UploadCharacter(obj_id player)
{
	dictionary params = new dictionary();
	Object[] triggerParams = new Object[2];
	triggerParams[0] = player;
	triggerParams[1] = params;

	try
	{
		int err = script_entry.runScripts("OnUploadCharacter", triggerParams);
		if(err == SCRIPT_CONTINUE)
		{
			byte[] packedData = params.pack();
			return new string(packedData);
		}
	}
	catch(Throwable t)
	{
		return null;
	}

	return null;
}
string DownloadCharacter(obj_id player, string packedData)
{
	byte[] data = packedData.getBytes();
	dictionary params = dictionary.unpack(data);

	Object[] triggerParams = new Object[2];
	triggerParams[0] = player;
	triggerParams[1] = params;
	try
	{
		script_entry.runScripts("OnDownloadCharacter", triggerParams);
	}
	catch(Throwable t)
	{
		return null;
	}
	return "OK";
}



/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
//
//
//  DO NOT ADD TRIGGERS TO THE BOTTOM OF THIS SCRIPT UNLESS THEY ACTUALLY DO SOMETHING!!!
//  PUT SIMPLE TRIGGER PROTOTYPES IN THE "#ifdef SPAM" BLOCK!!!
//  AND COMMENT YOUR TRIGGERS SO THE DESIGNERS WILL KNOW HOW THEY ARE USED!!!
//
//
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

