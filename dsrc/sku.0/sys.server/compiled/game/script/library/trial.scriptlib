include library.beast_lib;
include library.utils;
include library.colors;
include library.space_dungeon;
include library.stealth;
include library.attrib;
include library.prose;



const string MESSAGE_SESSION			= "messageTo.session";
const string WP_OBJECT				= "object/tangible/ground_spawning/patrol_waypoint.iff";
const string PARENT				= "parent";
const string ARRAY_CHILDREN			= "parent.tempChildren";
const string TEMP_OBJECT			= "tempObject";
const string WP_NAME				= "wp_name";


const boolean LOGGING				= false;

//************************
//Quest Signals

const string UPLINK_WIN_SIGNAL			="mustafar_uplink_established";
const string DECREPIT_ENTER_SIGNAL		="mustafar_factory_found";
const string DECREPIT_WIN_SIGNAL		="mustafar_factory_fixed";
const string ARMY_WIN_SIGNAL			="mustafar_droidarmy_victory";
const string WORKING_ENTER_SIGNAL		="mustafar_droidfactory_final";
const string WORKING_WIN_SIGNAL			="mustafar_droidfactory_shutdown";
const string VOLCANO_ENTER_SIGNAL		="volcano_arena_pilot";
const string VOLCANO_WIN_SIGNAL			="volcano_arena_victory";

//*************************
//Decrepit Droid Factory

const string DECREPIT_STF			= "mustafar/decrepit_droid_factory";
const string_id SID_NOT_LOCKED			= new string_id(DECREPIT_STF, "decrepit_not_locked");
const string_id SID_ACCESS_GRANTED		= new string_id(DECREPIT_STF, "access_granted");

const string DECREPIT_MAIN_HALL			= "mainroom27";
const string DECREPIT_ONE_TWO_STAIR		= "hall2";
const string DECREPIT_TWO_THREE_STAIR		= "hall5";
const string DECREPIT_TRAP_ROOM			= "smallroom4";
const string DECREPIT_PRE_TRAP_ROOM		= "smallroom5";
const string DECREPIT_ENVIRONMENTAL		= "smallroom12";
const string DECREPIT_FIRE_CELL_EXIT		= "hall15";
const string DECREPIT_FINAL_ROOM		= "centralroom28";
const string[] FIRE_CELLS			= {"mediumroom10","smallroom11","smallroom12","hall13"};

const string SECOND_ACCESS_BASE			= "second_floor_access";
const string ACCESS_CODE			= SECOND_ACCESS_BASE+".code";
const string RESET_CODE				= SECOND_ACCESS_BASE+".reset";
const int RESET_TIMER				= 20;
const int SENSOR_RESET_TIME			= 4;

const string TRAP_STATE				= "trap_state";
const string SENSOR_STATE			= "sensor_state";
const string FIRE_CELL_STATE			= "fire_cell_state";
const string POWER_CORE_STATE			= "power_core_state";
const string GUARDIAN_LOCK_STATE		= "guardian_lock_state";
const string DECREPIT_VICTORY_STATE		= "decrepit_victory_state";

//**********************************
//Working Droid Factory
const string WORKING_STF			= "mustafar/working_droid_factory";
const string_id TWINS_RESPAWN			= new string_id (WORKING_STF, "twin_respawn");
const string_id TWINS_DEFEATED			= new string_id (WORKING_STF, "twin_defeated");
const string_id TWINS_LOCK_ACTIVE		= new string_id (WORKING_STF, "access_denied");
const string_id TWINS_KILL_CLUE			= new string_id (WORKING_STF, "twin_kill_clue");

const string_id WORKING_DEVISTATOR_DEFEATED	= new string_id (WORKING_STF, "devistator_defeated");
const string_id WORKING_INHIBITOR_NOCHARGE	= new string_id (WORKING_STF, "inhibitor_lost_charge");
const string_id WORKING_INHIBITOR_RECHARGE	= new string_id (WORKING_STF, "inhibitor_recharging");
const string_id WORKING_INHIBITOR_INACTIVE	= new string_id (WORKING_STF, "inhibitor_inactive");
const string_id WORKING_INHIBITOR_COLLECT	= new string_id (WORKING_STF, "inhibitor_collect");
const string_id WORKING_INHIBITOR_TAKEN		= new string_id (WORKING_STF, "inhibitor_taken");
const string_id WORKING_RRU_OP_CLUE		= new string_id (WORKING_STF, "rru_clue");
const string_id WORKING_RRU_INACTIVE		= new string_id (WORKING_STF, "rru_inactive");
const string_id WORKING_RRU_ACTIVE		= new string_id (WORKING_STF, "rru_active");
const string_id WORKING_RRU_FALTER		= new string_id (WORKING_STF, "rru_falter");
const string_id WORKING_RRU_RECHARGE		= new string_id (WORKING_STF, "rru_recharge");
const string_id WORKING_MDE_DEFEATED		= new string_id (WORKING_STF, "mde_defeated");
const string_id WORKING_MDE_TAUNT		= new string_id (WORKING_STF, "mde_taunt");
const string_id WORKING_DOOM_DEFEATED		= new string_id (WORKING_STF, "doom_defeated");
const string_id WORKING_DOOM_FAILURE		= new string_id (WORKING_STF, "doom_failure");
const string_id WORKING_HK47_TAUNT		= new string_id (WORKING_STF, "hk47_taunt");
const string_id WORKING_DUALITY_APPLY		= new string_id (WORKING_STF, "duality_applied");
const string_id WORKING_IMBALANCE_APPLY		= new string_id (WORKING_STF, "imbalance_applied");
const string_id WORKING_IMBALANCE_FADE		= new string_id (WORKING_STF, "imbalance_fade");
const string_id WORKING_OBSERVER_DETONATE	= new string_id (WORKING_STF, "observer_detonate");


const string WORKING_MAIN_HALL			= "mainroom27";
const string WORKING_ONE_TWO_STAIR		= "hall2";
const string WORKING_TWO_THREE_STAIR		= "hall7";
const string WORKING_DE_HALL			= "hall13";
const string WORKING_MASTER_CONTROL		= "centralroom28";

const string WORKING_CLONER_EXIT		= "mdeClonerExit";

const string OBJECT_INHIBITOR			= "object/tangible/dungeon/mustafar/working_droid_factory/inhibitor_storage.iff";
const string OBJECT_REACTIVE_REPAIR		= "object/tangible/dungeon/mustafar/working_droid_factory/reactive_repair_module.iff";
const string OBJECT_DE_CLONER			= "object/tangible/dungeon/mustafar/working_droid_factory/rapid_assembly_station.iff";
const string OBJECT_DECTRUCT_PILE		= "object/tangible/dungeon/mustafar/working_droid_factory/radioactive_pile.iff";

const string WORKING_AUREK_KILLED		= "isAurekKilled";
const string WORKING_BESH_KILLED		= "isBeshKilled";
const string WORKING_AUREK_BESH_ENGAGED		= "isAurekBeckEngaged";
const string AUREK_HEALTH			= "health.aurek";
const string BESH_HEALTH			= "health.besh";

const string WORKING_DEVISTATOR_KILLED		= "isDevistatorKilled";
const string WORKING_DEVISTATOR_ENGAGED		= "isDevistatorEngaged";
const string WORKING_INHIBITOR_TRACKER		= "currentInhibitorSession";
const string WORKING_RRU_STATE			= "rapidRepairUnitState";

const string WORKING_MDE_KILLED			= "isMasterDroidEngineerKilled";
const string WORKING_MDE_ENGAGED		= "isMdeEngaged";
const string WORKING_MDE_MOB			= "isMdeMob";
const string WORKING_ASSEMBLY_STAGE		= "eventStage";
const string WORKING_MDE_REVIVED		= "wasRevived";

const string WORKING_POWER_SHUT_DOWN		= "isPowerCoreOff";

const string WORKING_DOOM_BRINGER_KILLED	= "isDoomBringerKilled";
const string WORKING_ACTIVE_HOD			= "doom.activeHandOfDoom";
const string WORKING_PRIMARY_HAND		= "doom.primaryHand";
const string WORKING_HOD_TARGET			= "doom.objectiveTarget";

const string WORKING_HK_SPAWNED			= "hk.isSpawned";
const string WORKING_HK_BOMB			= "hk.isDetonated";

const string WORKING_AUREKBESH_KILL_TIME	= "aurekBeshKillTime";
const int WORKING_AUREKBESH_RESPAWN_DELAY	= 15;

const boolean WORKING_LOGGING			= false;
//**************************************
//Uplink Cave

const boolean UPLINK_LOGGING			= false;
const string UPLINK_STF				= "mustafar/uplink_cave";
const string UPLINK_VICTORY_STATE		= "isUplinkEstablished";
const string UPLINK_DATA			= "datatables/dungeon/mustafar_trials/link_establish/link_event_data.iff";
const string RELAY_OBJECT			= "object/tangible/dungeon/mustafar/uplink_trial/relay_object.iff";
const string UPLINK_ESTABLISH_EFFECT		= "blah.cef";
const string UPLINK_ROOM			= "mainroom";
const string UPLINK_ACTIVE			= "isUplinkTrialActive";

const string_id UPLINK_FOREMAN_SPAWN		= new string_id(UPLINK_STF, "foreman_spawn");

//***************************************
//Droid Battlefield
const boolean VALLEY_LOGGING			= false;
const string VALLEY_DATA			= "datatables/dungeon/mustafar_trials/valley_battlefield/valley_event_data.iff";
const string BATTLEFIELD_VICTORY_STATE		= "armyDefeated";
const string BATTLEFIELD_DROID_ARMY		= "isArmy";
const string BATTLEFIELD_MINER			= "isMiner";
const string BATTLEFIELD_COMMANDER_KILLED	= "isCommanderKilled";
const string BATTLEFIELD_GENERATOR_DESTROYED	= "isGeneratorDestoryed";
const string BATTLEFIELD_COMMANDER_LOGIC	= "assaultFinal";
const string BATTLEFIELD_DROID_CORPSE		= "droidCorpse";

const string BATTLEFIELD_STF			= "mustafar/valley_battlefield";
const string_id BATTLEFIELD_GENERATOR_DEAD	= new string_id(BATTLEFIELD_STF, "generator_destroyed");
const string_id BATTLEFIELD_COMMANDER_DIED	= new string_id(BATTLEFIELD_STF, "commander_killed");
const string_id BATTLEFIELD_CMNDR_INTRO		= new string_id(BATTLEFIELD_STF, "commander_intro");
const string_id BATTLEFIELD_WIN_MESSAGE		= new string_id(BATTLEFIELD_STF, "battlefield_win_message");
const string_id BATTLEFIELD_LOSE_MESSAGE	= new string_id(BATTLEFIELD_STF, "battlefield_lose_message");
const string_id BATTLEFIELD_LOSE_1		= new string_id(BATTLEFIELD_STF, "about_to_lose_1");
const string_id BATTLEFIELD_LOSE_2		= new string_id(BATTLEFIELD_STF, "about_to_lose_2");
const string_id BATTLEFIELD_LOSE_3		= new string_id(BATTLEFIELD_STF, "about_to_lose_3");

const int BATTLEFIELD_WAVE_DELAY		= 150;
const int BATTLEFIELD_COMM_REZ_DELAY		= 18;

//***************************************
//Volcano Battlefield

const boolean VOLCANO_LOGGING			= false;
const string VOLCANO_STF			= "mustafar/volcano_battlefield";
const string_id VOLCANO_TASKMASTER_STRENGTHEN	= new string_id(VOLCANO_STF, "taskmaster_strengthen");
const string_id VOLCANO_CYM_BEETLE_NOTIFY	= new string_id(VOLCANO_STF, "four_summon_add");
const string_id VOLCANO_OPP_ADD_NOTIFY		= new string_id(VOLCANO_STF, "five_summon_trio");
const string_id VOLCANO_OPP_MIDGUARD		= new string_id(VOLCANO_STF, "five_summon_midguard");
const string_id VOLCANO_HK_SUMMON_AK		= new string_id(VOLCANO_STF, "hk_summon_walker");
const string_id VOLCANO_HK_TAUNT		= new string_id(VOLCANO_STF, "hk_prefight_taunt");




const string VOLCANO_THREE_IS_BOSS		= "isCommander";
const string VOLCANO_THREE_IS_CORPSE		= "isCorpse";

const string VOLCANO_FOUR_IS_BEETLE		= "isKubazaBeetle";

const string VOLCANO_FINAL_IS_CORPSE		= "isCorpse";

//**********************************************
//Sher Kar

const boolean MONSTER_LOGGING			= false;
const string MONSTER_DATA			="datatables/dungeon/mustafar_trials/sher_kar/sher_kar_data";
const string MONSTER_STF			= "mustafar/sher_kar";
const string MONSTER_AREA			= "r1";
const string MONSTER_WP				= "spawn_point";
const string MONSTER_SHER_KAR			= "sherKar.id";
const string MONSTER_KARLING			= "som_sherkar_karling";
const string MONSTER_PRAETORIAN			= "som_sherkar_praetorian";
const string MONSTER_SYMBIOT			= "som_sherkar_symbiot";

const string_id MONSTER_ENRAGE_WARNING		= new string_id(MONSTER_STF, "enrage_warning");
const string_id MONSTER_SK_DEFEATED		= new string_id(MONSTER_STF, "sk_defeated");


//****************************************
//Client Effects

const string SND_POWERUP			= "clienteffect/snd_forcefield_powerup.cef";
const string SND_POWERDOWN			= "clienteffect/snd_forcefield_powerdown.cef";
const string PRT_CYM_DISEASE			= "clienteffect/mus_cym_disease.cef";
const string PRT_CYM_POISON			= "clienteffect/mus_cym_poison.cef";
const string PRT_DROID_HEAL			= "clienteffect/mus_droid_heal.cef";
const string PRT_DROID_REVIVE			= "clienteffect/mus_droid_revive.cef";
const string PRT_RELAY_ACTIVATE			= "clienteffect/mus_relay_activate.cef";
const string PRT_RELAY_CREATE			= "clienteffect/mus_relay_create.cef";
const string PRT_KUBAZA_EXPLODE			= "clienteffect/exp_ap_landmine.cef";
const string PRT_KUBAZA_WARNING			= "clienteffect/mus_kubaza_warning.cef";
const string PRT_INVULN_SHIELD			= "appearance/pt_flash_shield.prt";
const string PRT_TRAP_STUN			= "clienteffect/mus_relay_activate.cef";
const string PRT_WORKING_REPAIR_REZ		= "clienteffect/mus_relay_create.cef";
const string PRT_WORKING_REPAIR_COMPILE		= "clienteffect/mus_relay_create.cef";
const string PRT_WORKING_DUALITY_EXPLOSION	= "appearance/pt_cmndo_shock_grenade5.prt";
const string PRT_WORKING_HK_BOOM_1		= "clienteffect/avatar_explosion_01.cef";
const string PRT_WORKING_HK_BOOM_2		= "clienteffect/avatar_explosion_02.cef";
const string PRT_WORKING_HK_BOOM_3		= "clienteffect/avatar_room_explosion.cef";
const string PRT_VOLCANO_WAVE_PRE		= "appearance/pt_blast_wave_build_up.prt";
const string PRT_VOLCANO_WAVE_EXE		= "appearance/pt_blast_wave.prt";
const string PRT_VOLCANO_AIR_PRE		= "appearance/pt_rocket_barrage_wind_up.prt";
const string PRT_VOLCANO_AIR_EXE		= "appearance/pt_rocket_barrage.prt";
const string PRT_VOLCANO_CONE_PRE		= "appearance/pt_large_beam_warm_up.prt";
const string PRT_VOLCANO_CONE_EXE		= "appearance/pt_large_beam.prt";
const string PRT_VOLCANO_YT_LANDING		= "appearance/must_smoke_plume01.prt";
const string PRT_SHER_KAR_CAVE_IN		= "clienteffect/cave_in_roof.cef";


//********************************************
//Sound Files

const string MUS_BATTLEFIELD_DROID_ARMY_INTRO	= "sound/mus_mustafar_droid_invasion_intro.snd";
const string MUS_VOLCANO_HK_INTRO		= "sound/mus_mustafar_hk47_intro.snd";
const string MUS_MUST_QUEST_WIN			= "sound/mus_mustafar_quest_success.snd";
const string MUS_MUST_QUEST_FAIL		= "sound/mus_mustafar_quest_fail.snd";
//*****************************************
//Script HP values

const int HP_DECREPIT_COLONEL			= 145000;
const int HP_DECREPIT_GUARDIAN			= 185250;

const int HP_WORKING_AUREK_BESH			= 448220;
const int HP_WORKING_DEVISTATOR			= 635425;
const int HP_WORKING_MDE			= 385225;
const int HP_WORKING_FIXER_ONE			= 855965;
const int HP_WORKING_DOOM_HAND			= 125000;
const int HP_WORKING_DOOM_BRINGER		= 705385;

const int HP_DOOM_TARGET			= 200000;
const int HP_WORKING_ASSEMBLY			= 50000;


const int HP_BATTLEFIELD_GENERATOR		= 65000;

const int HP_VOLCANO_ONE_GUARD			= 65000;
const int HP_VOLCANO_ONE_BOSS			= 545000;

const int HP_VOLCANO_TWO_GUARD			= 95250;
const int HP_VOLCANO_TWO_BOSS			= 655280;

const int HP_VOLCANO_THREE_GUARD		= 33500;
const int HP_VOLCANO_THREE_RISEN		= 60250;
const int HP_VOLCANO_THREE_BOSS			= 655250;

const int HP_VOLCANO_FOUR_GUARD			= 3000;
const int HP_VOLCANO_FOUR_BOSS			= 950485;

const int HP_VOLCANO_FIVE_GUARD			= 50000;
const int HP_VOLCANO_FIVE_MIDGUARD		= 100000;
const int HP_VOLCANO_FIVE_BOSS			= 220000;

const int HP_VOLCANO_HK_SOLDIER			= 14000;
const int HP_VOLCANO_HK_SQUAD_LEADER		= 20000;
const int HP_VOLCANO_HK_RISEN_GUARD		= 22525;
const int HP_VOLCANO_HK_BEETLE			= 9000;
const int HP_VOLCANO_HK_SEPTIPOD		= 75250;
const int HP_VOLCANO_HK_CWW			= 55855;
const int HP_VOLCANO_HK47			= 545852;

const int HP_SHER_KAR				= 885000;
const int HP_SHER_KAR_CONSORT			= 225000;
const int HP_SHER_KARLING			= 65400;
const int HP_SHER_KAR_PRAETORIAN		= 120000;
const int HP_SHER_KAR_LIFESAPPER		= 95000;

//***********************************************************
// Heroic Axkva HP Values
const int HP_AKXVA_NANDINA			= 245440;
const int HP_AXKVA_GORVO			= 614525;
const int HP_AXKVA_LILLI_HI			= 599258;
const int HP_AXKVA_KIMARU			= 818125;
const int HP_AXKVA_SUIN				= 1012400;
const int HP_AXKVA				= 1305858;

//***********************************************************
// Heroic Exar Kun
const int HP_EXAR_OPEN				= 515325;
const int HP_EXAR_MINDER			= 623145;
const int HP_EXAR_LURESH			= 355245;
const int HP_EXAR_VINRITH			= 255454;
const int HP_EXAR_CLOSED			= 1485235;

//***********************************************************
// Heroic Wampa Valley
const int HP_UNCLE_JOE				= 818125;
const int HP_JOES_ADDS				= 355325;


//***********************************************************
//Dungeon lockout timers

const int TIME_UPLINK_WIN			= 60*60*2; // 2 hours
const int TIME_DECREPIT_ADD			= 60*90*1; // 1.5 hours
const int TIME_DECREPIT_WIN			= 60*60*3; // 3 hours
const int TIME_BATTLEFIELD_WIN			= 60*60*3; // 3 hours
const int TIME_WORKING_ADD			= 60*60*2; // 2 hours
const int TIME_WORKING_WIN			= 60*60*6; // 6 hours
const int TIME_VOLCANO_ADD			= 60*60*2; // 2 hours
const int TIME_VOLCANO_WIN			= 60*60*12; // 12 hours
const int TIME_MONSTER_WIN			= 60*60*20; // 20 hours

//************************
//Heroic Encounter Items/Rewards

const string [] HEROIC_TOKENS 		=	{
							"item_heroic_token_axkva_01_01", 			// 0
							"item_heroic_token_tusken_01_01",			// 1
							"item_heroic_token_ig88_01_01",				// 2
							"item_heroic_token_black_sun_01_01",			// 3
							"item_heroic_token_exar_01_01",				// 4
							"item_heroic_token_echo_base_01_01",			// 5
							"item_battlefield_rebel_token_massassi_isle",		// 6
							"item_battlefield_imperial_token_massassi_isle",	// 7
							"item_battlefield_rebel_token_battlefield2",		// 8
							"item_battlefield_imperial_token_battlefield2",		// 9
							"item_battlefield_rebel_token_battlefield3",		// 10
							"item_battlefield_imperial_token_battlefield3",		// 11
							"item_battlefield_rebel_token_battlefield4",		// 12
							"item_battlefield_imperial_token_battlefield4",		// 13
							"item_pgc_token_01",					// 14
							"item_pgc_token_02",					// 15
							"item_pgc_token_03",					// 16
							"item_gcw_rebel_token",					// 17
							"item_gcw_imperial_token",				// 18
							"item_token_duty_space_01_01"				// 19
						};







const int NUM_HEROIC_TOKEN_TYPES 	= 20;

//**********************************************
//Heroic Constants

const string KIMARU_HATE_LIST	= "kimaru_hate_list";

//Sequencer Controller WP Data
const string WP_DATA				= "nearPoint";
const string PROT_CHILD				= "protected_data";
const string PROT_CHILD_ARRAY			= "protected_data.child_array";
const string PROT_CHILD_KEY_LIST		= "protected_data.key_list";
const string PATROL_PATH_FULL_DATA		= "all_instance_patrol_path";
const string SEQUENCER_PATH_DATA		= "sequencer_path_data";


//*************************************************
// Heroic Token Box - The Box of Achievements
const string SPACE_DUTY_TOKEN 			= "item_token_duty_space_01_01";



// Set up an int array with a size equal to the number of heroic encounters.
void initializeBox(obj_id self)
{
	int[] tokenTypes = new int[trial.NUM_HEROIC_TOKEN_TYPES];

	for(int i = 0; i < trial.NUM_HEROIC_TOKEN_TYPES; i++)
	{
		tokenTypes[i] = 0;
	}

	setObjVar(self, "item.set.tokens_held", tokenTypes);

	return;
}

// Make sure array size is same as number of heroic encounters. Increase array size if it grew.
void verifyBox(obj_id self)
{
	int[] tokenTypes = getIntArrayObjVar(self, "item.set.tokens_held");
	
	// Should never happen but in case it does.
	
	if(tokenTypes == null)
	{
		initializeBox(self);
	}
	
	// The number grew
	
	else if(tokenTypes.length < trial.NUM_HEROIC_TOKEN_TYPES)
	{
		int[] newTokenTypes = new int[trial.NUM_HEROIC_TOKEN_TYPES];

		// so increase size of the array
		for(int i = 0; i < trial.NUM_HEROIC_TOKEN_TYPES; i++)
		{
			newTokenTypes[i] = 0;
		}

		// and copy the old data over.
		for(int i = 0; i < tokenTypes.length; i++)
		{
			newTokenTypes[i] = tokenTypes[i];
		}

		setObjVar(self, "item.set.tokens_held", newTokenTypes);
	}

	return;
}

//*************************************************
// Decrepit Droid Factory
string generateNewKeyCode(obj_id dungeon)
{
	int code = rand(100000,999999);
	string stringCode = Integer.toString(code);
	int endTime = getGameTime() + RESET_TIMER;

	utils.setScriptVar(dungeon, ACCESS_CODE, stringCode);
	utils.setScriptVar(dungeon, RESET_CODE, endTime);
	messageTo(dungeon, "codeResetOccured", null, 0, false);

	return stringCode;
}

string initializeCode(obj_id dungeon)
{
	int code = 0;
	string stringCode = Integer.toString(code);
	int endTime = 0;

	utils.setScriptVar(dungeon, ACCESS_CODE, stringCode);
	utils.setScriptVar(dungeon, RESET_CODE, endTime);

	return stringCode;
}

string getKeyCode(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (!utils.hasScriptVar(dungeon, ACCESS_CODE))
		return generateNewKeyCode(dungeon);
	else
		return utils.getStringScriptVar(dungeon, ACCESS_CODE);
}

int getResetTime(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (!utils.hasScriptVar(dungeon, RESET_CODE))
	{
		generateNewKeyCode(dungeon);
		return utils.getIntScriptVar(dungeon, RESET_CODE);
	}
	else
		return utils.getIntScriptVar(dungeon, RESET_CODE);
}


void doCountdownTimerFlyText(obj_id terminal, int timer)
{
	dictionary dict = new dictionary();

	switch (timer)
	{
		case 10:
			showFlyText( terminal, new string_id(DECREPIT_STF, "ten"), 1.0f, colors.GREEN );
			dict.put("timer", 9);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;
		case 9:
			showFlyText( terminal, new string_id(DECREPIT_STF, "nine"), 1.0f, colors.GREEN );
			dict.put("timer", 8);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;
		case 8:
			showFlyText( terminal, new string_id(DECREPIT_STF, "eight"), 1.0f, colors.GREEN );
			dict.put("timer", 7);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;
		case 7:
			showFlyText( terminal, new string_id(DECREPIT_STF, "seven"), 1.0f, colors.GREEN );
			dict.put("timer", 6);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;
		case 6:
			showFlyText( terminal, new string_id(DECREPIT_STF, "six"), 1.0f, colors.GREEN );
			dict.put("timer", 5);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;
		case 5:
			showFlyText( terminal, new string_id(DECREPIT_STF, "five"), 1.0f, colors.GREEN );
			dict.put("timer", 4);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;
		case 4:
			showFlyText( terminal, new string_id(DECREPIT_STF, "four"), 1.0f, colors.GREEN );
			dict.put("timer", 3);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;
		case 3:
			showFlyText( terminal, new string_id(DECREPIT_STF, "three"), 1.0f, colors.GREEN );
			dict.put("timer", 2);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;
		case 2:
			showFlyText( terminal, new string_id(DECREPIT_STF, "two"), 1.0f, colors.GREEN );
			dict.put("timer", 1);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;
		case 1:
			showFlyText( terminal, new string_id(DECREPIT_STF, "one"), 1.0f, colors.GREEN );
			dict.put("timer", 0);
			messageTo(terminal, "showStatusFlyText", dict, 1, false);
			return;

	}

}

boolean isTrapActive(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	boolean triggered = true;
	if (utils.hasScriptVar(dungeon, TRAP_STATE))
		return  utils.getBooleanScriptVar(dungeon, TRAP_STATE);
	else
		return false;
}

boolean isTrapPrimed(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	obj_id[] sensors = getObjectsInDungeonWithScript(dungeon, "theme_park.dungeon.mustafar_trials.decrepit_droid_factory.trap_terminal_scanner");

	if (sensors == null || sensors.length == 0)
	{
		doLogging("isTrapPrimed", "Sensor list was null or empty");
		return false;
	}
	boolean primed = false;
	for (int i=0;i<sensors.length;i++)
	{
		if (isSensorActive(sensors[i]))
		{
			primed = true;
		}
	}

	return primed;
}

boolean isSensorActive(obj_id sensor)
{
	if (!utils.hasScriptVar(sensor, SENSOR_STATE))
	{
		utils.setScriptVar(sensor, SENSOR_STATE, true);
		return true;
	}

	return utils.getBooleanScriptVar(sensor, SENSOR_STATE);
}

void setTrapState(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);

	utils.setScriptVar(dungeon, TRAP_STATE, state);
}

void setFireCellState(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);

	utils.setScriptVar(dungeon, FIRE_CELL_STATE, state);
}


boolean isPowerCoreOn(obj_id dungeon)
{
	dungeon = getTop(dungeon);
	if (utils.hasScriptVar(dungeon, POWER_CORE_STATE))
		return utils.getBooleanScriptVar(dungeon, POWER_CORE_STATE);
	else
	{
		utils.setScriptVar(dungeon, POWER_CORE_STATE, false);
		return false;
	}
}

void setPowerCoreState(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);

	utils.setScriptVar(dungeon, POWER_CORE_STATE, state);
}


void setGuardianLockState(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, GUARDIAN_LOCK_STATE, state);
}

boolean isGuardianLockInPlace(obj_id dungeon)
{
	dungeon = getTop(dungeon);
	if (utils.hasScriptVar(dungeon, GUARDIAN_LOCK_STATE))
		return utils.getBooleanScriptVar(dungeon, GUARDIAN_LOCK_STATE);
	else
	{
		utils.setScriptVar(dungeon, GUARDIAN_LOCK_STATE, true);
		return true;
	}
}

boolean isDecrepitDefeated(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, DECREPIT_VICTORY_STATE))
		return utils.getBooleanScriptVar(dungeon, DECREPIT_VICTORY_STATE);
	else
	{
		utils.setScriptVar(dungeon, DECREPIT_VICTORY_STATE, false);
		return false;
	}
}

void setDecrepitTrialState(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, DECREPIT_VICTORY_STATE, state);
}

//*********************************************************************
//Working Droid Factory

void setAurekKilled(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, WORKING_AUREK_KILLED, state);
}

void setBeshKilled(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, WORKING_BESH_KILLED, state);
}

void setDevistatorKilled(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, WORKING_DEVISTATOR_KILLED, state);
}

void setMdeKilled(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, WORKING_MDE_KILLED, state);
}

void setPowerCoreDeactivated(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, WORKING_POWER_SHUT_DOWN, state);
}

void setDoomBringerKilled(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, WORKING_DOOM_BRINGER_KILLED, state);
}

void setAurekBeshEngaged(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, WORKING_AUREK_BESH_ENGAGED, state);
}

boolean isAurekBeshEngaged(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_AUREK_BESH_ENGAGED))
		return utils.getBooleanScriptVar(dungeon, WORKING_AUREK_BESH_ENGAGED);
	else
	{
		utils.setScriptVar(dungeon, WORKING_AUREK_BESH_ENGAGED, false);
		return false;
	}


}
void setAurekBeshKillTime(obj_id dungeon)
{
	dungeon = getTop(dungeon);
	int time = getGameTime();
	utils.setScriptVar(dungeon, WORKING_AUREKBESH_KILL_TIME, time);
}

int getAurekBeshKillTime(obj_id dungeon)
{
	dungeon = getTop(dungeon);
	if (utils.hasScriptVar(dungeon, WORKING_AUREKBESH_KILL_TIME))
		return utils.getIntScriptVar(dungeon, WORKING_AUREKBESH_KILL_TIME);
	else
	{
		utils.setScriptVar(dungeon, WORKING_AUREKBESH_KILL_TIME, 0);
		return 0;
	}
}

void clearAurekBeshKillTime(obj_id dungeon)
{
	if (utils.hasScriptVar(dungeon, WORKING_AUREKBESH_KILL_TIME))
		utils.removeScriptVar(dungeon, WORKING_AUREKBESH_KILL_TIME);
}

boolean isAurekKilled(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_AUREK_KILLED))
		return utils.getBooleanScriptVar(dungeon, WORKING_AUREK_KILLED);
	else
	{
		utils.setScriptVar(dungeon, WORKING_AUREK_KILLED, false);
		return false;
	}
}

boolean isBeshKilled(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_BESH_KILLED))
		return utils.getBooleanScriptVar(dungeon, WORKING_BESH_KILLED);
	else
	{
		utils.setScriptVar(dungeon, WORKING_BESH_KILLED, false);
		return false;
	}
}

boolean isAurekBeshKilled(obj_id dungeon)
{
	return (isAurekKilled(dungeon) && isBeshKilled(dungeon));
}

boolean isDevistatorKilled(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_DEVISTATOR_KILLED))
		return utils.getBooleanScriptVar(dungeon, WORKING_DEVISTATOR_KILLED);
	else
	{
		utils.setScriptVar(dungeon, WORKING_DEVISTATOR_KILLED, false);
		return false;
	}
}

boolean isMdeKilled(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_MDE_KILLED))
		return utils.getBooleanScriptVar(dungeon, WORKING_MDE_KILLED);
	else
	{
		utils.setScriptVar(dungeon, WORKING_MDE_KILLED, false);
		return false;
	}
}

boolean isPowerCoreDeactivated(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_POWER_SHUT_DOWN))
		return utils.getBooleanScriptVar(dungeon, WORKING_POWER_SHUT_DOWN);
	else
	{
		utils.setScriptVar(dungeon, WORKING_POWER_SHUT_DOWN, false);
		return false;
	}
}

boolean isDoomBringerKilled(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_DOOM_BRINGER_KILLED))
		return utils.getBooleanScriptVar(dungeon, WORKING_DOOM_BRINGER_KILLED);
	else
	{
		utils.setScriptVar(dungeon, WORKING_DOOM_BRINGER_KILLED, false);
		return false;
	}
}

void setRruDeactivated(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);

	utils.setScriptVar(dungeon, WORKING_RRU_STATE, state);
}

boolean isRruDeactivated(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_RRU_STATE))
		return utils.getBooleanScriptVar(dungeon, WORKING_RRU_STATE);
	else
	{
		utils.setScriptVar(dungeon, WORKING_RRU_STATE, false);
		return false;
	}

}

void setDevistatorEngaged(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, WORKING_DEVISTATOR_ENGAGED, state);
}

boolean isDevistatorEngaged(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_DEVISTATOR_ENGAGED))
		return utils.getBooleanScriptVar(dungeon, WORKING_DEVISTATOR_ENGAGED);
	else
	{
		utils.setScriptVar(dungeon, WORKING_DEVISTATOR_ENGAGED, false);
		return false;
	}

}

boolean isMdeEngaged(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (utils.hasScriptVar(dungeon, WORKING_MDE_ENGAGED))
		return utils.getBooleanScriptVar(dungeon, WORKING_MDE_ENGAGED);
	else
	{
		utils.setScriptVar(dungeon, WORKING_MDE_ENGAGED, false);
		return false;
	}
}

void setMdeEngaged(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, WORKING_MDE_ENGAGED, state);
}
void healAssemblyUnit(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	obj_id[] assemblyUnits = getObjectsInDungeonWithScript(dungeon, "theme_park.dungeon.mustafar_trials.working_droid_factory.rapid_assembly_unit");
	if (assemblyUnits == null || assemblyUnits.length == 0)
		return;

	for (int i=0;i<assemblyUnits.length;i++)
	{
		if (isDisabled(assemblyUnits[i]))
			clearCondition(assemblyUnits[i], CONDITION_DISABLED);

		int maxHitPoints = getMaxHitpoints(assemblyUnits[i]);
		setHitpoints(assemblyUnits[i], maxHitPoints);
		setInvulnerable(assemblyUnits[i], true);
		trial.bumpSession(assemblyUnits[i]);
	}

}

void clearMdeArea(obj_id dungeon)
{
	obj_id[] mdeCreatures = getObjectsInDungeonWithScriptVar(dungeon, WORKING_MDE_MOB);

	if (mdeCreatures == null || mdeCreatures.length == 0)
	{
		doLogging("xx", "There were no creatures to be found");
		return;
	}
	cleanupNpc(mdeCreatures);
}

void resetAssemblyStage(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	obj_id[] assemblyUnits = getObjectsInDungeonWithScript(dungeon, "theme_park.dungeon.mustafar_trials.working_droid_factory.rapid_assembly_unit");
	if (assemblyUnits == null || assemblyUnits.length == 0)
		return;

	for (int i=0;i<assemblyUnits.length;i++)
	{
		utils.setScriptVar(assemblyUnits[i], WORKING_ASSEMBLY_STAGE, 0);
	}
}

boolean isActiveHand(obj_id unit)
{
	if (utils.hasScriptVar(unit, WORKING_ACTIVE_HOD))
		return utils.getBooleanScriptVar(unit, WORKING_ACTIVE_HOD);
	else
	{
		utils.setScriptVar(unit, WORKING_ACTIVE_HOD, false);
		return false;
	}
}

boolean isPrimaryHand(obj_id unit)
{
	if (utils.hasScriptVar(unit, WORKING_PRIMARY_HAND))
		return utils.getBooleanScriptVar(unit, WORKING_PRIMARY_HAND);
	else
	{
		utils.setScriptVar(unit, WORKING_PRIMARY_HAND, false);
		return false;
	}
}

void setActiveHand(obj_id unit, boolean state)
{
	utils.setScriptVar(unit, WORKING_ACTIVE_HOD, state);
}

void setPrimaryHand(obj_id unit, boolean state)
{
	utils.setScriptVar(unit, WORKING_PRIMARY_HAND, state);
}

boolean isHkSpawned(obj_id unit)
{
	if (utils.hasScriptVar(unit, WORKING_HK_SPAWNED))
		return utils.getBooleanScriptVar(unit, WORKING_HK_SPAWNED);
	else
	{
		utils.setScriptVar(unit, WORKING_HK_SPAWNED, false);
		return false;
	}
}

boolean isHkDetonated(obj_id unit)
{
	if (utils.hasScriptVar(unit, WORKING_HK_BOMB))
		return utils.getBooleanScriptVar(unit, WORKING_HK_BOMB);
	else
	{
		utils.setScriptVar(unit, WORKING_HK_BOMB, false);
		return false;
	}
}

void setHkSpawned(obj_id unit, boolean state)
{
	utils.setScriptVar(unit, WORKING_HK_SPAWNED, state);
}

void setHkDetonated(obj_id unit, boolean state)
{
	utils.setScriptVar(unit, WORKING_HK_BOMB, state);
}


//**********************************************************************
//Uplink Trial

void setUplinkVictoryState(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, UPLINK_VICTORY_STATE, state);
}

boolean isUplinkDefeated(obj_id dungeon)
{
	dungeon = getTop(dungeon);
	boolean result = false;
	if (utils.hasScriptVar(dungeon, UPLINK_VICTORY_STATE))
		return utils.getBooleanScriptVar(dungeon, UPLINK_VICTORY_STATE);
	else
	{
		utils.setScriptVar(dungeon, UPLINK_VICTORY_STATE, false);
		return false;
	}
}

boolean isUplinkActive(obj_id dungeon)
{
	dungeon = getTop(dungeon);
	boolean result = false;
	if (utils.hasScriptVar(dungeon, UPLINK_ACTIVE))
		return utils.getBooleanScriptVar(dungeon, UPLINK_ACTIVE);
	else
	{
		utils.setScriptVar(dungeon, UPLINK_ACTIVE, false);
		return false;
	}

}

void setUplinkActiveState(obj_id dungeon, boolean state)
{
	dungeon = getTop(dungeon);
	utils.setScriptVar(dungeon, UPLINK_ACTIVE, state);

}


//**********************************************************************
//Droid Battlefield

void setIsDroidArmyDefeated(obj_id dungeon, boolean state)
{
	utils.setScriptVar(dungeon, BATTLEFIELD_VICTORY_STATE, state);
}

boolean isDroidArmyDefeated(obj_id dungeon)
{
	if (utils.hasScriptVar(dungeon, BATTLEFIELD_VICTORY_STATE))
		return utils.getBooleanScriptVar(dungeon, BATTLEFIELD_VICTORY_STATE);
	else
	{
		utils.setScriptVar(dungeon, BATTLEFIELD_VICTORY_STATE, false);
		return false;
	}

}

void setIsCommanderKilled(obj_id dungeon, boolean state)
{
	utils.setScriptVar(dungeon, BATTLEFIELD_COMMANDER_KILLED, state);
}

boolean isCommanderKilled(obj_id dungeon)
{
	if (utils.hasScriptVar(dungeon, BATTLEFIELD_COMMANDER_KILLED))
		return utils.getBooleanScriptVar(dungeon, BATTLEFIELD_COMMANDER_KILLED);
	else
	{
		utils.setScriptVar(dungeon, BATTLEFIELD_COMMANDER_KILLED, false);
		return false;
	}
}

void setIsGeneratorDestroyed(obj_id dungeon, boolean state)
{
	utils.setScriptVar(dungeon, BATTLEFIELD_GENERATOR_DESTROYED, state);
}

boolean isGeneratorDestroyed(obj_id dungeon)
{
	if (utils.hasScriptVar(dungeon, BATTLEFIELD_GENERATOR_DESTROYED))
		return utils.getBooleanScriptVar(dungeon, BATTLEFIELD_GENERATOR_DESTROYED);
	else
	{
		utils.setScriptVar(dungeon, BATTLEFIELD_GENERATOR_DESTROYED, false);
		return false;
	}
}



void markAsDroidArmy(obj_id npc)
{
	utils.setScriptVar(npc, BATTLEFIELD_DROID_ARMY, true);
}

void markAsMiner(obj_id npc)
{
	utils.setScriptVar(npc, BATTLEFIELD_MINER, true);
}

void markAsDroidCorpse(obj_id npc)
{
	utils.setScriptVar(npc, BATTLEFIELD_DROID_CORPSE, true);
}

//************************************************************
//Volcano Crater
void markAsVolcanoCommander(obj_id npc)
{
	utils.setScriptVar(npc, VOLCANO_THREE_IS_BOSS, true);
}

boolean isVolcanoCommander(obj_id npc)
{
	if (utils.hasScriptVar(npc, VOLCANO_THREE_IS_BOSS))
		return utils.getBooleanScriptVar(npc, VOLCANO_THREE_IS_BOSS);
	else
		return false;
}

void markAsVolcanoCorpse(obj_id npc)
{
	utils.setScriptVar(npc, VOLCANO_THREE_IS_CORPSE, true);
}

boolean isVolcanoCorpse(obj_id npc)
{
	if (utils.hasScriptVar(npc, VOLCANO_THREE_IS_CORPSE))
		return utils.getBooleanScriptVar(npc, VOLCANO_THREE_IS_CORPSE);
	else
		return false;

}


void markAsVolcanoBeetle(obj_id npc)
{
	utils.setScriptVar(npc, VOLCANO_FOUR_IS_BEETLE, true);
}

boolean isVolcanoBeetle(obj_id npc)
{
	if (utils.hasScriptVar(npc, VOLCANO_FOUR_IS_BEETLE))
		return utils.getBooleanScriptVar(npc, VOLCANO_FOUR_IS_BEETLE);
	else
		return false;

}

void markAsHkCorpse(obj_id npc)
{
	utils.setScriptVar(npc, VOLCANO_FINAL_IS_CORPSE, true);
}

boolean isHkCorpse(obj_id npc)
{
	if (utils.hasScriptVar(npc, VOLCANO_FINAL_IS_CORPSE))
		return utils.getBooleanScriptVar(npc, VOLCANO_FINAL_IS_CORPSE);
	else
		return false;

}

//-------------General Functions-----------------------


/****************************************************
* Message to fingerprints. Include the getSessionDict in your params
* or as the params in a message to. Then in the message handler verify
* the message with the verifySession. At a point of your choosing you can
* call bumpSession on your subject which will cause any older messageTo's
* such tagged to be ignored since the session #'s will be dissimilar.
****************************************************/

dictionary getSessionDict(obj_id subject)
{
	dictionary dict = new dictionary();
	int session = getSession(subject);
	dict.put(MESSAGE_SESSION, session);
	return dict;
}

dictionary getSessionDict(obj_id subject, string uniqueId)
{
	dictionary dict = new dictionary();
	int session = getSession(subject, uniqueId);
	dict.put(MESSAGE_SESSION+"."+uniqueId, session);
	return dict;

}

int getSession(obj_id subject)
{
	if(!isIdValid(subject) || !exists(subject))
	{
		return -1;
	}

	if (utils.hasScriptVar(subject, MESSAGE_SESSION))
		return utils.getIntScriptVar(subject,MESSAGE_SESSION );
	else
	{
		utils.setScriptVar(subject, MESSAGE_SESSION, 0);
		return 0;
	}
}

int getSession(obj_id subject, string uniqueId)
{
	if(!isIdValid(subject) || !exists(subject))
	{
		return -1;
	}

	string uniqueSession = MESSAGE_SESSION+"."+uniqueId;

	if (utils.hasScriptVar(subject, uniqueSession))
		return utils.getIntScriptVar(subject,uniqueSession );
	else
	{
		utils.setScriptVar(subject, uniqueSession, 0);
		return 0;
	}
}

boolean verifySession(obj_id subject, dictionary dict)
{
	int passed  = dict.getInt(MESSAGE_SESSION);
	int current = getSession(subject);
	return (current == passed);
}

boolean verifySession(obj_id subject, dictionary dict, string uniqueId)
{
	int passed  = dict.getInt(MESSAGE_SESSION+"."+uniqueId);
	int current = getSession(subject, uniqueId);
	doLogging("verifySession", "passed / current: "+passed+" / "+current);
	return (current == passed);
}

void bumpSession(obj_id subject)
{
	int session = 0;
	if (utils.hasScriptVar(subject, MESSAGE_SESSION))
		session = utils.getIntScriptVar(subject, MESSAGE_SESSION);

	session +=1;

	utils.setScriptVar(subject, MESSAGE_SESSION, session);
}

void bumpSession(obj_id subject, string uniqueId)
{
	string uniqueSession = MESSAGE_SESSION+"."+uniqueId;

	int session = 0;
	if (utils.hasScriptVar(subject, uniqueSession))
		session = utils.getIntScriptVar(subject, uniqueSession);

	session +=1;

	utils.setScriptVar(subject, uniqueSession, session);
}

/**
* Determines if the specified cell is public
* obj_id dungeon	dungeon or object in dungeon
* string cellName	name of cell to check
*
* returns boolean 	true if public
**/

boolean isCellPublic(obj_id dungeon, string cellName)
{
	dungeon = getTop(dungeon);

	obj_id cellId = getCellId(dungeon, cellName);
	if (!isIdValid(cellId))
	{
		return false;
	}

	return permissionsIsPublic(cellId);
}

/**
* Makes a specified cell public
* obj_id dungeon	dungeon or object in dungeon
* string cellName	name of cell to check
*
* returns void
**/
void makeCellPublic(obj_id dungeon, string cellName)
{
	dungeon = getTop(dungeon);

	obj_id cellId = getCellId(dungeon, cellName);

	if (!isIdValid(cellId))
	{
		return;
	}

	permissionsMakePublic(cellId);
}

/**
* Makes a specified cell private
* obj_id dungeon	dungeon or object in dungeon
* string cellName	name of cell to check
*
* returns void
**/
void makeCellPrivate(obj_id dungeon, string cellName)
{
	dungeon = getTop(dungeon);

	obj_id cellId = getCellId(dungeon, cellName);

	if (!isIdValid(cellId))
	{
		return;
	}

	permissionsMakePrivate(cellId);
}

/**
* Gets the top most container of an object, returns self if top item
* obj_id item		Object to check
*
* returns 	top most container or self if uncontained
**/
obj_id getTop(obj_id item)
{
	if (!isIdValid(item))
	{
		return null;
	}

	obj_id top = getTopMostContainer(item);

	if (isIdValid(top) && top != item)
	{
		item = top;
	}

	return item;
}

/**
* Gets a list of all players in a specified dungeon
* obj_id dungeon	The dungeon to scan
*
* returns 	array of player obj_id
**/
obj_id[] getPlayersInDungeon(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	obj_id[] cellIds = getCellIds(dungeon);

	if (cellIds == null || cellIds.length == 0)
		return null;

	resizeable obj_id[] eventPlayers = new obj_id[0];

	for (int i=0;i<cellIds.length;i++)
	{
		obj_id[] contents = getContents(cellIds[i]);
		if (contents!= null && contents.length > 0)
		{
			for (int k=0; k<contents.length;k++)
			{
				if (isPlayer(contents[k]))
				{
					eventPlayers = utils.addElement(eventPlayers, contents[k]);
				}
			}
		}
	}

	if (eventPlayers == null)
		return null;

	obj_id[] convertedArray = eventPlayers;

	if (convertedArray.length > 0)
		return convertedArray;
	else
		return null;
}

/**
* Gets a list of non incapped players and pets in a dungeon
* obj_id dungeon	Dungeon to get the player list for
*
* return obj_id[] 	Array of valid targets
**/
obj_id[] getValidTargetsInDungeon(obj_id dungeon)
{
	obj_id[] players = getPlayersInDungeon(dungeon);
	obj_id[] pets = getObjectsInDungeonWithScript(dungeon, "ai.pet");

	resizeable obj_id[] validTargets = new obj_id[0];

	if (players != null && players.length > 0)
	{
		for (int i=0;i<players.length;i++)
		{
			if (!isIncapacitated(players[i]) && !isDead(players[i]))
				utils.addElement(validTargets, players[i]);
		}
	}

	if (pets != null && pets.length > 0)
	{
		for (int q=0;q<pets.length;q++)
		{
			if (!isIncapacitated(pets[q]) && !isDead(pets[q]))
				utils.addElement(validTargets, pets[q]);
		}
	}

	if (validTargets == null || validTargets.length == 0)
		return null;

	obj_id[] returnList = validTargets;
	return returnList;
}

obj_id[] getValidTargetsInCell(obj_id dungeon, string cell)
{
	return getNonStealthedTargetsInCell(dungeon, cell);
}

obj_id[] getNonStealthedTargetsInCell(obj_id dungeon, string cell)
{
	obj_id[] players = getPlayersInCell(dungeon, cell);

	resizeable obj_id[] validTargets = new obj_id[0];

	if (players == null || players.length == 0)
		return null;

	for (int i = 0;i < players.length; i++)
	{
		if (!isIncapacitated(players[i]) && !isDead(players[i]) && !stealth.hasInvisibleBuff(players[i]))
			utils.addElement(validTargets, players[i]);
	}

	if (validTargets == null || validTargets.length == 0)
		return null;

	obj_id[] returnList = validTargets;
	return returnList;
}

obj_id[] getPlayersInCell(obj_id dungeon, string cell)
{
	dungeon = getTop(dungeon);

	obj_id cellId = getCellId(dungeon, cell);

	if (!isIdValid(cellId))
		return null;

	resizeable obj_id[] players = new obj_id[0];

	obj_id[] contents = getContents(cellId);

	if (contents != null && contents.length > 0)
	{
		for (int k=0;k<contents.length;k++)
		{
			if (isPlayer(contents[k]))
				utils.addElement(players, contents[k]);
		}
	}

	if (players == null || players.length == 0)
		return null;

	obj_id[] returnPlayers = players;

	return returnPlayers;

}

obj_id[] getPlayersInCell(obj_id dungeon, obj_id cell)
{
	string cellName = getCellName(cell);
	if (cellName == null || cellName == "")
		return null;

	return getPlayersInCell(dungeon, cellName);
}
/**
* Gets a list of all players in a set of cells in a specified dungeon
* obj_id dungeon	The dungeon to scan
* string[] cells	string array of cell names
*
* returns 	array of player obj_id
**/
obj_id[] getPlayersInCellList(obj_id dungeon, string[] cells)
{
	dungeon = getTop(dungeon);

	obj_id[] searchCells = new obj_id[cells.length];

	for (int j=0;j<cells.length;j++)
	{
		searchCells[j] = getCellId(dungeon, cells[j]);
	}

	if (searchCells == null || searchCells.length == 0)
		return null;

	resizeable obj_id[] players = new obj_id[0];

	for (int i=0;i<searchCells.length;i++)
	{
		obj_id[] contents = getContents(searchCells[i]);

		if (contents != null && contents.length > 0)
		{
			for (int k=0;k<contents.length;k++)
			{
				if (isPlayer(contents[k]))
					utils.addElement(players, contents[k]);
			}
		}
	}

	if (players == null || players.length == 0)
		return null;

	obj_id[] returnPlayers = players;

	return returnPlayers;
}

/**
* Gets a list of all objects in a dungeon with a specified script
* obj_id dungeon	The dungeon to scan
* string script		The script to search for
*
* returns 		array of objects with script
**/
obj_id[] getObjectsInDungeonWithScript(obj_id dungeon, string script)
{
	dungeon = getTop(dungeon);

	if (!isIdValid(dungeon))
		return null;

	if (script == null || script.equals(""))
		return null;

	obj_id[] cells = getCellIds(dungeon);

	if (cells == null || cells.length == 0)
		return null;

	resizeable obj_id[] objectsWithScript = new obj_id[0];

	for (int i=0;i<cells.length;i++)
	{
		obj_id[] contents = getContents(cells[i]);

		if (contents != null && contents.length > 0)
		{
			for (int k=0;k<contents.length;k++)
			{
				if (hasScript(contents[k], script))
					utils.addElement(objectsWithScript, contents[k]);
			}
		}
	}

	if (objectsWithScript == null || objectsWithScript.length == 0)
		return null;

	obj_id[] returnList = objectsWithScript;

	return returnList;
}
/**
*
* obj_id dungeon	The dungeon to query
*
* return obj_id[] 	An array of obj_id
*
**/
obj_id[] getAllObjectsInDungeon(obj_id dungeon)
{
	dungeon = getTop(dungeon);

	if (!isIdValid(dungeon))
		return null;

	obj_id[] cells = getCellIds(dungeon);

	if (cells == null || cells.length == 0)
		return null;

	resizeable obj_id[] objects = new obj_id[0];

	for (int i=0;i<cells.length;i++)
	{
		obj_id[] contents = getContents(cells[i]);

		if (contents != null && contents.length > 0)
		{
			for (int k=0;k<contents.length;k++)
			{
				utils.addElement(objects, contents[k]);
			}
		}
	}

	if (objects == null || objects.length == 0)
		return null;

	obj_id[] returnList = objects;

	return returnList;

}

/**
* Gets a list of all objects in a dungeon with a specified objvar
* obj_id dungeon	The dungeon to scan
* string script		The objvar to search for
*
* returns 		array of objects with objvar
**/
obj_id[] getObjectsInDungeonWithObjVar(obj_id dungeon, string objvar)
{
	dungeon = getTop(dungeon);

	if (!isIdValid(dungeon))
		return null;

	if (objvar == null || objvar.equals(""))
		return null;

	obj_id[] cells = getCellIds(dungeon);

	if (cells == null || cells.length == 0)
		return null;

	resizeable obj_id[] objectsWithObjVar = new obj_id[0];

	for (int i=0;i<cells.length;i++)
	{
		obj_id[] contents = getContents(cells[i]);

		if (contents != null && contents.length > 0)
		{
			for (int k=0;k<contents.length;k++)
			{
				if (hasObjVar(contents[k], objvar))
					utils.addElement(objectsWithObjVar, contents[k]);
			}
		}
	}

	if (objectsWithObjVar == null || objectsWithObjVar.length == 0)
		return null;

	obj_id[] returnList = objectsWithObjVar;

	return returnList;

}

obj_id[] getObjectsInCellWithObjVar(obj_id dungeon, string cellName, string objvar)
{
	dungeon = getTop(dungeon);

	if (!isIdValid(dungeon))
		return null;

	if (objvar == null || objvar.equals(""))
		return null;

	obj_id checkCell = getCellId(dungeon, cellName);

	if (!isIdValid(checkCell))
		return null;

	resizeable obj_id[] objectsWithObjVar = new obj_id[0];

	obj_id[] contents = getContents(checkCell);

	if (contents != null && contents.length > 0)
	{
		for (int k=0;k<contents.length;k++)
		{
			if (hasObjVar(contents[k], objvar))
				utils.addElement(objectsWithObjVar, contents[k]);
		}
	}


	if (objectsWithObjVar == null || objectsWithObjVar.length == 0)
		return null;

	obj_id[] returnList = objectsWithObjVar;

	return returnList;

}
/**
*
* obj_id dungeon	The Dungeon to scan
* string scriptVar	The Script Variable you are searching for
*
* return obj_id[]	An array of Obj_id of objects with the desired script var
**/

obj_id[] getObjectsInDungeonWithScriptVar(obj_id dungeon, string scriptVar)
{
	dungeon = getTop(dungeon);

	if (!isIdValid(dungeon))
		return null;

	if (scriptVar == null || scriptVar.equals(""))
		return null;

	obj_id[] cells = getCellIds(dungeon);

	if (cells == null || cells.length == 0)
		return null;

	resizeable obj_id[] objectsWithScriptVar = new obj_id[0];

	for (int i=0;i<cells.length;i++)
	{
		obj_id[] contents = getContents(cells[i]);

		if (contents != null && contents.length > 0)
		{
			for (int k=0;k<contents.length;k++)
			{
				if (utils.hasScriptVar(contents[k], scriptVar))
					utils.addElement(objectsWithScriptVar, contents[k]);
			}
		}
	}

	if (objectsWithScriptVar == null || objectsWithScriptVar.length == 0)
		return null;

	obj_id[] returnList = objectsWithScriptVar;

	return returnList;

}

/**
* Gets a list of all non-incapacitated players and pets in a specified range
* obj_id center		The center object from which to scan for targets
* float range		Range at which to get targets
*
* returns 		array of valid targets
**/
obj_id[] getValidTargetsInRadius(obj_id center, float range)
{
	obj_id[] pets = getNPCsInRange(center, range);
	obj_id[] players = getPlayerCreaturesInRange(center, range);

	resizeable obj_id[] targets = new obj_id[0];

	if (pets != null && pets.length != 0)
	{
		for (int i=0;i<pets.length;i++)
		{
			if (isIdValid(pets[i]) && exists(pets[i]) && (hasScript(pets[i], "ai.pet") || beast_lib.isBeast(pets[i]) && canSee(center, pets[i])))
				utils.addElement(targets, pets[i]);
		}
	}

	if (players != null && players.length != 0)
	{
		for (int k=0;k<players.length;k++)
		{
			if (isIdValid(players[k]) && exists(players[k]) && !isIncapacitated(players[k]) && canSee(center, players[k]))
				utils.addElement(targets, players[k]);
		}
	}

	if (targets == null || targets.length == 0)
	{
		doLogging("getValidTargetsInRadius", "There were no valid pets or players in the radial area");
		return null;
	}
	obj_id[] validTargets = targets;

	return validTargets;
}

/**
* Gets a list of all non-incapacitated players and pets in a specified range
* obj_id center		The center object from which to scan for targets
* float range		Range at which to get targets
*
* returns 		array of valid targets
**/
obj_id[] getValidTargetsInRadiusIgnoreLOS(obj_id center, float range)
{
	obj_id[] pets = getNPCsInRange(center, range);
	obj_id[] players = getPlayerCreaturesInRange(center, range);

	resizeable obj_id[] targets = new obj_id[0];

	if (pets != null && pets.length != 0)
	{
		for (int i=0;i<pets.length;i++)
		{
			if (isIdValid(pets[i]) && exists(pets[i]) && (hasScript(pets[i], "ai.pet") || beast_lib.isBeast(pets[i])))
				utils.addElement(targets, pets[i]);
		}
	}

	if (players != null && players.length != 0)
	{
		for (int k=0;k<players.length;k++)
		{
			if (isIdValid(players[k]) && exists(players[k]) && !isIncapacitated(players[k]))
				utils.addElement(targets, players[k]);
		}
	}

	if (targets == null || targets.length == 0)
	{
		doLogging("getValidTargetsInRadius", "There were no valid pets or players in the radial area");
		return null;
	}
	obj_id[] validTargets = targets;

	return validTargets;
}

/**
* Gets a list of all non-incapacitated players and pets in a specified cone
* obj_id center		The center object from which to scan for targets
* float range		Range at which to get targets
* float cone
*
* returns 		array of valid targets
**/

obj_id[] getValidTargetsInCone(obj_id self, obj_id target, float range, float cone)
{
	obj_id[] pets = getNPCsInCone(self,target, range, cone);
	obj_id[] players = getPlayerCreaturesInCone(self, target, range, cone);

	resizeable obj_id[] targets = new obj_id[0];

	if (pets != null && pets.length != 0)
	{
		for (int i=0;i<pets.length;i++)
		{
			if (isIdValid(pets[i]) && exists(pets[i]) && hasScript(pets[i], "ai.pet"))
				utils.addElement(targets, pets[i]);
		}
	}

	if (players != null && players.length != 0)
	{
		for (int k=0;k<players.length;k++)
		{
			if (isIdValid(players[k]) && exists(players[k]) && !isIncapacitated(players[k]))
				utils.addElement(targets, players[k]);
		}
	}

	if (targets == null || targets.length == 0)
	{
		doLogging("getValidTargetsInCone", "There were no valid pets or players in the cone area");
		return null;
	}
	obj_id[] validTargets = targets;

	return validTargets;
}

/**
* Gets a list of all non-incapacitated players
* obj_id center		The center object from which to scan for targets
* float range		Range at which to get targets
*
* returns 		array of valid targets
**/

obj_id[] getValidPlayersInRadius(obj_id self, float range)
{
	obj_id[] players = getPlayerCreaturesInRange(self, range);

	resizeable obj_id[] targets = new obj_id[0];

	if (players != null && players.length != 0)
	{
		for (int k=0;k<players.length;k++)
		{
			if (isIdValid(players[k]) && exists(players[k]) && !isIncapacitated(players[k]) && canSee(self, players[k]))
				utils.addElement(targets, players[k]);
		}
	}

	if (targets == null || targets.length == 0)
	{
		doLogging("getValidPlayersInRadius", "There were no valid players in the radial area");
		return null;
	}
	obj_id[] validTargets = targets;

	return validTargets;
}

/**
* Set the dungeon end timer to 5 minutes and send a timer update
*
* obj_id dungeon_controller	The dungeon controller for the instance
* int timeAddition		Time to add to current time for the dungeon to end
*
* returns			void
**/
void setDungeonCleanOutTimer(obj_id dungeon_controller)
{
	setDungeonCleanOutTimer(dungeon_controller, 300);
}

void setDungeonCleanOutTimer(obj_id dungeon_controller, int timeAddition)
{
	int newEndTime = getGameTime() + timeAddition;
	setObjVar(dungeon_controller, space_dungeon.VAR_DUNGEON_END_TIME, newEndTime);
	int sessionId = space_dungeon.getDungeonSessionId(dungeon_controller);
	dictionary dict = new dictionary();
	dict.put("sessionId", sessionId);
	messageTo(dungeon_controller, "handleSessionTimerUpdate", dict, 0, false);

	instance.setClock(dungeon_controller, 300);

}

/**
* Sets an NPC in a state where they will react to any stimilus
*
* obj_id npc			The NPC to set interest for
*
* return			void
*
**/
void setInterest(obj_id npc)
{
	if (!isIdValid(npc))
		return;

	setAttributeInterested(npc, attrib.ALL);
	setAttributeAttained(npc, attrib.ALL);
}

/**
* Sends  a groundquest wait for task signal to the participants of a dungeon on victory
*
* obj_id dungeon			The dungeon the players have defeated
* string signalName			The string name of the signal to send
*
* return 				void
**/
void sendCompletionSignal(obj_id dungeon, string signalName)
{
	obj_id[] players = instance.getPlayersInInstanceArea(dungeon);
	groundquests.sendSignal(players, signalName);
}

/**
* Removes all scripts and objvars from an object and cleans them up
* Will eject any players before
*
* obj_id creature			The Creature to destroy
*
* return				void
**/
void cleanupNpc(obj_id npc)
{
	if (!isIdValid(npc))
	{
		return;
	}

	if (isPlayer(npc))
		return;


	if (isMob(npc))
	{
		detachAllScripts(npc);
		removeAllObjVars(npc);
		kill(npc);
	}
	else
		cleanupObject(npc);

	destroyObject(npc);
}

void cleanupObject(obj_id object)
{
	if (!isIdValid(object))
	{
		return;
	}

	if (isPlayer(object))
		return;


	if ( !hasScript(object, "systems.dungeon_sequencer.sequence_controller") && !vehicle.isBattlefieldVehicle(object))
		detachAllScripts(object);

	trial.unregisterObjectWithSequencer(trial.getParent(object), object);

	removeAllObjVars(object);

	if (isMob(object))
	{
		kill(object);
	}

	obj_id[] cells = getCellIds(object);
	if (cells != null)
	{
		obj_id[] objects = getAllObjectsInDungeon(object);
		location ejectPoint = getLocation(object);

		if (objects != null && objects.length > 0)
		{
			for (int i=0;i<objects.length;i++)
			{
				if (isPlayer(objects[i]))
					expelFromBuilding(objects[i]);
				else
					cleanupObject(objects[i]);
			}
		}
	}

	if (vehicle.isVehicle(object))
	{
		if ( vehicle.isBattlefieldVehicle(object) )
		{
			queueCommand(getRiderId(object), ##"battlefieldDismount", object, getName(object), COMMAND_PRIORITY_FRONT);
		}
		else
		{
			queueCommand(getRiderId(object), ##"dismount", object, getName(object), COMMAND_PRIORITY_FRONT);
		}
	}

	destroyObject(object);

}

void cleanupNpc(obj_id[] npc)
{
	cleanupObject(npc);
}

void cleanupObject(obj_id[] objects)
{
	if (objects == null || objects.length == 0)
		return;

	for (int i=0;i<objects.length;i++)
		cleanupObject(objects[i]);
}

/**
*
* Sets the HP for a creature or object to a specified amount
*
* obj_id subject	The object to modify HP on
*
* return 		void
**/

void setHp(obj_id target, int ammount)
{
	if (!isIdValid(target))
	{
		return;
	}

	if (ammount < 0)
	{
		return;
	}

	if ( isMob(target) && !vehicle.isVehicle(target) )
	{
		setMaxAttrib(target, HEALTH, ammount );
		setAttrib(target, HEALTH, ammount );
	}
	else
	{
		setMaxHitpoints(target, ammount);
		setHitpoints(target, ammount);
	}
}

/**
*
* Sets the objvar "Parent" on an object, this is the object in charge of the child object
*
* obj_id object 		Object to mark
* obj_id parent			The parent object to mark with
* boolean permenant		Sets an objvar on true, scriptvar on false
*
* return void
*
**/

void setParent(obj_id parent, obj_id child, boolean permenant)
{
	if (!isIdValid(child) || !isIdValid(parent))
	{
		doLogging("setParent", "Parent or child object was null");
		return;
	}

	if (permenant)
	{
		setObjVar(child, PARENT, parent);
	}
	else
	{
		utils.setScriptVar(child, PARENT, parent);
		addToChildArray(parent, child);
	}
}

void addToChildArray(obj_id parent, obj_id child)
{
	resizeable obj_id[] children = new obj_id[0];

	if (utils.hasScriptVar(parent, ARRAY_CHILDREN))
	{
		children = utils.getResizeableObjIdArrayScriptVar(parent, ARRAY_CHILDREN);
		utils.removeScriptVar(parent, ARRAY_CHILDREN);
	}

	utils.addElement(children, child);

	utils.setScriptVar(parent, ARRAY_CHILDREN, children);
}

obj_id[] getChildArray(obj_id parent)
{
	if (!utils.hasScriptVar(parent, ARRAY_CHILDREN))
		return null;

	resizeable obj_id[] tempArray = utils.getResizeableObjIdArrayScriptVar(parent, ARRAY_CHILDREN);

	return tempArray;
}

/**
*
* obj_id object		The object to get a parent for
*
* return obj_id		The parent object
*
**/
obj_id getParent(obj_id object)
{
	if (!isIdValid(object) || !exists(object))
	{
		doLogging("getParent", "Object was null");
		return null;
	}
	if (utils.hasScriptVar(object, PARENT))
	{
		return utils.getObjIdScriptVar(object, PARENT);
	}
	if (hasObjVar(object, PARENT))
	{
		return getObjIdObjVar(object, PARENT);
	}

	return object;
}

/**
*
* obj_id parent		The object to compare against
* obj_id child
*
* return boolean	True if the child belongs to the parent
*
**/
boolean isChild(obj_id parent, obj_id child)
{
	if (!isIdValid(parent) || !isIdValid(child))
		return false;

	if (utils.hasScriptVar(child, PARENT))
		return (utils.getObjIdScriptVar(child, PARENT) == parent);

	if (hasObjVar(child, PARENT))
		return (getObjIdObjVar(child, PARENT) == parent);

	return false;
}

/**
*
* obj_id dungoen	The Dungeon to scan for children
* obj_id parent		The parent to compare against
*
* return obj_id[]	An array of children
*
**/
obj_id[] getAllChildrenInDungeon(obj_id dungeon, obj_id parent)
{
	if (!isIdValid(dungeon) || !isIdValid(parent))
		return null;

	obj_id[] cells = getCellIds(dungeon);

	if (cells == null || cells.length == 0)
		return null;

	resizeable obj_id[] objects = new obj_id[0];

	for (int i=0;i<cells.length;i++)
	{
		obj_id[] contents = getContents(cells[i]);

		if (contents != null && contents.length > 0)
		{
			for (int k=0;k<contents.length;k++)
			{
				if (isChild(parent, contents[k]))
					utils.addElement(objects, contents[k]);
			}
		}
	}

	if (objects == null || objects.length == 0)
		return null;

	obj_id[] returnList = objects;

	return returnList;
}


/**
*
* obj_id baseObject	The object in the center of your search area
* obj_id parent		The parent objvar to compare children against
* obj_id range		The radius to search
*
* return obj_id[] 	An array of children
**/
obj_id[] getChildrenInRange(obj_id baseObject, obj_id parent, float range)
{
	if (!isIdValid(baseObject) || !isIdValid(parent))
		return null;

	location baseLoc = getLocation(baseObject);

	return getChildrenInRange(baseLoc, parent, range);
}

obj_id[] getChildrenInRange(location baseLoc, obj_id parent, float range)
{
	if (!isIdValid(parent))
		return null;

	obj_id[] objects = getObjectsInRange(baseLoc, range);

	if (objects == null || objects.length == 0)
		return null;

	resizeable obj_id[] children = new obj_id[0];

	for (int i=0;i<objects.length;i++)
	{
		if (isChild(parent, objects[i]))
			utils.addElement(children, objects[i]);
	}

	if (children == null || children.length == 0)
		return null;

	obj_id[] returnList = children;
	return returnList;
}

/**
*
* obj_id baseObj		The center object to conduct the search from
* string scriptVar		The scriptvar to search for
* float range			The radius to search
*
* return obj_id[] 		An array of objects with the script var
*
**/
obj_id[] getObjectsInRangeWithScriptVar(obj_id baseObj, string scriptVar, float range)
{
	if (!isIdValid(baseObj) || scriptVar.equals(""))
		return null;

	location baseLoc = getLocation(baseObj);

	return getObjectsInRangeWithScriptVar(baseLoc, scriptVar, range);
}

obj_id[] getObjectsInRangeWithScriptVar(location baseLoc, string scriptVar, float range)
{
	if (scriptVar.equals(""))
		return null;

	obj_id[] objects = getObjectsInRange(baseLoc, range);

	if (objects == null || objects.length == 0)
		return null;

	resizeable obj_id[] withVar = new obj_id[0];

	for (int i=0;i<objects.length;i++)
	{
		if (utils.hasScriptVar(objects[i], scriptVar))
			utils.addElement(withVar, objects[i]);
	}

	if (withVar == null || withVar.length == 0)
		return null;

	obj_id[] returnList = withVar;
	return returnList;

}

/**
* This will prevent a corpse from decaying on death
*
* obj_id corpse		The corpse to remove pertinant scripts from
*
* return void
*
**/
void prepareCorpse(obj_id corpse)
{
	detachScript(corpse, "ai.ai");
}


//Depricated to space_dungeon.scriptlib
void playMusicInInstance(obj_id dungeon, string sound)
{
	space_dungeon.playMusicInInstance(dungeon, sound);
}


void sendInstanceSystemMessage(obj_id dungeon, string_id message)
{
	space_dungeon.sendInstanceSystemMessage(dungeon, message);
}

obj_id getClosestValidTarget(obj_id base, obj_id[] targets)
{
	return getClosest(base, targets);
}

obj_id getClosest(obj_id base, obj_id[] targets)
{
	obj_id prefered = obj_id.NULL_ID;

	for (int i=0;i<targets.length;i++)
	{
		if (!isDead(targets[i]))
		{
			if (!isIdValid(prefered))
				prefered = targets[i];
			else
			{
				if (getDistance(base, targets[i]) < getDistance(base, prefered) && canSee(base, targets[i]) && !stealth.hasInvisibleBuff(targets[i]))
					prefered = targets[i];
			}
		}
	}

	return prefered;
}

obj_id getSecondClosest(obj_id base, obj_id[] targets)
{
	obj_id prefered = obj_id.NULL_ID;
	obj_id previous = obj_id.NULL_ID;

	for(int i=0;i < targets.length; i++)
	{
		if(!isDead(targets[i]))
		{
			if(!isIdValid(prefered))
			{
				prefered = targets[i];
			}
			else
			{
				if(getDistance(base, targets[i]) < getDistance(base, prefered) && canSee(base, targets[i]))
				{
					previous = prefered;
					prefered = targets[i];
				}
			}
		}
	}

	return previous;
}

obj_id getClosestObject(obj_id base, obj_id[] targets)
{
	obj_id prefered = null;

	for (int i=0;i<targets.length;i++)
	{
		if (!isIdValid(prefered))
			prefered = targets[i];
		else
		{
			if (getDistance(base, targets[i]) < getDistance(base, prefered) && canSee(base, targets[i]))
				prefered = targets[i];
		}
	}


	return prefered;

}

void markAsTempObject(obj_id object, boolean permenant)
{
	if (permenant)
		setObjVar(object, TEMP_OBJECT, true);
	else
		utils.setScriptVar(object, TEMP_OBJECT, true);
}

boolean isTempObject(obj_id object)
{
	if (utils.hasScriptVar(object, TEMP_OBJECT))
		return true;

	if (hasObjVar(object, TEMP_OBJECT))
		return true;

	return false;
}

obj_id[] getTempObjectsInDungeon(obj_id dungeon)
{
	obj_id[] objects = getAllObjectsInDungeon(dungeon);

	if (objects == null || objects.length == 0)
		return null;

	resizeable obj_id[] tempObjects = new obj_id[0];

	for (int i=0;i<objects.length;i++)
	{
		if (isTempObject(objects[i]))
			utils.addElement(tempObjects, objects[i]);
	}

	if (tempObjects == null || tempObjects.length == 0)
		return null;

	return tempObjects;
}

obj_id[] getTempObjectsInBuildoutArea(obj_id baseObject)
{
	obj_id[] objects = utils.getAllObjectsInBuildoutArea(baseObject);

	if (objects == null || objects.length == 0)
		return null;

	resizeable obj_id[] tempObjects = new obj_id[0];

	for (int i=0;i<objects.length;i++)
	{
		if (trial.isTempObject(objects[i]))
			tempObjects.add(objects[i]);
	}

	if (tempObjects == null || tempObjects.length == 0)
		return null;

	return tempObjects;
}

string getNearestPatrolPoint(obj_id actor, string[] patrolPointList)
{
	int idx = getNearestPatrolPointIndex(actor, patrolPointList);
	return patrolPointList[idx];
}

int getNearestPatrolPointIndex(obj_id actor, string[] patrolPointList)
{
	obj_id[] points = getAllObjectsWithObjVar(getLocation(actor), 2000.0f, "sequence_controller.patrolPointName");

	resizeable string[] ppl = patrolPointList;

	float distance = 2000.0f;
	int idx = 0;

	for (int i=0;i<points.length;i++)
	{
		if (getParent(actor) != getParent(points[i]))
			continue;

		string testName = getStringObjVar(points[i], "sequence_controller.patrolPointName");

		if (ppl.indexOf(testName) == -1)
			continue;
		if (getDistance(actor, points[i]) < distance && canSee(actor, points[i]))
		{
			idx = ppl.lastIndexOf(testName);
			distance = getDistance(actor, points[i]);
		}
	}

	return idx;
}

location[] convertPatrolPointNameToLoc(obj_id actor, string[] patrolPointList)
{
	resizeable location[] locList = new location[0];

	for (int i=0;i<patrolPointList.length;i++)
	{
		obj_id[] points = getAllObjectsWithObjVar(getLocation(actor), 2000.0f, "sequence_controller.patrolPointName");

		for (int k=0;k<points.length;k++)
		{
			if (getStringObjVar(points[k], "sequence_controller.patrolPointName").equals(patrolPointList[i]) &&
				trial.getParent(points[k]) == trial.getParent(actor))
			{
				utils.addElement(locList,getLocation(points[k]));
			}
		}
	}

	if (locList == null || locList.length == 0)
		return null;


	location[] returnList = locList;

	return locList;
}

obj_id[] getObjectsInListWithObjVar(obj_id[] list, string objvar)
{
	resizeable obj_id[] targetObjects = new obj_id[0];

	for (int i=0;i<list.length;i++)
	{
		if (isIdValid(list[i]) && exists(list[i]) && hasObjVar(list[i], objvar))
			utils.addElement(targetObjects, list[i]);
	}

	if (targetObjects == null || targetObjects.length == 0)
		return null;

	obj_id[] returnList = targetObjects;

	return returnList;
}

location[] shuffleByIndex(string type, location[] ppl, int idx)
{
	location[] retarded = (location[])ppl.clone();
	resizeable location[] oldPpl = retarded;
	resizeable location[] newPpl = new string[0];


	if (type.equals("patrol"))
	{
		for (int i=idx;i<ppl.length;i++)
		{
			newPpl.add(ppl[i]);
			oldPpl.remove(ppl[i]);
		}

		for (int q=0;q<idx;q++)
		{
			newPpl.addElement(oldPpl[q]);
		}
	}

	if (type.equals("patrolOnce"))
	{
		for (int i=idx;i<ppl.length;i++)
		{
			newPpl.add(ppl[i]);
		}
	}

	if (type.equals("patrolFlip"))
	{
		for (int i=idx;i<ppl.length;i++)
		{
			newPpl.add(ppl[i]);
		}

		for (int q=ppl.length - 2;q> -1 ; q--)
		{
			newPpl.add(ppl[q]);
		}

		for (int r=0;r<idx;r++)
		{
			newPpl.add(ppl[r]);
		}
	}

	if (type.equals("patrolFlipOnce"))
	{
		for (int i=idx;i<ppl.length;i++)
		{
			newPpl.add(ppl[i]);
		}

	}
	if (type.equals("patrolRandom") || type.equals("patrolRandomOnce"))
	{
		newPpl = ppl;
	}

	return newPpl;
}

obj_id[] getSpawnedChildren(obj_id object)
{
	dictionary spawnList = utils.getDictionaryScriptVar(object, PROT_CHILD_ARRAY);
	resizeable string[] keyList = spawnList.getResizeableStringArray(PROT_CHILD_KEY_LIST);

	resizeable obj_id[] allChildren = new obj_id[0];

	if (keyList == null || keyList.length == 0)
		return null;

	for (int i=0;i<keyList.length;i++)
	{
		resizeable obj_id[] thisList = spawnList.getResizeableObjIdArray(keyList[i]);

		if (thisList == null || thisList.length == 0)
			continue;

		allChildren.addAll(thisList);
	}

	obj_id[] returnList = allChildren;

	return returnList;
}

obj_id[] getObjectsInInstanceBySpawnId(obj_id baseObject, string spawn_id)
{
	dictionary spawnList = utils.getDictionaryScriptVar(trial.getParent(baseObject), PROT_CHILD_ARRAY);

	if (!spawnList.containsKey(spawn_id))
		return null;

	resizeable obj_id[] thisList = spawnList.getResizeableObjIdArray(spawn_id);

	obj_id[] returnList = thisList;

	return returnList;
}

obj_id[] getObjectsInInstanceBySpawnId(obj_id baseObject, string[] idList)
{
	dictionary spawnList = utils.getDictionaryScriptVar(trial.getParent(baseObject), PROT_CHILD_ARRAY);

	resizeable obj_id[] allSpawn = new obj_id[0];

	for (int i=0; i < idList.length; i++)
	{
		if (!spawnList.containsKey(idList[i]))
			continue;

		resizeable obj_id[] thisList = spawnList.getResizeableObjIdArray(idList[i]);

		if (thisList == null || thisList.length == 0)
			continue;

		allSpawn.addAll(thisList);
	}

	obj_id[] returnList = allSpawn;

	return returnList;

}

obj_id[] getObjectsInInstanceByObjVar(obj_id baseObject, string obj_var)
{
	obj_id[] allChildren = getSpawnedChildren(trial.getParent(baseObject));
	return getObjectsInListWithObjVar(allChildren, obj_var);
}

obj_id[] getObjectsInInstanceByObjVar(obj_id baseObject, string[] idList)
{
	if (idList == null || idList.length == 0)
		return null;

	resizeable obj_id[] allSpawns = new obj_id[0];

	for (int i=0;i<idList.length;i++)
	{
		obj_id[] thisVector = getObjectsInInstanceByObjVar(baseObject, idList[i]);

		for (int q=0;q<thisVector.length;q++)
			allSpawns.add(thisVector[q]);
	}

	if (allSpawns == null || allSpawns.length == 0)
		return null;

	return allSpawns;
}

void sendSequenceTrigger(string sequence_trigger)
{
	obj_id instance_id = instance.getAreaInstanceController(getSelf());

	if (!isIdValid(instance_id) || !exists(instance_id))
		return;

	dictionary dict = trial.getSessionDict(instance_id);
	dict.put("triggerType", "triggerId");
	dict.put("triggerName", sequence_trigger);
	messageTo(instance_id, "triggerFired", dict, 1.0f, false);

}

boolean registerObjectWithSequencer(obj_id object)
{
	obj_id instance_id = instance.getAreaInstanceController(object);
	if (!isIdValid(instance_id))
		return false;

	return registerObjectWithSequencer(instance_id, object);
}

boolean registerObjectWithSequencer(obj_id sequencer, obj_id object)
{
	dictionary dict = trial.getSessionDict(sequencer);
	dict.put("object", object);
	messageTo(sequencer, "registerObjectWithSequencer", dict, 0.0f, false);
	return true;
}

boolean unregisterObjectWithSequencer(obj_id object)
{
	obj_id instance_id = instance.getAreaInstanceController(object);
	if (!isIdValid(instance_id))
		return false;

	return 	unregisterObjectWithSequencer(instance_id, object);
}

boolean unregisterObjectWithSequencer(obj_id sequencer, obj_id object)
{
	if (!isIdValid(sequencer) && sequencer == getSelf())
		return false;

	dictionary dict = trial.getSessionDict(sequencer);
	dict.put("object", object);
	string spawn_id = "none";

	if(isIdValid(object) && exists(object))
	{
		spawn_id = hasObjVar(object, "spawn_id") ? getStringObjVar(object, "spawn_id") : "none";
	}
	
	dict.put("spawn_id", spawn_id);
	messageTo(sequencer, "unregisterObjectWithSequencer", dict, 0.0f, false);
	return true;
}

void storeSpawnedChild(obj_id self, obj_id child, string spawn_id)
{
	dictionary childArray = utils.getDictionaryScriptVar(self, trial.PROT_CHILD_ARRAY);

	resizeable obj_id[] thisList = new obj_id[0];
	resizeable string[] all_spawn_id = new string[0];

	if (childArray.containsKey(spawn_id))
		thisList = childArray.getResizeableObjIdArray(spawn_id);

	if (childArray.containsKey(trial.PROT_CHILD_KEY_LIST))
		all_spawn_id = childArray.getResizeableStringArray(trial.PROT_CHILD_KEY_LIST);

	thisList.add(child);

	if (!all_spawn_id.contains(spawn_id))
		all_spawn_id.add(spawn_id);

	childArray.put(spawn_id, thisList);
	childArray.put(trial.PROT_CHILD_KEY_LIST, all_spawn_id);

	utils.setScriptVar(self, trial.PROT_CHILD_ARRAY, childArray);
}

void setFullPathData(obj_id object)
{
	obj_id parent = getParent(object);

	string[] pathArray = getFullPathData(parent);

	if (pathArray == null)
		return;

	utils.setScriptVar(object, PATROL_PATH_FULL_DATA, pathArray);
}

string[] getFullPathData(obj_id parent)
{
	if(!isIdValid(parent) || !exists(parent))
	{
		return null;
	}

	if (utils.hasScriptVar(parent, PATROL_PATH_FULL_DATA))
		return utils.getStringArrayScriptVar(parent, PATROL_PATH_FULL_DATA);

	string[] path_column = dataTableGetStringColumnNoDefaults(getStringObjVar(parent, "instance.data_table"), "paths");

	if (path_column == null || path_column.length == 0)
		return null;

	return path_column;
}

void doLogging(string section, string message)
{
	if (LOGGING)
		LOG("doLogging/library.trial/"+section, message);
}

obj_id createSchedulerNPC(obj_id parent, obj_id patrolPoint, string npcName)
{
	location loc = getLocation(parent);
	
	obj_id npc = createSchedulerNPC(parent, patrolPoint, npcName, loc);
	
	return npc;
}

obj_id createSchedulerNPC(obj_id parent, obj_id patrolPoint, string npcName, location loc)
{
	// LOG("doLogging", "createSchedulerNPC kit: " + kit + " npcName: " + npcName);

	if(!isIdValid(parent) || !exists(parent))
	{
		return null;
	}
	
	obj_id kitParent = trial.getParent(parent);

	if(!isIdValid(kitParent) || !exists(kitParent))
	{
		return null;
	}

	// Create the npc
	//location loc = getLocation(parent);
	
	obj_id npc = create.object(npcName, loc);
	
	if(!isIdValid(npc) || !exists(npc))
	{
		return null;
	}
	
	trial.markAsTempObject(npc, true);
	trial.setParent(kitParent, npc, true);
	trial.setInterest(npc);

	setObjVar(npc, "spawn_id", "gcwPatrol");
	
	trial.storeSpawnedChild(kitParent, npc, "gcwPatrol");

	string patrol = getStringObjVar(parent, "patrolPoint");

	// LOG("doLogging", "createSchedulerNPC npc: " + npc + " npcName: " + npcName);
	
	if(patrol != null && patrol.length() > 0)
	{
		dictionary path_data = utils.hasScriptVar(kitParent, trial.SEQUENCER_PATH_DATA) ? utils.getDictionaryScriptVar(kitParent, trial.SEQUENCER_PATH_DATA) : null;

		if (path_data != null && !path_data.isEmpty())
			utils.setScriptVar(npc, trial.SEQUENCER_PATH_DATA, utils.getDictionaryScriptVar(kitParent, trial.SEQUENCER_PATH_DATA));

		setObjVar(npc, "patrol_path", patrol);
		setHibernationDelay(npc, 3600.0f);
		removeObjVar(npc, gcw.GCW_ENTERTAINMENT_FLAG);
		aiEquipPrimaryWeapon(npc);
	}
	else
	{
		//defensive position: mark NPC as entertainment npc
		utils.setScriptVar(patrolPoint, gcw.GCW_NPC_SCRIPTVAR_FLAG, npc);
	}
	
	attachScript(npc, "systems.dungeon_sequencer.ai_controller");

	return npc;
}

boolean addNonInstanceFactionParticipant(obj_id who, obj_id target)
{
	if(!isIdValid(who) || !exists(who) || !isPlayer(who) || !isIdValid(target) || !exists(target))
	{
		return false;
	}

	//If the egg is not in a construction or combat phase, don't do anything. 
	if(gcw.getGcwCityInvasionPhase(target) <= 0)
	{
		return false;	
	}
	
	obj_id parent = trial.getParent(target);
	
	if(!isIdValid(parent) || !exists(parent))
	{
		return false;
	}
	
	obj_id lastParent = null;
	
	while(!hasScript(parent, "systems.dungeon_sequencer.sequence_controller") && parent != lastParent)
	{
		lastParent = parent;
		parent = trial.getParent(parent);
		
		if(!isIdValid(parent) || !exists(parent))
		{
			return false;
		}
	}
	
	string participantScriptVar = "";
	
	if(factions.isRebelorRebelHelper(who))
	{
		participantScriptVar = "gcw.rebel.participants";
	}
	else if(factions.isImperialorImperialHelper(who))
	{
		participantScriptVar = "gcw.imperial.participants";
	}

	if(participantScriptVar == null || participantScriptVar.length() < 1)
	{
		CustomerServiceLog("gcw_city_invasion", "trial.addNonInstanceFactionParticipant: Player: "+who+" did not have the faction affiliation needed to be added to a participant list.");	
		return false;
	}

	resizeable obj_id[] sideParticipants = new obj_id[0];
	
	if(utils.hasScriptVar(parent, participantScriptVar))
	{
		sideParticipants = utils.getResizeableObjIdArrayScriptVar(parent, participantScriptVar);

		if(sideParticipants != null && utils.isElementInArray(sideParticipants, who))
		{
			CustomerServiceLog("gcw_city_invasion", "trial.addNonInstanceFactionParticipant: Player: "+who+" was already on the list as a paricipant so the operation was aborted.");	
			return false;
		}
	}
	
	utils.addElement(sideParticipants, who);
	utils.setScriptVar(parent, participantScriptVar, sideParticipants);
	CustomerServiceLog("gcw_city_invasion", "trial.addNonInstanceFactionParticipant: Player: "+who+" has been added as a valid participant of the GCW city invasion for city object: "+parent);	
	return true;
}

boolean removeNonInstanceFactionParticipant(obj_id who, obj_id target)
{
	if(!isIdValid(who) || !exists(who) || !isPlayer(who) || !isIdValid(target) || !exists(target))
	{
		return false;
	}

	obj_id parent = trial.getParent(target);
	
	if(!isIdValid(parent) || !exists(parent))
	{
		return false;
	}
	
	obj_id lastParent = null;
	
	while(!hasScript(parent, "systems.dungeon_sequencer.sequence_controller") && parent != lastParent)
	{
		lastParent = parent;
		parent = trial.getParent(parent);
		
		if(!isIdValid(parent) || !exists(parent))
		{
			return false;
		}
	}
	
	string participantScriptVar = "";
	
	if(factions.isRebelorRebelHelper(who))
	{
		participantScriptVar = "gcw.rebel.participants";
	}
	else if(factions.isImperialorImperialHelper(who))
	{
		participantScriptVar = "gcw.imperial.participants";
	}

	if(participantScriptVar == null || participantScriptVar.length() < 1)
	{
		return false;
	}

	resizeable obj_id[] sideParticipants = new obj_id[0];
	
	if(utils.hasScriptVar(parent, participantScriptVar))
	{
		sideParticipants = utils.getResizeableObjIdArrayScriptVar(parent, participantScriptVar);

		if(sideParticipants != null && !utils.isElementInArray(sideParticipants, who))
		{
			return false;
		}
	}

	utils.removeElement(sideParticipants, who);

	if(sideParticipants.length == 0)
	{
		utils.removeScriptVar(parent, participantScriptVar);
		CustomerServiceLog("gcw_city_invasion", "trial.removeNonInstanceFactionParticipant: Player: "+who+" has been REMOVED as a valid participant of the GCW city invasion for city object: "+parent);	
		return true;
	}
	else if(utils.setScriptVar(parent, participantScriptVar, sideParticipants))
	{
		CustomerServiceLog("gcw_city_invasion", "trial.removeNonInstanceFactionParticipant: Player: "+who+" has been REMOVED as a valid participant of the GCW city invasion for city object: "+parent);	
		return true;
	}
	
	LOG("participant_credit", "removeNonInstanceFactionParticipant failed to set script var");

	return false;	
}

boolean isNonInstanceFactionParticipant(obj_id who, obj_id target)
{
	if(!isIdValid(who) || !exists(who) || !isPlayer(who) || !isIdValid(target) || !exists(target))
	{
		return false;
	}

	obj_id parent = trial.getParent(target);
	
	if(!isIdValid(parent) || !exists(parent))
	{
		return false;
	}
	
	obj_id lastParent = null;
	
	while(!hasScript(parent, "systems.dungeon_sequencer.sequence_controller") && parent != lastParent)
	{
		lastParent = parent;
		parent = trial.getParent(parent);
		
		if(!isIdValid(parent) || !exists(parent))
		{
			return false;
		}
	}
	
	string participantScriptVar = "";
	
	if(factions.isRebelorRebelHelper(who))
	{
		participantScriptVar = "gcw.rebel.participants";
	}
	else if(factions.isImperialorImperialHelper(who))
	{
		participantScriptVar = "gcw.imperial.participants";
	}

	if(participantScriptVar == null || participantScriptVar.length() < 1)
	{
		return false;
	}

	resizeable obj_id[] sideParticipants = new obj_id[0];
	
	if(utils.hasScriptVar(parent, participantScriptVar))
	{
		sideParticipants = utils.getResizeableObjIdArrayScriptVar(parent, participantScriptVar);

		if(sideParticipants != null && !utils.isElementInArray(sideParticipants, who))
		{
			return false;
		}


		for(int i = 0; i < sideParticipants.length; i++)
		{
			if(!isValidId(sideParticipants[i]))
			{
				continue;
			}
				
			if(sideParticipants[i] != who)
			{
				continue;
			}
			return true;
		}
	}
	return false;
}

resizeable obj_id[] getNonInstanceFactionParticipants(obj_id sequencer, int faction)
{
	if(!isIdValid(sequencer) || !exists(sequencer))
	{
		CustomerServiceLog("gcw_city_invasion", "trial.getNonInstanceFactionParticipants: Sequencer was invalid. Returning NULL.");		
		return null;
	}

	if(!hasScript(sequencer, "systems.dungeon_sequencer.sequence_controller"))
	{
		CustomerServiceLog("gcw_city_invasion", "trial.getNonInstanceFactionParticipants: Sequencer did not have the sequence controller script. Returning NULL.");		
		return null;
	}

	string participantScriptVar = "";
	
	if(factions.FACTION_FLAG_REBEL == faction)
	{
		participantScriptVar = "gcw.rebel.participants";
	}
	else if(factions.FACTION_FLAG_IMPERIAL == faction)
	{
		participantScriptVar = "gcw.imperial.participants";
	}

	if(participantScriptVar == null || participantScriptVar.length() <= 0)
	{
		CustomerServiceLog("gcw_city_invasion", "trial.getNonInstanceFactionParticipants: Participant list not found. Returning NULL.");		
		return null;
	}
		
	if(utils.hasScriptVar(sequencer, participantScriptVar))
	{
		return utils.getResizeableObjIdArrayScriptVar(sequencer, participantScriptVar);
	}
	
	CustomerServiceLog("gcw_city_invasion", "trial.getNonInstanceFactionParticipants: Participant list not found. Returning NULL.");		
	return null;
}

void clearNonInstanceFactionParticipants(obj_id sequencer)
{
	if(!isIdValid(sequencer) || !exists(sequencer))
	{
		CustomerServiceLog("gcw_city_invasion", "trial.clearNonInstanceFactionParticipants: Sequencer invalid. Aborting.");			
		return;
	}

	if(!hasScript(sequencer, "systems.dungeon_sequencer.sequence_controller"))
	{
		CustomerServiceLog("gcw_city_invasion", "trial.clearNonInstanceFactionParticipants: Sequencer did not have sequence controller script. Aborting.");			
		return;
	}

	utils.removeScriptVar(sequencer, "gcw.rebel.participants");
	utils.removeScriptVar(sequencer, "gcw.imperial.participants");
}

boolean purchaseTokenItem(obj_id player, int price, string tokenName)
{
	// Attempt to make the item in their inventory.
	
	if(!isIdValid(player) || !exists(player) || price < 0 || tokenName == null || tokenName.length() <= 0)
	{
		return false;
	
	}
	
	obj_id[] inventoryContents = getInventoryAndEquipment(player);
	if(inventoryContents == null || inventoryContents.length <= 0)
	{
		return false;
	
	}
	int tokensOwed = price;

	
	// Destroy tokens
	boolean foundTokenHolderBox = false;
	
	for(int i = 0; i < inventoryContents.length; i++)
	{


		if(!isIdValid(inventoryContents[i]) || !exists(inventoryContents[i])) 
		{
			continue;
		}
		
		string itemName = getStaticItemName(inventoryContents[i]);

		if (itemName != null && itemName != "")
		{
		
			if(itemName.equals(tokenName))
			{
				if(getCount(inventoryContents[i]) > 1)
				{
					if(getCount(inventoryContents[i]) > tokensOwed)
					{
						setCount(inventoryContents[i], (getCount(inventoryContents[i]) - tokensOwed));
						tokensOwed = 0;
					}
					
					else
					{
						tokensOwed = tokensOwed - getCount(inventoryContents[i]);
						destroyObject(inventoryContents[i]);
					
					}
					
				}
				else
				{
					destroyObject(inventoryContents[i]);
					tokensOwed--;
				}
			}
			
			// Virtual tokens.
			if(!foundTokenHolderBox && itemName.equals("item_heroic_token_box_01_01"))
			{
				foundTokenHolderBox = true;
				int vTokens = 0;
				if(hasObjVar(inventoryContents[i], "item.set.tokens_held"))
				{
					int[] virtualTokens = getIntArrayObjVar(inventoryContents[i], "item.set.tokens_held");
					int t = -1;
					for(int k = 0; k < HEROIC_TOKENS.length; k++)
					{					
						if(HEROIC_TOKENS[k].equals(tokenName))
						{
							t = k;
							vTokens = virtualTokens[t];
						}
					}
					
					if(t > -1)
					{
						if(vTokens > tokensOwed)
						{
							vTokens = vTokens - tokensOwed;
							virtualTokens[t] = vTokens;
							tokensOwed = 0;
						}

						else
						{

							tokensOwed = tokensOwed - vTokens;
							virtualTokens[t] = 0;
						}
						setObjVar(inventoryContents[i], "item.set.tokens_held", virtualTokens);
					}
				}
			}
		}
	}
	
	if(tokensOwed == 0)
	{
		return true;
	}

	return false;
}


// Space Duty - Get token price
int getSpaceDutyTokenPrice(int level)
{
	int price = level * 5;
	price = price + 50;
	return price;
}

int getTokenTotal(obj_id player, string token)
{
	int tokenCount = 0;


	if(!isIdValid(player) || !exists(player) || token == null || token.length() <= 0)
	{
		return 0;
	
	}

	obj_id[] inventoryContents = getInventoryAndEquipment(player);
	
	if(inventoryContents == null || inventoryContents.length <= 0)
	{
		return 0;
	}
	
	boolean foundTokenHolderBox = false;
	for(int i = 0; i < inventoryContents.length; i++)
	{

		if(!isIdValid(inventoryContents[i]) || !exists(inventoryContents[i])) 
		{
			continue;
		}
	
		string itemName = getStaticItemName(inventoryContents[i]);
		if (itemName != null && itemName != "")
		{
			// Physical tokens.
			if(itemName.equals(token))
			{
				if(getCount(inventoryContents[i]) > 1)
				{
					tokenCount = tokenCount + getCount(inventoryContents[i]);
				}
				else
				{
					tokenCount++;
				}
				
			}

			// Virtual tokens.
			if(!foundTokenHolderBox && itemName.equals("item_heroic_token_box_01_01"))
			{
				foundTokenHolderBox = true;
				trial.verifyBox(inventoryContents[i]);
				int t = 0;
				
				if(hasObjVar(inventoryContents[i], "item.set.tokens_held"))
				{
					int[] virtualTokenArray = getIntArrayObjVar(inventoryContents[i], "item.set.tokens_held");
					
					for(int k = 0; k < trial.HEROIC_TOKENS.length; k++)
					{
						if(trial.HEROIC_TOKENS[k].equals(token))
						{
							t = k;
						}
					}
					tokenCount = tokenCount+virtualTokenArray[t];
				}
			}
		}
	}
	return tokenCount;
}	