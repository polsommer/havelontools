/**
 * Copyright (c)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        vehicle.scriptlib
 * Description:  Base library for manipulating vehicle properties
 * @author       $Author:$
 * @version      $Revision:$
 */

/***** INCLUDES ********************************************************/
include library.callable;
include library.colors;
include library.money;
include library.pet_lib;
include library.hue;
include library.space_transition;
include library.group;
include library.ai_lib;
include library.space_dungeon;
include library.buff;
include library.instance;

/***** CONSTANTS *******************************************************/

const int MAX_STORED_VEHICLES = 3;
const int MAX_STORED_VEHICLES_MUSTAFAR_EXPANSION= 6;
const int MAX_VEHICLES = 1;

const int VAR_SPEED_MIN      = 0;
const int VAR_SPEED_MAX      = 1;
const int VAR_TURN_RATE_MIN  = 2;
const int VAR_TURN_RATE_MAX  = 3;
const int VAR_ACCEL_MIN      = 4;
const int VAR_ACCEL_MAX      = 5;
const int VAR_DECEL          = 6;
const int VAR_SLOPE_MOD      = 7;
const int VAR_DAMP_ROLL      = 8;
const int VAR_DAMP_PITCH     = 9;
const int VAR_DAMP_HEIGHT    = 10;
const int VAR_GLIDE          = 11;
const int VAR_BANKING        = 12;
const int VAR_HOVER_HEIGHT   = 13;
const int VAR_AUTO_LEVEL     = 14;
const int VAR_STRAFE         = 15;

const string_id SID_SYS_CANT_CALL_LOC	= new string_id("pet/pet_menu","cant_call_vehicle");
const string_id SID_SYS_CANT_CALL_NUM	= new string_id("pet/pet_menu","cant_call_vehicle");
const string_id SID_SYS_HAS_MAX_VEHICLE	= new string_id("pet/pet_menu","has_max_vehicle");
const string_id SID_NO_GROUND_VEHICLE_IN_SPACE = new string_id("space/space_interaction", "no_ground_vehicle_in_space");
const string_id SID_NOT_WHILE_IN_COMBAT	= new string_id("pet/pet_menu","cannot_call_in_combat");
const string_id SID_NOT_WHILE_DEAD	= new string_id("pet/pet_menu", "cannot_call_while_dead");
const string_id SID_NO_CALL_INDOORS	= new string_id("pet/pet_menu", "cannot_call_indoors");

const string VEHICLE_FINISH = "player.vehicleCallFinish";

const string_id SID_SYS_USES_LEFT_NEW			= new string_id("pet/pet_menu","uses_left_new");
const string_id SID_SYS_USES_LEFT			= new string_id("pet/pet_menu","uses_left");
const string_id SID_SYS_USES_LEFT_LAST			= new string_id("pet/pet_menu","uses_left_last");
const string_id SID_SYS_USES_COMPLETE			= new string_id("pet/pet_menu","uses_complete");
const string_id SID_SUI_CONFIRM_VEHICLE_REPAIRS		= new string_id("pet/pet_menu","sui_confirm_vehicle_repairs");

const string_id SID_VEHICLE_TO_SCHEM			= new string_id("spam", "vehicle_to_schem");
const string_id SID_CONVERT_PROMPT			= new string_id("spam", "vehicle_to_schem_prompt");
const string_id SID_CONVERT_TITLE 			= new string_id("spam", "vehicle_to_schem_title");
const string_id SID_CONVERT_CONVERT_FAIL		= new string_id("spam", "vehicle_to_schem_failure");
const string_id SID_CONVERT_CONVERT_SUCCESS		= new string_id("spam", "vehicle_to_schem_success");
const string_id SID_CONVERT_INVALID_RESPONSE		= new string_id("spam", "vehicle_to_schem_invalid_response");
const string_id SID_CONVERT_VEHICLE_OUT			= new string_id("spam", "vehicle_to_schem_vehicle_out");
const string_id SID_CONVERT_VCD_MOVED			= new string_id("spam", "vehicle_to_schem_vcd_moved");


const string STF 			= "pet/pet_menu";
const string VEHICLE_STAT_TABLE		= "datatables/vehicle/vehicle_stats.iff";

const int	 MOD_TYPE_MAX_SPEED				= 1; // passed in the message handler to undo the speed mod
const string OBJVAR_MOD_MAX_SPEED_DURATION  = "vehicle.mod.maxSpeed.duration";
const string OBJVAR_MOD_MAX_SPEED_OLD		= "vehicle.mod.maxSpeed.old";

const string [] s_varInfoNames = new string []
{
	"/private/index_speed_min",
	"/private/index_speed_max",
	"/private/index_turn_rate_min",
	"/private/index_turn_rate_max",
	"/private/index_accel_min",
	"/private/index_accel_max",
	"/private/index_decel",
	"/private/index_slope_mod",
	"/private/index_damp_roll",
	"/private/index_damp_pitch",
	"/private/index_damp_height",
	"/private/index_glide",
	"/private/index_banking",
	"/private/index_hover_height",
	"/private/index_auto_level",
	"/private/index_strafe",
};

const float [] s_varInfoConversions = new float []
{
	10.0f,
	10.0f,
	1.0f,
	1.0f,
	10.0f,
	10.0f,
	10.0f,
	10.0f,
	10.0f,
	10.0f,
	10.0f,
	10.0f,
	1.0f,
	10.0f,
	100.0f,
	1.0f,
};

//////////////////////  NEW COLORIZATION STUFF BELOW /////////////////

const int VEHICLE_DECAY_CYCLE					= 600;

const int CUSTOMIZATION_COUNT			= 200;

const string VAR_PALVAR_BASE			= "ai.pet.palvar";
const string VAR_PALVAR_VARS			= VAR_PALVAR_BASE + ".vars";
const string VAR_PALVAR_CNT			= VAR_PALVAR_BASE + ".cnt";
const string VAR_DECONSTRUCT_SCHEMATIC		= "schematic.name";


//---------------------------------------------------------------

int setValue (obj_id vehicle, float value, int var_index)
{
	string vi_name = s_varInfoNames [var_index];
	float vi_conversion = s_varInfoConversions [var_index];


	int ivalue = (int)(value * vi_conversion);
	setRangedIntCustomVarValue(vehicle, vi_name, ivalue);

	return ivalue;
}

//---------------------------------------------------------------

float getValue (obj_id vehicle, int var_index)
{
	string vi_name = s_varInfoNames [var_index];
	float vi_conversion = s_varInfoConversions [var_index];

	int ivalue = getRangedIntCustomVarValue(vehicle, vi_name);
	float value = ((float)ivalue) / vi_conversion;

	return value;
}

/***** FUNCTIONS ****************************************************/

/*
* @param value [0-100] (human 0.0)
*/

void setMinimumSpeed (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_SPEED_MIN);
}

//---------------------------------------------------------------

/*
* @param value [0-100] (human 5.3)
*/

void setMaximumSpeed (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_SPEED_MAX);
}

//---------------------------------------------------------------

/*
* @param value [0-1000] (human 720)
*/

void setTurnRateMin (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_TURN_RATE_MIN);
}

//---------------------------------------------------------------

/*
* @param value [0-1000] (human 360)
*/

void setTurnRateMax (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_TURN_RATE_MAX);
}

//---------------------------------------------------------------

/*
* @param value [0-1000] (human 9)
*/

void setAccelMin (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_ACCEL_MIN);
}

//---------------------------------------------------------------

/*
* @param value [0-1000] (human 3)
*/

void setAccelMax (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_ACCEL_MAX);
}

//---------------------------------------------------------------

/*
* @param value [0-100] (does not apply to humans)
*/

void setDecel (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_DECEL);
}

//---------------------------------------------------------------

/*
* @param value [0-100]
*/

void setDampingRoll (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_DAMP_ROLL);
}

//---------------------------------------------------------------

/*
* @param value [0-100]
*/

void setDampingPitch (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_DAMP_PITCH);
}

//---------------------------------------------------------------

/*
* @param value [0-100]
*/

void setDampingHeight (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_DAMP_HEIGHT);
}

//---------------------------------------------------------------

/*
* @param value [0-100]
*/

void setGlide (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_GLIDE);
}

//---------------------------------------------------------------

/*
* @param value [-90,90] (degrees, negative is roll-out)
*/

void setBankingAngle (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_BANKING);
}

//---------------------------------------------------------------

/*
* @param value [0,100] (meters)
*/

void setHoverHeight (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_HOVER_HEIGHT);
}

//---------------------------------------------------------------

/*
* @param value [0,1]
*/

void setAutoLevelling (obj_id vehicle, float value)
{
	setValue (vehicle, value, VAR_AUTO_LEVEL);
}

//---------------------------------------------------------------

/*
* @param value [0,1]
*/

void setStrafe (obj_id vehicle, boolean canStrafe)
{
	float value = canStrafe ? 1.0f : 0.0f;
	setValue (vehicle, value, VAR_STRAFE);
}


//---------------------------------------------------
//---------------------------------------------------
//---------------------------------------------------

/*
* @param value [0-100] (human 0.0)
*/

float getMinimumSpeed (obj_id vehicle)
{
	return getValue (vehicle, VAR_SPEED_MIN);
}

//---------------------------------------------------------------

/*
* @param value [0-100] (human 5.3)
*/

float getMaximumSpeed (obj_id vehicle)
{
	return getValue (vehicle, VAR_SPEED_MAX);
}

//---------------------------------------------------------------

/*
* @param value [0-1000] (human 720)
*/

float getTurnRateMin (obj_id vehicle)
{
	return getValue (vehicle, VAR_TURN_RATE_MIN);
}

//---------------------------------------------------------------

/*
* @param value [0-1000] (human 360)
*/

float getTurnRateMax (obj_id vehicle)
{
	return getValue (vehicle, VAR_TURN_RATE_MAX);
}

//---------------------------------------------------------------

/*
* @param value [0-1000] (human 9)
*/

float getAccelMin (obj_id vehicle)
{
	return getValue (vehicle, VAR_ACCEL_MIN);
}

//---------------------------------------------------------------

/*
* @param value [0-1000] (human 3)
*/

float getAccelMax (obj_id vehicle)
{
	return getValue (vehicle, VAR_ACCEL_MAX);
}

//---------------------------------------------------------------

/*
* @param value [0-100] (does not apply to humans)
*/

float getDecel (obj_id vehicle)
{
	return getValue (vehicle, VAR_DECEL);
}

//---------------------------------------------------------------

/*
* @param value [0-100]
*/

float getDampingRoll (obj_id vehicle)
{
	return getValue (vehicle, VAR_DAMP_ROLL);
}

//---------------------------------------------------------------

/*
* @param value [0-100]
*/

float getDampingPitch (obj_id vehicle)
{
	return getValue (vehicle, VAR_DAMP_PITCH);
}

//---------------------------------------------------------------

/*
* @param value [0-100]
*/

float getDampingHeight (obj_id vehicle)
{
	return getValue (vehicle, VAR_DAMP_HEIGHT);
}

//---------------------------------------------------------------

/*
* @param value [0-100]
*/

float getGlide (obj_id vehicle)
{
	return getValue (vehicle, VAR_GLIDE);
}

//---------------------------------------------------------------

/*
* @param value [0-100] (degrees, negative is roll-out)
*/

float getBankingAngle (obj_id vehicle)
{
	return getValue (vehicle, VAR_BANKING);
}

//---------------------------------------------------------------

/*
* @param value [0-100] (meters)
*/

float getHoverHeight (obj_id vehicle)
{
	return getValue (vehicle, VAR_HOVER_HEIGHT);
}

//---------------------------------------------------------------

/*
* @param value [0-100]
*/

float getAutoLevelling (obj_id vehicle)
{
	return getValue (vehicle, VAR_AUTO_LEVEL);
}

//---------------------------------------------------------------

boolean getStrafe (obj_id vehicle)
{
	float value = getValue (vehicle, VAR_STRAFE);
	return value > 0.0f ? true : false;
}

//---------------------------------------------------------------

boolean isRidingVehicle(obj_id objPlayer)
{
	if ( !isMob(objPlayer) )
	{
		return false;
	}

	obj_id objMount = getMountId(objPlayer);

	if(isIdValid(objMount))
	{
		if(hasScript(objMount,"systems.vehicle_system.vehicle_base") || isBattlefieldVehicle(objMount))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

//---------------------------------------------------------------

boolean isRidingBattlefieldVehicle(obj_id objPlayer)
{
	obj_id objMount = getMountId(objPlayer);

	if( isIdValid(objMount) )
	{
		if( isBattlefieldVehicle(objMount) )
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

//---------------------------------------------------------------

boolean isDriveableVehicle(obj_id objThing)
{
	if(hasScript(objThing,"systems.vehicle_system.vehicle_base"))
	{
		return true;
	}
	else
	{
		return false;
	}
}

//---------------------------------------------------------------

boolean isVehicle(obj_id obj)
{
	return isGameObjectTypeOf (getGameObjectType (obj), GOT_vehicle);
}

boolean isBattlefieldVehicle(obj_id obj)
{
	return isVehicle(obj) && hasScript(obj, "systems.vehicle_system.battlefield_vehicle");
}

//---------------------------------------------------------------

string getVehicleTemplate(obj_id controlDevice)
{
	if(!isIdValid(controlDevice))
		return null;

	string ref = getVehicleReference(controlDevice);
	if(ref == null || ref.equals(""))
		return null;

	return dataTableGetString(create.VEHICLE_TABLE, ref, "OBJECT_TEMPLATE");
}

//---------------------------------------------------------------

void doTempMaxSpeedReduction(obj_id vehicle, float factor, float duration)
{
	if(factor < 0.01f || factor > 1.0f)
	{
		return;
	}

	if(hasObjVar(vehicle, OBJVAR_MOD_MAX_SPEED_OLD))
	{
		return; // for now we dont allow over-riding existing reduction to prevent a potentially ungodly amount of dangling messages
	}

	float currentMaxSpeed = getMaximumSpeed(vehicle);
	setObjVar(vehicle, OBJVAR_MOD_MAX_SPEED_OLD, currentMaxSpeed);
	setObjVar(vehicle, OBJVAR_MOD_MAX_SPEED_DURATION, duration);
	dictionary params = new dictionary();
	params.put("type", MOD_TYPE_MAX_SPEED);
	messageTo(vehicle, "revertVehicleMod", params, duration, false);
	setMaximumSpeed(vehicle, currentMaxSpeed * factor);

	return;
}

//---------------------------------------------------------------

string getVehicleReference(obj_id controlDevice)
{
	if(!isIdValid(controlDevice))
		return null;

	return getStringObjVar(controlDevice, "vehicle_attribs.object_ref");
}

//---------------------------------------------------------------

boolean repairVehicle(obj_id player, obj_id vehicle)
{
	if(!isIdValid(player) || !isIdValid(vehicle) || !vehicle.isLoaded())
	{
		return false;
	}

	obj_id petControlDevice = callable.getCallableCD(vehicle);

	if((isDisabled(vehicle) || getHitpoints(vehicle) < 1) && !canRepairDisabledVehicle(petControlDevice))
	{
		sendSystemMessage(player, new string_id("pet/pet_menu", "cannot_repair_disabled")); // You may not repair a disabled vehicle.
		return false;
	}

	obj_id garage = utils.getObjIdScriptVar(vehicle, "inRepairZone");
	if(!isIdValid(garage) || !garage.isLoaded())
	{
		sendSystemMessage(player, new string_id("pet/pet_menu", "repair_unrecognized_garages")); // Your vehicle does not recognize any local garages. Try again in a garage repair zone.
		return false;
	}

	if(utils.hasScriptVar(player, "vehicleRepair.pid"))
	{
		int oldpid = utils.getIntScriptVar(player, "vehicleRepair.pid");
		sui.closeSUI(player, oldpid);
		utils.removeScriptVarTree(player, "vehicleRepair");
	}

	int cost = getVehicleRepairCost(vehicle);

	if(cost == 0)
	{
		sendSystemMessage(player, new string_id("pet/pet_menu", "undamaged_vehicle")); // The targeted vehicle does not require any repairs at the moment.
		return false;
	}
	else if(cost < 0)
	{
		sendSystemMessage(player, new string_id("pet/pet_menu", "repair_error")); // There has been an error in calculating vehicle repair costs. Please contact a CSR for assistance.
		return false;
	}

	int total = getTotalMoney(player);

	if(total < cost)
	{
		prose_package ppLackFunds = prose.getPackage(new string_id(STF, "lacking_funds"));
		prose.setDI(ppLackFunds, cost - total);
		sendSystemMessageProse(player, ppLackFunds); // You lack the additional (cost-total) credits required to repair your vehicle.
		return false;
	}

	string prompt = getString(new string_id(STF, "vehicle_repair_d")); // You have chosen to repair your vehicle. Please review the listed details and confirm your selection.

	/*
	string vname = getName(vehicle);
	if(vname.startsWith("@") && vname.indexOf(":") > -1)
		vname = getString(utils.unpackString(vname));
	*/

	//prompt += "\n\nVehicle: " + vname;
	prompt += "\n\n" + getString(new string_id(STF, "vehicle_prompt")) +getString(getNameStringId(vehicle)); // Vehicle:
	prompt += "\n" + getString(new string_id(STF, "repair_cost_prompt")) + cost; // Repair Cost:
	prompt += "\n" + getString(new string_id(STF, "total_funds_prompt")) + total; // Total Funds Available:

	string title = utils.packStringId(SID_SUI_CONFIRM_VEHICLE_REPAIRS);

	int pid = sui.msgbox(garage, player, prompt, sui.OK_CANCEL, title, "handleRepairConfirm");

	if(pid > -1)
	{

		utils.setScriptVar(player, "vehicleRepair.pid", pid);
		utils.setScriptVar(player, "vehicleRepair.vehicle", vehicle);
		utils.setScriptVar(player, "vehicleRepair.cost", cost);
		return true;
	}

	return false;
}

int getVehicleRepairCost(obj_id vehicle)
{
	if(!isIdValid(vehicle))
		return -1;

	int toHeal = getMaxHitpoints(vehicle)-getHitpoints(vehicle);
	//debugConsoleMsg(getOwner(vehicle), "heal amt = " + toHeal);

	float repair_rate = getVehicleRepairRate(vehicle);
	float city_base = 100f;
	float city_add = 0f;

	int city_id = getCityAtLocation(getLocation(vehicle), 0);
	obj_id city = cityGetCityHall(city_id);
	if(isIdValid(city))
	{
		string cityName = cityGetName(city_id);
		string cityGarage = cityName + ".garageFee";
		if(hasObjVar(city, cityGarage))
			city_add = (float)getIntObjVar(city, cityGarage);
	}

	if(!isIdValid(city))
	{
		city = obj_id.NULL_ID;
	}
	utils.setScriptVar(vehicle, "vehicleRepair.city_id", city);

	float city_tax = ((city_base + city_add)/100f);
	float city_cut = (((toHeal * repair_rate) * city_tax) - (toHeal * repair_rate));
	utils.setScriptVar(vehicle, "vehicleRepair.city_tax", city_cut);

	return Math.round((toHeal * repair_rate) * city_tax);
}

float getVehicleRepairRate(obj_id vehicle)
{
	if(!isIdValid(vehicle) )
		return -1f;

	obj_id controlDevice = callable.getCallableCD(vehicle);

	if(!isIdValid(controlDevice))
		return -1f;

	string ref = getVehicleReference(controlDevice);
	if(ref == null || ref.equals(""))
		return -1f;

	return dataTableGetFloat(create.VEHICLE_TABLE, ref, "REPAIR_RATE");
}

/*******************************************/

void decayVehicle(obj_id vehicle)
{
	if(!isIdValid(vehicle))
		return;

	int now = getGameTime();
	float decay_rate = getVehicleDecayRate(vehicle);
	if(decay_rate <= 0f)
		return;

	int decayAmt = 0;
	if(utils.hasScriptVar(vehicle, "decay.stamp"))
	{
		int stamp = utils.getIntScriptVar(vehicle, "decay.stamp");
		int delta = now - stamp;

		float ratio = delta / VEHICLE_DECAY_CYCLE;

		decayAmt = Math.round(ratio * decay_rate);
	}
	else
	{
		decayAmt = Math.round(decay_rate / 2f);
	}

	if(decayAmt <= 0)
		return;

	int currentHP = getHitpoints(vehicle);
	currentHP -= decayAmt;

	setHitpoints(vehicle, currentHP);

	obj_id vcd = callable.getCallableCD(vehicle);

	dictionary params = new dictionary();
	params.put("hp", currentHP);
	params.put("penalty", decayAmt);
	messageTo(vcd, "handleStoreVehicleDamage", params, 0f, false);

	utils.setScriptVar(vehicle, "decay.stamp", now);
	messageTo(vehicle, "handleVehicleDecay", null, VEHICLE_DECAY_CYCLE, false);
}

float getVehicleDecayRate(obj_id vehicle)
{
	if(!isIdValid(vehicle))
		return -1f;

	obj_id controlDevice = callable.getCallableCD(vehicle);

	if(!isIdValid(controlDevice))
		return -1f;

	string ref = getVehicleReference(controlDevice);

	if(ref == null || ref.equals(""))
		return -1f;

	return dataTableGetFloat(create.VEHICLE_TABLE, ref, "DECAY_RATE");
}

/*******************************************/

boolean isInValidUnpackLocation(obj_id master)
{

	// cannot call vehicles in ships
	if(isSpaceScene())
	{
		sendSystemMessage(master, SID_NO_GROUND_VEHICLE_IN_SPACE);
		return false;
	}

	location yourLoc = getLocation(master);

	// cannot call vehicles in structure
	if(isIdValid(yourLoc.cell))
	{
		sendSystemMessage(master, SID_NO_CALL_INDOORS);
		return false;
	}
	if(isInRestrictedScene(master))
	{
		sendSystemMessage(master, pet_lib.SID_SYS_VEHICLE_RESTRICTED_SCENE);
		return false;
	}

	return true;
}

boolean isInRestrictedScene(obj_id master)
{
	string scene = getCurrentSceneName();
	string restrictionTable = "datatables/vehicle/vehicle_restrictions.iff";
	string[] restrictedScenes = dataTableGetStringColumn(restrictionTable, 0);
	int[] restrictions = dataTableGetIntColumn(restrictionTable, 1);


	if(isIdValid(instance.getAreaInstanceController(master)) && !instance.vehicleAllowedInInstance(instance.getAreaInstanceController(master)))
	{
		sendSystemMessage(master, new string_id("instance", "no_vehicle"));
		return true;
	}

	if(hasObjVar(master, space_dungeon.VAR_DUNGEON_ID) ||
		(locations.isInRegion(master, "@dathomir_region_names:black_mesa") && buff.hasBuff(master, "death_troopers_no_vehicle")))
	{
		return true;
	}

	for(int i = 0; i < restrictedScenes.length; i++)
	{
		if(restrictedScenes[i].equals(scene))
		{
			if(restrictions[i] == 1)
			{
				if(isGod(master))
					sendSystemMessageTestingOnly(master, "GODMODE MSG:  You are in a vehicle restricted scene.");
				return true;
			}
		}
	}

	return false;
}

boolean canQuickUnpack(obj_id master)
{
	location yourLoc = getLocation(master);
	if(isIdValid(yourLoc.cell))
		return false;//Cannot call in a building!

	if(isInRestrictedScene(master))
		return false;

	return true;
}//end canQuickUnpack

boolean isInValidCallState(obj_id player)
{
	if(ai_lib.aiIsDead(player))
	{
		sendSystemMessage(player, SID_NOT_WHILE_DEAD);
		return false;
	}

	if(ai_lib.isInCombat(player))
	{
		sendSystemMessage(player, SID_NOT_WHILE_IN_COMBAT);
		return false;
	}

	return true;
}

/*******************************************/

boolean storeVehicle(obj_id vehicleControlDevice, obj_id player)
{
	return storeVehicle(vehicleControlDevice, player, true);
}

boolean storeVehicle(obj_id vehicleControlDevice, obj_id player, boolean checkCombat)
{
	obj_id currentVehicle = callable.getCDCallable(vehicleControlDevice);

	if(!isIdValid(currentVehicle))
	{
		debugServerConsoleMsg(player, "+++ VEHICLE library . storeVehicle +++ current vehicle obj_id is NOT valid");
		return false;
	}

	if(checkCombat)
	{
		if(pet_lib.wasInCombatRecently(currentVehicle, player, true) && !isJetPack(vehicleControlDevice))
		{
			return false;
		}
	}

	debugServerConsoleMsg(player, "+++ VEHICLE library . storeVehicle +++ current vehicle obj_id is valid. Doing tons of stuff.");

	if(hasObjVar(vehicleControlDevice, "pet.uses_left"))
	{
		int uses = getIntObjVar(vehicleControlDevice, "pet.uses_left");

		if(uses <= 0)
		{
			sendSystemMessage(player, SID_SYS_USES_COMPLETE);
			destroyObject(vehicleControlDevice);

			return true;
		}
	}

	setTimeStored(vehicleControlDevice);

	//decayVehicle (currentVehicle);

	int currentHP = getHitpoints(currentVehicle);

	dictionary params = new dictionary();
	params.put("hp", currentHP);
	params.put("penalty", 0);

	messageTo(vehicleControlDevice, "handleStoreVehicleDamage", params, 0f, false);

	messageTo(currentVehicle, "handlePackRequest", null, 1, false);

	callable.setCDCallable(vehicleControlDevice, null);

	return true;
}

/*******************************************/

void setTimeStored(obj_id PCD)
{
	setObjVar(PCD, "pet.timeStored", getGameTime());
}

/*******************************************/

void storeAllVehicles(obj_id master)
{
	debugServerConsoleMsg(master, "+++ VEHICLE library . storeAllVehicles +++ just entered function. master obj_id fed in is: " + master);

	obj_id objVehicle = callable.getCallable(master, callable.CALLABLE_TYPE_RIDEABLE);

	if(isIdValid(objVehicle))
	{
		if(!objVehicle.isLoaded() == false)
		{
			//ON DIFF GAMESERVER, JUST MSG PET TO DESTROY ITSELF:
			messageTo(objVehicle, "handlePackRequest", null, 0, false);
		}
		else
		{
			if(group.isGrouped(objVehicle))
			{
				obj_id group = getGroupObject(objVehicle);

				if(isIdValid(group))
				{
					queueCommand(objVehicle, ##"leaveGroup", group, "", COMMAND_PRIORITY_IMMEDIATE);
				}
			}


			if(ai_lib.aiIsDead(master))
			{
				debugServerConsoleMsg(master, "+++ VEHICLE library . storeAllVehicles +++ Game thinks that we're dead. Following that branch of storeAllVehicles");

				//IF YOU ARE DEAD OR INCAP'D AND LOGOUT THEN:
				boolean isFactionPet = (ai_lib.isNpc(objVehicle) || ai_lib.aiGetNiche(objVehicle) == NICHE_VEHICLE || ai_lib.isAndroid(objVehicle));

				if(hasObjVar(objVehicle, battlefield.VAR_CONSTRUCTED) || isFactionPet)
				{
					//FACTION PETS ARE FLAGGED 'DEAD' AND DELETED:
					obj_id petControlDevice = callable.getCallableCD(objVehicle);

					if(isIdValid(petControlDevice))
					{
						messageTo(petControlDevice, "handleFlagDeadCreature", null, 0, false);
					}

					destroyObject(objVehicle);
				}
				else
				{
					debugServerConsoleMsg(master, "+++ VEHICLE library . storeAllVehicles +++ Looks like we're dead, but pet's weren't faction. Firing off a storeVehicle function.");
					//NON-FACTION PETS ARE JUST STORED:
					storeVehicle(objVehicle, master);
				}
			}
			else
			{
				//IF YOU ARE NOT DEAD THEN JUST STORE YOUR PETS REGARDLESS
				debugServerConsoleMsg(master, "+++ VEHICLE library . storeAllVehicles +++ We aren't dead. Firing off a storeVehicle function.");
				storeVehicle(objVehicle, master);
			}
		}
	}
}

boolean hasMaxStoredVehicles(obj_id player)
{
	return callable.hasMaxStoredRideables(player);
}

/*******************************************/

//////////////////////  NEW COLORIZATION STUFF BELOW /////////////////

void reHueVehicle(obj_id vehicleControlDevice, obj_id vehicle)
{
	// Set customization info
	int colorIdx = hue.getVarColorIndex(vehicleControlDevice, hue.INDEX_1);
	if(hasObjVar(vehicleControlDevice, "creature_attribs.hue"))
	{
		colorIdx = getIntObjVar(vehicleControlDevice, "creature_attribs.hue");
	}

	hue.setColor(vehicle, hue.INDEX_1, colorIdx);

	return;
}

/*******************************************/

//////////////////////  NEW COLORIZATION STUFF BELOW /////////////////

void saveVehicleInfo (obj_id vehicleControlDevice, obj_id vehicle)
{
	if(!isIdValid(vehicle) || !isIdValid(vehicleControlDevice))
		return;

	if(!vehicle.isLoaded())
		return;

	obj_id master = getMaster(vehicle);
	if(isIdValid(master) && master.isLoaded())
	{
		setHomeLocation(vehicle, getLocation(master));
	}

	pet_lib.storeDamage(vehicle, vehicleControlDevice);
	setObjVar(vehicleControlDevice, "pet.timeStored", getGameTime());

	ranged_int_custom_var[] ri = hue.getPalcolorVars(vehicle);
	if(ri != null && ri.length > 0)
	{
		boolean wasUpdated = false;
		for (int i = 0; i < ri.length; i++)
		{
			int val = ri[i].getValue();
			if(val > -1)
			{
				string varpath = VAR_PALVAR_VARS + "." + ri[i].getVarName();
				int cur = getIntObjVar(vehicleControlDevice, varpath);
				if(cur != val)
				{
					setObjVar(vehicleControlDevice, varpath, val);
				}
			}
		}

		if(utils.hasScriptVar(vehicle, "customizationUpdated"))
			setObjVar(vehicleControlDevice, VAR_PALVAR_CNT, CUSTOMIZATION_COUNT);
	}
}

void restoreCustomization(obj_id vehicle, obj_id vehicleControlDevice)
{
	if ( hasObjVar(vehicleControlDevice, pet_lib.VAR_PALVAR_BASE) )
	{
		obj_var_list ovl = getObjVarList(vehicleControlDevice, pet_lib.VAR_PALVAR_VARS);
		if ( ovl != null )
		{
			int numItem = ovl.getNumItems();
			for ( int i = 0; i < numItem; i++ )
			{
				obj_var ov = ovl.getObjVar(i);
				string var = ov.getName();
				int idx = ov.getIntData();
				hue.setColor(vehicle, var, idx);
			}
		}
	}
}

/*******************************************/

void storeDamage(obj_id vcd, int currentHP, int penalty) {

	if(!isIdValid(vcd))
		return;

	if(currentHP == ATTRIB_ERROR) {

		currentHP = getIntObjVar(vcd, "attrib.hit_points");
		currentHP -= penalty;

		if(currentHP < 0)
			currentHP = 0;

	}

	setObjVar(vcd, "attrib.hit_points", currentHP);
}

void initializeVehicle (obj_id vehicle)
{
	initializeVehicle(vehicle, null);
}

void initializeVehicle (obj_id vehicle, obj_id player)
{

	if (!isIdValid(player))
		player = vehicle;

	string datatable = VEHICLE_STAT_TABLE;
	string row = getTemplateName (vehicle);

	if(dataTableHasColumn (datatable, "min_speed"))
	{
		float minSpeed = dataTableGetFloat (datatable, row, "min_speed");
		setMinimumSpeed (vehicle, minSpeed);
	}

	if(dataTableHasColumn (datatable, "speed"))
	{
		float speed = dataTableGetFloat (datatable, row, "speed");
		setMaximumSpeed (vehicle, speed);
	}

	if(dataTableHasColumn (datatable, "turn_rate"))
	{
		float turnRate = dataTableGetFloat (datatable, row, "turn_rate");
		float turnSkillMod = getEnhancedSkillStatisticModifier (player, "force_vehicle_control");

		turnRate = turnRate + turnSkillMod;
		setTurnRateMin (vehicle, turnRate);
	}

	if(dataTableHasColumn (datatable, "turn_rate_max"))
	{
		float turnRateMax = dataTableGetFloat (datatable, row, "turn_rate_max");
		float maxTurnSkillMod = getEnhancedSkillStatisticModifier (player, "force_vehicle_control");

		turnRateMax = turnRateMax + maxTurnSkillMod;
		setTurnRateMax (vehicle, turnRateMax);
	}

	if(dataTableHasColumn (datatable, "accel_min"))
	{
		float accelMin = dataTableGetFloat (datatable, row, "accel_min");
		float accelSkillMod = getEnhancedSkillStatisticModifier (player, "force_vehicle_speed");

		accelMin = accelMin + accelSkillMod;
		setAccelMin (vehicle, accelMin);
	}

	if(dataTableHasColumn (datatable, "accel_max"))
	{
		float accelMax = dataTableGetFloat (datatable, row, "accel_max");
		float maxAccelSkillMod = getEnhancedSkillStatisticModifier (player, "force_vehicle_speed");

		accelMax = accelMax + maxAccelSkillMod;
		setAccelMax (vehicle, accelMax);
	}

	if(dataTableHasColumn (datatable, "decel"))
	{
		float decel = dataTableGetFloat (datatable, row, "decel");
		float decelSkillMod = getEnhancedSkillStatisticModifier (player, "force_vehicle_speed");

		decel = decel + decelSkillMod;
		setDecel (vehicle, decel);
	}

	if(dataTableHasColumn (datatable, "damping_roll"))
	{
		float dampingRoll = dataTableGetFloat (datatable, row, "damping_roll");
		setDampingRoll (vehicle, dampingRoll);
	}

	if(dataTableHasColumn (datatable, "damping_pitch"))
	{
		float dampingPitch = dataTableGetFloat (datatable, row, "damping_pitch");
		setDampingPitch (vehicle, dampingPitch);
	}

	if(dataTableHasColumn (datatable, "damping_height"))
	{
		float dampingHeight = dataTableGetFloat (datatable, row, "damping_height");
		setDampingHeight (vehicle, dampingHeight);
	}

	if(dataTableHasColumn (datatable, "glide"))
	{
		float glide = dataTableGetFloat (datatable, row, "glide");
		setGlide (vehicle, glide);
	}

	if(dataTableHasColumn (datatable, "banking_angle"))
	{
		float bankingAngle = dataTableGetFloat (datatable, row, "banking_angle");
		setBankingAngle (vehicle, bankingAngle);
	}

	if(dataTableHasColumn (datatable, "hover_height"))
	{
		float hoverHeight = dataTableGetFloat (datatable, row, "hover_height");
		setHoverHeight (vehicle, hoverHeight);
	}

	if(dataTableHasColumn (datatable, "auto_level"))
	{
		float autoLevel = dataTableGetFloat (datatable, row, "auto_level");
		setAutoLevelling (vehicle, autoLevel);
	}

	if(dataTableHasColumn (datatable, "strafe"))
	{
		int strafe = dataTableGetInt(datatable, row, "strafe");
		setStrafe (vehicle, strafe != 0);
	}

	return;
}

boolean mountPermissionCheck(obj_id vehicle, obj_id rider, boolean verbose)
{
	if(!isIdValid(vehicle) || !isIdValid(rider))
	{
		return false;
	}

	obj_id driver = getRiderId(vehicle);

	if(!isIdValid(driver))
	{
		return false;
	}

	if(getOwner(vehicle) == rider)      //rider is vehicle's owner
	{
		return true;
	}

	if(!group.inSameGroup(rider, driver))
	{
		return false;
	}

	if(getState(rider, STATE_COMBAT) == 1) //rider is in combat
	{
		if(verbose)
		{
			string_id strSpam = new string_id("vehicle/vehicle", "rider_in_combat");
			sendSystemMessage(rider, strSpam);
		}
		return false;
	}

	if(factions.isDeclared(rider))
	{
	 	if(factions.isDeclared(driver) && pvpAreFactionsOpposed(pvpGetAlignedFaction(rider), pvpGetAlignedFaction(driver))) //rider and driver have opposed factions
	 	{
			if(verbose)
			{
				string_id strSpam = new string_id("vehicle/vehicle", "rider_opposing_faction");
				sendSystemMessage(rider, strSpam);
			}
			return false;
		}
		else if(!factions.isDeclared(driver))
		{
			if(verbose)
			{
				string_id strSpam = new string_id("vehicle/vehicle", "rider_overt_driver_not");
				sendSystemMessage(rider, strSpam);
			}
                        return false;
		}
	}

	return true;
}

void restoreVehicle(obj_id player, obj_id vehicle)
{
	obj_id tool = utils.getItemPlayerHasByTemplate(player, "object/tangible/item/ep3/barc_repair_tool.iff");
	if(!isIdValid(tool))
		return;

	clearCondition(vehicle, CONDITION_DISABLED);
	int maxHp = getMaxHitpoints(vehicle);
	setHitpoints(vehicle, maxHp);

	int currentCount = getCount(tool);
	if(currentCount > 1)
	{
		--currentCount;
		setCount(tool, currentCount);
	}
	else
	{
		destroyObject(tool);
	}
}

//Function to check if the vehicle is a jetPack
//requires the ObjId of the the VCD.
boolean isJetPack(obj_id vehicleControlDevice)
{
	if(!isValidId(vehicleControlDevice))
		return false;
	string name = getVehicleTemplate(vehicleControlDevice);
	if( isJetPackTemplate(name) )
		return true;

	return false;
}

boolean isJetPackVehicle(obj_id vehicle)
{
	if(!isValidId(vehicle))
		return false;
		
	string name = getTemplateName(vehicle);
	if( isJetPackTemplate(name) )
		return true;
	
	return false;
}

boolean isJetPackTemplate(string template)
{
	if( template == null || template.length() <= 0 )
		return false;
		
	if( template.equals("object/mobile/vehicle/jetpack.iff") )
		return true;

	if( template.equals("object/mobile/vehicle/tcg_merr_sonn_jt12_jetpack.iff") )
		return true;
		
	if( template.equals("object/mobile/vehicle/tcg_hk47_jetpack.iff") )
		return true;
	
	return false;
}


void applyVehicleBuffs(obj_id player, obj_id vehicle)
{
	string template = getTemplateName(vehicle);
	if(template == null || template == "")
	{
		LOG("mount", template + " bailed out because template is bad");
		return;
	}

	dictionary vehicleData = new dictionary();
	vehicleData = dataTableGetRow(VEHICLE_STAT_TABLE, template);
	if(vehicleData == null || vehicleData == "")
	{
		LOG("mount", vehicleData + " bailed out because row in datatable is bad");
		return;
	}

	string buffName = vehicleData.getString("player_buff");
	string vehicleBuffName = vehicleData.getString("vehicle_buff");
	string clientEffect = vehicleData.getString("buff_client_effect");

	boolean hasPlayerBuff = buffName != null && buffName != "";
	boolean hasVehicleBuff = vehicleBuffName != null && vehicleBuffName != "";

	if(!hasPlayerBuff && !hasVehicleBuff)
	{
		LOG("mount","bailed out because this vehicle has no buffs");
		return;
	}

	//put the buff on the player
	if(hasPlayerBuff && buff.canApplyBuff(player, buffName))
	{
		buff.applyBuff(player, buffName);
		//play an animation
		if(clientEffect != null && !clientEffect.equals(""))
			playClientEffectObj(player, clientEffect, vehicle, "");
	}

	//lets put a buff on the vehicle while you are on it. It is more difficult to hit a moving target that a stationary parked one
	if(hasVehicleBuff && buff.canApplyBuff(vehicle, vehicleBuffName))
	{
		buff.applyBuff(vehicle, vehicleBuffName);
	}

	return;
}


boolean canRepairDisabledVehicle(obj_id controlDevice)
{
	string ref = getVehicleReference(controlDevice);
	if(ref == null || ref.equals(""))
		return false;

	if(dataTableGetInt(create.VEHICLE_TABLE, ref, "CAN_REPAIR_DISABLED") == 1)
		return true;

	return false;
}

boolean checkForMountAndDismountPlayer(obj_id player)
{
	obj_id playerCurrentMount = getMountId(player);
	if( isIdValid(playerCurrentMount) )
	{
		if ( vehicle.isBattlefieldVehicle(playerCurrentMount) )
		{
			queueCommand(player, ##"battlefieldDismount", playerCurrentMount, getName(playerCurrentMount), COMMAND_PRIORITY_IMMEDIATE);
		}
		else
		{
			queueCommand(player, ##"dismount", playerCurrentMount, getName(playerCurrentMount), COMMAND_PRIORITY_IMMEDIATE);
		}
		return true;
	}

	return false;
}

//function to turn armor into new appearance schems
boolean turnVehicleIntoSchem(obj_id player, obj_id vehiclePCD)
{
	if(!isIdValid(vehiclePCD) || !exists(vehiclePCD))
		return false;

	if(!isIdValid(player) || !exists(player))
		return false;

	if(!hasObjVar(vehiclePCD, VAR_DECONSTRUCT_SCHEMATIC))
		return false;

	string schemName = getStringObjVar(vehiclePCD, VAR_DECONSTRUCT_SCHEMATIC);

	if(schemName == null || schemName.equals(""))
		return false;

	string limitedUseTemplate = "object/tangible/loot/loot_schematic/deconstructed_vehicle_schematic.iff";

	obj_id pInv = utils.getInventoryContainer(player);

	if(!isIdValid(pInv) || !exists(pInv))
		return false;

	obj_id newSchem = createObjectOverloaded(limitedUseTemplate, pInv);

	if(!isIdValid(newSchem) || !exists(newSchem))
		return false;

	CustomerServiceLog("new_vehicle_conversion", "New schematic("+schemName+") converted from vehiclePCD("+vehiclePCD+") for player "+getFirstName(player)+"("+player+")");

	string name = getEncodedName(vehiclePCD);
	if (name.startsWith("@"))
		name = localize(getNameStringId(vehiclePCD));

	setName(newSchem, "Advanced " + name);
	setObjVar(newSchem, "loot_schematic.schematic", schemName);
	setObjVar(newSchem, "loot_schematic.uses", 1);
	setObjVar(newSchem, "loot_schematic.skill_req", "class_engineering_phase1_master");

	//Bio-link this thing.
	setBioLink(newSchem, player);

	attachScript(newSchem, "item.loot_schematic.loot_schematic");
	CustomerServiceLog("new_vehicle_conversion", "vehiclePCD("+vehiclePCD+") about to be destroyed on player "+getFirstName(player)+"("+player+") because it was converted into schematic "+schemName+"("+newSchem+")");

	//TODO add Bio-Link stuff

	return true;
}

// ----------------------------------------------------------------------

obj_id[] findVehicleControlDevicesForPlayer(obj_id player)
{
	return findVehicleControlDevicesForPlayer(player, false);
}

obj_id[] findVehicleControlDevicesForPlayer(obj_id player, boolean includeHangerSlot)
{
	obj_id datapad = utils.getDatapad(player);	
	obj_id playerHangarSlot = obj_id.NULL_ID;

	if( includeHangerSlot )
		playerHangarSlot = utils.getPlayerHangar(player);


	//LOG("vehicle", "datapad is "+datapad);
	if ( isIdValid(datapad) )
	{
		obj_id[] datapadContents = getContents(datapad);
		//LOG("vehicle", "contents length is "+datapadContents);
		if ( datapadContents != null )
		{
			int count = 0;
			for (int i = 0; i < datapadContents.length; ++i)
			{

				//LOG("vehicle", "datapadContents["+i+"] is "+ getGameObjectType(datapadContents[i]));
				//LOG("vehicle", "Check type is "+ GOT_data_vehicle_control_device);
				if (isIdValid(datapadContents[i]) && getGameObjectType(datapadContents[i]) == GOT_data_vehicle_control_device)
					++count;
			}
			if( includeHangerSlot && isIdValid(playerHangarSlot) )
			{
				obj_id[] hangarContents = getContents(playerHangarSlot);

				if( hangarContents != null && hangarContents.length > 0 )
				{
					for (int q = 0; q < hangarContents.length; ++q)
					{
						//LOG("space", "hangarContents["+q+"] is "+ getGameObjectType(hangarContents[q]));
						//LOG("space", "Check type is "+ GOT_data_ship_control_device);
						if (isIdValid(hangarContents[q]) && getGameObjectType(hangarContents[q]) == GOT_data_vehicle_control_device)
							++count;
					}
				}
			}
			if ( count > 0 )
			{
				obj_id[] vehicleControlDevices = new obj_id[count];
				//LOG("vehicle", "Count is "+count);
				count = 0;
				for ( int j = 0; j < datapadContents.length; ++j )
				{
					if ( isIdValid(datapadContents[j]) && getGameObjectType(datapadContents[j]) == GOT_data_vehicle_control_device )
					{
						//LOG("vehicle", "adding "+datapadContents[j]);
						vehicleControlDevices[count++] = datapadContents[j];
					}
				}

				if(includeHangerSlot && isIdValid(playerHangarSlot))
				{
					obj_id[] hangarContents = getContents(playerHangarSlot);
					if( hangarContents != null && hangarContents.length > 0 )
					{
						for ( int k = 0; k < hangarContents.length; ++k )
						{
							if ( isIdValid(hangarContents[k]) && getGameObjectType(hangarContents[k]) == GOT_data_vehicle_control_device )
							{
								//LOG("vehicle", "adding "+hangarContents[k]);
								vehicleControlDevices[count++] = hangarContents[k];
							}
						}
					}
				}

				return vehicleControlDevices;
			}
		}
	}
	return null;
}

obj_id[] findVehicleControlDevicesInHangarSlot(obj_id player)
{
	obj_id playerHangarSlot = utils.getPlayerHangar(player);
	if ( isIdValid(playerHangarSlot) )
	{
		obj_id[] hangarContents = getContents(playerHangarSlot);

		if( hangarContents != null && hangarContents.length > 0 )
		{
			int count = 0;
			for (int q = 0; q < hangarContents.length; ++q)
			{
				//LOG("space", "hangarContents["+q+"] is "+ getGameObjectType(hangarContents[q]));
				//LOG("space", "Check type is "+ GOT_data_ship_control_device);
				if (isIdValid(hangarContents[q]) && getGameObjectType(hangarContents[q]) == GOT_data_vehicle_control_device)
					++count;
			}
			
			if ( count > 0 )
			{
				obj_id[] vehicleHangarSlotControlDevices = new obj_id[count];
				count = 0;
				for ( int k = 0; k < hangarContents.length; ++k )
				{
					if ( isIdValid(hangarContents[k]) && getGameObjectType(hangarContents[k]) == GOT_data_vehicle_control_device )
					{
						//LOG("vehicle", "adding "+hangarContents[k]);
						vehicleHangarSlotControlDevices[count++] = hangarContents[k];
					}
				}
				return vehicleHangarSlotControlDevices;
			}
		}
	}
	return null;
}

// ----------------------------------------------------------------------
