/**********************************************************************
 * Copyright (c)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        squad_leader.scriptlib
 * Description:  utility functions for smuggler abilities
 * @author       $Author:$
 * @version      $Revision:$
 **********************************************************************/

/***** INCLUDES ********************************************************/
include library.chat;
include library.skill;
include library.prose;
include library.luck;
include library.static_item;
include library.utils;
include library.corpse;
include library.groundquests;

/***** CONSTANTS *******************************************************/

const string TBL = "datatables/npc/junk_dealer/junk_dealer.iff";

// Names of script vars that will be used to keep track of the sui and relic items
const string SCRIPTVAR_JUNK_SUI				= "relicdealer.biogenic.sui";
const string SCRIPTVAR_JUNK_IDS				= "relicdealer.biogenic.ids";

// Name of the script var that is used to keep track of whether an item is in the process of being sold
const string SCRIPTVAR_SOLD					= "soldAsJunk";

// The sting file that contains all strings used for this relic dealer
const string STF = "loot_dealer";

// Pre-defined string ids
const string_id PROSE_NO_BUY_FENCE			= new string_id(STF, "prose_no_buy_smuggler");
const string_id PROSE_NO_BUY_FENCE_ALL			= new string_id(STF, "prose_no_buy_all_smuggler");
const string_id PROSE_NO_BUY				= new string_id(STF, "prose_no_buy");
const string_id PROSE_NO_BUY_ALL			= new string_id(STF, "prose_no_buy_all");
const string_id PROSE_SOLD_JUNK_FENCE			= new string_id(STF, "prose_sold_junk_smuggler");
const string_id PROSE_NO_SALE_FENCE			= new string_id(STF, "prose_no_sale_smuggler");
const string_id PROSE_SOLD_JUNK				= new string_id(STF, "prose_sold_junk");
const string_id PROSE_NO_SALE				= new string_id(STF, "prose_no_sale");
const string_id PROSE_PURCHASED_JUNK			= new string_id(STF, "prose_buy_back_junk");
const string_id PROSE_NO_BUY_BACK			= new string_id(STF, "prose_no_buy_back");
const string_id PROSE_SOLD_ALL_JUNK			= new string_id(STF, "prose_sold_all_junk");
const string_id PROSE_NO_ALL_SALE			= new string_id(STF, "prose_no_all_sale");
const string_id PROSE_JUNK_SOLD				= new string_id(STF, "prose_junk_sold");
const string_id SID_NO_BUY_BACK_ITEMS_FOUND		= new string_id(STF, "no_buy_back_items_found");
const string_id PROSE_JUNK_SOLD_FENCE			= new string_id(STF, "prose_junk_sold_smuggler");
const string_id PROSE_FENCE_COMM_NOTHING 		= new string_id(STF, "prose_fence_comm_nothing");
const string_id GENERIC_NO_SALE				= new string_id(STF, "generic_no_sale");
const string_id SID_NO_SPACE_IN_INVENTORY		= new string_id(STF, "no_space_in_inventory");
// Uncomment this when testing this script through the radial menu
const string_id MENU_SELL				= new string_id("junk_dealer", "mnu_sell_junk");
const string_id MENU_BUY_BACK				= new string_id("junk_dealer", "mnu_buy_back_junk");
const string_id MENU_FLAG_NO_SALE			= new string_id("junk_dealer", "mnu_flag_no_sale_junk");

const string SELL_TITLE						= "@" + STF + ":sell_title";
const string SELL_PROMPT					= "@" + STF + ":sell_prompt";
const string NO_ITEMS_PROMPT					= "@" + STF + ":no_items";
const string BTN_EXAMINE					= "@" + STF + ":examine";
const string BTN_SELL						= "@" + STF + ":btn_sell";
const string BTN_BUY_BACK					= "@" + STF + ":btn_buy_back";
const string BUY_BACK_PROMPT					= "@" + STF + ":buy_back_prompt";
const string BUY_BACK_TITLE					= "@" + STF + ":buy_back_title";
const string SELL_TITLE_FENCE					= "@" + STF + ":sell_title_smuggler";
const string SELL_PROMPT_FENCE					= "@" + STF + ":sell_prompt_smuggler";
const string BTN_SELL_FENCE					= "@" + STF + ":btn_sell_smuggler";
const string BTN_CANCEL_FENCE					= "@" + STF + ":btn_cancel_smuggler";
const string FLAG_NO_SELL_TITLE					= "@" + STF + ":junk_no_sell_title";
const string FLAG_NO_SELL_DESC					= "@" + STF + ":junk_no_sell_desc";
const string FLAG_NO_SELL					= "@" + STF + ":junk_no_sell_button";
const string REFLAG_SELL_TITLE					= "@" + STF + ":junk_reflag_sell_title";
const string REFLAG_SELL_DESC					= "@" + STF + ":junk_reflag_sell_desc";
const string REFLAG_SELL					= "@" + STF + ":junk_reflag_sell_button";
const string FLAG_ITEM_TITLE					= "@" + STF + ":junk_not_found_title";
const string NO_ITEMS_FOUND_PROMPT				= "@" + STF + ":junk_not_found_description";

const string BUY_BACK_CONTROL_DEVICE_TEMPLATE	= "object/intangible/buy_back/buy_back_control_device.iff";

const string_id[] PROSE_FENCE_COMM 			= {
	new string_id(STF, "prose_fence_comm"),
	new string_id(STF, "prose_fence_comm_1"),
	new string_id(STF, "prose_fence_comm_2")
};
const string[] COMM_SPECIES 				= {
	"object/mobile/dressed_borvos_thief.iff",
	"object/mobile/dressed_corsair_cutthroat_hum_m.iff",
	"object/mobile/dressed_binayre_thief_twk_male_01.iff",
	"object/mobile/dressed_binayre_goon_bith_male_01.iff",
	"object/mobile/dressed_cobral_mugger_human_male_01.iff"
};

const string[] COMM_SOUND 				= {
	"sound/sys_comm_other.snd",
	"sound/sys_comm_generic.snd",
	"sound/sys_comm_imperial.snd",
	"sound/sys_comm_rebel_male.snd"
};

const string_id SID_CONTRABAND_FOUND = new string_id( "smuggler/messages", "contraband_found" );

//Fence takes 10% of proceeds
const float FENCE_MULTIPLIER_LOW			= 0.80f;
const float FENCE_MULTIPLIER				= 0.85f;
const float FENCE_MULTIPLIER_HIGH			= 0.95f;


//Smuggler System Constants
const int TIER_1_ILLICIT_SELL_VALUE			= 1000;
const int TIER_2_ILLICIT_SELL_VALUE			= 2500;
const int TIER_3_ILLICIT_SELL_VALUE			= 5000;
const int TIER_4_ILLICIT_SELL_VALUE			= 7500;
const int TIER_5_ILLICIT_SELL_VALUE			= 10000;

const int TIER_1_GENERIC_FRONT_COST			= 500;
const int TIER_2_GENERIC_FRONT_COST			= 1000;
const int TIER_3_GENERIC_FRONT_COST			= 2000;
const int TIER_4_GENERIC_FRONT_COST			= 3000;
const int TIER_5_GENERIC_FRONT_COST			= 5000;

const int TIER_4_GENERIC_PVP_FRONT_COST		= 13000;
const int TIER_5_GENERIC_PVP_FRONT_COST		= 18000;

const string BUYBACK_OBJ_TIMESTAMP			= "buyback.timeMoved";
const string BUYBACK_OBJ_CREDITS			= "buyback.credits";
const string BUYBACK_OBJ_SOLD				= "buyback.soldAsJunk";
const string BUYBACK_CONTAINER_VAR			= "buyBackContainer";
const string JUNK_DEALKER_NO_SALE_FLAG			= "doNotSellFlag";


const boolean LOGGING_ON	= true;
const string LOGNAME		= "junk_log";

/***** FUNCTIONS **************************************************/
//looks for any sellable items in the players inventory, determined by value colum in master item table or old template method in a sellable loot table

obj_id[] getAllJunkItems(obj_id player)
{
	return getAllJunkItems(player, false);
}

obj_id[] getAllJunkItems(obj_id player, boolean getFlaggedNoSale)
{
	// If the player is not valid, quit out
	if(!isIdValid(player))
		return null;

	// Get all the objects in the player's inventory
	obj_id[] contents = utils.getFilteredPlayerContents(player);

	// If there are contents in the inventory
	if((contents != null) && (contents.length > 0))
	{
		resizeable obj_id[] junk = new obj_id[0];

		// Step through each item in the inventory
		for(int i = 0; i < contents.length; i++)
		{
			//check to see if we are a volume container
			if(!validateItemsBeingSold(player, contents[i]))
				continue;

			if(!getFlaggedNoSale && hasObjVar(contents[i], JUNK_DEALKER_NO_SALE_FLAG))
				continue;
				
			if(hasObjVar(contents[i], "noTrade") || utils.isEquipped(contents[i]))
				continue;

			if(hasObjVar(contents[i], "junkDealer.intPrice"))
			{
				junk = utils.addElement(junk, contents[i]);
			}
			//new hotness static item value colum
			else if(static_item.isStaticItem(contents[i]))
			{
				if(static_item.getStaticObjectValue(getStaticItemName(contents[i])) > 0)
				{
					junk = utils.addElement(junk, contents[i]);
				}
			}
			//old and busted nasty template method
			else
			{
				if (!isCrafted(contents[i]))
				{
					// Get the template name of the item
					string template = getTemplateName(contents[i]);

					// If the entry in the datatable exists
					if ((template != null) && (!template.equals("")))
					{

						// If the price is at least 1 credit
						if(dataTableGetInt(TBL, template, "price") > 0)
						{

							// Add the item to our list
							junk = utils.addElement(junk, contents[i]);
						}
					}
				}
			}
		}

		// If we've found at least one relic to buy
		if((junk != null) && (junk.length > 0))
		{
			// Return the list
			return utils.toStaticObjIdArray(junk);
		}
	}

	return null;
}


///////////////////////////////////////////////////////////////////////////
// Shows the loot items (if any) in a neat sui list box
void showSellJunkSui(obj_id player, obj_id salesman, boolean fence, boolean showCommWindow)
{
	// If the player and the relic dealer are not valid objects quit out
	if(!isIdValid(player) || !isValidId(salesman))
		return;

	//if the target is an NPC and not the player 
	if(player != salesman)
	{
		if (utils.outOfRange(salesman, player, 10.0f, true))
			return;
	}
	
	// If the player already has a dealer sui open
	if(utils.hasScriptVar(player, SCRIPTVAR_JUNK_SUI))
	{
		// Get the PID of the sui and clean the script vars off the player
		int pidClose = utils.getIntScriptVar(player, SCRIPTVAR_JUNK_SUI);
		cleanupSellJunkSui(player);

		// Close the sui
		sui.closeSUI(player, pidClose);
	}

	// Get all of the relics in the player's inventory
	obj_id[] junk = getAllJunkItems(player);

	//comm window randomization
	string strSpecies = COMM_SPECIES[rand(0, COMM_SPECIES.length-1)];
	string strSound = COMM_SOUND[rand(0, COMM_SOUND.length-1)];

	// If there are relics...
	if(junk != null && junk.length > 0)
	{
		if(showCommWindow && fence)
		{
			prose_package ppfence = prose.getPackage(PROSE_FENCE_COMM[rand(0, PROSE_FENCE_COMM.length-1)]);
			commPlayers(player, strSpecies, strSound, 7f, player, ppfence);
		}

		float cashMultiplier = 1.0f;
		if(fence)
		{
			int playerLevel = getLevel(player);
			cashMultiplier = FENCE_MULTIPLIER_LOW;
			
			if (playerLevel > 55)
				cashMultiplier = FENCE_MULTIPLIER;
			if (playerLevel > 80)
				cashMultiplier = FENCE_MULTIPLIER_HIGH;
		}
		
		string[] entries = new string[junk.length];
		// Step through each of the relic items
		for(int i = 0; i < junk.length; i++)
		{
			int price = (int)(getPrice(junk[i]));
			if(fence)
			{
				// Get the template name and use it to reference the datatable for the price
				price = (int)(getPrice(junk[i]) * cashMultiplier);
			}

			// Set up the entry for the list box
			string name = getAssignedName(junk[i]);
			if(name.equals("") || name == null)
			{
				name = getString(getNameStringId(junk[i]));
			}
			string entry = "[" + price + "] " + name;

			// And store it in our list
			// entries = utils.addElement(entries, entry);
			entries[i] = entry;
			
		}

		// Make sure that we have a list
		if(entries != null && entries.length > 0)
		{
			string title = SELL_TITLE;
			string description = SELL_PROMPT;
			string buttonSell = BTN_SELL;
			
			if(fence)
			{
				title = SELL_TITLE_FENCE;
				description = SELL_PROMPT_FENCE;
				buttonSell = BTN_SELL_FENCE;
				utils.setScriptVar(player, "fence", true);
			}
			else
			{
				utils.setScriptVar(player, "fence", false);			
			}
						
			// And make a sui listbox
			// At this point, the listbox is still hidden so that we can rename the buttons
			int pid = sui.listbox(salesman, player, description, sui.OK_CANCEL_REFRESH, title, entries, "handleSellJunkSui", false, false);

			// If the sui creation was successful
			if(pid > -1)
			{
				// Rename some buttons and show the sui
				setSUIProperty(pid, sui.LISTBOX_BTN_OK, sui.PROP_TEXT, buttonSell);
				setSUIProperty (pid, sui.LISTBOX_BTN_OTHER, sui.PROP_VISIBLE, "true");
				setSUIProperty (pid, sui.LISTBOX_BTN_OTHER, sui.PROP_TEXT, BTN_EXAMINE);
				subscribeToSUIProperty (pid, "this", sui.LISTBOX_PROP_OTHER_PRESSED);				
				showSUIPage(pid);

				// Set some script vars on the player
				utils.setScriptVar(player, SCRIPTVAR_JUNK_SUI, pid);
				utils.setBatchScriptVar(player, SCRIPTVAR_JUNK_IDS, junk);
			}
		}
	}
	// If there are no relics in the player's inventory
	else
	{
		if(fence)
		{
			prose_package ppfence = prose.getPackage(PROSE_FENCE_COMM_NOTHING);
			commPlayers(player, strSpecies, strSound, 7f, player, ppfence);
		}
		else
		{
			int msgPid = sui.msgbox(salesman, player, NO_ITEMS_PROMPT, sui.OK_ONLY, SELL_TITLE, "noHandler");
		}
		cleanupSellJunkSui(player);
	}
}

///////////////////////////////////////////////////////////////////////////
// Cleans script vars off of the player when dealing is complete
void cleanupSellJunkSui(obj_id player)
{
	utils.removeScriptVar(player, "fence");	
	utils.removeScriptVar(player, SCRIPTVAR_JUNK_SUI);
	utils.removeBatchScriptVar(player, SCRIPTVAR_JUNK_IDS);
}

///////////////////////////////////////////////////////////////////////////
// The procedure to sell one item from the list box , this is for the Fence ability only
void sellJunkItem(obj_id player, obj_id item, boolean fence, boolean reshowSui)
{
	obj_id salesman = getSelf();

	// Make sure the player and the item to sell are valid, if not quit out
	if(!isIdValid(player) || !isIdValid(item))
		return;




	//If the salesman and the player are not the same...
	if(salesman != player)
	{
		blog("smuggler.sellJunkItem() the salesperson is not the player.");

		if (utils.outOfRange(salesman, player, 10.0f, true))
			return;	
	}



	//do one last validation to ensure nothing strange has gone on with the item
	if(!validateItemsBeingSold(player, item))
	{
		prose_package ppSold = prose.getPackage(GENERIC_NO_SALE, item);
		sendSystemMessageProse(player, ppSold);
		return;
	}

	// If the item is in the process of being sold, let the player know and quit out
	if(hasObjVar(item, BUYBACK_OBJ_SOLD))
	{
		prose_package ppSold = prose.getPackage(PROSE_JUNK_SOLD, item);		
		sendSystemMessageProse(player, ppSold);
		return;
	}

	float cashMultiplier = 1.0f;
	if(fence)
	{
		int playerLevel=getLevel(player);
		cashMultiplier = FENCE_MULTIPLIER_LOW;
		
		if (playerLevel > 55)
			cashMultiplier = FENCE_MULTIPLIER;
		if (playerLevel > 80)
			cashMultiplier = FENCE_MULTIPLIER_HIGH;
	}

	int price = (int)(getPrice(item));
	if(fence)
	{
		price = (int)(getPrice(item) * cashMultiplier);
	}

	// Fetch the template name and reference the price from the datatable
	// If the price is greater than zero, and the item is not a quest item
	if(price > 0 && !hasObjVar(item, "quest_item"))
	{
		dictionary params = new dictionary();
		params.put("item",item);
		params.put("price",price);
		params.put("reshowSui", reshowSui);

		if(luck.isLucky(player, 0.01f))
		{
			float bonus = price * 0.2f;
			if(bonus < 1.0f)
				bonus = 1.0f;

			price += bonus;
		}

		if(fence)
		{
			blog("smuggler.sellJunkItem() this is a fence player");
			params.put("fence", true);
		}
		else
		{
			blog("smuggler.sellJunkItem() this is NOT a fence player");
			params.put("fence", false);		
		}
		// Give the player the money and send a "handleSoldJunk" message to ourselves
		money.systemPayout(money.ACCT_JUNK_DEALER, player, price, "handleSoldJunk", params);

		// CS logging
		int calendarTime = getCalendarTime();
		string realTime = getCalendarTimeStringLocal(calendarTime);
		string playerName = getName(player);
		string itemName = getEncodedName(item);
		CustomerServiceLog("Junk_Dealer: ", "smuggler.sellJunkItem() - Player (" + playerName + " OID: " + player + ") sold item (" + itemName + " OID: " + item + ") for (" + price + ")credits, at (" + realTime + ")");
			
		//Is this even used anymore?????
		if(!fence && (player != salesman))
		{
			obj_id master = utils.getObjIdScriptVar(salesman, "smugglerMaster");

			// Junk dealers that are summoned by smugglers can give a cut to that smuggler.
			if(isIdValid(master) && group.inSameGroup(player, master))
			{
				dictionary junkParams = new dictionary();
				params.put("item",item);
				params.put("price",price);
				params.put("reshowSui", false);

				int smugglerCut = (int)getSkillStatisticModifier(master, "expertise_junk_dealer_cut");

				if(smugglerCut > 0)
				{
					price = (int)((float)price * (float)smugglerCut * 0.01f);

					money.systemPayout(money.ACCT_RELIC_DEALER, master, price, "handleSoldJunk", junkParams);

					// CS logging
					CustomerServiceLog("Junk_Dealer: ", "smuggler.sellJunkItem() - Player (" + playerName + " OID: " + player + ") sold item (" + itemName + " OID: " + item + ") for (" + price + ")credits, at (" + realTime + ")");

					int totalProfits = utils.getIntScriptVar(salesman, "totalProfits");

					totalProfits += price;

					utils.setScriptVar(salesman, "totalProfits", totalProfits);
				}
			}
		}		
	}
	// if for some reason we can't buy that item
	else
	{
		prose_package ppNoBuy = prose.getPackage(PROSE_NO_BUY, salesman, item);
		if(fence)
		{
			ppNoBuy = prose.getPackage(PROSE_NO_BUY_FENCE, salesman, item);
		}
		sendSystemMessageProse(player, ppNoBuy);
	}
}

// Wrapper function. If not specified, we default to NOT reshowing the sui
void sellJunkItem(obj_id player, obj_id item)
{
	sellJunkItem(player, item, false);
}

void sellJunkItem(obj_id player, obj_id item, boolean reshowUi)
{
	sellJunkItem(player, item, false, reshowUi);
}

int getPrice(obj_id item)
{
	int price = 0;

	if(hasObjVar(item, "junkDealer.intPrice"))
	{
		price = getIntObjVar(item, "junkDealer.intPrice");
	}
	else if(static_item.isStaticItem(item))
	{
		price = static_item.getStaticObjectValue(getStaticItemName(item));
	}

	else
	{
		string template = getTemplateName(item);
		price = dataTableGetInt(TBL, template, "price");
	}
	int intCount = getCount(item);
	if(intCount>0)
	{
		price = price * intCount;
	}
	return price;

}

//this used to exist in 20 different junk dealer conversations, put in here for safekeeping
boolean checkInventory (obj_id player, obj_id npc)
{
	string item = "";
	string itemTemplate = "";

	int itemLength = dataTableGetNumRows(TBL);

	int x = 0;
	int y = 0;

	obj_id inventory = utils.getInventoryContainer(player);

	if(isIdValid(inventory))
	{
		obj_id[] contents = utils.getContents(inventory, true);
		if(contents != null)
		{
			for(x = 0; x < contents.length; x++)
			{
				y = 0;
				if (!isCrafted(contents[x]))
				{
					if(static_item.getStaticObjectValue(getStaticItemName(contents[x])) > 0)
						return true;

					itemTemplate = getTemplateName(contents[x]);
					while(y < itemLength)
					{
						item = dataTableGetString(TBL, y, "items");

						if(itemTemplate == item)
						{
							return true;
						}
						y++;
					}
				}
			}
		}
	}
	return false;
}

//check to see if we are a volume container (ie a bag) 2 = CT_volume
boolean hasItemsInContainer(obj_id item)
{
	if(getContainerType(item) == 2)
	{
		obj_id[] subContents = utils.getContents(item);
		//if the bag has anything in it, do not let it be sold and continue on through inventory
		if (subContents.length > 0)
			return true;
	}
	return false;
}

//make sure the item is still in players inventory, is not a container with objects in it and not equipped
//call this when generating the Sell Sui and validate when the sell button is actually clicked.
boolean validateItemsBeingSold(obj_id player, obj_id item)
{
	if (utils.getContainingPlayer(item) != (player))
		return false;

	if(hasItemsInContainer(item))
		return false;

	if (utils.isEquipped(item))
		return false;

	return true;
}

boolean canSlyLie(obj_id playerSmuggler)
{
	location here = getLocation(playerSmuggler);
	obj_id[] objects = getObjectsInRange(here, 25);

	for(int i = 0; i < objects.length; i++)
	{
		if (hasObjVar(objects[i], "quest.owner"))
		{
			if (playerSmuggler == getObjIdObjVar(objects[i], "quest.owner"))
			{
				if (utils.hasScriptVar(objects[i], "contrabandCheck"))
				{
					return true;
				}
			}
		}
	}

	// system message no one is listening to your lies
	return false;
}

boolean doSlyLie(obj_id playerSmuggler)
{
	location here = getLocation(playerSmuggler);
	obj_id[] objects = getObjectsInRange(here, 25);

	for(int i = 0; i < objects.length; i++)
	if (hasObjVar(objects[i], "quest.owner"))
	{
		if (playerSmuggler == getObjIdObjVar(objects[i], "quest.owner"))
		{
			if (utils.hasScriptVar(objects[i], "contrabandCheck"))
			{
				utils.setScriptVar(objects[i], "slyLie", 1);
				return true;
			}
		}
	}

	sendSystemMessage(playerSmuggler, new string_id("smuggler/enemy", "sly_lie_failure"));
	// system message no one is listening to your lies
	return false;
}

boolean canFastTalk(obj_id playerSmuggler, obj_id target)
{
	if (!hasScript(target, "ai.smuggler_spawn_enemy"))
	{
		// Send message - invalid target
		return false;
	}

	if (ai_lib.isInCombat(target))
	{
		obj_id enemyTarget = getHateTarget(target);
		if (enemyTarget != playerSmuggler)
		{
			// Send message - not listening
			return false;
		}
	}

	return true;
}

boolean doFastTalk(obj_id playerSmuggler, obj_id target)
{
	if (!hasScript(target, "ai.smuggler_spawn_enemy"))
	{
		// Send message - invalid target
		return false;
	}

	if (ai_lib.isInCombat(target))
	{
		obj_id enemyTarget = getHateTarget(target);
		if (enemyTarget != playerSmuggler)
		{
			// Send message - not listening
			return false;
		}
	}

	dictionary params = new dictionary();
	params.put("playerSmuggler", playerSmuggler);

	messageTo(target, "fastTalkReaction", params, 0, false);

	return true;
}

int getSmugglerRank(float underworldFaction)
{
	if (underworldFaction < 1000.0f )
	{
		return 0;
	}

	if (underworldFaction < 2000.0f )
	{
		return 1;
	}

	if (underworldFaction < 3000.0f )
	{
		return 2;
	}

	return 3;
}


int getSmuggleTier(float underworldFaction)
{
	if (underworldFaction < 1000.0f )
	{
		return 1;
	}

	if (underworldFaction < 1500.0f )
	{
		return 2;
	}

	if (underworldFaction < 2000.0f )
	{
		return 3;
	}

	if (underworldFaction < 2500.0f )
	{
		return 4;
	}

	return 5;
}

// Returns true if the player has illicit contraband items
boolean hasIllicitContraband(obj_id player)
{
	string contrabandName = "item_smuggler_contraband_0";
 	obj_id[] contents = getInventoryAndEquipment(player);
	if (contents != null && contents.length > 0)
	{
		for(int i = 0;i < contents.length;i++)
		{
			if (static_item.isStaticItem(contents[i]))
			{
				string itemName = getStaticItemName(contents[i]);

				if (itemName.startsWith(contrabandName))
				{
					return true;
			}	}
		}
	}

	return false;
}

// Returns true if the player has illicit contraband with one stack of a size of 5 or higher
boolean hasIllicitMissionContraband(obj_id player)
{
	string contrabandName = "item_smuggler_contraband_0";
	obj_id[] contents = getInventoryAndEquipment(player);
	if (contents != null && contents.length > 0)
	{
		for(int i = 0;i < contents.length;i++)
		{
			if (static_item.isStaticItem(contents[i]))
			{
				string itemName = getStaticItemName(contents[i]);

				if (itemName.startsWith(contrabandName))
				{
					obj_id[] contrabandToCheck = utils.getAllStaticItemsInPlayerInventory(player, itemName);

					int contrabandCount = utils.countOfStackedItemsInArray(contrabandToCheck);

					if( contrabandCount >= 5 )
					{
						return true;
					}
				}
			}
		}
	}

	return false;
}

// Returns the tier of illicit contraband by name
int getIllicitContrabandTier(string itemName)
{
	if (itemName.startsWith("item_smuggler_contraband_01"))
	{
		return 1;
	}

	if (itemName.startsWith("item_smuggler_contraband_02"))
	{
		return 2;
	}

	if (itemName.startsWith("item_smuggler_contraband_03"))
	{
		return 3;
	}

	if (itemName.startsWith("item_smuggler_contraband_04"))
	{
		return 4;
	}

	if (itemName.startsWith("item_smuggler_contraband_05"))
	{
		return 5;
	}

	return 0;
}

// Returns the name of the first stack of illicit contraband of size 5 or higher
// that is the correct tier for the smuggler to do a mission on.  IF no matching
// contraband is found returns the last stack of contraband of size 5 or higher
// that is not of the correct tier for the smuggler

string getIllicitMissionContrabandSmugglerTier(obj_id player, int smugglerTier)
{

	string contrabandName = "item_smuggler_contraband_0";
	string contrabandFound = "";
	obj_id[] contents = getInventoryAndEquipment(player);
	if (contents != null && contents.length > 0)
	{
		for(int i = 0;i < contents.length;i++)
		{
			if (static_item.isStaticItem(contents[i]))
			{
				string itemName = getStaticItemName(contents[i]);
				if (itemName.startsWith(contrabandName))
				{
					obj_id[] contrabandToCheck = utils.getAllStaticItemsInPlayerInventory(player, itemName);

					int contrabandCount = utils.countOfStackedItemsInArray(contrabandToCheck);

					if( contrabandCount >= 5 )
					{
						int contrabandTier = getIllicitContrabandTier(itemName);

						if (contrabandTier == smugglerTier)
						{
							return itemName;
						}
						else
						{
							contrabandFound = itemName;
						}
					}
				}
			}
		}
	}

	return contrabandFound;
}

// Returns true if player has stack of 5 illicit contraband that the NPC is interested in
// Correct Tier

boolean hasMissionContrabandForTransaction(obj_id player, int brokerTier)
{

	string contrabandName = "item_smuggler_contraband_0";
	obj_id[] contents = getInventoryAndEquipment(player);
	if (contents != null && contents.length > 0)
	{
		for(int i = 0;i < contents.length;i++)
		{
			if (static_item.isStaticItem(contents[i]))
			{
				string itemName = getStaticItemName(contents[i]);

				if (itemName.startsWith(contrabandName))
				{
					obj_id[] contrabandToCheck = utils.getAllStaticItemsInPlayerInventory(player, itemName);

					int contrabandCount = utils.countOfStackedItemsInArray(contrabandToCheck);

					if( contrabandCount >= 5 )
					{
						int contrabandTier = getIllicitContrabandTier(itemName);
						if (contrabandTier == brokerTier)
						{
							return true;
						}
					}
				}
			}
		}
	}

	return false;
}

string getMissionContrabandForTransactionName(obj_id player, int brokerTier)
{
	string contrabandName = "item_smuggler_contraband_0";
	obj_id[] contents = getInventoryAndEquipment(player);
	if (contents != null && contents.length > 0)
	{
		for(int i = 0;i < contents.length;i++)
		{
			if (static_item.isStaticItem(contents[i]))
			{
				string itemName = getStaticItemName(contents[i]);

				if (itemName.startsWith(contrabandName))
				{
					obj_id[] contrabandToCheck = utils.getAllStaticItemsInPlayerInventory(player, itemName);

					int contrabandCount = utils.countOfStackedItemsInArray(contrabandToCheck);

					if( contrabandCount >= 5 )
					{
						int contrabandTier = getIllicitContrabandTier(itemName);
						if (contrabandTier == brokerTier)
						{
							return itemName;
						}
					}
				}
			}
		}

	}

	return "";
}

// Returns the tier of the first stack of illicit contraband of size 5 or higher

int getMissionCotrabandPointerTier(obj_id player)
{

	string contrabandName = "item_smuggler_contraband_0";
	obj_id[] contents = getInventoryAndEquipment(player);
	if (contents != null && contents.length > 0)
	{
		for(int i = 0;i < contents.length;i++)
		{
			if (static_item.isStaticItem(contents[i]))
			{
				string itemName = getStaticItemName(contents[i]);

				if (itemName.startsWith(contrabandName))
				{
					obj_id[] contrabandToCheck = utils.getAllStaticItemsInPlayerInventory(player, itemName);

					int contrabandCount = utils.countOfStackedItemsInArray(contrabandToCheck);

					if( contrabandCount >= 5 )
					{
						return(getIllicitContrabandTier(itemName));
					}
				}
			}
		}
	}

	return 0;
}

void createRandomContrabandTier(obj_id player, int dropTier)
{
	obj_id pInv = utils.getInventoryContainer(player);

	int tierItem = rand(1,5);

	string contrabandToCreate = "item_smuggler_contraband_0" +dropTier +"_0" +tierItem;

	string_id contrabandName = new string_id ("static_item_n", contrabandToCreate);

	obj_id newItem = static_item.createNewItemFunction (contrabandToCreate, pInv);

	prose_package pp = null;

	pp = prose.getPackage(SID_CONTRABAND_FOUND, contrabandName);

	sendSystemMessageProse(player, pp);

	return;
}

void spaceContrabandDropCheck(obj_id player)
{
	float underworldFaction = factions.getFactionStanding( player, "underworld" );
	int tier = getSmuggleTier(underworldFaction);

	int chance = (12 - tier*2);
	int buffFeelingLucky = 0;

	chance += buffFeelingLucky = (int)getSkillStatisticModifier(player, "expertise_increase_smuggler_loot");

	if (chance >= rand(1,100))
	{
		createRandomContrabandTier(player, tier);
		if(buffFeelingLucky > 0 && !buff.hasBuff(player, "sm_feeling_lucky") && !buff.hasBuff(player, "sm_feeling_lucky_recourse"))
		{
			// Buff Feeling Lucky and play effects
			buff.applyBuff(player, "sm_feeling_lucky");
		}
	}
	return;
}


void contrabandDropCheck(obj_id player, obj_id target, int tier, int corpseLevel)
{
	int dropTier = 0;

	if (corpseLevel >0 && corpseLevel <21)
	{
		dropTier = 1;
	}

	if (corpseLevel >20 && corpseLevel <41)
	{
		dropTier = 2;
	}

	if (corpseLevel >40 && corpseLevel<61)
	{
		dropTier = 3;
	}

	if (corpseLevel >60 && corpseLevel <71)
	{
		dropTier = 4;
	}

	if (corpseLevel >70)
	{
		dropTier = 5;
	}

	if (dropTier > tier)
	{
		dropTier = tier;
	}

	// Base Drop Rates ||Tier 1 10%||Tier 2 8%||Tier 3 6%||Tier 4 4%||Tier 5 2%||
	int chance = (12 - (dropTier*2));
	int buffFeelingLucky = 0;

	chance += buffFeelingLucky = (int)getSkillStatisticModifier(player, "expertise_increase_smuggler_loot");

	utils.setScriptVar(target, "contrabandChecked", 1);
	if (chance >= rand(1,100))
	{
		createRandomContrabandTier(player, dropTier);

		if(buffFeelingLucky > 0 && !buff.hasBuff(player, "sm_feeling_lucky") && !buff.hasBuff(player, "sm_feeling_lucky_recourse"))
		{
			// Buff Feeling Lucky and play effects
			buff.applyBuff(player, "sm_feeling_lucky");
		}
		return;
	}
	sendSystemMessage(player, new string_id("smuggler/messages", "no_contraband_found"));
	return;
}

void inspectCorpseForContraband(obj_id player, obj_id target)
{
	if( !isIdValid(target) )
	{
		return;
	}

	if( !isMob(target) )
	{
		return;
	}

	if( !isIncapacitated(target) )
	{
		return;
	}

	if( isIncapacitated(player))
	{
		return;
	}

	if( pet_lib.isPet (target))
	{
		return;
	}

	if(utils.hasScriptVar(target, "contrabandChecked"))
	{
		sendSystemMessage(player, new string_id("smuggler/messages", "contraband_already_checked"));
		return;
	}

	if (!corpse.hasLootPermissions(target, player))
	{
		return;
	}

	string strLootTable = getStringObjVar(target, "loot.lootTable");

	if (!strLootTable.startsWith("npc") && (!strLootTable.startsWith("droid")) )
	{
		sendSystemMessage(player, new string_id("smuggler/messages", "contraband_not_possible"));
		return;
	}

	float underworldFaction = factions.getFactionStanding( player, "underworld" );

	int smugglerTier = getSmuggleTier(underworldFaction);

	int intLevel = getIntObjVar(target, "intCombatDifficulty");

	contrabandDropCheck(player, target, smugglerTier, intLevel);

	return;
}

void removeFromBountyTerminal(obj_id self, int questCrc, boolean failed)
{
	if(questCrc == ##"quest/smuggle_pvp_4" || questCrc == ##"quest/smuggle_pvp_5")
	{
		if(hasObjVar(self, "smuggler.bounty"))
		{
			int bounty = getIntObjVar(self, "smuggler.bounty");
			int current_bounty = 0;

			if(failed)
				bounty *= 0.95f;

			if(hasObjVar(self, "bounty.amount"))
				current_bounty = getIntObjVar(self, "bounty.amount");

			current_bounty -= bounty;
			if(current_bounty <= 0)
			{
				current_bounty = 0;
				removeObjVar(self, "bounty.amount");
				setJediBountyValue(self, 0);
			}
			else
			{
				setObjVar(self, "bounty.amount", current_bounty);
				setJediBountyValue(self, current_bounty);
			}

			if(current_bounty < 15000)
			{
				obj_id[] hunters = getJediBounties(self);

				dictionary d = new dictionary();
				d.put("target", self);
				d.put("bounty", current_bounty);

				if(hunters != null && hunters.length > 0)
				{
					for(int i = 0; i < hunters.length; i++)
						messageTo(hunters[i], "handleBountyMissionIncomplete", d, 0.0f, true);
				}

				removeAllJediBounties(self);
			}

			removeObjVar(self, "smuggler.bounty");
			updateJediScriptData(self, "smuggler", 0);
		}
	}

	return;
}

void checkSmugglerMissionBountyFailure(obj_id player, obj_id killer)
{
	if(utils.isProfession(player, utils.SMUGGLER))
	{
		if(groundquests.isQuestActive(player, "quest/smuggle_pvp_4") || groundquests.isQuestActive(player, "quest/smuggle_pvp_5"))
		{
			int amount = 50;

			if(groundquests.isQuestActive(player, "quest/smuggle_pvp_5"))
				amount = 100;

			groundquests.applyQuestPenalty(killer, "underworld", amount);

			removeObjVar(player, "smuggler.bounty");
			updateJediScriptData(player, "smuggler", 0);

			messageTo(player, "handleSmugglerMissionFailureSignal", null, 1.0f, true);
		}
	}
}

void checkSmugglerTitleGrants(obj_id player, float value)
{

	if (value >= 1000.0f)
	{
		if (!hasSkill(player, "sm_title_bootlegger"))
		{
			grantSkill(player, "sm_title_bootlegger");
		}
	}
	else
	{
		if (hasSkill(player, "sm_title_bootlegger"))
		{
			revokeSkill(player, "sm_title_bootlegger");
		}
	}

	if (value >= 2000.0f)
	{
		if (!hasSkill(player, "sm_title_pirate"))
		{
			grantSkill(player, "sm_title_pirate");
		}
	}
	else
	{
		if (hasSkill(player, "sm_title_pirate"))
		{
			revokeSkill(player, "sm_title_pirate");
		}
	}

	if (value >= 3000.0f)
	{
		if (!hasSkill(player, "sm_title_master_smuggler"))
		{
			grantSkill(player, "sm_title_master_smuggler");
		}
	}
	else
	{
		if (hasSkill(player, "sm_title_master_smuggler"))
		{
			revokeSkill(player, "sm_title_master_smuggler");
		}
	}
	return;
}

void checkBountyTitleGrants(obj_id player, float value)
{
	if (value <= -1000.0f)
	{
		if (!hasSkill(player, "bh_title_informant"))
		{
			grantSkill(player, "bh_title_informant");
		}
	}

	if (value <= -2000.0f)
	{
		if (!hasSkill(player, "bh_title_inspector"))
		{
			grantSkill(player, "bh_title_inspector");
		}
	}

	if (value <= -3000.0f)
	{
		if (!hasSkill(player, "bh_title_agent"))
		{
			grantSkill(player, "bh_title_agent");
		}
	}
	return;
}

void checkRewardQuestGrants(obj_id target, float value)
{
	if (value >= 1000.0f)
	{
		if (!groundquests.isQuestActive(target, "smuggler_reward_1")
		&& (!groundquests.hasCompletedQuest(target, "smuggler_reward_1")) )
		{
			groundquests.requestGrantQuest(target, "smuggler_reward_1");
		}
	}

	if (value >= 2000.0f)
	{
		if (!groundquests.isQuestActive(target, "smuggler_reward_2")
		&& (!groundquests.hasCompletedQuest(target, "smuggler_reward_2")) )
		{
			groundquests.requestGrantQuest(target, "smuggler_reward_2");
		}
	}

	if (value >= 3000.0f)
	{
		if (!groundquests.isQuestActive(target, "smuggler_reward_3")
		&& (!groundquests.hasCompletedQuest(target, "smuggler_reward_3")) )
		{
			groundquests.requestGrantQuest(target, "smuggler_reward_3");
		}
	}

	return;
}

boolean moveBuyBackObjectIntoContainer(obj_id player, obj_id object, int credits)
{
	if(!isValidId(player) || !exists(player))
	{
		return false;
	}

	if(!isValidId(object) || !exists(object))
	{
		return false;		
	}

	if(credits <= 0)
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.moveBuyBackObjectIntoContainer() - Player (OID: " + player + ") attempted to move an object with a value of 0 or less into his buy back container.");		
		return false;		
	}

	if(!hasObjVar(player, BUYBACK_CONTAINER_VAR))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.moveBuyBackObjectIntoContainer() - Player (OID: " + player + ") did not havee a buy back conteiner objvar yet!!");		
		return false;
	}

	obj_id objContainer = getObjIdObjVar(player, BUYBACK_CONTAINER_VAR);
	if(!isIdValid(objContainer))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.moveBuyBackObjectIntoContainer() - Player (OID: " + player + ") does not have a valid buy back container.");			
		return false;
	}
	
	obj_id[] allObjects = getBuyBackItemsInContainer(player);
	if(allObjects != null && allObjects.length == 10)
	{
		if(!isIdValid(allObjects[0]) || getIntObjVar(allObjects[0], BUYBACK_OBJ_TIMESTAMP) <= 0)
		{
			return false;
		}
		//if 10 objects exits, destroy oldest
		obj_id oldestObject = allObjects[0];
		int oldestTime = getIntObjVar(oldestObject, BUYBACK_OBJ_TIMESTAMP);
		for(int i = 1;i <= allObjects.length - 1; i++)
		{
			if(!isIdValid(allObjects[i]))
				continue;
			
			int oldTimerCandidate = getIntObjVar(allObjects[i], BUYBACK_OBJ_TIMESTAMP);
			if(oldTimerCandidate <= 0)
				continue;
				
			if(oldTimerCandidate < oldestTime)
			{
				oldestObject = allObjects[i];
				oldestTime = oldTimerCandidate;
			}
		}
		
		CustomerServiceLog("Junk_Dealer: ", "smuggler.moveBuyBackObjectIntoContainer() - Player (OID: " + player + ") has had object: " + oldestObject + " deleted in the buy back container: "+objContainer+" because the item was the oldest of the 10 objects in that container.");			
		destroyObject(oldestObject);
	}
	
	int timeNow = getCalendarTime();
	setObjVar(object, BUYBACK_OBJ_TIMESTAMP, timeNow);
	setObjVar(object, BUYBACK_OBJ_CREDITS, credits);
		
	//int objectsMoved = moveObjects(objectToBeMoved, objContainer);
	if(putIn(object, objContainer, player))
	{
		return true;
	}
	return false;
}

boolean moveBuyBackObjectIntoInventory(obj_id player, obj_id object)
{
	if(!isValidId(player) || !exists(player))
	{
		return false;
	}

	if(!isValidId(object) || !exists(object))
	{
		return false;		
	}

	if(!hasObjVar(player, BUYBACK_CONTAINER_VAR))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.moveBuyBackObjectIntoInventory() - Player (OID: " + player + ") did not havee a buy back conteiner objvar yet!!");	
		return false;
	}

	obj_id objContainer = utils.getInventoryContainer(player);
	if(!isIdValid(objContainer) || !exists(objContainer))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.moveBuyBackObjectIntoInventory() - Player (OID: " + player + ") does not have a valid buy back container.");		
		return false;
	}
	
	if(putIn(object, objContainer, player))
	{
		removeObjVar(object, BUYBACK_OBJ_TIMESTAMP);
		removeObjVar(object, BUYBACK_OBJ_CREDITS);
		removeObjVar(object, BUYBACK_OBJ_SOLD);
		return true;
	}
	
	CustomerServiceLog("Junk_Dealer: ", "smuggler.moveBuyBackObjectIntoInventory() - Player (OID: " + player + ") could not put object: "+object+" in buy back container.");	
	return false;
}

obj_id[] getBuyBackItemsInContainer(obj_id player)
{
	if(!isValidId(player) || !exists(player))
	{
		return null;
	}

	if(!hasObjVar(player, BUYBACK_CONTAINER_VAR))
	{
		return null;
	}

	obj_id objContainer = getObjIdObjVar(player, BUYBACK_CONTAINER_VAR);
	if(!isIdValid(objContainer) || !exists(objContainer))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.getBuyBackItemsInContainer() - Player (OID: " + player + ") does not have a valid buy back container.");	
		return null;
	}

	obj_id[] objContents = utils.getContents(objContainer, true);
	if(objContents == null || objContents.length <= 0)
	{
		return null;	
	}

	return objContents;
}

boolean hasBuyBackContainer(obj_id player)
{
	if(!isValidId(player) || !exists(player))
	{
		return false;
	}
	
	if(!hasObjVar(player, BUYBACK_CONTAINER_VAR))
	{	
		return false;
	}
	
	obj_id buyBackContainer = getObjIdObjVar(player, BUYBACK_CONTAINER_VAR);
	if(!isValidId(buyBackContainer) || !exists(buyBackContainer))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.hasBuyBackContainer() - Player (OID: " + player + ") does not have a valid buy back container.");		
		return false;
	}

	return true;
}

obj_id createBuyBackControlDeviceOnPlayer(obj_id player)
{
	if(!isValidId(player) || !exists(player))
	{
		return null;
	}

	obj_id datapad = utils.getPlayerDatapad(player);
	if(!isValidId(datapad))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.createBuyBackControlDeviceOnPlayer() - Player (OID: " + player + ") did not have a valid datapad.");
		return null;
	}
	
	//First we chack to make sure the player doesn't already have a buy back container.	
	obj_id[] objContents = utils.getContents(datapad, true);
	if(objContents != null && objContents.length > 0)
	{
		for(int i = 0; i < objContents.length; i++)
		{
			if(isIdValid(objContents[i]))
			{
				string template = getTemplateName(objContents[i]);
				if(template != null && template.length() > 0)
				{
					if(template.equals(BUY_BACK_CONTROL_DEVICE_TEMPLATE))
					{
						CustomerServiceLog("Junk_Dealer: ", "smuggler.createBuyBackControlDeviceOnPlayer() - Player (OID: " + player + ") had an already valid buy back controller device that somehow got removed!: "+objContents[i]);
						setBuyBackContainerObjVar(player, objContents[i]);
						return objContents[i];
					}
				}
			}
		}
	}

	obj_id buyBackControlDevice = createObject(BUY_BACK_CONTROL_DEVICE_TEMPLATE, datapad, "");
	if(!isValidId(buyBackControlDevice))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.createBuyBackControlDeviceOnPlayer() - Player (OID: " + player + ") did not receive a valid buy back container.");
		return null;
	}
	
	setBuyBackContainerObjVar(player, buyBackControlDevice);
	return buyBackControlDevice;
}

void setBuyBackContainerObjVar(obj_id player, obj_id buyBackControlDevice)
{
	obj_id buyBackContainer = utils.getInventoryContainer(buyBackControlDevice);
	if ( isIdValid(buyBackContainer) )
	{
		setObjVar(player, BUYBACK_CONTAINER_VAR, buyBackContainer);
	}
	else
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.setBuyBackContainerObjVar() - Player (OID: " + player + ") buy back control device did not have a back buy container in its inventory.");
	}
	return;
}

obj_id getBuyBackContainerObjVar(obj_id player)
{
	if(hasObjVar(player, BUYBACK_CONTAINER_VAR))
	{
		return getObjIdObjVar(player, BUYBACK_CONTAINER_VAR);
	}
	CustomerServiceLog("Junk_Dealer: ", "smuggler.getBuyBackContainerObjVar() - Player (OID: " + player + ") did not have a buy back container objvar. Attempting to find buy back control device.");
	return utils.getInventoryContainer(createBuyBackControlDeviceOnPlayer(player));
}

boolean hasBuyBackItems(obj_id player)
{
	if(!isValidId(player))
	{
		return false;
	}
	
	obj_id[] listOfBuyBacks = getBuyBackItemsInContainer(player);
	return listOfBuyBacks != null && listOfBuyBacks.length > 0;
}


// Shows the relic items (if any) in a neat sui list box
boolean showBuyBackSui(obj_id player, obj_id target)
{
	// If the player and the relic dealer are not valid objects quit out
	if(!isIdValid(player) || !isIdValid(target))
		return false;

	//range check
	if(utils.outOfRange(target, player, 10.0f, true))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.showBuyBackSui() - Player: "+player+" attempted to get a list of buy back items but the action failed. The player was too far away from the NPC.");				
		return false;
	}

	obj_id playerInv = utils.getInventoryContainer(player);
	if ( isIdValid(playerInv) )
	{
		int free_space = getVolumeFree(playerInv);
		if (free_space < 1 )
		{
			sendSystemMessage(player, SID_NO_SPACE_IN_INVENTORY);
			CustomerServiceLog("Junk_Dealer: ", "smuggler.showBuyBackSui() - Player: "+player+" could not buy back any more items due to inventory space restrictions.");
			return false;
		}
	}
	
	// If the player already has a dealer sui open
	if(utils.hasScriptVar(player, SCRIPTVAR_JUNK_SUI))
	{
		// Get the PID of the sui and clean the script vars off the player
		int pidClose = utils.getIntScriptVar(player, SCRIPTVAR_JUNK_SUI);
		cleanupSellJunkSui(player);

		// Close the sui
		sui.closeSUI(player, pidClose);
	}

	// Get all of the relics in the player's inventory
	obj_id[] junk = getBuyBackItemsInContainer(player);

	// If there are relics...
	if(junk == null && junk.length <= 0)
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.showBuyBackSui() - Player: "+player+" attempted to get a list of buy back items but the action failed. There were no items to buy back.");			
		sendSystemMessage(player, SID_NO_BUY_BACK_ITEMS_FOUND);
		return false;
	}

	string[] entries = new string[junk.length];

	for(int i = 0; i < junk.length; i++)
	{
		int price = getIntObjVar(junk[i], BUYBACK_OBJ_CREDITS);

		// Set up the entry for the list box
		string name = getAssignedName(junk[i]);
		if(name.equals("") || name == null)
		{
			name = getString(getNameStringId(junk[i]));
		}
		string entry = "[" + price + "] " + name;

		// And store it in our list
		// entries = utils.addElement(entries, entry);
		entries[i] = entry;
	}

	if(entries == null || entries.length <= 0)
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.showBuyBackSui() - Player: "+player+" attempted to get a list of buy back items but the action failed. Somehow the Junk Dealer system failed to create a list of buy back item string names.");					
		return false;
	}

	int pid = sui.listbox(target, player, BUY_BACK_PROMPT, sui.OK_CANCEL_REFRESH, BUY_BACK_TITLE, entries, "handleBuyBackSui", false, false);
	if(pid <= -1)
	{
		return false;
	}
	
	// Rename some buttons and show the sui
	setSUIProperty(pid, sui.LISTBOX_BTN_OK, sui.PROP_TEXT, BTN_BUY_BACK);
	setSUIProperty (pid, sui.LISTBOX_BTN_OTHER, sui.PROP_VISIBLE, "true");
	setSUIProperty (pid, sui.LISTBOX_BTN_OTHER, sui.PROP_TEXT, BTN_EXAMINE);
	subscribeToSUIProperty (pid, "this", sui.LISTBOX_PROP_OTHER_PRESSED);				
	showSUIPage(pid);

	// Set some script vars on the player
	utils.setScriptVar(player, SCRIPTVAR_JUNK_SUI, pid);
	utils.setBatchScriptVar(player, SCRIPTVAR_JUNK_IDS, junk);
	return true;
}

boolean buyBackJunkItem(obj_id player, obj_id junkDealer, obj_id item, boolean reshowSui)
{
	// Make sure the player and the item to sell are valid, if not quit out
	if(!isIdValid(player) || !isIdValid(item) || !isValidId(junkDealer))
		return false;

	//range check
	if(utils.outOfRange(junkDealer, player, 10.0f, true))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.buyBackJunkItem() - Player: "+player+" cannot buy back item: "+item+" because they walked too far from the Junk Dealer: "+junkDealer);		
		return false;
	}

	if(!hasObjVar(player, smuggler.BUYBACK_CONTAINER_VAR))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.buyBackJunkItem() - Player: "+player+" cannot buy back item: "+item+" because the player doesn't have a buy back container objvar.");		
		return false;
	}
		
	if(!hasObjVar(item, smuggler.BUYBACK_OBJ_SOLD))
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.buyBackJunkItem() - Player: "+player+" cannot buy back item: "+item+" because it has a sold objvar. This item has already been marked as sold. Aborting.");
		return false;
	}

	if(!hasObjVar(item, smuggler.BUYBACK_OBJ_CREDITS) || getIntObjVar(item, smuggler.BUYBACK_OBJ_CREDITS) <= 0)
	{
		CustomerServiceLog("Junk_Dealer: ", "smuggler.buyBackJunkItem() - Player: "+player+" cannot buy back item: "+item+" because the credit amount was not found or invalid.");	
		return false;
	}
	
	int price = getIntObjVar(item, smuggler.BUYBACK_OBJ_CREDITS);

	dictionary params = new dictionary();
	params.put("item",item);
	params.put("price",price);
	CustomerServiceLog("Junk_Dealer: ", "junk_dealer.buyBackJunkItem() - Player: "+player+" is about to be charged: "+price+" for object: "+item+" as part of the buy back functionality.");				
	money.requestPayment(player, junkDealer, price, "handleTheBuyBack", params, true);
	return true;		
}

void flagJunkSaleSui(obj_id player, obj_id salesman)
{
	// If the player and the relic dealer are not valid objects quit out
	if(!isIdValid(player) || !isValidId(salesman))
		return;

	if (utils.outOfRange(salesman, player, 10.0f, true))
		return;
	
	// If the player already has a dealer sui open
	if(utils.hasScriptVar(player, smuggler.SCRIPTVAR_JUNK_SUI))
	{
		// Get the PID of the sui and clean the script vars off the player
		int pidClose = utils.getIntScriptVar(player, smuggler.SCRIPTVAR_JUNK_SUI);
		smuggler.cleanupSellJunkSui(player);

		// Close the sui
		sui.closeSUI(player, pidClose);
	}

	// Get all of the relics in the player's inventory
	obj_id[] junk = smuggler.getAllJunkItems(player, true);

	// If there are relics...
	if(junk != null && junk.length > 0)
	{
		string[] entries = new string[junk.length];
		// Step through each of the relic items
		for(int i = 0; i < junk.length; i++)
		{
			
			// Set up the entry for the list box
			string entry = "[ Sellable ] "+getString(getNameStringId(junk[i]));
			if(hasObjVar(junk[i], smuggler.JUNK_DEALKER_NO_SALE_FLAG))
			{
				entry = "[ *No Sell* ] "+getString(getNameStringId(junk[i]));
			}
			
			// And store it in our list
			// entries = utils.addElement(entries, entry);
			entries[i] = entry;
		}

		// Make sure that we have a list
		if(entries != null && entries.length > 0)
		{									
			// And make a sui listbox
			// At this point, the listbox is still hidden so that we can rename the buttons
			int pid = sui.listbox(salesman, player, smuggler.FLAG_NO_SELL_DESC, sui.OK_CANCEL_REFRESH, smuggler.FLAG_NO_SELL_TITLE, entries, "handleFlagJunkSui", false, false);

			// If the sui creation was successful
			if(pid > -1)
			{
				// Rename some buttons and show the sui
				setSUIProperty(pid, sui.LISTBOX_BTN_OK, sui.PROP_TEXT, smuggler.FLAG_NO_SELL);
				setSUIProperty (pid, sui.LISTBOX_BTN_OTHER, sui.PROP_VISIBLE, "true");
				setSUIProperty (pid, sui.LISTBOX_BTN_OTHER, sui.PROP_TEXT, smuggler.BTN_EXAMINE);
				subscribeToSUIProperty (pid, "this", sui.LISTBOX_PROP_OTHER_PRESSED);				
				showSUIPage(pid);

				// Set some script vars on the player
				utils.setScriptVar(player, smuggler.SCRIPTVAR_JUNK_SUI, pid);
				utils.setBatchScriptVar(player, smuggler.SCRIPTVAR_JUNK_IDS, junk);
			}
		}
	}
	// If there are no relics in the player's inventory
	else
	{
		int msgPid = sui.msgbox(salesman, player, smuggler.NO_ITEMS_FOUND_PROMPT, sui.OK_ONLY, smuggler.FLAG_ITEM_TITLE, "noHandler");
		smuggler.cleanupSellJunkSui(player);
	}
}

boolean blog(string txt)
{
	if(LOGGING_ON)
	{
		LOG(LOGNAME, txt);
	}
	return true;
}
