include library.callable;
include library.pet_lib;
include library.utils;
include library.attrib;
include library.skill;
include library.ai_lib;
include library.space_flags;
include library.performance;
include library.combat;
include library.luck;
include library.skill;


const int RESIGN_TIME				= 0;
const int COVERT_TIME				= 300;


const string VAR_RESIGNING			= "faction_recruiter.resigning";

const float BOTHAN_NEGATIVE_MOD				= 0.90f;

const string FACTION                    	= "faction";
const float FACTION_RATING_MIN          	= -5000.0f;
const float FACTION_RATING_MAX          	= +5000.0f;
const float NON_ALIGNED_FACTION_MAX			= +1000.0f;
const float FACTION_RATING_DECLARABLE_MIN	= 200.0f;
const float FACTION_RATING_SYMPATHIZER_MIN	= 750.0f;
const float FACTION_RATING_INVALID			= 0.0f;
const float MAX_FACTION_KILL_REWARD			= 30.0f;
const int NEWLY_DECLARED_INTERVAL			= 300;

const int AD_HOC_FACTION = -1;
const int NPC_FACTION_START_INDEX = 2;//index 0 is Imperial, and index 1 is Rebel, so NPC Factions start at 2.

const int REACTION_LIKE = 2;//they won't assist in combat, but will say nice things.
const int REACTION_POSITIVE = 1;//an Aggro faction will assist in combat
const int REACTION_NEUTRAL = 0;
const int REACTION_NEGATIVE = -1;//an Aggro faction will attack
const int REACTION_DISLIKE = -2;//they won't attack on site, but will say mean things.

const int STATUS_FRIEND = 0;
const int STATUS_NEUTRAL = 1;
const int STATUS_ENEMY = 2;

const string FACTION_IMPERIAL = "Imperial";
const string FACTION_REBEL = "Rebel";
const string FACTION_HUTT = "Hutt";
const string FACTION_NEUTRAL = "Neutral";

const int FACTION_FLAG_UNKNOWN				= 0;
const int FACTION_FLAG_REBEL				= 1;
const int FACTION_FLAG_IMPERIAL				= 2;
const int FACTION_FLAG_NEUTRAL				= 3;

const string IN_ADHOC_PVP_AREA		= "pvp_faction.in_adhoc_pvp_area";

const string FACTION_TABLE = "datatables/faction/faction.iff";

const string_id PROSE_AWARD_FACTION			= new string_id("base_player","prose_award_faction");
const string_id PROSE_LOSE_FACTION			= new string_id("base_player","prose_lose_faction");
const string_id PROSE_MAX_FACTION			= new string_id("base_player","prose_max_faction");
const string_id PROSE_MIN_FACTION			= new string_id("base_player","prose_min_faction");

const string_id PROSE_TEF					= new string_id("base_player","prose_tef");

//Quest factions for EP3 expansion
const string KASHYYYK					= "Kashyyyk";
const string HSSKOR					= "Hsskor";

// Ranks
/*
const string[] ranks = {"recruit", "private", "lance_corporal", "corporal", "sergeant", "staff_sergeant", "staff_corporal", "warrant_officer_2", "master_sergeant", "warrant_officer_1",
		"second_lieutenant", "lieutenant", "captain", "major", "lieutenant_colonel", "colonel", "high_colonel", "brigadier_general", "major_general",
		"lieutenant_general", "general", "high_general", "surface_marshal"};

const int[] rank_costs = {10, 10, 400, 800, 1200, 1600, 2000, 2500, 3000, 3500, 4000, 5000, 5000, 5500, 5500, 6000, 6000, 6500, 6500, 7000, 7000, 7500, 7500, 8000};
*/

const string TBL_RANK						= "datatables/faction/rank.iff";
const string GCW_RANK_TABLE					= "datatables/gcw/gcw_rank.iff";

const string COL_INDEX						= "INDEX";
const string COL_NAME						= "NAME";
const string COL_COST						= "COST";
const string COL_DELEGATE_MULTIPLIER		= "DELEGATE_MULTIPLIER";

const int MAXIMUM_RANK = 15;

//from PLAYER_RECRUITER script
const string DATATABLE_ALLOWED_XP_TYPES		= "datatables/npc/faction_recruiter/allowed_xp_types.iff";

const string SCRIPT_PLAYER_RECRUITER		= "npc.faction_recruiter.player_recruiter";
const string SCRIPT_FACTION_ITEM		= "npc.faction_recruiter.faction_item";

const string VAR_TRAINING_SELECTION		= "faction_recruiter.training_selection";
const string VAR_TRAINING_COST			= "faction_recruiter.cost";
const string VAR_TRAINING_XP			= "faction_recruiter.xp";
const string VAR_AVAILABLE_ITEMS		= "faction_recruiter.available_items";
const string VAR_FACTION			= "faction_recruiter.faction";
const string VAR_DECLARED			= "faction_recruiter.declared";
const string VAR_FACTION_HIRELING		= "faction_recruiter.faction_hireling";
const string VAR_PLAYER				= "faction_recruiter.player";
const string VAR_NEWLY_DECLARED			= "faction_recruiter.newly_declared";

const string_id SID_RESIGN_COMPLETE		= new string_id("faction_recruiter", "resign_complete");
const string_id SID_COVERT_COMPLETE		= new string_id("faction_recruiter", "covert_complete");
const string_id SID_INVALID_AMOUNT_ENTERED	= new string_id("faction_recruiter", "invalid_amount_entered");
const string_id SID_NOT_ENOUGH_STANDING_SPEND	= new string_id("faction_recruiter", "not_enough_standing_spend");
const string_id SID_AMOUNT_TOO_SMALL		= new string_id("faction_recruiter", "amount_to_spend_too_small");
const string_id SID_EXPERIENCE_GRANTED		= new string_id("faction_recruiter", "training_experience_granted");
const string_id SID_ITEM_PURCHASED		= new string_id("faction_recruiter", "item_purchase_complete");
const string_id SID_ACQUIRE_HIRELING		= new string_id("faction_recruiter", "hireling_purchase_complete");
const string_id SID_TOO_MANY_HIRELINGS		= new string_id("faction_recruiter", "too_many_hirelings");
const string_id SID_HIRELING_RELEASED		= new string_id("faction_recruiter", "hireling_released");
const string_id SID_INVENTORY_FULL		= new string_id("faction_recruiter", "inventory_full");
const string_id SID_DATAPAD_FULL		= new string_id("faction_recruiter", "datapad_full");
const string_id SID_ORDER_PURCHASED		= new string_id("faction_recruiter", "order_purchase_complete");
const string_id SID_SCHEMATIC_PURCHASED		= new string_id("faction_recruiter", "schematic_purchase_complete");
const string_id SID_SCHEMATIC_DUPLICATE		= new string_id("faction_recruiter", "schematic_duplicate");
const string_id SID_MUST_BE_DECLARED		= new string_id("faction_recruiter", "must_be_declared");
const string_id SID_MUST_BE_FACTION_MEMBER	= new string_id("faction_recruiter", "must_be_faction_member");
const string_id SID_MUST_BE_DECLARED_USE	= new string_id("faction_recruiter", "must_be_declared_use");
const string_id SID_MUST_BE_FACTION_MEMBER_USE	= new string_id("faction_recruiter", "must_be_faction_member_use");
const string_id SID_MUST_BE_NOTONLEAVE		= new string_id("faction_recruiter", "must_be_not_onleave");
const string_id SID_ACHIEVED_RANK			= new string_id("faction_recruiter", "achieved_rank");
const string_id SID_DEMOTED_RANK			= new string_id("faction_recruiter", "demoted_rank");
const string_id SID_SUI_DELEGATE_FACTION	= new string_id("faction_recruiter", "sui_delegate_faction");
const string_id SID_SUI_DELEGATE_FACTION_TEXT = new string_id("faction_recruiter", "sui_delegate_faction_text");
const string_id SID_SUI_DELEGATE_FACTION_TITLE = new string_id("faction_recruiter", "sui_delegate_faction_title");
const string_id SID_SUI_DELEGATE_FACTION_CAT = new string_id("faction_recruiter", "sui_faction_delegate_cat");
const string_id SID_SUI_FACTION_RESIG_TITLE = new string_id("faction_recruiter", "sui_faction_resig_title");
const string_id SID_SUI_FACTION_RESIG_TEXT	= new string_id("faction_recruiter", "sui_faction_resig_text");

const string_id SID_INVALID_TRAINING_TYPE		= new string_id("faction_recruiter", "invalid_training_type");
const string_id SID_NO_RANK_NAME                = new string_id("faction_recruiter", "no_rank_name");

const string_id SID_INSPIRE_BONUS		= new string_id("performance", "perform_inspire_faction_bonus");

const string_id SID_FACTION_ADJUSTED_LOWER		= new string_id("error_message", "faction_adjusted_lower");
const string_id SID_FACTION_INVALID_LOOKAT		= new string_id("error_message", "faction_invalid_lookat");
const string_id SID_FACTION_CANT_GIVE_YOURSELF	= new string_id("error_message", "faction_cant_give_yourself");
const string_id SID_FACTION_ONLY_OTHER_PLAYERS	= new string_id("error_message", "faction_only_other_players");
const string_id SID_FACTION_NONE_TO_GIVE		= new string_id("error_message", "faction_none_to_give");
const string_id SID_FACTION_LACK_POINTS_TO_GIVE	= new string_id("error_message", "faction_lack_points_to_give");
const string_id SID_FACTION_TARGET_AT_CAP		= new string_id("error_message", "faction_target_at_cap");
const string_id SID_FACTION_ONLY_DELEGATE_N_POINTS = new string_id("error_message", "faction_only_delegate_n_points");
const string_id SID_FACTION_DELEGATE_X_TO_TARGET = new string_id("error_message", "faction_delegate_x_to_target");
const string_id SID_FACTION_DELEGATE_SYNTAX		= new string_id("error_message", "faction_delegate_syntax");

const string SCRIPTVAR_FACTIONAL_HELPER_SUI_ID 			= "factionalHelperSuiId";
const string SCRIPTVAR_FACTIONAL_HELPER_SUI_CHOICES 		= "factionalHelperSuiChoices";

const string MERC_END_COVERT_IMPERIAL				= "covert_imperial_mercenary_end";
const string MERC_END_OVERT_IMPERIAL				= "overt_imperial_mercenary_end";
const string MERC_END_COVERT_REBEL				= "covert_rebel_mercenary_end";
const string MERC_END_OVERT_REBEL				= "overt_rebel_mercenary_end";
const string MERC_BEGIN_COVERT_IMPERIAL				= "covert_imperial_mercenary_begin";
const string MERC_BEGIN_OVERT_IMPERIAL				= "overt_imperial_mercenary_begin";
const string MERC_BEGIN_COVERT_REBEL				= "covert_rebel_mercenary_begin";
const string MERC_BEGIN_OVERT_REBEL				= "overt_rebel_mercenary_begin";

const string_id SID_MERC_IMPERIAL_SF_BEGIN			= new string_id("gcw", "merc_imperial_special_forces_begin");
const string_id SID_MERC_IMPERIAL_SF_END			= new string_id("gcw", "merc_imperial_special_forces_end");
const string_id SID_MERC_IMPERIAL_COMBATANT_BEGIN		= new string_id("gcw", "merc_imperial_combatant_begin");
const string_id SID_MERC_IMPERIAL_COMBATANT_END			= new string_id("gcw", "merc_imperial_combatant_end");
const string_id SID_MERC_REBEL_SF_BEGIN				= new string_id("gcw", "merc_rebel_special_forces_begin");
const string_id SID_MERC_REBEL_SF_END				= new string_id("gcw", "merc_rebel_special_forces_end");
const string_id SID_MERC_REBEL_COMBATANT_BEGIN			= new string_id("gcw", "merc_rebel_combatant_begin");
const string_id SID_MERC_REBEL_COMBATANT_END			= new string_id("gcw", "merc_rebel_combatant_end");

const string_id SID_MERC_IMPERIAL_SF_GRANTED			= new string_id("gcw", "merc_imperial_sf_status_granted");
const string_id SID_MERC_IMPERIAL_SF_TERMINATED			= new string_id("gcw", "merc_imperial_sf_status_terminated");
const string_id SID_MERC_IMPERIAL_COMBATANT_GRANTED		= new string_id("gcw", "merc_imperial_combatant_status_granted");
const string_id SID_MERC_IMPERIAL_COMBATANT_TERMINATED		= new string_id("gcw", "merc_imperial_combatant_status_terminated");
const string_id SID_MERC_REBEL_SF_GRANTED			= new string_id("gcw", "merc_rebel_sf_status_granted");
const string_id SID_MERC_REBEL_SF_TERMINATED			= new string_id("gcw", "merc_rebel_sf_status_terminated");
const string_id SID_MERC_REBEL_COMBATANT_GRANTED		= new string_id("gcw", "merc_rebel_combatant_status_granted");
const string_id SID_MERC_REBEL_COMBATANT_TERMINATED		= new string_id("gcw", "merc_rebel_combatant_status_terminated");

/* -----------------8/1/2002 1:18PM------------------
 * FACTION SYSTEM VARIABLES
 *
 * For NPCs:
 * 		faction - 		string ObjVar containing the name of
 * 						the faction to which this NPC belongs.
 *
 * For Players:
 * 		faction.		ObjVar List of the player's factions.
 * 			[Name]		Float value of the player's faction rating
 * 						within the faction called [Name]
 *
 * e.g.
 *
 * faction.Imperial 	On an NPC, this means the NPC is a member of
 * 						the Imperial faction.
 *
 * e.g.
 *
 * faction.Imperial 750.0		The player has 750.0 rating in Imperial
 * faction.Ewok 	-20.0			The player has -20.0 rating in Ewok.
 *
 * AD HOC FACTIONS:
 * Non-players (only) can be added to factions which do not exist
 * in the datatable.  They will respond neutrally to all other factions,
 * all other factions will respond neutrally to them.  They will
 * always repond Positively toward members of their own faction.
 * --------------------------------------------------*/

void goCovertWithDelay(obj_id objPlayer, float fltDelay)
{
	// make the player covert using a messageto
	if(!canGoCovert(objPlayer))
	{
		return;
	}
	setObjVar(objPlayer, "intChangingFactionStatus", 1);
	pvpPrepareToBeCovert(objPlayer);
	messageTo(objPlayer, "msgGoCovert", null, fltDelay, true);
	return;
}
void goCovert(obj_id objPlayer)
{
	if(!hasObjVar(objPlayer, "intChangingFactionStatus"))
	{
			return;
	}
	removeObjVar(objPlayer, "intChangingFactionStatus");

	if(!canGoCovert(objPlayer))
	{
		return;
	}
	string_id strSpam = new string_id("faction_recruiter", "covert_complete");
	sendSystemMessage(objPlayer, strSpam);

	//need to check for aura buffs that need to be cleared
	buff.removeAllAuraBuffs(objPlayer);

	pvpMakeCovert(objPlayer);
	CustomerServiceLog( "player_faction", "PLAYER-FACTION ALTERED|TIME:"+getGameTime()+"|PLAYER:"+objPlayer+"|PLAYER NAME:"+getName(objPlayer)+"|ZONE:"+getCurrentSceneName()+"|Player has been set to covert");
	return;
}
void goOvertWithDelay(obj_id objPlayer, float fltDelay)
{
	setObjVar(objPlayer, "intChangingFactionStatus", 1);
	pvpPrepareToBeDeclared(objPlayer);
	messageTo(objPlayer, "msgGoOvert", null, fltDelay, true);
	return;
}

void goOvert(obj_id objPlayer)
{
	if(!hasObjVar(objPlayer, "intChangingFactionStatus"))
	{
		return;
	}

	removeObjVar(objPlayer, "intChangingFactionStatus");
	string_id strSpam = new string_id("faction_recruiter", "overt_complete");
	sendSystemMessage(objPlayer, strSpam);

	//need to check for aura buffs that need to be cleared
	buff.removeAllAuraBuffs(objPlayer);
	pvpMakeDeclared(objPlayer);
	CustomerServiceLog( "player_faction", "PLAYER-FACTION ALTERED|TIME:"+getGameTime()+"|PLAYER:"+objPlayer+"|PLAYER NAME:"+getName(objPlayer)+"|ZONE:"+getCurrentSceneName()+"|Player has been set to overt");
	return;
}
void goOnLeaveWithDelay(obj_id objPlayer, float fltDelay)
{


	if(!canGoOnLeave(objPlayer))
	{
		return;

	}
	setObjVar(objPlayer, "intChangingFactionStatus", 1);
	pvpPrepareToBeNeutral(objPlayer);
	messageTo(objPlayer, "msgGoOnLeave", null, fltDelay, true);
		return;
}

void goOnLeave(obj_id objPlayer)
{

	if(!hasObjVar(objPlayer, "intChangingFactionStatus"))
	{
		return;
	}
	removeObjVar(objPlayer, "intChangingFactionStatus");
	if(!canGoOnLeave(objPlayer))
	{
		return;
	}

	string_id strSpam = new string_id("faction_recruiter", "on_leave_complete");
	sendSystemMessage(objPlayer, strSpam);

	//need to check for aura buffs that need to be cleared
	buff.removeAllAuraBuffs(objPlayer);

	pvpMakeOnLeave(objPlayer);
	CustomerServiceLog( "player_faction", "PLAYER-FACTION ALTERED|TIME:"+getGameTime()+"|PLAYER:"+objPlayer+"|PLAYER NAME:"+getName(objPlayer)+"|ZONE:"+getCurrentSceneName()+"|Player has been set to On Leave");
}
void unequipFactionEquipment(obj_id self, boolean checkForDeclaredObjVar)
{
	obj_id[] items = getContents(self);
	if (items == null)
	{
		LOG("LOG_CHANNEL", "player_recruiter::msgGoCovert -- " + self + "'s contents are null.");
		return;
	}

	obj_id inv = getObjectInSlot(self, "inventory");
	for (int i = 0; i < items.length; i++)
	{
		if (hasScript(items[i], factions.SCRIPT_FACTION_ITEM))
		{
			if (!checkForDeclaredObjVar || hasObjVar(items[i], factions.VAR_DECLARED))
			{
				// don't unequip the faction backpack because that may
				// seriously overload the player and he would have to
				// delete a lot of items before he can move again
				string strTemplate = getTemplateName(items[i]);
				if(!strTemplate.endsWith("marine/armor_marine_backpack.iff"))
				putInOverloaded(items[i], inv);
			}
		}
	}

	obj_id appearanceInv = getAppearanceInventory(self);
	if(!isIdValid(appearanceInv))
	{
		LOG("LOG_CHANNEL", "Player " + self + " has no valid appearance inventory. Skipping unequip faction appearance items...");
		return;
	}
	obj_id[] appInvItems = getContents(appearanceInv);
	if(appInvItems == null)
	{
		LOG("LOG_CHANNEL", "Player " + self + " has an appearance inventory, but the contents were null. Skipping appearance inventory faction unequip...");
		return;
	}
	for (int i = 0; i < appInvItems.length; i++)
	{
		if (hasScript(appInvItems[i], factions.SCRIPT_FACTION_ITEM))
		{
			if (!checkForDeclaredObjVar || hasObjVar(appInvItems[i], factions.VAR_DECLARED))
			{
				putInOverloaded(appInvItems[i], inv);
			}
		}
	}
	return;
}

boolean isDeclared( obj_id target )
{
	if ( pvpGetType( target ) == PVPTYPE_DECLARED )
	{
		int myFactionHash = pvpGetAlignedFaction( target );
		if ( myFactionHash == ##"nonaggressive" || myFactionHash == ##"nonaggressive" )
			return false;
		else
			return true;
	}
	return false;
}

/* -----------------8/16/2002 4:45PM-----------------
 * Declared players are always considered to be Covert,
 * so far as AI is concerned.
 *
 * Note that the reverse is Not true.
 * --------------------------------------------------*/
boolean isCovert( obj_id target )
{
	int pvpType = pvpGetType( target );
	if ( pvpType == PVPTYPE_COVERT || pvpType == PVPTYPE_DECLARED )
		return true;

	return false;
}

/**
 * On NPCs:
 * If the NPC is declared, returns the string name of the faction.
 * Otherwise:
 * Returns the string name of the faction to which the NPC belongs.
 *
 * On Players:
 * Returns the faction to which the player is Declared.
 *
 * Returns NULL if the Npc has no faction or if the player is not
 * Declared.
 *
 * Covert Players look neutral.
  */
string getFaction( obj_id target )
{
	if ( isPlayer(target) )
	{
			if ( pvpGetType(target)==PVPTYPE_NEUTRAL )
				return null;
			return getFactionNameByHashCode( pvpGetAlignedFaction( target ) );
	}
	else
	{
		return getStringObjVar( target, FACTION );
	}
}

int getFactionFlag(obj_id target)
{
	if(isRebel(target))
	{
		return FACTION_FLAG_REBEL;
	}
	else if(isImperial(target))
	{
		return FACTION_FLAG_IMPERIAL;
	}
	else
	{
		return FACTION_FLAG_NEUTRAL;
	}
}

boolean isRebelHelper(obj_id target)
{
	if(!isIdValid(target) || !exists(target))
	{
		return false;
	}
	
	int currentMercenaryFaction = pvpNeutralGetMercenaryFaction(target);

	if(0 == currentMercenaryFaction)
		return false;

	if(##"rebel" == currentMercenaryFaction)
	{
		return true;
	}
	
	return false;
}

boolean isImperialHelper(obj_id target)
{
	if(!isIdValid(target) || !exists(target))
	{
		return false;
	}

	int currentMercenaryFaction = pvpNeutralGetMercenaryFaction(target);

	if(0 == currentMercenaryFaction)
	{
		return false;
	}

	if(##"imperial" == currentMercenaryFaction)
	{
		return true;
	}
	
	return false;
}

boolean isRebelorRebelHelper(obj_id target)
{
	if(!isIdValid(target) || !exists(target))
	{
		return false;
	}

	if(isRebelHelper(target) || getFactionFlag(target) == FACTION_FLAG_REBEL)
	{
		return true;
	}
	
	return false;
}

boolean isImperialorImperialHelper(obj_id target)
{
	if(!isIdValid(target) || !exists(target))
	{
		return false;
	}

	if(isImperialHelper(target) || getFactionFlag(target) == FACTION_FLAG_IMPERIAL)
	{
		return true;
	}
	
	return false;
}

boolean isSameFactionorFactionHelper(obj_id target, obj_id target2)
{
	if(!isIdValid(target) || !exists(target) || !isIdValid(target2) || !exists(target2))
	{
		return false;
	}
	
	if((isImperialorImperialHelper(target) && isImperialorImperialHelper(target2)) || (isRebelorRebelHelper(target) && isRebelorRebelHelper(target2)))
	{
		return true;
	}
		
	return false;
}

/**
 * For NPC's:
 * returns 1.0 if the npc is a member of this faction.
 * returns 0.0 is the npc is not a member of this faction.
 *
 * For Players:
 * returns the player's factionValue in this faction.
 */

float getFactionStanding( obj_id target, int intFaction)
{
	return getFactionStanding(target, getFactionNameByHashCode(intFaction));
}
float getFactionStanding( obj_id target, string factionName )
{
	if ( !exists(target) )
		return 0.0f;

	if ( !isPlayer( target ) )
	{
		if ( getFaction( target) == factionName )
			return FACTION_RATING_MAX;
		else
			return 0.0f;
	}

	if ( !hasObjVar( target, FACTION + "." + factionName ))
		return 0.0f;
	else
		return getFloatObjVar( target, FACTION + "." + factionName );

}

float getFactionMax( obj_id target, int intFactionId)
{
	return getFactionMax(target, getFactionNameByHashCode(intFactionId));
}

float getFactionMax( obj_id target, string factionName )
{
	return FACTION_RATING_MAX;
}

void validateFactionStanding(obj_id player, string factionName)
{
	float currentStanding = getFactionStanding(player, factionName);
	float maxStanding = getFactionMax(player, factionName);
	if ( currentStanding > maxStanding )
	{
		setFactionStanding(player, factionName, maxStanding);
		prose_package ppFactionLower = prose.getPackage(SID_FACTION_ADJUSTED_LOWER);
		prose.setTO(ppFactionLower, new string_id("faction/faction_names", factionName));
		prose.setDI(ppFactionLower, (int)maxStanding);
		sendSystemMessageProse(player, ppFactionLower);
	}
}

string getRankName(int rank, string faction)
{
	return utils.packStringId(getRankNameStringId(rank, faction));
}

string_id getRankNameStringId(int rank, string faction)
{
	string rankName = constructRankName(rank, faction);
	if ( rankName != null && rankName.length() > 0 )
		return new string_id("gcw_rank",rankName);

	CustomerServiceLog("faction", "WARNING: factions.getRankNameStringId() called with rank " + rank +
		" that has no rank name associated with it");
	return SID_NO_RANK_NAME;
}

string constructRankName(int rank, string faction)
{
	return toLower(faction)+"_rank"+rank;
}

int getRankCost(int rank)
{
	return dataTableGetInt(TBL_RANK, rank, COL_COST);
}

int getAvailableFactionPoints(obj_id target, string factionName)
{
	if ( isIdValid(target) && isPlayer(target) && factionName != null && !factionName.equals("") )
	{
		int standing = (int)getFactionStanding(target, factionName);
		if ( standing > 0 )
		{
			int available = standing - (int)FACTION_RATING_DECLARABLE_MIN;
			if ( available > 0 )
				return available;
		}
	}

	return 0;
}

int getAvailableFactionPoints(obj_id target, int faction)
{
	if ( isIdValid(target) && isPlayer(target) )
	{
		string factionName = getFactionNameByHashCode(faction);
		return getAvailableFactionPoints(target, factionName);
	}

	return 0;
}

void delegateFactionPoints(obj_id self, obj_id target, string params)
{
	if ( !isIdValid(target) )
	{
		sendSystemMessage(self, SID_FACTION_INVALID_LOOKAT);
		return;
	}

	if ( target == self )
	{
		sendSystemMessage(self, SID_FACTION_CANT_GIVE_YOURSELF);
		return;
	}

	if ( !isPlayer(target) )
	{
		sendSystemMessage(self, SID_FACTION_ONLY_OTHER_PLAYERS);
		return;
	}

	if ( !isDeclared(self) )
	{
		sendSystemMessage(self, new string_id("base_player", "must_be_declared"));
		return;
	}

	int fac = pvpGetAlignedFaction(self);
	string sFac = getFaction(self);

	int available = getAvailableFactionPoints(self, fac);
	if ( available <= 0 )
	{
		sendSystemMessage(self, SID_FACTION_NONE_TO_GIVE);
		return;
	}

	if ( utils.hasScriptVar(self, "delegate.pid") )
	{
		int oldpid = utils.getIntScriptVar(self, "delegate.pid");
		sui.closeSUI(self, oldpid);
		utils.removeScriptVarTree(self, "delegate");
	}

	int rank = pvpGetCurrentGcwRank(self);
	string faction = getFaction(self);

	int ratioFrom = dataTableGetInt(TBL_RANK, rank, "DELEGATE_RATIO_FROM");
	int ratioTo = dataTableGetInt(TBL_RANK, rank, "DELEGATE_RATIO_TO");
	if ( ratioFrom <= 0 || ratioTo <= 0 )
		return;

	float multiplier = (float)ratioTo/(float)ratioFrom;

	if ( params == null || params.equals("") )
	{
		//do sui here
		string title = utils.packStringId(SID_SUI_DELEGATE_FACTION);
		prose_package ppSuiTitle = prose.getPackage(SID_SUI_DELEGATE_FACTION_TEXT);
		prose.setTT(ppSuiTitle, getRankNameStringId(rank, faction));
		prose.setTO(ppSuiTitle, "" + ratioFrom + ":" + ratioTo);
		prose.setDI(ppSuiTitle, available);
		string prompt = " \0" + packOutOfBandProsePackage(null, ppSuiTitle);

		int pid = sui.transfer(self, self, prompt, title, utils.packStringId(SID_SUI_DELEGATE_FACTION_TITLE), Math.round(available), utils.packStringId(SID_SUI_DELEGATE_FACTION_CAT), 0, "handleDelegateSui", ratioFrom, ratioTo);
		if ( pid > -1 )
		{
			utils.setScriptVar(self, "delegate.pid", pid);
			utils.setScriptVar(self, "delegate.target", target);
		}

		return;
	}
	else
	{
		java.util.StringTokenizer st = new java.util.StringTokenizer(params);
		string sAmt = st.nextToken();
		int amt = utils.stringToInt(sAmt);
		if ( amt > 0 )
		{
			int required = (int)Math.ceil(amt/multiplier);
			if ( required > available )
			{
				prose_package ppLackPointsToGive = prose.getPackage(SID_FACTION_LACK_POINTS_TO_GIVE);
				prose.setTT(ppLackPointsToGive, target);
				prose.setTO(ppLackPointsToGive, "" + amt);
				prose.setDI(ppLackPointsToGive, required);
				sendSystemMessageProse(self, ppLackPointsToGive);
			}
			else
			{
				int targetMax = (int)getFactionMax(target, sFac);
				int targetCur = (int)getFactionStanding(target, sFac);
				int targetDelta = targetMax - targetCur;
				if ( targetDelta == 0 )
				{
					prose_package ppAtCap = prose.getPackage(SID_FACTION_TARGET_AT_CAP);
					prose.setTT(ppAtCap, target);
					sendSystemMessageProse(self, ppAtCap);
					return;
				}

				if ( amt > targetDelta )
				{
					prose_package ppOnlyDelegate = prose.getPackage(SID_FACTION_ONLY_DELEGATE_N_POINTS);
					prose.setTT(ppOnlyDelegate, target);
					prose.setDI(ppOnlyDelegate, targetDelta);
					sendSystemMessageProse(self, ppOnlyDelegate);
					return;
				}

				if ( addUnmodifiedFactionStanding(self, sFac, -required) )
				{
					addUnmodifiedFactionStanding(target, sFac, amt);
					prose_package ppDelegate = prose.getPackage(SID_FACTION_DELEGATE_X_TO_TARGET);
					prose.setTT(ppDelegate, target);
					prose.setDI(ppDelegate, amt);
					prose.setTO(ppDelegate, "" + required);
					sendSystemMessageProse(self, ppDelegate);
					CustomerServiceLog("faction_perk", getFirstName(self) + "(" + self + ") delegated " + amt + " points to " + getFirstName(target) + " for a cost of " + required + " points.");
				}
			}

			return;
		}
	}

	sendSystemMessage(self, SID_FACTION_DELEGATE_SYNTAX);
}

void resignFromFaction(obj_id player, int intFaction)
{
	resignFromFaction(player, getFactionNameByHashCode(intFaction));
}
void resignFromFaction(obj_id player, string resign_faction)
{
	if (isInAdhocPvpArea(player))
		return;

	if(isOnLeave(player))
	{
		string_id strSpam = new string_id("faction_recruiter", "resign_on_leave");
		sendSystemMessage(player, strSpam);
		removeObjVar(player, "intChangingFactionStatus");
		return;
	}

	if(!hasObjVar(player, "intChangingFactionStatus"))
	{
		return;
	}

	removeObjVar(player, "intChangingFactionStatus");
	if ( !isIdValid(player) || !isPlayer(player) || resign_faction == null || resign_faction.equals("") )
		return;

	//need to check for aura buffs that need to be cleared
	buff.removeAllAuraBuffs(player);

	//set pilots back to their old faction (they'll still be pvptype neutral)
	if ( space_flags.isRebelPilot(player) )
		space_skill.retire(player, space_skill.REBEL);
	else if ( space_flags.isImperialPilot(player) )
		space_skill.retire(player, space_skill.IMPERIAL);

	CustomerServiceLog("player_faction", "|PLAYER:"+player+" |PLAYER NAME:"+getName(player)+" |PLAYER LEFT FACTION: "+resign_faction+" |OLD RANK WAS: "+pvpGetCurrentGcwRank(player));

	pvpMakeNeutral(player);
	pvpSetAlignedFaction(player, 0);
	//sendSystemMessageTestingOnly(player, "Resigned from faction " + resign_faction);
	string factionNormalized = toLower(resign_faction);
	if(factionNormalized.equals("imperial") || factionNormalized.equals("rebel"))
	{
		setObjVar(player, "lastFactionResignedFrom", resign_faction);
		setObjVar(player, "lastFactionResignedTime", getGameTime());
	}

	float factionStanding = getFactionStanding(player, resign_faction);

	//debugSpeakMsg(player, "resign_faction is " + resign_faction + " factionStanding is " + factionStanding);
	//The penalty for dersertion is -2500 faction standing
	if(factionStanding > -2500)
		setFactionStanding(player, resign_faction, -2500);

	// remove any equipped faction items
	unequipFactionEquipment(player, false);

	// Release faction hirelings.
	releaseFactionHirelings(player);

	prose_package pp = prose.getPackage(SID_RESIGN_COMPLETE, resign_faction);
	sendSystemMessageProse(player, pp);
}

void resignFromFaction(obj_id player)
{
	resignFromFaction(player, getFaction(player));
}

/**
 * For NPCs:
 * 		Does nothing.  NPCs dont gain faction.
 *
 * For players:
 *   	If the player is allowed to gain in this faction, the value is
 * 		added to his current faction rating
 */

boolean addFactionStanding( obj_id target, int intFaction, float value )
{
	return addFactionStanding(target, getFactionNameByHashCode(intFaction), value);

}
boolean addFactionStanding( obj_id target, string factionName, float value )
{
	if ( !isIdValid(target) )
		return false;
/** This ludicrous antiquated mod is effecting faction perk sales too, removing due to kinder gentler world
	int species = getSpecies(target);
	switch ( species )
	{
		case SPECIES_BOTHAN:
			if ( value < 0f )
			{
				value *= BOTHAN_NEGATIVE_MOD;
			}
			break;
	}
*********************************** Rejoice ye Bothans ****************************************************/

	return addUnmodifiedFactionStanding(target, factionName, value) && grantFactionBonus(target, factionName, value);
}

boolean addUnmodifiedFactionStanding(obj_id target, string factionName, float value, boolean verbose)
{
	if ( !isIdValid(target) || factionName == null || factionName.equals("") || value == 0.0f )
		return false;

	if ( !isPlayer( target ) )
	{
		setFaction( target, factionName );
		return false;
	}

	int factionNum = getFactionNumber(factionName);
	if ( factionNum == AD_HOC_FACTION )
		return false;//cannot add Faction Standing to an ad hoc faction.

	int playerAllowed = dataTableGetInt(FACTION_TABLE, factionNum, "playerAllowed");
	if ( playerAllowed != 1 )
		return false;

	if(utils.hasScriptVar(target, "buff.general_inspiration.value"))
	{
		float factionBonus = utils.getFloatScriptVar(target, "buff.general_inspiration.value");
		factionBonus /= 100.0f;
		factionBonus += 1.0f;

		value *= factionBonus;
	}

	/*
	// Inspiration faction bonus code HG 3/30/5
	if (buff.hasBuff(target, performance.BUFF_PERFORM_INSPIRATION))
	{
		if (value > 0)
		{
			value *= (performance.INSPIRATION_BONUS + 1.0f);
		}
	}

	// End Inspiration faction bonus code
	*/


	float oldRating = getFactionStanding( target, factionName );
	float newRating = oldRating + value;

	float factionMax = getFactionMax( target, factionName );
	if ( newRating < FACTION_RATING_MIN )
		newRating = FACTION_RATING_MIN;
	else if ( newRating >= factionMax )
		newRating = factionMax;

	float actual_value = value;
	if ( oldRating + value > newRating )
		actual_value = newRating-oldRating;

	if ( newRating == oldRating )
	{
		return false;
	}

	if ( newRating != 0.0f )
	{
		setObjVar(target, FACTION + "." + factionName, newRating );
		if ( verbose )
		{
			if ( (int)value > 0 )
			{
				prose_package pp = prose.getPackage(PROSE_AWARD_FACTION, getLocalizedFactionName( factionName ), (int)actual_value);
				sendSystemMessageProse(target, pp);
			}
			else
			{
				actual_value = actual_value * -1;//get the absolute value without including java.Lang.Math
				prose_package pp = prose.getPackage( PROSE_LOSE_FACTION, getLocalizedFactionName( factionName ), (int)actual_value );
				sendSystemMessageProse( target, pp );
			}
		}
	}
	else
	{
		removeObjVar(target, FACTION + "." + factionName );
	}

	if ( verbose && oldRating != newRating )
	{
		if ( newRating == factionMax )
		{
			prose_package pp = prose.getPackage(PROSE_MAX_FACTION, getLocalizedFactionName( factionName ));
			sendSystemMessageProse(target, pp);
		}
		else if ( newRating == FACTION_RATING_MIN )
		{
			prose_package pp = prose.getPackage(PROSE_MIN_FACTION, getLocalizedFactionName( factionName ));
			sendSystemMessageProse(target, pp);
		}
	}

	return true;
}

boolean addUnmodifiedFactionStanding(obj_id target, string factionName, float value)
{
	return addUnmodifiedFactionStanding(target, factionName, value, true);
}

boolean grantFactionBonus(obj_id target, string factionName, float value)
{
	if ( !isIdValid(target) || factionName == null || factionName.equals("") || value == 0.0f )
		return false;

	/* Removing COA Bonus JBenjamin 1/10/06
	//////////////////////////////////////////////
	// TEMPORARY STORY REWARD!!
	// CoA - Act 1 faction reward perk
	int bonus = Math.round(getFactionStoryReward(target, factionName, value));
	////////////////////////////////////////////

	//////////////////////////////////////////////
	// TEMPORARY STORY REWARD!!
	// CoA - Act 1 faction reward message
	if (bonus > 0 && addUnmodifiedFactionStanding(target, factionName, bonus, false))
	{
		prose_package pp = prose.getPackage(new string_id("base_player", "prose_coa_bonus"), getLocalizedFactionName( factionName ), bonus);
		sendSystemMessageProse(target, pp);
	}
	////////////////////////////////////////////
	*/
	return true;
}

float getFactionStoryReward(obj_id target, string factionName, float value)
{
	float bonus = 0;
	int myFac = pvpGetAlignedFaction(target);

	// Give 10% bonus to Rebel players for positive Rebel faction hits.
	if (value > 0 && myFac == ##"rebel" && getFactionNameByHashCode(myFac).equals(factionName) )
	{
		if ( pvpGetType( target ) != PVPTYPE_NEUTRAL )
			bonus = (value * 0.10f);
	}

	return bonus;
}

/**
 * For NPCs:
 * 		Sets the NPCs faction to factionName.  Ignores value.
 *
 * For Players:
 * 		If players are allowed to acquire this faction:
 * 		Sets the player's faction rating to Value
 */
void setFactionStanding( obj_id target, string factionName, float value )
{
	if ( factionName == null || factionName == "" )
		return;

	if ( !isPlayer( target ) )
	{
		setFaction( target, factionName );
		return;
	}

	int factionNum = getFactionNumber(factionName);
	if ( factionNum == AD_HOC_FACTION || factionNum < 0 )
		return;//players cannot acquire ad hoc factions

	int playerAllowed = dataTableGetInt(FACTION_TABLE, factionNum, "playerAllowed");
	if ( playerAllowed != 1 )
		return;

	float factionMax = getFactionMax( target, factionName );
	if ( value < FACTION_RATING_MIN )
		value = FACTION_RATING_MIN;
	else if ( value >= factionMax )
		value = factionMax;

	if ( value != 0.0f )
	{
		if ( (utils.getPlayerProfession(target) == utils.SMUGGLER) && (factionName == "underworld") )
		{
			smuggler.checkSmugglerTitleGrants(target, value);
			smuggler.checkRewardQuestGrants(target, value);

			messageTo(target, "applySmugglingBonuses", null, 1.0f, false);
		}

		if( (utils.getPlayerProfession(target) == utils.BOUNTY_HUNTER) && (factionName == "underworld") )
		{
			smuggler.checkBountyTitleGrants(target, value);
		}

		setObjVar(target, FACTION + "." + factionName, value );
	}
	else
	{
		removeObjVar(target, FACTION + "." + factionName );
		messageTo(target, "removeSmugglingBonuses", null, 1.0f, false);
	}

	armor.recalculateArmorForPlayer(target);
	obj_id tempWeapon = getObjectInSlot(target, "hold_r");

	if(isIdValid(tempWeapon))
	{
		weapons.adjustWeaponRangeForExpertise(target, tempWeapon, true);
	}


}

/**
 * For Players:
 * 		Does nothing.  Use setFaction( target, faction, value), above.
 *
 * For NPCs:
 * 		Sets the NPCs faction to factionName.
 */
void setFaction( obj_id target, string factionName )
{
	if ( factionName == null || factionName == "" )
		return;

	setFaction( target, factionName, true );
}

void setFaction(obj_id target, string factionName, int pvpOnly)
{
	setFaction(target, factionName, true, pvpOnly);
}

void setFaction( obj_id target, string factionName, boolean isAggro)
{
	setFaction(target, factionName, isAggro, 0);
}

void setFaction( obj_id target, string factionName, boolean isAggro, int pvpOnly )
{
	if ( factionName == null || factionName == "" )
		return;

	if ( isPlayer( target ) )
		return;

	// Check for; will only attack and be attacked by SF players.
	boolean pvp_only = pvpOnly == 1 ? true : false;

	//set attribs and interest for trigger volume breaches:
	if ( factionName.equals( FACTION_IMPERIAL ))
	{
		setAttributeAttained( target, attrib.IMPERIAL );
		setAttributeInterested( target, attrib.REBEL );
		ai_lib.setDefaultCalmMood( target, "npc_imperial");
		if (pvp_only)
			setObjVar(target, "huysMagicSpecialForcesOnlyObjvar", true);
	}
	else if ( factionName.equals( FACTION_REBEL ))
	{
		setAttributeAttained( target, attrib.REBEL );
		setAttributeInterested( target, attrib.IMPERIAL );
		if (pvp_only)
			setObjVar(target, "huysMagicSpecialForcesOnlyObjvar", true);
	}


	setObjVar( target, FACTION, factionName );
	pvpMakeNeutral(target);//removes old FEF's, if any.
	removeObjVar( target, "ai.faction.nonAggro" );

	int factionNum = getFactionNumber(factionName);
	if ( factionNum == AD_HOC_FACTION )
	{
		if ( !isAggro )
		{
		LOG("gcw", "1");
			pvpSetAlignedFaction(target, ##"nonaggressive");
    		pvpMakeDeclared(target);
			setObjVar( target, "ai.faction.nonAggro", true );
		}
		LOG("gcw", "2");
		return;//ad hoc faction
	}
	LOG("gcw", "10");

	int factionHashCode = dataTableGetInt(FACTION_TABLE, factionNum, "pvpFaction");
	if ( factionHashCode == 0 )
		return;
	LOG("gcw", "setting aligned faction to "+factionHashCode);
	LOG("gcw", "making "+target+" covert");
	pvpSetAlignedFaction(target, factionHashCode);
	pvpMakeDeclared(target);
}

/**
 *
 * return True if the player or NPC is not Declared.
 * (Covert players will appear to be Neutral to AI)
 *
 */
boolean isNeutral( obj_id target )
{

	int intPlayerFaction = pvpGetAlignedFaction(target);
	if(intPlayerFaction==0)
	{
		return true;
	}
	if(pvpGetType(target)==PVPTYPE_NEUTRAL)
	{
		return true;
	}
	return false;
}

string getFactionNameByHashCode( int hashCode )
{
	// Hash code of 0 is now returning the first row with an empty hash column (which is currently Hutt).
	// Therefore, return null since 0 should not return any faction.
	if (hashCode == 0)
		return null;

	int[] columns = dataTableGetIntColumn(FACTION_TABLE, "pvpFaction");
	for ( int i = 0; i < columns.length; i++ )
	{
		if ( hashCode == columns[i] )
			return dataTableGetString(FACTION_TABLE, i, "factionName");
	}
	return null;
}

int getFactionNumber( string factionName )
{
	if ( factionName == null )
		return AD_HOC_FACTION;
	return dataTableSearchColumnForString(factionName, "factionName", FACTION_TABLE);
}

int getFactionStatus(obj_id ai, obj_id target)
{
	int result = STATUS_NEUTRAL;
	const int factionReaction = getFactionReaction(ai, target);

	if (factionReaction < REACTION_NEUTRAL)
	{
		result = STATUS_ENEMY;
	}
	else if (factionReaction > REACTION_NEUTRAL)
	{
		result = STATUS_FRIEND;
	}

	return result;
}

int getFactionReaction( obj_id npc, obj_id target )
{
	PROFILER_START("library.faction.getFactionReaction");

	int result = REACTION_NEUTRAL;

	string npcFaction = getFaction(npc);
	if (npcFaction != null)
	{
		//player's faction reactions are based on their faction standing:
		if (isPlayer(target))
		{
			if ( !isNeutral(npc) && (!isNeutral(target)))
			{
				//debugSpeakMsg( npc, "i am declared and so are you" );
				string yourFaction = getDeclaredFaction( target );
				string myFaction = getDeclaredFaction( npc );
				if ( yourFaction==null)
				{
					LOG("DESIGNER_FATAL", "In faction.getFactionReaction, getDeclaredFaction returned null for yourFaction. obj_id,  " +target );
					PROFILER_STOP("library.faction.getFactionReaction");
					return REACTION_NEUTRAL;
				}

				if ( myFaction==null)
				{
					LOG("DESIGNER_FATAL", "In faction.getFactionReaction, getDeclaredFaction returned null for myFaction. obj_id,  " +npc );
					PROFILER_STOP("library.faction.getFactionReaction");
					return REACTION_NEUTRAL;
				}

				if ( yourFaction.equals( myFaction ) )
				{
					PROFILER_STOP("library.faction.getFactionReaction");
					return REACTION_POSITIVE;
				}
				else
				{
					PROFILER_STOP("library.faction.getFactionReaction");
					return REACTION_NEGATIVE;
				}
			}

			int npcFactionNum = getFactionNumber(npcFaction);
			if (npcFactionNum != AD_HOC_FACTION)
			{
				boolean playerAllowed = (dataTableGetInt(FACTION_TABLE, npcFactionNum, "playerAllowed") == 1);
				if (playerAllowed)
				{
					float playerFaction = getFactionStanding(target, npcFaction);
					if (playerFaction > (FACTION_RATING_MAX * .75f))
						result = REACTION_POSITIVE;
					else if (playerFaction > (FACTION_RATING_MAX * .5f))
						result = REACTION_LIKE;
					else if (playerFaction < (FACTION_RATING_MIN * .75f))
						result = REACTION_NEGATIVE;
					else if (playerFaction < (FACTION_RATING_MIN * .5f))
						result = REACTION_DISLIKE;
				}
			}
		}
		else
		{
			string targetFaction = getFaction( target );
			if (targetFaction != null)
			{
				//Two npcs of the same Ad Hoc faction Will defend each other:
				// unless they were spawned as NonAggro:
				int npcFactionNum = getFactionNumber(npcFaction);
				if (npcFactionNum == AD_HOC_FACTION)
				{
					if (npcFaction.equals(targetFaction) && !hasObjVar(npc, "ai.faction.nonAggro"))
						result = REACTION_POSITIVE;
				}
				else
				{
					int targetFactionNum = getFactionNumber(targetFaction);
					if (targetFactionNum == AD_HOC_FACTION )
						result = REACTION_NEUTRAL;
					else
					{
						string enemies = dataTableGetString( FACTION_TABLE, npcFaction, "enemies" );
						if ( enemies == null )
							result = REACTION_NEUTRAL;
						else
						{
							string[] enemiesList = split( enemies, ',' );
							if ( utils.getElementPositionInArray(enemiesList, targetFaction )!=-1)
								result = REACTION_NEGATIVE;
							else
								result = REACTION_NEUTRAL;
						}
					}
				}
			}
		}
	}

	PROFILER_STOP("library.faction.getFactionReaction");
	return result;
}

string getDeclaredFaction( obj_id target )
{
	if (!isDeclared( target) )
		return null;

	if (!isPlayer(target))
		return getStringObjVar( target, FACTION );

	int factionHashCode = pvpGetAlignedFaction(target);
	return getFactionNameByHashCode( factionHashCode );
}

boolean isAggro( obj_id npc )
{
	string factionName = getFaction( npc );
	if ( factionName == null )
		return false;

	int factionNum = getFactionNumber( factionName );
	if ( factionNum == AD_HOC_FACTION )
		return (!hasObjVar( npc, "ai.faction.nonAggro" ));

	return (dataTableGetInt(FACTION_TABLE, factionNum, "isAggro") == 1);
}

void clearFaction( obj_id npc )
{
	if (isPlayer(npc))
		return;

	removeObjVar( npc, FACTION );
	pvpMakeNeutral(npc);//removes old FEF's, if any.
}

/**
 * For NPCs:
 * 		Does nothing.  NPCs dont gain faction.
 *
 * For players:
 *   	If the player is allowed to gain in this faction, the value is
 * 		added to his current faction rating
 */
boolean awardFactionStanding(obj_id player, string factionName, int value)
{
	if ( (player == null) || (!isPlayer(player)) )
		return false;

	if(value > 0)
	{
		if(luck.isLucky(player, 0.01f))
		{
			float bonus = value * 0.2f;
			if(bonus < 1)
				bonus = 1;

			value += bonus;
		}
	}

	if ( addFactionStanding(player, factionName, value) )
		return true;

	//debugSpeakMsg(player, "awardFactionStanding:FAIL - faction = " + factionName);
	return false;
}

// Grant combat faction points to a killer for a target kill.
void grantCombatFaction( obj_id killer, obj_id target, double percentDamage )
{


	// Check params.
	if ( !isIdValid(target) || !isIdValid(killer) || percentDamage < 0.f || percentDamage > 1.f )
		return;

	if ( target == killer )
	{
		return;
	}

	// Killer must be a player.
	if ( !isPlayer( killer ) )
		return;

	// Get factions.
	string killerFaction = getFaction( killer );
	string targetFaction = getFaction( target );

	if ( (killerFaction == null) || (targetFaction == null) )
	{
		return;
	}

	float killerStanding = getFactionStanding( killer, killerFaction );
	float targetStanding = getFactionStanding( target, targetFaction );

	// Make sure they are opposing factions.
	if ( isPlayer( killer) && pvpGetType( killer ) == PVPTYPE_NEUTRAL )
		return;

	if ( isPlayer( target ) && pvpGetType( target ) == PVPTYPE_NEUTRAL )
		return;

	if ( !pvpAreFactionsOpposed(pvpGetAlignedFaction(killer), pvpGetAlignedFaction(target)) )
		return;

	// Get the relative difficulty of each party.
	int killerDiff = getLevel( killer );
	int targetDiff = getLevel( target );

	gcw.incrementGCWStanding(killer, target);
	// Check if a player died.
	if ( isPlayer( target ) )
	{
		// Make sure the target has a positive faction standing.
		if ( targetStanding <= 0 )
			return;

		/*
			/// THIS ENTIRE COMMENT BLOCK IS FUCKING STUPID. DON'T READ THIS OR PAY ATTENTION
			TO THE LOGIC, OR THE TERMINAOLOGY BECAUSE JEDI ARE NOT DIFFERENT ANYMORE.
		// Cap the players difficulty because this whole calc gets wacked when it goes too high.
		// We may want to do something different with Jedi later
		if ( killerDiff > 25 ) killerDiff = 25;

		// On a scale of 0 to 50, 50 being a really hard kill for the killer.
		int diffDelta = (targetDiff - killerDiff) + 25;
		float diffFactor = diffDelta / 50.f;

		//debugSpeakMsg( killer, "diffs " + targetDiff + " " + killerDiff + " " + MAX_FACTION_KILL_REWARD );
		*/

		int kRank = pvpGetCurrentGcwRank(killer);
		int tRank = pvpGetCurrentGcwRank(target);

		float diffFactor = 1f + (tRank - kRank)/(2*MAXIMUM_RANK);

		// Determine faction standing reward.
		int actualReward = (int) (MAX_FACTION_KILL_REWARD * percentDamage * diffFactor);
		int factionLoss = (int) (-1.5f * actualReward);

		// Adjust if a smuggler was involved.
		if ( hasSkill( target, "class_smuggler_phase2_novice" ) )
		{
			actualReward /= 2;
			factionLoss /= 2;
		}

		// Reward this faction to the killer.
		if(pvpGetType(killer)==PVPTYPE_DECLARED)
		{
			actualReward = actualReward * 2;
		}
		awardFactionStanding( killer, killerFaction, actualReward );
		addFactionStanding( killer, targetFaction, factionLoss ); // Lose some opposing faction.

		// Punish the loser.  This is make player/player faction interaction at least a zero sum game.
		addFactionStanding( target, targetFaction, factionLoss );




	}
	else
	{
		// Player killed a faction aligned NPC.
		// Cap target difficulty...consider anything above level 25 a hard kill?
		if ( targetDiff > 25 ) targetDiff = 25;

		// Cap the players difficulty because this whole calc gets wacked when it goes too high.
		// We may want to do something different with Jedi later
		if ( killerDiff > 25 ) killerDiff = 25;

		// On a scale of 0 to 50, 50 being a really hard kill for the killer.
		int diffDelta = (targetDiff - killerDiff) + 25;
		float diffFactor = diffDelta / 50.f;

		// Determine faction standing reward.
		int actualReward = (int) (MAX_FACTION_KILL_REWARD * percentDamage * diffFactor);
		int factionLoss = (int) (-1.5f * actualReward);

		// Reward this faction to the killer.
		awardFactionStanding( killer, killerFaction, actualReward );
		addFactionStanding( killer, targetFaction, factionLoss ); // Lose some opposing faction.

	}


}

//when a player kills an npc / creature, he gains faction standing with
// that creature's factional enemies, and loses faction with the npc:
void adjustSocialStanding( obj_id target, string faction, int amount )
{
	if ( !isPlayer( target ) )
		return;

	if ( faction == null || faction == "" )
		return;

	if ( !isIdValid(target) )
		return;

	if ( amount == 0 )
		return;

	//these are special-case factions, handled above:
	if ( faction.equals(FACTION_IMPERIAL) || faction.equals(FACTION_REBEL) )
		return;

	// Get combat factor
	int factionNum = getFactionNumber(faction);
	float combatFactor = 1.0f;
	if ( factionNum != AD_HOC_FACTION )
		combatFactor = dataTableGetFloat(FACTION_TABLE, factionNum, "combatFactor");
	amount *= combatFactor;

	//addFaction does all the validation for us, and returns false if anything went wrong:
	// Note that amount is probably negative, so this is Reducing faction standing:

	//first, add to self:

	//since this amount is negative, this is lowering faction standing with the
	// thing you just killed:

	//debugSpeakMsg( target, "subtracting " + amount + " for " + faction );

	addFactionStanding( target, faction, amount );

	//get the allies list and lower faction for each ally:
	string allies = dataTableGetString( FACTION_TABLE, faction, "allies" );
	if ( allies != null )
	{
		string[] alliesList = split( allies, ',' );
		for ( int i = 0; i < alliesList.length; i++ )
		{
			//since amount was negative, this is lowering faction standing:

			//debugSpeakMsg( target, "subtracting " + amount + " for " + alliesList[i] );
			if (!alliesList[i].equals(FACTION_IMPERIAL) && !alliesList[i].equals(FACTION_REBEL) )
				addFactionStanding( target, alliesList[i], amount );
		}
	}

	//halve the amount for everything else:
	amount = amount/2;
	if ( amount >= -1 && amount <= 1 )
		return;//no sense messing with this if the amount is between 1 and -1

	//get the enemies list and raise faction for each enemy:
	string enemies = dataTableGetString( FACTION_TABLE, faction, "enemies" );
	if ( enemies == null )
		return;
	string[] enemiesList = split( enemies, ',' );
	for ( int i = 0; i < enemiesList.length; i++ )
	{
		//since amount was negative, this is Adding faction standing:
		// but only half as much as you gained:

		//debugSpeakMsg( target, "adding " + amount + " for " + enemiesList[i] );
		if (!enemiesList[i].equals(FACTION_IMPERIAL) && !enemiesList[i].equals(FACTION_REBEL) )
			addFactionStanding( target, enemiesList[i], -amount );
	}
}

string_id getLocalizedFactionName( string factionName )
{
	return ( new string_id( "faction/faction_names", toLower(factionName) ) );
}

boolean setTemporaryEnemyFlag(obj_id player, obj_id target)
{
	if ( !isIdValid(player) || !isIdValid(target) )
	{
		return false;
	}

	string sTargetFaction = getFactionNameByHashCode(pvpGetAlignedFaction(target));
	if ( (sTargetFaction == null) || (sTargetFaction.equals("")) )
	{
		return false;
	}

	if ( !pvpIsEnemy(target, player) )
	{
		if(pvpCanAttack(target, player))
		{
			pvpAttackPerformed(player, target);

			string_id sidFaction = getLocalizedFactionName(sTargetFaction);
			prose_package ppTEF = prose.getPackage(PROSE_TEF, sidFaction);
			sendSystemMessageProse(player, ppTEF);
		}
	}

	return true;
}

boolean areFactionsOpposed(string faction1, string faction2)
{
	int facNum1 = getFactionNumber(faction1);
	int facNum2 = getFactionNumber(faction2);
	if ( facNum1 == AD_HOC_FACTION || facNum2 == AD_HOC_FACTION )
		return false;

	int hc1 = dataTableGetInt(FACTION_TABLE, facNum1, "pvpFaction");
	int hc2 = dataTableGetInt(FACTION_TABLE, facNum2, "pvpFaction");
	if ( hc1 == 0 || hc2 == 0 )
		return false;

	return pvpAreFactionsOpposed(hc1, hc2);
}

obj_id getFactionParentObject()
{
	obj_id objParent = getPlanetByName("tatooine");
	return objParent;
}


void changeFactionPoints(string strFaction, int intPoints)
{
	obj_id objParent = getFactionParentObject();
	int intOldPoints= getIntObjVar(objParent, "gcw."+strFaction);
	intPoints = intPoints + intOldPoints;
	setObjVar(objParent, "gcw."+strFaction, intPoints);
}

int getFactionPointStanding(string strFaction)
{
	obj_id objParent = getFactionParentObject();
	int intPoints = getIntObjVar(objParent, strFaction);
	return intPoints;
}



void shiftPointsTo(string strFaction, int intPoints) // moves from 1 to the other
{
	string strRebel = FACTION_REBEL;
	string strImperial = FACTION_IMPERIAL;
	if(strFaction==strRebel)
	{
		changeFactionPoints(factions.FACTION_REBEL, intPoints);
		changeFactionPoints(factions.FACTION_IMPERIAL, intPoints*-1);


	}
	if(strFaction==strImperial)
	{
		changeFactionPoints(factions.FACTION_REBEL, intPoints);
		changeFactionPoints(factions.FACTION_IMPERIAL, intPoints*-1);
	}
	return;

}


boolean isFactionWinning(string strFaction)
{
	obj_id objParent = getFactionParentObject();

	string strRebel = FACTION_REBEL;
	string strImperial = FACTION_IMPERIAL;
	int intRebel = getIntObjVar(objParent, "gcw."+strRebel);
	int intImperial = getIntObjVar(objParent, "gcw."+strImperial);
	if(strFaction ==strRebel)
	{
		if(intRebel>intImperial)
		{
			return true;

		}
		return false;

	}
	if(strFaction==strImperial)
	{
		if(intImperial>intRebel)
		{
			return true;

		}
		return false;

	}
	return false;

}

boolean setRank(obj_id player, int rank)
{
	return false;
}

boolean releaseFactionHirelings(obj_id player)
{
	if(!isIdValid(player))
	{
		return false;
	}

	obj_id hireling = callable.getCallable(player, callable.CALLABLE_TYPE_COMBAT_OTHER); // Always use OTHER for a temporary pet

	if(hasObjVar(hireling, VAR_FACTION_HIRELING))
	{
		pet_lib.releasePet(hireling);

		prose_package pp = prose.getPackage(SID_HIRELING_RELEASED, player, hireling);
		sendSystemMessageProse(player, pp);

		return true;
	}
	else
	{
		return false;
	}
}

boolean isNewlyDeclared(obj_id player)
{
	if (!isIdValid(player))
		return false;

	if (utils.hasScriptVar(player, VAR_NEWLY_DECLARED))
		return true;
	else
		return false;
}

/**
 * Tests if a player can use a factional item or not.
 *
 * @param player		the player to test
 * @param item			the item the player wants to use
 * @param overt			flag that the player must be overt
 */
boolean canUseFactionItem(obj_id player, obj_id item)
{
	if ( !isIdValid(player) || !isIdValid(item) )
	{
		CustomerServiceLog("Faction", "WARNING: factions.canUseFactionItem called with invalid player (%TU) or item (" + item + ")", player);
		return false;
	}

	string faction;
	if (hasObjVar(item, VAR_FACTION))
		faction = getStringObjVar(item, VAR_FACTION);
	else
	{
		CustomerServiceLog("Faction", "WARNING: factions::canUseFactionItem -- " + item + " is a faction item with no faction objvar.");
		return false;
	}

	// Check to see if the player belongs to a faction.
	int player_faction_id = pvpGetAlignedFaction(player);
	if ( player_faction_id == 0 || pvpGetType(player) == PVPTYPE_NEUTRAL )
	{
		prose_package pp = prose.getPackage(SID_MUST_BE_FACTION_MEMBER, faction);
		sendSystemMessageProse(player, pp);
		return false;
	}

	// Check to see if the player is of the faction of the item.
	string player_faction = factions.getFactionNameByHashCode(player_faction_id);
	if (player_faction == null)
		return false;
	if (!player_faction.equals(faction))
	{
		prose_package pp = prose.getPackage(SID_MUST_BE_FACTION_MEMBER, faction);
		sendSystemMessageProse(player, pp);
		return false;
	}
	return true;
}

/**
Awards Kashyyyk (wookiee resistance) standing to the player and removes a like ammount of Hsskor (Trandoshan) faction.
obj_id player		The player to recieve the faction
int ammount		The ammount of faction to grant

return void
**/
void awardKashyyykFaction(obj_id player, int ammount)
{
	if (!isPlayer(player))
		return;

	//Can't adjust by 0
	if (ammount == 0)
		return;

	validateBalance(player, KASHYYYK);

	float hsskorAmmount = getFactionStanding(player, HSSKOR);
	float kashyyykAmmount = getFactionStanding(player, KASHYYYK);

	//You cannot gain opposing faction, you must betray your current faction to be reset
	if (kashyyykAmmount < 0)
		return;

	//You lose an equal ammount of the opposing faction
	float gain = kashyyykAmmount + (float)ammount;
	float lose = hsskorAmmount - (float)ammount;

	setObjVar(player, FACTION + "." + KASHYYYK, gain );
	setObjVar(player, FACTION + "." + HSSKOR, lose);

	prose_package pp = prose.getPackage(PROSE_AWARD_FACTION, getLocalizedFactionName( KASHYYYK ), (int)ammount);
	sendSystemMessageProse(player, pp);

	ammount *= -1;
	pp = prose.getPackage( PROSE_LOSE_FACTION, getLocalizedFactionName( HSSKOR ), (int)ammount );
	sendSystemMessageProse(player, pp );

	return;
}

/**
Awards Hsskor (Trandoshan) standing to the player and removes a like ammount of Kashyyyk (wookiee resistance) faction.
obj_id player		The player to recieve the faction
int ammount		The ammount of faction to grant

return void
**/
void awardHsskorFaction(obj_id player, int ammount)
{
	if (!isPlayer(player))
		return;

	//Can't adjust by 0
	if (ammount == 0)
		return;

	validateBalance(player, HSSKOR);

	float hsskorAmmount = getFactionStanding(player, HSSKOR);
	float kashyyykAmmount = getFactionStanding(player, KASHYYYK);

	//You cannot gain opposing faction, you must betray your current faction to be reset
	if (hsskorAmmount < 0)
		return;

	//You lose an equal ammount of the opposing faction
	float gain = hsskorAmmount + (float)ammount;
	float lose = kashyyykAmmount - (float)ammount;

	setObjVar(player, FACTION + "." + HSSKOR, gain );
	setObjVar(player, FACTION + "." + KASHYYYK, lose);

	prose_package pp = prose.getPackage(PROSE_AWARD_FACTION, getLocalizedFactionName( HSSKOR ), (int)ammount);
	sendSystemMessageProse(player, pp);

	ammount *= -1;
	pp = prose.getPackage( PROSE_LOSE_FACTION, getLocalizedFactionName( KASHYYYK ), (int)ammount );
	sendSystemMessageProse(player, pp );

	return;
}

/**
Ensures that a players kashyyyk and hsskor factions are equal and opposite
obj_id player		player whos faction to check
string faction		The faction to balance against
return void
**/
void validateBalance(obj_id player, string faction)
{
	string checkHsskor = FACTION + "." + HSSKOR;
	string checkKashyyyk = FACTION + "." + KASHYYYK;
	float hsskorBalance = 0f;
	float kashyyykBalance = 0f;

	if (hasObjVar(player, checkHsskor))
	{
		if(!hasObjVar(player, checkKashyyyk))
			setObjVar(player, checkKashyyyk, -1*getFactionStanding(player, HSSKOR));
	}

	if (hasObjVar(player, checkKashyyyk))
	{
		if(!hasObjVar(player, checkHsskor))
			setObjVar(player, checkHsskor, -1*getFactionStanding(player, KASHYYYK));
	}

	hsskorBalance = getFloatObjVar(player, checkHsskor);
	kashyyykBalance = getFloatObjVar(player, checkKashyyyk);

	if (hsskorBalance != -1*kashyyykBalance)
	{
		if (faction.equals(HSSKOR))
			setObjVar(player, checkKashyyyk, -1*getFactionStanding(player, HSSKOR));
		else
			setObjVar(player, checkHsskor, -1*getFactionStanding(player, KASHYYYK));
	}

	return;
}

/**
This will check if the player either does not have the ObjVar Factions or of the levels are set to 0
obj_id player		The player whos faction allignment to check
return boolean		Returns true if the player has not chosen a side
**/
boolean isUnaligned(obj_id player)
{
	string hsskor = FACTION + "." + HSSKOR;
	string kashyyyk = FACTION + "." + KASHYYYK;

	//Remove a case where one objvar is present and not the other
	validateBalance(player, HSSKOR);

	if (!hasObjVar(player, hsskor ) && !hasObjVar(player, kashyyyk))
		return true;

	if (getFloatObjVar(player, hsskor) != 0)
		return false;

	return true;
}

/**
Checks if the player has a positive ammount of Kashyyyk Faction.
obj_id player		The player who's faction standing to check
return boolean		True if the players faction standing with Kashyyyk is greater than 0
**/
boolean isAlignedKashyyyk(obj_id player)
{
	if(isUnaligned(player))
		return false;

	return (getFactionStanding(player, KASHYYYK) > 0);
}

/**
Checks if the player has a positive ammount of Hsskor Faction.
obj_id player		The player who's faction standing to check
return boolean		True if the players faction standing with Hsskor is greater than 0
**/
boolean isAlignedHsskor(obj_id player)
{
	if(isUnaligned(player))
		return false;

	return (getFactionStanding(player, HSSKOR) > 0);
}


boolean isImperial(obj_id objPlayer)
{
	int intPlayerFaction = pvpGetAlignedFaction(objPlayer);
	if(intPlayerFaction==##"Imperial")
	{
		return true;
	}
	return false;

}
boolean isRebel(obj_id objPlayer)
{
	int intPlayerFaction = pvpGetAlignedFaction(objPlayer);
	if(intPlayerFaction==##"Rebel")
	{
		return true;
	}
	return false;
}
boolean isOnLeave(obj_id objPlayer)
{
	int intFaction = pvpGetAlignedFaction(objPlayer);
	if (( intFaction!=0) && pvpGetType(objPlayer) == PVPTYPE_NEUTRAL )
	{
		return true;
	}
	return false;
}
boolean isActiveImperial(obj_id objPlayer)
{
	return (isImperial(objPlayer) && !isOnLeave(objPlayer));
}
boolean isActiveRebel(obj_id objPlayer)
{
	return (isRebel(objPlayer) && !isOnLeave(objPlayer));
}

boolean isGatedByJoinTimer(obj_id player, string factionJoining)
{
	factionJoining = toLower(factionJoining);

	// can join other factions aside from imp and reb
	if(!factionJoining.equals("imperial") && !factionJoining.equals("rebel"))
	{
		return false;
	}

	if(hasObjVar(player, "lastFactionResignedFrom") && hasObjVar(player, "lastFactionResignedTime"))
	{
		//sendSystemMessageTestingOnly(player, "Has objvars");
		string lastFactionResignedFrom = getStringObjVar(player, "lastFactionResignedFrom");
		//sendSystemMessageTestingOnly(player, "Resigned from " + lastFactionResignedFrom + ", trying to join " + factionJoining);

		// can always rejoin the faction I left
		if(!toLower(lastFactionResignedFrom).equals(factionJoining))
		{
			//sendSystemMessageTestingOnly(player, "Joining different faction than left.");
			int now = getGameTime();
			int lastFactionResignedTime = getIntObjVar(player, "lastFactionResignedTime");
			int interval = now - lastFactionResignedTime;
			//sendSystemMessageTestingOnly(player, "Interval since leaving: " + interval);

			int minIntervalToJoin = 60 * 60 * 24 * 5; // seconds * minutes * hours * days

			//sendSystemMessageTestingOnly(player, "Min interval is " + minIntervalToJoin + ", player waited " + interval);
			if(interval < minIntervalToJoin)
			{
				return true;
			}
		}
	}

	return false;

}

boolean canJoinFaction(obj_id player, int faction_id)
{
	if ( !isIdValid(player) )
	{
		LOG("LOG_CHANNEL", "faction_recruiter::canJoinFaction -- player is null");
		return false;
	}
	if (faction_id == 0)
	{
		LOG("LOG_CHANNEL", "faction_recruiter::canJoinFaction -- faction is 0");
		return false;
	}
	string faction = factions.getFactionNameByHashCode(faction_id);
	if (faction == null)
	{
		LOG("LOG_CHANNEL", "faction_recruiter::canJoinFaction -- can not find " + faction_id + " in the faction datatable");
		return false;
	}

	// no faction hopping
	if(isGatedByJoinTimer(player, faction))
	{
		return false;
	}

	int player_faction_id = pvpGetAlignedFaction(player);
	if (player_faction_id != 0)
	{
		//you're an allied pilot!
		if ( player_faction_id==faction_id && pvpGetType(player) == PVPTYPE_NEUTRAL )
			player_faction_id=0;
		else
			return false;//you can't join, you dope!
	}

	return true;
}
boolean isFactionMember(obj_id player, obj_id npc)
{
	if ( !isIdValid(player) )
	{
		LOG("LOG_CHANNEL", "faction_recruiter::isFactionMember -- player is null");
		return false;
	}
	if (npc == null || npc == obj_id.NULL_ID)
	{
		LOG("LOG_CHANNEL", "faction_recruiter::isFactionMember -- npc is null");
		return false;
	}

	int player_faction_id = pvpGetAlignedFaction(player);
	int npc_faction_id = pvpGetAlignedFaction(npc);
	if (player_faction_id == 0)
		return false;

	if (player_faction_id == npc_faction_id)
		return true;
	else
		return false;
}


boolean joinFaction(obj_id player, int faction_id, boolean returnFromReserves)
{
	if ( !isIdValid(player) )
	{
		LOG("LOG_CHANNEL", "faction_recruiter::joinFaction -- player is null");
		return false;
	}

	if (faction_id == 0)
	{
		LOG("LOG_CHANNEL", "faction_recruiter::joinFaction -- faction is 0");
		return false;
	}
	int intFaction = pvpGetAlignedFaction(player);
	if(intFaction!=0)
	{
		// you're already in a faction. Something is weeeeird.
		return false;
	}
	CustomerServiceLog("factions",  player+" named "+getName(player)+" joined "+getFactionNameByHashCode(faction_id));
	if (!canJoinFaction(player, faction_id))
		return false;

	//need to check for aura buffs that need to be cleared
	buff.removeAllAuraBuffs(player);

	pvpSetAlignedFaction(player, faction_id);
	pvpMakeCovert(player);
	LOG("LOG_CHANNEL", "faction_recruiter::joinFaction -- " + player + " has joined faction " + faction_id);
	return true;
}



boolean joinFaction(obj_id player, int faction_id)
{
	return joinFaction(player, faction_id, false);
}


boolean isOnLeaveFromFriendlyFaction(obj_id objPlayer, obj_id objNPC)
{
	if(pvpGetAlignedFaction(objPlayer)== pvpGetAlignedFaction(objNPC)&&(pvpGetType(objPlayer)==PVPTYPE_NEUTRAL))
	{
		return true;
	}
	return false;
}
boolean isInEnemyFaction(obj_id objPlayer, obj_id objNPC)
{
	int intFaction = pvpGetAlignedFaction(objPlayer);
	if((intFaction!=0)&&(intFaction!= pvpGetAlignedFaction(objNPC)))
	{
		return true;
	}
	return false;
}
boolean isInFriendlyFaction(obj_id objPlayer, obj_id objNPC)
{
	if(pvpGetAlignedFaction(objPlayer)== pvpGetAlignedFaction(objNPC))
	{
		return true;
	}
	return false;
}
boolean isOnLeaveFromEnemyFaction(obj_id objPlayer, obj_id objNPC)
{
	int intFaction = pvpGetAlignedFaction(objPlayer);
	if((intFaction!=0)&&(intFaction!= pvpGetAlignedFaction(objNPC)&&(pvpGetType(objPlayer)==PVPTYPE_NEUTRAL)))
	{
		return true;
	}
	return false;
}


boolean qualifiesForPromotion(obj_id objPlayer, int intFaction)
{

	int intPlayerFaction = pvpGetAlignedFaction(objPlayer);
	if(intPlayerFaction!=intFaction)
	{
		return false;
	}

	int current_rank = pvpGetCurrentGcwRank(objPlayer);
	if (current_rank >= factions.MAXIMUM_RANK)
	{
		return false;
	}
	int cost = factions.getRankCost(current_rank + 1);
	int faction_standing = (int)factions.getFactionStanding(objPlayer, intFaction);
	if(faction_standing>=cost)
	{
		return true;
	}
	return false;
}

void applyPromotion(obj_id objPlayer, int intFaction)
{
	if(qualifiesForPromotion(objPlayer, intFaction))
	{
		int current_rank = pvpGetCurrentGcwRank(objPlayer);
		int cost = factions.getRankCost(current_rank + 1);
		int faction_standing = (int)factions.getFactionStanding(objPlayer, intFaction);
		if (factions.addFactionStanding(objPlayer, intFaction, -cost))
		{
			CustomerServiceLog( "player_faction", "PLAYER-FACTION ALTERED|TIME:"+getGameTime()+"|PLAYER:"+objPlayer+"|PLAYER NAME:"+getName(objPlayer)+"|ZONE:"+getCurrentSceneName()+"|Player has purchased rank for "+cost);
			factions.setRank(objPlayer, current_rank + 1);
		}

	}
	return;
}

boolean isSmuggler (obj_id player)
{
	if ( hasSkill( player, "class_smuggler_phase3_novice" ) )
	{
		return true;
	}
	else if ( hasSkill( player, "class_smuggler_phase4_novice" ) )
	{
		return true;
	}

	return false;
}

boolean canBuyFaction(obj_id objPlayer, obj_id objNPC)
{
	int intNPCFaction = pvpGetAlignedFaction(objNPC);

	string rec_faction = getFactionNameByHashCode(intNPCFaction);
	int intPlayerFaction = pvpGetAlignedFaction(objPlayer);


	string oppfaction = "";
	if ( rec_faction == "Imperial" )
		oppfaction = "Rebel";
	else
		oppfaction = "Imperial";
	float oppstanding = factions.getFactionStanding( objPlayer, oppfaction );
	float ourstanding = factions.getFactionStanding( objPlayer, intPlayerFaction);


	float fltFactionMax = factions.getFactionMax(objPlayer, intNPCFaction);
	if ( oppstanding > 200 )
	{
		return false;
	}
	else if ( ourstanding >= fltFactionMax)
	{
		return false;
	}
	return true;
}

void buyFaction (obj_id objPlayer, obj_id objNPC, int intAmount )
{
		// Begin cash transfer.
		dictionary outp = new dictionary();
		money.requestPayment( objPlayer, objNPC, intAmount, "payBribe", outp, true );
		return;
}





boolean leaveFaction(obj_id player, int faction_id)
{
	if ( !isIdValid(player) )
	{
		LOG("LOG_CHANNEL", "faction_recruiter::joinFaction -- player is null");
		return false;
	}

	if (faction_id == 0)
	{
		LOG("LOG_CHANNEL", "faction_recruiter::joinFaction -- faction is 0");
		return false;
	}

	// Send a message to the player that removes him from the faction after the alloted resignation time.
	/*
	if (!hasScript(player, faction_perk.SCRIPT_PLAYER_RECRUITER))
		attachScript(player, faction_perk.SCRIPT_PLAYER_RECRUITER);
	*/

	string title = utils.packStringId(SID_SUI_FACTION_RESIG_TITLE);
	string prompt = utils.packStringId(SID_SUI_FACTION_RESIG_TEXT);
	int pid = sui.inputbox(player, player, prompt, title, "handleLeaveFactionSui", "");
	return (pid > -1);
}

boolean isPVPStatusChanging(obj_id objPlayer)
{
	if(hasObjVar(objPlayer, "intChangingFactionStatus"))
	{
		return true;
	}
	return false;

}

boolean pvpDoAllowedAttackCheck(obj_id objPlayer, obj_id objTarget)
{
	if(!isPlayer(objPlayer))
	{
		LOG("combat", "return 1");
		return pvpCanAttack(objPlayer, objTarget);
	}
	if(!pvpCanAttack(objPlayer, objTarget))
	{
		if(hasObjVar(objPlayer, "intChangingFactionStatus"))
		{
			LOG("combat", "return 2");
			return false;
		}

		int intMyFaction = pvpGetAlignedFaction(objPlayer);
		int intYourFaction = pvpGetAlignedFaction(objTarget);
		if(intMyFaction==intYourFaction)
		{
			LOG("combat", "return 3");
			return false;
		}
		else
		{
			int intMyPVPType = pvpGetType(objPlayer);
			int intYourPVPType = pvpGetType(objTarget);
			if(!isPlayer(objTarget)&&(!pet_lib.isPet(objTarget)))
			{
				// potentially an enemy
				if(intMyPVPType==PVPTYPE_NEUTRAL)
				{
					// maybe you can help
					// what's the target
					if(intYourPVPType==PVPTYPE_NEUTRAL)
					{
						return false; //
					}
					if(intYourPVPType==PVPTYPE_COVERT)
					{
						LOG("combat", "return 5");
						doTransitionSui(objPlayer, objTarget, 30f);
						return false;
						// you can help if you go covert.
						// do a box here
					}
					if(intYourPVPType==PVPTYPE_DECLARED)
					{
						LOG("combat", "return 6");
						//doTransitionSui(objPlayer, objTarget, 300f);
						return false;

						// do we do a box.
					}
				}
				else if(intMyPVPType==PVPTYPE_COVERT)
				{
					if(intYourPVPType==PVPTYPE_NEUTRAL)
					{
						LOG("combat", "return 7");
						return false; // on leaves can help each other.
					}
					if(intYourPVPType==PVPTYPE_COVERT)
					{
						LOG("combat", "return 8");
						return true; // no helpy
					}
					if(intYourPVPType==PVPTYPE_DECLARED)
					{
						LOG("combat", "return 9");
						//doTransitionSui(objPlayer, objTarget, 300f);
						// do we do a box.
						return false;
					}
				}
				else if(intMyPVPType==PVPTYPE_DECLARED)
				{
					if(intYourPVPType==PVPTYPE_NEUTRAL)
					{
						LOG("combat", "return 10");
						return false; // on leaves can help each other.
					}
					if(intYourPVPType==PVPTYPE_COVERT)
					{
						LOG("combat", "return 11");
						return true; // no helpy
					}
					if(intYourPVPType==PVPTYPE_DECLARED)
					{
						LOG("combat", "return 12");
						return true;
					}
				}

			}
			LOG("combat", "return 13");
			return false;

		}
	}
	else
	{
		LOG("combat", "return 14");
		return true;
	}

}

void doTransitionSui(obj_id objPlayer, obj_id objTarget, float fltDelay)
{

	if(hasObjVar(objPlayer, "intChangingFactionStatus"))
	{
		return;
	}
	int intFaction = pvpGetAlignedFaction(objPlayer);
	if(intFaction==0)
	{
		return; // no transition if you're really neutral
	}

	int intMyPVPType = pvpGetType(objPlayer);
	int intYourPVPType = pvpGetType(objTarget);
	string_id strTitleId = new string_id("gcw", "gcw_status_change");
	string strTitle = utils.packStringId(strTitleId);


	if(intMyPVPType==PVPTYPE_NEUTRAL)
	{
		if(intYourPVPType==PVPTYPE_COVERT)
		{
			// 1 step
			// 30 seconds
			string_id strSpam = new string_id("gcw", "gcw_status_change_covert");
			string strPrompt = utils.packStringId(strSpam);
			int pid = sui.inputbox(objPlayer, objPlayer, strPrompt, strTitle, "handleGoCovert", "");
			return;
		}
		else if(intYourPVPType==PVPTYPE_DECLARED)
		{
			string_id strSpam = new string_id("gcw", "gcw_status_change_overt");
			string strPrompt = utils.packStringId(strSpam);
			int pid = sui.inputbox(objPlayer, objPlayer, strPrompt, strTitle, "handleGoOvert", "");
			return;
			// 5 mins
		}
		else
		{
			sendSystemMessageTestingOnly(objPlayer, "Error # 4 : You got a PVP error message. Your PVP Type is "+intMyPVPType+". Your faction is"+pvpGetAlignedFaction(objPlayer)+". Your target is "+objTarget+" their pvp type is "+pvpGetType(objTarget)+" and their faction is "+pvpGetAlignedFaction(objTarget));
		}

	}
	else if(intMyPVPType==PVPTYPE_COVERT)
	{
		if(intYourPVPType==PVPTYPE_COVERT)
		{
			sendSystemMessageTestingOnly(objPlayer, "Error # 1 : You got a PVP error message. Your PVP Type is "+intMyPVPType+". Your faction is"+pvpGetAlignedFaction(objPlayer)+". Your target is "+objTarget+" their pvp type is "+pvpGetType(objTarget)+" and their faction is "+pvpGetAlignedFaction(objTarget));
		}
		else if(intYourPVPType==PVPTYPE_DECLARED)
		{
			// 1 step, 5 mins
			string_id strSpam = new string_id("gcw", "gcw_status_change_overt");
			string strPrompt = utils.packStringId(strSpam);
			int pid = sui.inputbox(objPlayer, objPlayer, strPrompt, strTitle, "handleGoOvert", "");
			return;
		}
		else
		{
			sendSystemMessageTestingOnly(objPlayer, "Error # 3 : You got a PVP error message. Your PVP Type is "+intMyPVPType+". Your faction is"+pvpGetAlignedFaction(objPlayer)+". Your target is "+objTarget+" their pvp type is "+pvpGetType(objTarget)+" and their faction is "+pvpGetAlignedFaction(objTarget));
		}


	}
	else
	{
		// Major fuckup here
		sendSystemMessageTestingOnly(objPlayer, "Error # 2 : You got a PVP error message. Your PVP Type is "+intMyPVPType+". Your faction is"+pvpGetAlignedFaction(objPlayer)+". Your target is "+objTarget+" their pvp type is "+pvpGetType(objTarget)+" and their faction is "+pvpGetAlignedFaction(objTarget));
	}



}

boolean pvpDoAllowedHelpCheck(obj_id objPlayer, obj_id objTarget)
{

	if(!isPlayer(objPlayer))
	{
		LOG("combat", "return 1");
		return pvpCanHelp(objPlayer, objTarget);
	}

	if(!pvpCanHelp(objPlayer, objTarget))
	{
		if(hasObjVar(objPlayer, "intChangingFactionStatus"))
		{
			LOG("combat", "return 2");
			return false;
		}

		int intMyFaction = pvpGetAlignedFaction(objPlayer);
		int intYourFaction = pvpGetAlignedFaction(objTarget);
		if(intMyFaction!=intYourFaction)
		{
			LOG("combat", "return 3");
			return false;
		}
		else
		{
			int intMyPVPType = pvpGetType(objPlayer);
			int intYourPVPType = pvpGetType(objTarget);
			// potentially an enemy
			if(intMyPVPType==PVPTYPE_NEUTRAL)
			{
				if(intYourPVPType==PVPTYPE_COVERT)
				{
					LOG("combat", "return 5");
					doTransitionSui(objPlayer, objTarget, 30f);
					return false;
					// you can help if you go covert.
					// do a box here
				}
			}

				}
					return false;
				}
	else
	{
		LOG("combat", "return 14");
		return true;
	}

}

boolean canGoOnLeave(obj_id objPlayer)
{

	if (isInAdhocPvpArea(objPlayer))
		return false;

	return true;
}

boolean canGoCovert(obj_id objPlayer)
{
	if (isInAdhocPvpArea(objPlayer))
		return false;

	return true;
}

prose_package getFactionProsePackage(String factionName, int actualValue)
{
	prose_package pp = null;

	if (actualValue > 0)
	{
		pp = prose.getPackage(PROSE_AWARD_FACTION, getLocalizedFactionName(factionName), actualValue);
	}
	else
	{
		pp = prose.getPackage(PROSE_LOSE_FACTION, getLocalizedFactionName(factionName), -actualValue);
	}

	return pp;
}

const string IGNORE_PLAYER		= "ignorePlayer";
boolean ignorePlayer(obj_id attacker, obj_id target)
{
	if (isPlayer(attacker) || (isMob(attacker) && isIdValid(getMaster(attacker)) && isPlayer(getMaster(attacker))))
	{
		if (utils.hasScriptVar(target, IGNORE_PLAYER))
			return true;
	}
	else
	{
		if (isPlayer(target) || (isMob(target) && isIdValid(getMaster(target)) && isPlayer(getMaster(target))))
		{
			if (utils.hasScriptVar(attacker, IGNORE_PLAYER))
				return true;
		}
	}

	if (utils.hasScriptVar(target, IGNORE_PLAYER))
	{
		if (isPlayer(attacker) || (isIdValid(getMaster(attacker)) && isPlayer(getMaster(attacker))))
			return true;
	}

	return false;
}

void setIgnorePlayer(obj_id npc)
{
	utils.setScriptVar(npc, IGNORE_PLAYER, true);
}

boolean isInAdhocPvpArea(obj_id player)
{
	if (!isIdValid(player))
		return false;

	if (utils.hasScriptVar(player, IN_ADHOC_PVP_AREA))
		return utils.getBooleanScriptVar(player, IN_ADHOC_PVP_AREA);

	return false;
}

void removeAllPvpSkills (obj_id player)
{
	skill.revokeSkill (player, "pvp_imperial_retaliation_ability");
	skill.revokeSkill (player, "pvp_imperial_adrenaline_ability");
	skill.revokeSkill (player, "pvp_imperial_unstoppable_ability");
	skill.revokeSkill (player, "pvp_imperial_last_man_ability");
	skill.revokeSkill (player, "pvp_imperial_aura_buff_self");
	skill.revokeSkill (player, "pvp_imperial_airstrike_ability");
	skill.revokeSkill (player, "pvp_rebel_retaliation_ability");
	skill.revokeSkill (player, "pvp_rebel_adrenaline_ability");
	skill.revokeSkill (player, "pvp_rebel_unstoppable_ability");
	skill.revokeSkill (player, "pvp_rebel_last_man_ability");
	skill.revokeSkill (player, "pvp_rebel_aura_buff_self");
	skill.revokeSkill (player, "pvp_rebel_airstrike_ability");
	return;
}

boolean shareSocialGroup(obj_id creatureOne, obj_id creatureTwo)
{
	string socialOne = getStringObjVar(creatureOne, "socialGroup");
	string socialTwo = getStringObjVar(creatureTwo, "socialGroup");

	if (socialOne.equals(socialTwo))
		return true;

	return false;
}

boolean areCreaturesAllied(obj_id creatureOne, obj_id creatureTwo)
{
	string factionOne = getStringObjVar(creatureOne, "faction");
	string factionTwo = getStringObjVar(creatureTwo, "faction");

	if (factionOne == null || factionOne == "" || factionTwo == null || factionTwo == "")
		return false;

	if (factionOne.equals(factionTwo))
		return true;

	int row = dataTableSearchColumnForString(factionOne, "factionName", "datatables/faction/faction.iff");

	if (row == -1)
		return false;

	string allies = dataTableGetString("datatables/faction/faction.iff", row, "allies");

	if (allies == null || allies == "")
		return false;

	string[] alliesParse = split(allies, ',');

	for (int i=0;i<alliesParse.length;i++)
	{
		if (alliesParse[i].equals(factionTwo))
			return true;
	}

	return false;
}

boolean isPlayerSameGcwFactionAsSchedulerObject(obj_id player, obj_id object)
{
	LOG("faction_check","isPlayerSameGcwFactionAsSchedulerObject init");
	if(!isValidId(player) || !exists(player))
		return false;
	if(!isValidId(object) || !exists(object))
		return false;
	LOG("faction_check","isPlayerSameGcwFactionAsSchedulerObject basic validation completed");
	
	//This is not a scheduler object
	if(!utils.hasScriptVar(object, "faction"))
		return false;
	LOG("faction_check","isPlayerSameGcwFactionAsSchedulerObject has faction int script var");

	int intFaction = utils.getIntScriptVar(object, "faction");

	if(intFaction !=  FACTION_FLAG_IMPERIAL && intFaction != FACTION_FLAG_REBEL)
		return false;

	LOG("faction_check","isPlayerSameGcwFactionAsSchedulerObject faction int script var is a valid number");

	//Not a neutral player
	if(0 != pvpGetAlignedFaction(player))
	{
		LOG("faction_check","isPlayerSameGcwFactionAsSchedulerObject FACTIONED player");

		//Not the same faction as object
		if(intFaction != factions.getFactionFlag(player))
			return false;
	}
	//Is a neutral player
	else
	{

		LOG("faction_check","isPlayerSameGcwFactionAsSchedulerObject NEUTRAL player");

		int currentMercenaryFaction = pvpNeutralGetMercenaryFaction(player);
		LOG("faction_check","isPlayerSameGcwFactionAsSchedulerObject currentMercenaryFaction: "+currentMercenaryFaction);
		if(0 == currentMercenaryFaction)
			return false;
		
		if(##"imperial" == currentMercenaryFaction && intFaction != FACTION_FLAG_IMPERIAL)
			return false;
		if(##"rebel" == currentMercenaryFaction && intFaction != FACTION_FLAG_REBEL)
			return false;
	}

	return true;
}

boolean canChangeNeutralMercenaryStatus(obj_id player, string faction)
{
	if(!isValidId(player) || !exists(player))
		return false;

	//must be neutral to be mercenary
	if(0 != pvpGetAlignedFaction(player))
		return false;

	//must not be a merc already
	if(0 != pvpNeutralGetMercenaryFaction(player))
		return false;

	//doesn't have an outstanding request
	if(hasMessageTo(player, "executeFactionalHelperChoice"))
		return false;

	const int timeNow = getCalendarTime();

	// 30 minutes after you stop helping the Rebels, you can start helping the Imperials
	if(faction.toLowerCase().equals("imperial") && hasObjVar(player, "factionalHelper.timeStopHelpingRebel"))
	{
		int time = getIntObjVar(player, "factionalHelper.timeStopHelpingRebel");
		if((time > 0) && ((time + 1800) > timeNow))
		{
			LOG("time_left", "rebel time left: "+((time + 1800) - timeNow));
			return false;
		}
	}
	
	// 30 minutes after you stop helping the Imperials, you can start helping the Rebels
	if(faction.toLowerCase().equals("rebel") && hasObjVar(player, "factionalHelper.timeStopHelpingImperial"))
	{
		int time = getIntObjVar(player, "factionalHelper.timeStopHelpingImperial");
		if ((time > 0) && ((time + 1800) > timeNow))
		{
			LOG("time_left", "imperial time left: "+((time + 1800) - timeNow));
			return false;
		}
	}

	return true;
}

boolean neutralMercenaryStatusMenu(obj_id player)
{
	if(!isValidId(player) || !exists(player))
		return false;

	// close any existing SUI
	utils.removeScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_CHOICES);

	if (utils.hasScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_ID))
	{
		int savedPageId = utils.getIntScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_ID);
		utils.removeScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_ID);

		forceCloseSUIPage(savedPageId);
	}

	// must be neutral to be mercenary
	if(0 != pvpGetAlignedFaction(player))
	{
		sendSystemMessage(player, "You must be a Civilian to be a factional helper.", "");
		return false;
	}

	// has outstanding request
	if(hasMessageTo(player, "executeFactionalHelperChoice"))
	{
		sendSystemMessage(player, "You currently have an outstanding factional helper request.", "");
		return false;
	}

		
	// is currently mercenary?
	int currentMercenaryFaction = pvpNeutralGetMercenaryFaction(player);
	if (0 != currentMercenaryFaction)
	{
		boolean isDeclared = pvpNeutralIsMercenaryDeclared(player);
		if (##"imperial" == currentMercenaryFaction)
		{
			Vector choicesDisplay = new Vector();
			Vector choicesInternal = new Vector();
			if (isDeclared)
			{
				string configSetting = getConfigSetting("GameServer", "enableCovertImperialMercenary");
				if ((configSetting != null) && (configSetting.length() > 0) && !configSetting.toLowerCase().equals("false") && !configSetting.equals("0"))
				{
					choicesDisplay.addElement("I want to help the Imperials as a Combatant.");
					choicesInternal.addElement("covert_imperial_mercenary_begin");
				}

				choicesDisplay.addElement("I want to stop being a Special Forces Imperial helper.");
				choicesInternal.addElement("overt_imperial_mercenary_end");
			}
			else
			{
				choicesDisplay.addElement("I want to stop being a Combatant Imperial helper.");
				choicesInternal.addElement("covert_imperial_mercenary_end");
				
				string configSetting = getConfigSetting("GameServer", "enableOvertImperialMercenary");
				if ((configSetting != null) && (configSetting.length() > 0) && !configSetting.toLowerCase().equals("false") && !configSetting.equals("0"))
				{
					choicesDisplay.addElement("I want to help the Imperials as a Special Forces.");
					choicesInternal.addElement("overt_imperial_mercenary_begin");
				}			
			}

			int pid = sui.listbox(player, player, "What would you like to do?", sui.OK_CANCEL, "Factional Helper", choicesDisplay, "handleFactionalHelperChoice", true, false);
			utils.setScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_CHOICES, choicesInternal);
			utils.setScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_ID, pid);

			return true;
		}
		else if (##"rebel" == currentMercenaryFaction)
		{
			Vector choicesDisplay = new Vector();
			Vector choicesInternal = new Vector();
			if (isDeclared)
			{
				string configSetting = getConfigSetting("GameServer", "enableCovertRebelMercenary");
				if ((configSetting != null) && (configSetting.length() > 0) && !configSetting.toLowerCase().equals("false") && !configSetting.equals("0"))
				{
					choicesDisplay.addElement("I want to help the Rebels as a Combatant.");
					choicesInternal.addElement("covert_rebel_mercenary_begin");
				}

				choicesDisplay.addElement("I want to stop being a Special Forces Rebel helper.");
				choicesInternal.addElement("overt_rebel_mercenary_end");
			}
			else
			{
				choicesDisplay.addElement("I want to stop being a Combatant Rebel helper.");
				choicesInternal.addElement("covert_rebel_mercenary_end");
				
				string configSetting = getConfigSetting("GameServer", "enableOvertRebelMercenary");
				if ((configSetting != null) && (configSetting.length() > 0) && !configSetting.toLowerCase().equals("false") && !configSetting.equals("0"))
				{
					choicesDisplay.addElement("I want to help the Rebels as a Special Forces.");
					choicesInternal.addElement("overt_rebel_mercenary_begin");
				}
			}

			int pid = sui.listbox(player, player, "What would you like to do?", sui.OK_CANCEL, "Factional Helper", choicesDisplay, "handleFactionalHelperChoice", true, false);
			utils.setScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_CHOICES, choicesInternal);
			utils.setScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_ID, pid);

			return true;
		}
	}
	
	const int timeNow = getCalendarTime();
	const int timeCooldown = (isGod(player) ? 10 : 1800);
	int secondsUntilCanHelpRebel = 0;
	int secondsUntilCanHelpImperial = 0;

	// 30 minutes after you stop helping the Rebels, you can start helping the Imperials
	if (hasObjVar(player, "factionalHelper.timeStopHelpingRebel"))
	{
		int time = getIntObjVar(player, "factionalHelper.timeStopHelpingRebel");
		if ((time > 0) && ((time + timeCooldown) > timeNow))
		{
			secondsUntilCanHelpImperial = time + timeCooldown - timeNow;
		}
	}
	// 30 minutes after you stop helping the Imperials, you can start helping the Rebels
	else if (hasObjVar(player, "factionalHelper.timeStopHelpingImperial"))
	{
		int time = getIntObjVar(player, "factionalHelper.timeStopHelpingImperial");
		if ((time > 0) && ((time + timeCooldown) > timeNow))
		{
			secondsUntilCanHelpRebel = time + timeCooldown - timeNow;
		}
	}

	Vector choicesDisplay = new Vector();
	Vector choicesInternal = new Vector();

	if (secondsUntilCanHelpImperial <= 0)
	{
		string configSetting = getConfigSetting("GameServer", "enableCovertImperialMercenary");
		if ((configSetting != null) && (configSetting.length() > 0) && !configSetting.toLowerCase().equals("false") && !configSetting.equals("0"))
		{
			choicesDisplay.addElement("I want to help the Imperials as a Combatant.");
			choicesInternal.addElement("covert_imperial_mercenary_begin");
		}

		configSetting = getConfigSetting("GameServer", "enableOvertImperialMercenary");
		if ((configSetting != null) && (configSetting.length() > 0) && !configSetting.toLowerCase().equals("false") && !configSetting.equals("0"))
		{
			choicesDisplay.addElement("I want to help the Imperials as a Special Forces.");
			choicesInternal.addElement("overt_imperial_mercenary_begin");
		}
	}

	if (secondsUntilCanHelpRebel <= 0)
	{
		string configSetting = getConfigSetting("GameServer", "enableCovertRebelMercenary");
		if ((configSetting != null) && (configSetting.length() > 0) && !configSetting.toLowerCase().equals("false") && !configSetting.equals("0"))
		{
			choicesDisplay.addElement("I want to help the Rebels as a Combatant.");
			choicesInternal.addElement("covert_rebel_mercenary_begin");
		}

		configSetting = getConfigSetting("GameServer", "enableOvertRebelMercenary");
		if ((configSetting != null) && (configSetting.length() > 0) && !configSetting.toLowerCase().equals("false") && !configSetting.equals("0"))
		{
			choicesDisplay.addElement("I want to help the Rebels as a Special Forces.");
			choicesInternal.addElement("overt_rebel_mercenary_begin");
		}
	}

	if (choicesDisplay.size() <= 0)
	{
		sendSystemMessage(player, "The factional helper functionality is currently disabled.", "");
		return false;
	}

	string prompt = "What would you like to do?";
	if (secondsUntilCanHelpImperial > 0)
	{
		prompt += "\n\n";
		prompt += "(You must wait " + (secondsUntilCanHelpImperial / 60) + "m:" + (secondsUntilCanHelpImperial % 60) + "s before you can become an Imperial factional helper.)";
	}
	else if (secondsUntilCanHelpRebel > 0)
	{
		prompt += "\n\n";
		prompt += "(You must wait " + (secondsUntilCanHelpRebel / 60) + "m:" + (secondsUntilCanHelpRebel % 60) + "s before you can become a Rebel factional helper.)";
	}

	int pid = sui.listbox(player, player, prompt, sui.OK_CANCEL, "Factional Helper", choicesDisplay, "handleFactionalHelperChoice", true, false);
	utils.setScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_CHOICES, choicesInternal);
	utils.setScriptVar(player, SCRIPTVAR_FACTIONAL_HELPER_SUI_ID, pid);
	return true;
}

boolean setNeturalMercenaryCovert(obj_id player, int factionFlag)
{
	if(!isValidId(player) || !exists(player))
		return false;

	if(factionFlag < FACTION_FLAG_REBEL || factionFlag > FACTION_FLAG_IMPERIAL)
		return false;

	string covertType = "";

	if(factionFlag == FACTION_FLAG_REBEL)
	{
		sendSystemMessage(player, SID_MERC_REBEL_COMBATANT_BEGIN);	
		covertType = MERC_BEGIN_COVERT_REBEL;
	}
	else if(factionFlag == FACTION_FLAG_IMPERIAL)	
	{
		sendSystemMessage(player, SID_MERC_IMPERIAL_COMBATANT_BEGIN);	
		covertType = MERC_BEGIN_COVERT_IMPERIAL;	
	}

	if(covertType == null || covertType.length() <= 0)
		return false;

	dictionary messageToParams = new dictionary();
	messageToParams.put("mercenary_type", covertType);
		
	if(isGod(player))
	{
		sendSystemMessage(player, "Reducing wait to 5 seconds ***BECAUSE YOU ARE IN GOD MODE***.", "");
		messageTo(player, "executeFactionalHelperChoice", messageToParams, 5.0f, false);
	}
	else
	{
		messageTo(player, "executeFactionalHelperChoice", messageToParams, 60.0f, false);
	}
	
	return true;
}

boolean setNeturalMercenaryOvert(obj_id player, int factionFlag)
{
	if(!isValidId(player) || !exists(player))
		return false;

	if(factionFlag < FACTION_FLAG_REBEL || factionFlag > FACTION_FLAG_IMPERIAL)
		return false;

	string overtType = "";
	
	if(factionFlag == FACTION_FLAG_REBEL)
	{
		sendSystemMessage(player, SID_MERC_REBEL_SF_BEGIN);
		overtType = MERC_BEGIN_OVERT_REBEL;
	}
	else if(factionFlag == FACTION_FLAG_IMPERIAL)	
	{
		sendSystemMessage(player, SID_MERC_IMPERIAL_SF_BEGIN);
		overtType = MERC_BEGIN_OVERT_IMPERIAL;	
	}

	if(overtType == null || overtType.length() <= 0)
		return false;

	dictionary messageToParams = new dictionary();
	messageToParams.put("mercenary_type", overtType);
		
	if(isGod(player))
	{
		sendSystemMessage(player, "Reducing wait to 5 seconds ***BECAUSE YOU ARE IN GOD MODE***.", "");
		messageTo(player, "executeFactionalHelperChoice", messageToParams, 5.0f, false);
	}
	else
	{
		messageTo(player, "executeFactionalHelperChoice", messageToParams, 60.0f, false);
	}
		
	return true;
}

boolean removeNeturalMercenary(obj_id player, int factionFlag)
{
	if(!isValidId(player) || !exists(player))
		return false;

	if(factionFlag < FACTION_FLAG_REBEL || factionFlag > FACTION_FLAG_IMPERIAL)
		return false;

	boolean isDeclared = pvpNeutralIsMercenaryDeclared(player);
	string type = "";
	
	if(factionFlag == FACTION_FLAG_REBEL)
	{
		if(isDeclared)
		{
			sendSystemMessage(player, SID_MERC_REBEL_SF_END);		
			type = MERC_END_OVERT_REBEL;
		}
		else
		{
			sendSystemMessage(player, SID_MERC_REBEL_COMBATANT_END);				
			type = MERC_END_COVERT_REBEL;		
		}
	}
	else if(factionFlag == FACTION_FLAG_IMPERIAL)	
	{
		if(isDeclared)
		{
			sendSystemMessage(player, SID_MERC_IMPERIAL_SF_END);				
			type = MERC_END_OVERT_IMPERIAL;
		}
		else
		{
			sendSystemMessage(player, SID_MERC_IMPERIAL_COMBATANT_END);		
			type = MERC_END_COVERT_IMPERIAL;		
		}
	}

	if(type == null || type.length() <= 0)
		return false;

	dictionary messageToParams = new dictionary();
	messageToParams.put("mercenary_type", type);

	if(isGod(player))
	{
		sendSystemMessage(player, "Reducing wait to 5 seconds ***BECAUSE YOU ARE IN GOD MODE***.", "");
		messageTo(player, "executeFactionalHelperChoice", messageToParams, 5.0f, false);
	}
	else
	{
		messageTo(player, "executeFactionalHelperChoice", messageToParams, 60.0f, false);
	}

	return true;
}