/**
 * Copyright (c)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved

/***** INCLUDES ********************************************************/
include library.gcw;
include library.player_structure;
include library.planetary_map;
include library.structure;
include library.theater;
include library.trial;
include library.utils;

/***** CONSTANTS *******************************************************/

const float VULNERABILITY_CYCLE				= 172800f;			// 2/1/05 new, post GCW re-work 48 hour cycle
//const float VULNERABILITY_CYCLE				= 86400f;		// original 24 hour cycle
//const float VULNERABILITY_CYCLE				= 900f;			// TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE


const float VULNERABILITY_LENGTH			= 10800f;	// 2/10/05 new, post GCW re-work 3 hour vulnerability cycle
//const float VULNERABILITY_LENGTH			= 7200f;	// original 2 hour vulnerability cycle
//const float VULNERABILITY_LENGTH			= 450f;		// TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE TEST VALUE

const string SCRIPT_CLONING_OVERRIDE		= "faction_perk.hq.terminal_cloning_override";
const string SCRIPT_INSURANCE_OVERRIDE		= "faction_perk.hq.terminal_insurance_override";

const string SCRIPT_TERMINAL_DISABLE		= "faction_perk.hq.terminal_disable";

const string SCRIPT_DEFENSE_OBJECT			= "faction_perk.hq.defense_object";

const string VAR_HQ_BASE					= "hq";

const string SCRIPTVAR_FLATTENER			= "hq.flattener";

const string SCRIPTVAR_THEATER_OBJECTS		= "hq.theaterObjects";
const string SCRIPTVAR_TERMINALS			= "hq.terminals";
const string VAR_DEFENSE_TURTERMINALS		= "hq.turterminals.terminals";

const string VAR_SPAWN_BASE					= VAR_HQ_BASE + ".spawn";
const string SCRIPTVAR_SPAWN_INTERIOR		= VAR_SPAWN_BASE + ".interior";
const string SCRIPTVAR_SPAWN_EXTERIOR		= VAR_SPAWN_BASE + ".exterior";

const string SCRIPTVAR_SPAWN_REINFORCEMENT	= VAR_SPAWN_BASE + ".reinforcement";

const string VAR_HQ_RESOURCE_CNT			= VAR_HQ_BASE + ".resource.cnt";

const string VAR_DEFENSE_BASE				= VAR_HQ_BASE + ".defense";

const string VAR_DEFENSE_PARENT				= VAR_DEFENSE_BASE + ".parent";

const string VAR_OBJECTIVE_BASE				= VAR_HQ_BASE + ".objective";
const string VAR_OBJECTIVE_STAMP			= VAR_OBJECTIVE_BASE + ".stamp";

const string VAR_OBJECTIVE_TRACKING			= VAR_OBJECTIVE_BASE + ".tracking";
const string VAR_OBJECTIVE_ID				= VAR_OBJECTIVE_TRACKING + ".id";
const string VAR_OBJECTIVE_DISABLED			= VAR_OBJECTIVE_TRACKING + ".disabled";

const string VAR_VULNERABILITY_RESET		= VAR_HQ_BASE + ".vulnerabilityReset";
const int RESET_MAX							= 1;

const string VAR_IS_DISABLED				= VAR_OBJECTIVE_BASE + ".isDisabled";

const string[] OBJECTIVE_TEMPLATE	= {
										"object/tangible/hq_destructible/uplink_terminal.iff",
										"object/tangible/hq_destructible/security_terminal.iff",
										"object/tangible/hq_destructible/override_terminal.iff",
										"object/tangible/hq_destructible/power_regulator.iff"
										};

const string VAR_TERMINAL_DISABLE			= VAR_HQ_BASE + ".terminal.disable";

const string TBL_TERMINAL_PATH				= "datatables/faction_perk/hq/terminal/";
const string TBL_TURRET_TERMINAL_PATH		= "datatables/faction_perk/hq/turret_terminal/";

const string TBL_SPAWN_PATH					= "datatables/faction_perk/hq/spawn/";
const string TBL_SPAWN_INTERIOR_PATH		= TBL_SPAWN_PATH + "interior/";
const string TBL_SPAWN_EXTERIOR_PATH		= TBL_SPAWN_PATH + "exterior/";
const string TBL_SPAWN_EGG_PATH				= TBL_SPAWN_PATH + "egg/";
const string TBL_SPAWN_FORMATION_PATH		= TBL_SPAWN_PATH + "formation/";

const string TBL_DEFENSE_PATH				= "datatables/faction_perk/hq/defense/";

const string TBL_OBJECTIVE_PATH				= "datatables/faction_perk/hq/objective/";

const string_id PROSE_DISABLE_OTHER			= new string_id("hq", "prose_disable_other");

const string HANDLER_LOAD_VULNERABILITY		= "handleLoadVulnerability";
const string HANDLER_UNLOAD_VULNERABILITY	= "handleUnloadVulnerability";

const string TEMPLATE_SPAWN_EGG				= "object/tangible/hq_egg/hq_spawner.iff";

const string VAR_SPAWN_TYPE					= VAR_HQ_BASE + ".spawnType";

//SPAWN TYPES
const int ST_NONE							= 0;
const int ST_SMALL							= 1;
const int ST_MEDIUM							= 2;
const int ST_LARGE							= 3;

const string VAR_SPAWN_CHILDREN				= VAR_SPAWN_BASE + ".children";
const string VAR_SPAWN_PARENT				= VAR_SPAWN_BASE + ".parent";

const string VAR_SPAWN_TEMPLATE				= VAR_SPAWN_BASE + ".template";
const string VAR_SPAWN_YAW					= VAR_SPAWN_BASE + ".yaw";
const string VAR_SPAWN_COUNT				= VAR_SPAWN_BASE + ".cnt";

const string SCRIPT_SPAWN_CHILD				= "faction_perk.hq.spawn_child";

const string VAR_SPAWN_LEADER				= VAR_SPAWN_BASE + ".leader";

const float FACTION_BASE_REFUND_AMOUNT		= 60000f;

const int MAX_MINE_TYPES					= 3;

/***** FUNCTIONS ****************************************************/
void loadHqTheater(obj_id hq)
{
	LOG("hq","loadHqTheater entered...");
	LOG("hq","loadHqTheater: hq yaw = " + getYaw(hq));
	obj_id[] children = theater.spawnDatatableOffset(hq);
	utils.removeBatchScriptVar(hq, SCRIPTVAR_THEATER_OBJECTS);
	if ( children != null && children.length > 0 )
	{
		utils.setBatchScriptVar(hq, SCRIPTVAR_THEATER_OBJECTS, children);
		messageTo(hq, "handleTheaterComplete", null, 5f, false);
	}

}

void cleanupHqTheater(obj_id hq)
{
	LOG("hq","cleanupHqTheater entered...");
	obj_id[] children = utils.getObjIdBatchScriptVar(hq, SCRIPTVAR_THEATER_OBJECTS);
	if ( children != null && children.length > 0 )
	{
		utils.destroyObjects(children);
	}
}

void loadHqTerminals(obj_id hq)
{
	LOG("hq","loadHqTerminals entered...");
	string faction = factions.getFaction(hq);
	if ( faction != null && !faction.equals("") )
	{
		obj_id[] terminals = structure.createStructureTerminals(hq, TBL_TERMINAL_PATH + toLower(faction) + ".iff");
		if ( terminals != null && terminals.length > 0 )
		{
			utils.setBatchScriptVar(hq, SCRIPTVAR_TERMINALS, terminals);

			for ( int i = 0; i < terminals.length; i++ )
			{
				int tGot = getGameObjectType(terminals[i]);
				if ( tGot == GOT_terminal_cloning )
				{
					attachScript(terminals[i], SCRIPT_CLONING_OVERRIDE);
				}
				else if ( tGot == GOT_terminal_insurance )
				{
					attachScript(terminals[i], SCRIPT_INSURANCE_OVERRIDE);
				}
			}
		}

		//if structure disabled, disable stuff...
	}
	else
	{
		destroyObject(hq);
	}
}

void loadTurretTerminals(obj_id hq)
{
 	LOG("***hq***", "loadTurretTerminals entered...");
  	string faction = factions.getFaction(hq);
  	if ( faction != null && !faction.equals("") )
  	{
  		obj_id[] turTerminals = structure.createStructureTerminals(hq, TBL_TURRET_TERMINAL_PATH + toLower(faction) + ".iff");
  		if ( turTerminals != null && turTerminals.length > 0 )
  		{
  			utils.setBatchObjVar(hq, VAR_DEFENSE_TURTERMINALS, turTerminals);
  		}
  	}
}

void loadHqSpawns(obj_id hq)
{
	LOG("hq","loadHqSpawns entered...");
	loadInteriorHqSpawns(hq);
	loadExteriorHqSpawns(hq);
}

void loadInteriorHqSpawns(obj_id hq)
{
	LOG("hq","loadInteriorHqSpawns entered...");

	string filename = utils.getTemplateFilenameNoPath(hq);
	if ( filename != null && !filename.equals("") )
	{
		obj_id[] interiorSpawns = spawnInterior(hq, TBL_SPAWN_INTERIOR_PATH + filename);
		if ( interiorSpawns != null && interiorSpawns.length > 0 )
			utils.setBatchScriptVar(hq, SCRIPTVAR_SPAWN_INTERIOR, interiorSpawns);
	}
}

obj_id[] spawnInterior(obj_id hq, string tbl)
{
	LOG("hq","spawnInterior entered...");
	if ( !isIdValid(hq) || tbl == null || tbl.equals("") )
		return null;

	int numRow = dataTableGetNumRows(tbl);
	if ( numRow > 0 )
	{
		resizeable obj_id[] spawns = new obj_id[0];

		location here = getLocation(hq);

		string myFac = factions.getFaction(hq);
		if ( myFac == null || myFac.equals("") )
			return null;

		LOG("hq","spawnInterior: numRows = " + numRow);
		for ( int i = 0; i < numRow; i++ )
		{
			dictionary params = dataTableGetRow(tbl, i);

			string spawnType = params.getString("SPAWN");
			LOG("hq","spawnInterior: (" + i + ") spawnType = " + spawnType);
			if ( spawnType != null && !spawnType.equals("") )
			{
				float x = params.getFloat("X");
				float y = params.getFloat("Y");
				float z = params.getFloat("Z");
				//float yaw = params.getFloat("HEADING");
				float yaw = params.getFloat("YAW");
				string cellname = params.getString("CELL");

				location there = null;
				if ( cellname != null && !cellname.equals("") )
				{
					if ( cellname.equals("WORLD_DELTA") )
					{
						there = new location(here.x + x, here.y + y, here.z + z);
					}
					else
					{
						obj_id cellId = getCellId(hq, cellname);
						if ( isIdValid(cellId) )
							there = new location(x, y, z, here.area, cellId);
						else
							LOG("hq","spawnInterior: unable to determine id for hq = " + hq + " cell = " + cellname);
					}
				}

				if ( there != null )
				{
					obj_id spawn = null;
					LOG("hq","spawnInterior: attempting to load interior spawn with type: " + spawnType);
					if ( spawnType.startsWith("egg") )
					{
						spawn = createInteriorEgg(hq, there, myFac, yaw);

						if ( spawnType.indexOf(":") > -1 )
						{
							string[] tmpSplit = split(spawnType, ':');
							if ( tmpSplit.length > 1 )
							{
								setObjVar(spawn, VAR_SPAWN_TEMPLATE, tmpSplit[1]);
							}
						}
					}
					else
					{
						spawn = create.object(spawnType, there);
						if ( isIdValid(spawn) )
							setYaw(spawn, yaw);
					}

					if ( isIdValid(spawn) )
					{
						spawns = utils.addElement(spawns, spawn);
					}
				}
				else
				{
					LOG("hq","spawnInterior: unable to load valid location for #" + i + " -> spawnType = " + spawnType);
				}
			}
		}

		if ( spawns != null && spawns.length > 0 )
			return spawns;
	}

	return null;
}

obj_id createInteriorEgg(obj_id hq, location there, string myFac, float yaw)
{
	LOG("hq","spawnInterior: loading interior spawn egg...");
	obj_id spawn = create.object(TEMPLATE_SPAWN_EGG, there);
	if ( isIdValid(spawn) )
	{
		LOG("hq","spawnInterior: spawn egg loaded...");
		setObjVar(spawn, VAR_SPAWN_TYPE, ST_SMALL);
		setObjVar(spawn, VAR_SPAWN_PARENT, hq);

		setObjVar(spawn, VAR_SPAWN_YAW, yaw);

		factions.setFaction(spawn, myFac);

		messageTo(spawn, "handleSpawnRequest", null, rand(1,5), false);
		return spawn;
	}
	else
	{
		LOG("hq","spawnInterior: UNABLE TO LOAD interior spawn egg...");
	}

	return null;
}

void loadExteriorHqSpawns(obj_id hq)
{
	LOG("hq","loadExteriorHqSpawns entered...");

	string filename = utils.getTemplateFilenameNoPath(hq);
	if ( filename != null && !filename.equals(""))
	{
		if ( filename.indexOf( "_pvp" ) == -1 )
		{
			obj_id[] exteriorSpawns = spawnExterior(hq, TBL_SPAWN_EXTERIOR_PATH + filename);
			if ( exteriorSpawns != null && exteriorSpawns.length > 0 )
				utils.setBatchScriptVar(hq, SCRIPTVAR_SPAWN_EXTERIOR, exteriorSpawns);
		}
	}
}

obj_id[] spawnExterior(obj_id hq, string tbl)
{
	LOG("hq","spawnExterior entered...");
	if ( !isIdValid(hq) || tbl == null || tbl.equals("") )
		return null;

	resizeable obj_id[] spawns = new obj_id[0];

	location here = getLocation(hq);
	float yaw = getYaw(hq);

	string myFac = factions.getFaction(hq);
	if ( myFac == null || myFac.equals("") )
		return null;

	int numCols = dataTableGetNumColumns(tbl);
	for ( int i = 0; i < numCols; i++ )
	{
		string colName = dataTableGetColumnName(tbl, i);

		string[] locs = dataTableGetStringColumnNoDefaults(tbl, i);
		if ( locs != null && !locs.equals("") )
		{
			for ( int n = 0; n < locs.length; n++ )
			{
				//location spawnLoc = parseExteriorLocation(here, locs[n]);

				java.util.StringTokenizer st = new java.util.StringTokenizer(locs[n], ",");
				if ( st.countTokens() == 2 )
				{
					float dx = utils.stringToFloat(st.nextToken());
					float dz = utils.stringToFloat(st.nextToken());
					if ( dx != Float.NEGATIVE_INFINITY && dz != Float.NEGATIVE_INFINITY )
					{
						location spawnLoc = player_structure.transformDeltaWorldCoord(here, dx, dz, yaw);
						if ( spawnLoc != null )
						{
							obj_id spawn = create.object(TEMPLATE_SPAWN_EGG, spawnLoc);
							LOG("hq","spawnExterior: spawn egg id = " + spawn);
							if ( isIdValid(spawn) )
							{
								if ( colName.equalsIgnoreCase("small") )
								{
									setObjVar(spawn, VAR_SPAWN_TYPE, ST_SMALL);
								}
								else if ( colName.equalsIgnoreCase("med") )
								{
									setObjVar(spawn, VAR_SPAWN_TYPE, ST_MEDIUM);
								}
								else if ( colName.equalsIgnoreCase("large") )
								{
									setObjVar(spawn, VAR_SPAWN_TYPE, ST_LARGE);
								}

								setObjVar(spawn, VAR_SPAWN_PARENT, hq);

								factions.setFaction(spawn, myFac);

								messageTo(spawn, "handleSpawnRequest", null, rand(1,5), false);

								spawns = utils.addElement(spawns, spawn);
							}
						}
					}
				}
			}
		}
	}

	if ( spawns != null && spawns.length > 0 )
		return spawns;

	return null;
}

location parseExteriorLocation(location home, string delta)
{
	if ( home == null || delta == null || delta.equals("") )
		return null;

	java.util.StringTokenizer st = new java.util.StringTokenizer(delta, ",");
	if ( st.countTokens() != 2 )
		return null;

	float dx = utils.stringToFloat(st.nextToken());
	float dz = utils.stringToFloat(st.nextToken());
	if ( dx == Float.NEGATIVE_INFINITY || dz == Float.NEGATIVE_INFINITY )
		return null;

	return new location(home.x+dx, home.y, home.z+dz, home.area);
}

void cleanupHqSpawns(obj_id hq)
{
	LOG("hq","cleanupHqSpawns entered...");
	obj_id[] intSpawn = utils.getObjIdBatchScriptVar(hq, SCRIPTVAR_SPAWN_INTERIOR);
	if ( intSpawn != null && intSpawn.length > 0 )
		utils.destroyObjects(intSpawn);

	obj_id[] extSpawn = utils.getObjIdBatchScriptVar(hq, SCRIPTVAR_SPAWN_EXTERIOR);
	if ( extSpawn != null && extSpawn.length > 0 )
		utils.destroyObjects(extSpawn);

	if ( utils.hasScriptVar(hq, SCRIPTVAR_SPAWN_REINFORCEMENT))
	{
		obj_id reinforcementSpawner = utils.getObjIdScriptVar(hq, SCRIPTVAR_SPAWN_REINFORCEMENT);
		messageTo(reinforcementSpawner, "handleParentCleanup", null, 300, false);
	}
}

void prepareHqDefenses(obj_id hq)
{
	if ( hasObjVar(hq, VAR_DEFENSE_BASE) )
		return;

	string filename = utils.getTemplateFilenameNoPath(hq);
	if ( filename != null && !filename.equals("") )
	{
		string tbl = TBL_DEFENSE_PATH + filename;
		int numCol = dataTableGetNumColumns(tbl);
		for ( int i = 0; i < numCol; i++ )
		{
			string colName = toLower(dataTableGetColumnName(tbl, i));
			string[] data = dataTableGetStringColumnNoDefaults(tbl, i);
			if ( data != null && data.length > 0 )
			{
				obj_id[] tmp = new obj_id[data.length];
				for (int j = 0; j < tmp.length; ++j)
				{
					tmp[j] = obj_id.NULL_ID;
				}
				setObjVar(hq, VAR_DEFENSE_BASE + "." + colName, tmp);
			}
		}

		messageTo(hq, "handleCreateMinefield", null, 5f, false);

		int[] mines = new int[MAX_MINE_TYPES];
		setObjVar(hq, "mines", mines);
	}
}

void cleanupHqDefenses(obj_id hq)
{
	if ( !hasObjVar(hq, VAR_DEFENSE_BASE) )
		return;

	obj_var_list ovl = getObjVarList(hq, VAR_DEFENSE_BASE);
	if ( ovl == null )
		return;

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		obj_var ov = ovl.getObjVar(i);
		if ( ov != null )
		{
			obj_id[] defenses = ov.getObjIdArrayData();
			if ( defenses != null && defenses.length > 0 )
			{
				for ( int x = 0; x < defenses.length; x++ )
				{
					if ( isIdValid(defenses[x]) )
						destroyObject(defenses[x]);
				}
			}
		}
	}
}

void disableHqTerminals(obj_id hq)
{
	setObjVar(hq, VAR_TERMINAL_DISABLE, true);

	obj_id[] terminals = utils.getObjIdBatchScriptVar(hq, SCRIPTVAR_TERMINALS);
	if ( terminals != null && terminals.length > 0 )
	{
		for ( int i = 0; i < terminals.length; i++ )
		{
			if ( !hasScript(terminals[i], SCRIPT_TERMINAL_DISABLE) )
				attachScript(terminals[i], SCRIPT_TERMINAL_DISABLE);
		}
	}
}

void enableHqTerminals(obj_id hq)
{
	setObjVar(hq, VAR_TERMINAL_DISABLE, false);
	removeObjVar(hq, VAR_OBJECTIVE_DISABLED);
	obj_id[] objects = trial.getAllObjectsInDungeon(hq);
	if (objects == null || objects.length == 0)
		return;

	for (int i=0;i<objects.length;i++)
	{
		if (hasScript(objects[i], SCRIPT_TERMINAL_DISABLE))
			detachScript(objects[i], SCRIPT_TERMINAL_DISABLE);
		if (hasObjVar(objects[i], VAR_IS_DISABLED))
			removeObjVar(objects[i], VAR_IS_DISABLED);

	}
}

void loadVulnerability(obj_id hq)
{
	setInvulnerable(hq, true);

	//LOG("hq", "loadVulnerability ********* ENTERED FUNCTION...");
	if ( hasObjVar(hq, VAR_OBJECTIVE_ID) )
		unloadVulnerabilityForObjectReInit(hq);

	int currentTime = getCurrentTimeInSecsNormalized();

	//LOG("hq", "loadVulnerability ********* Real time is " + currentTime);

	if(!hasObjVar(hq, VAR_OBJECTIVE_STAMP))
	{
		setObjVar(hq, VAR_OBJECTIVE_STAMP, currentTime);
		//LOG("hq", "loadVulnerability ********* stamp objvar re-written with current time due to lack of stamp");
	}

	int stamp = getIntObjVar(hq, VAR_OBJECTIVE_STAMP);
	//LOG("hq", "loadVulnerability ********* stamp objvar loaded is = " + stamp);
	int diff = stamp - currentTime;
	//LOG("hq", "loadVulnerability ********* now = " + currentTime);
	//LOG("hq", "loadVulnerability ********* calculated stamp diff = " + diff);

	int checkfutureclose = (int)VULNERABILITY_LENGTH/2;
	int checkfuturefar = (int)VULNERABILITY_CYCLE;
	int checkpastclose = checkfutureclose*-1;
	int checkpastfar = checkfuturefar*-1;

	//LOG("hq", "loadVulnerability ********* checkfutureclose = " + checkfutureclose + " and checkpastclose = " + checkpastclose);
	//LOG("hq", "loadVulnerability ********* checkfuturefar = " + checkfuturefar + " and checkpastfar = " + checkpastfar);

	if ( diff <= checkfutureclose && diff >= checkpastclose )
	{
		//LOG("hq", "loadVulnerability ********* NOTE A: - diff <= checkfutureclose && diff >= checkpastclose -  ATTEMPTING TO LOAD OBJECTIVES...");
		obj_id[] objectives = loadObjectives(hq);
		if ( objectives != null && objectives.length > 0 )
		{
			LOG("hq", "loadVulnerability ********* OBJECTIVES LOADED...");
			setObjVar(hq, VAR_OBJECTIVE_ID, objectives);

			int stampNew = stamp + ((int)VULNERABILITY_CYCLE);

			if ( stampNew < 0 )	//	ERROR CORRECTION SECTION FOR INVALID STAMPS PASSED IN AND BEING RESET. WE'RE TAKING A STAB AT FIXING THE BROKEN STAMP BEFORE RE-WRITING IT.
			{
				stampNew = overdueStampReplacer (stamp, currentTime);
				//LOG("hq", "loadVulnerability ********* NOTE B: - diff <= checkpastclose  newStamp is negative, and thus being recalculated by overdueStampReplacer.");
			}

			//This code block adjusts the faction base to look 'active' on the planetary map
			dictionary mapParams = new dictionary();
			int newStatus = 1;
			mapParams.put( "status", newStatus );
			messageTo(hq, "handleFlagVulnerabilityChange", mapParams, 10, false);
			LOG("hq", "loadVulnerability \\\\\\\\\\\\\\\\\\\\\\\\  fired message to 'handleFlagVulnerabilityChange' with status of : "+newStatus);


			setObjVar(hq, VAR_OBJECTIVE_STAMP, stampNew);	//change status on planetary map to VULNERABLE ('active')
			//LOG("hq", "loadVulnerability ********* NOTE B: - diff <= checkpastclose  newStamp calculated and written out. It is: " + stampNew);
			messageTo(hq, HANDLER_UNLOAD_VULNERABILITY, null, VULNERABILITY_LENGTH, false);
			//LOG("hq", "loadVulnerability ********* NOTE B: - diff <= checkpastclose  Sending new messageTo UNLOADVulnerability with delay of VULNERABILITY_LENGTH: " + VULNERABILITY_LENGTH);
			return;
		}
		else
		{
			//LOG("hq", "loadVulnerability ********* WARNING WARNING WARNING  - OBJECTIVES FAILED TO LOAD...");
		}

		messageTo(hq, HANDLER_LOAD_VULNERABILITY, null, VULNERABILITY_CYCLE + diff, false);
		return;
	}
	else if (diff <= checkpastclose)
	{
		int stampNew = overdueStampReplacer (stamp, currentTime);
		//LOG("hq", "loadVulnerability ********* NOTE B: - overdue stamp replaced by overdueStampReplacer. New stamp is = " + stampNew);
		setObjVar(hq, VAR_OBJECTIVE_STAMP, stampNew);
		int vulnerabilityDelay = stampNew-currentTime;
		messageTo(hq, HANDLER_LOAD_VULNERABILITY, null, vulnerabilityDelay, false);
		//LOG("hq", "loadVulnerability ********* NOTE B: - diff <= checkpastclose  Sending new messageTo loadVulnerability with vulnerabilityDelay of stampNew-currentTime: " + vulnerabilityDelay);
		return;
	}
	else if ( diff > checkfutureclose && diff < checkfuturefar)
	{
		//LOG("hq", "loadVulnerability ********* NOTE C: diff > checkfutureclose && diff < checkfuturefar (STAMP IS coming up, normally)  Sending new messageTo loadVulnerability with delay of diff: " + diff);
		messageTo(hq, HANDLER_LOAD_VULNERABILITY, null, diff, false);
		return;
	}
	else if (diff >= checkfuturefar)
	{
		int stampNew = farFutureStampReplacer (stamp, currentTime);
		setObjVar(hq, VAR_OBJECTIVE_STAMP, stampNew);
		int vulnerabilityDelay = stampNew-currentTime;
		//LOG("hq", "loadVulnerability ********* NOTE D: diff > checkfuturefar (STAMP IS WAY FUTURE)  building new stamp immediately and recalling function right now. New stamp is " + stampNew);
		//LOG("hq", "loadVulnerability ********* NOTE D: diff > checkfuturefar (STAMP IS WAY FUTURE)  Sending new messageTo loadVulnerability with vulnerabilityDelay of stampNew-currentTime: " + vulnerabilityDelay);
		messageTo(hq, HANDLER_LOAD_VULNERABILITY, null, vulnerabilityDelay, false);
	}
}


obj_id[] loadObjectives(obj_id hq)
{
	string filename = utils.getTemplateFilenameNoPath(hq);
	if ( filename == null || filename.equals("") )
		return null;

	string tbl = TBL_OBJECTIVE_PATH + filename;

	int numRows = dataTableGetNumRows(tbl);
	resizeable int[] opt = new int[0];

	for ( int i = 0; i < numRows; i++ )
	{
		opt = utils.addElement(opt, i);
	}

	location here = getLocation(hq);
	float yaw = getYaw(hq);

	resizeable obj_id[] objectives = new obj_id[0];
	for ( int i = 0; i < OBJECTIVE_TEMPLATE.length; i++ )
	{
		int idx = rand(0, opt.length - 1);
		int rowIdx = opt[idx];

		opt = utils.removeElementAt(opt, idx);

		dictionary row = dataTableGetRow(tbl, rowIdx);

		string cellName = row.getString("CELL");
		float dx = row.getFloat("X");
		float dy = row.getFloat("Y");
		float dz = row.getFloat("Z");
		float dyaw = row.getFloat("YAW");

		obj_id objective = null;
		if ( cellName == null || cellName.equals("") || cellName.equals("WORLD_DELTA") )
		{
			location there = player_structure.transformDeltaWorldCoord(here, dx, dz, yaw);
			objective = createObject(OBJECTIVE_TEMPLATE[i], there);
			if ( isIdValid(objective) )
			{
				setYaw(objective, yaw+dyaw);
				utils.addElement(objectives, objective);
			}
		}
		else
		{
			obj_id cellId = getCellId(hq, cellName);
			if ( isIdValid(cellId) )
			{
				location iSpot = new location(dx, dy, dz, here.area, cellId);
				objective = createObjectInCell(OBJECTIVE_TEMPLATE[i], hq, cellName, iSpot);
				if ( isIdValid(objective) )
				{
					setYaw(objective, dyaw);
					utils.addElement(objectives, objective);
				}
			}
		}
	}

	return objectives;
}


int overdueStampReplacer (int stamp, int currentTime)
{
	int timeOverdue = currentTime - stamp;
	int timeOverdueMagnitude = timeOverdue / (int)(VULNERABILITY_CYCLE);
	int stampNew = ((timeOverdueMagnitude+1)*(int)(VULNERABILITY_CYCLE)) + stamp;
	return stampNew;
}


int farFutureStampReplacer (int stamp, int currentTime)
{
	int futureDiff = stamp - currentTime;
	int futureMagnitude = futureDiff / (int)(VULNERABILITY_CYCLE);
	int stampNew = stamp - (futureMagnitude+(int)(VULNERABILITY_CYCLE));
	return stampNew;
}


void unloadVulnerabilityForObjectReInit(obj_id hq)
{
	obj_id[] objectives = getObjIdArrayObjVar(hq, VAR_OBJECTIVE_ID);

	setObjVar(hq, "planetMap.flags", MLF_INACTIVE);
	//planetary_map.updateFacilityActive(hq, false);
	//This code block adjusts the faction base to look 'active' on the planetary map
	dictionary mapParams = new dictionary();
	int newStatus = 0;
	mapParams.put( "status", newStatus );
	messageTo(hq, "handleFlagVulnerabilityChange", mapParams, 10, false);
	LOG("hq", "unloadVulnerabilityForObjectReInit \\\\\\\\\\\\\\\\\\\\\\\\  fired message to 'handleFlagVulnerabilityChange' with status of : "+newStatus);

	removeObjVar(hq, VAR_OBJECTIVE_TRACKING);

	if ( objectives != null && objectives.length > 0 )
	{
		for ( int i = 0; i < objectives.length; i++ )
			destroyObject(objectives[i]);
	}
	activateHackAlarms(hq, false);
	cleanupHqSecurityTeam(hq);	//(if it exists, remove it)
}


void unloadVulnerability(obj_id hq)
{
	//LOG("hq", "UNLOADVulnerability ********* ENTERED FUNCTION...");

	obj_id[] objectives = getObjIdArrayObjVar(hq, VAR_OBJECTIVE_ID);


	//planetary_map.updateFacilityActive(hq, false);
	//This code block adjusts the faction base to look 'active' on the planetary map
	dictionary mapParams = new dictionary();
	int newStatus = 0;
	mapParams.put( "status", newStatus );
	messageTo(hq, "handleFlagVulnerabilityChange", mapParams, 10, false);
	LOG("hq", "unloadVulnerability \\\\\\\\\\\\\\\\\\\\\\\\  fired message to 'handleFlagVulnerabilityChange' with status of : "+newStatus);

	removeObjVar(hq, VAR_OBJECTIVE_TRACKING);

	if ( objectives != null && objectives.length > 0 )
	{
		for ( int i = 0; i < objectives.length; i++ )
			destroyObject(objectives[i]);
	}

	int currentTime = getCurrentTimeInSecsNormalized();
	//LOG("hq", "UNLOADVulnerability ********* NOTE E: currentTime is: " + currentTime);
	int reVulnerableDelay = (int) (VULNERABILITY_CYCLE - VULNERABILITY_LENGTH);
	//LOG("hq", "UNLOADVulnerability ********* NOTE E: reVulnerableDelay which is (int) (VULNERABILITY_CYCLE - VULNERABILITY_LENGTH) = : " + reVulnerableDelay);

	if(hasObjVar(hq, VAR_OBJECTIVE_STAMP))
	{
		int stamp = getIntObjVar(hq, VAR_OBJECTIVE_STAMP);
		//LOG("hq", "UNLOADVulnerability ********* NOTE E: read in stamp. It is = : " + stamp);
		if ( stamp < 0 )
		{
			stamp = overdueStampReplacer (stamp, currentTime);
			//LOG("hq", "UNLOADVulnerability ********* stamp < 0 - stamp replaced by overdueStampReplacer. New stamp is = " + stamp);
		}
		else if (stamp > (stamp + (int)(VULNERABILITY_CYCLE*2)))
		{
			stamp = farFutureStampReplacer (stamp, currentTime);
			//LOG("hq", "UNLOADVulnerability ********* stamp > (stamp + (int)(VULNERABILITY_CYCLE*2)) - stamp replaced by farFutureStampReplacer. New stamp is = " + stamp);
		}

		reVulnerableDelay = stamp - currentTime; // subtract the current time from the new 'go' time to see how far out we are, and send a message with that delay.
		//LOG("hq", "UNLOADVulnerability ********* NOTE E: re-calculated reVulnerableDelay is stamp - currentTime = : " + reVulnerableDelay);
		setObjVar(hq, VAR_OBJECTIVE_STAMP, stamp);
	}
	//LOG("hq", "UNLOADVulnerability ********* NOTE E: Sending new messageTo loadVulnerability with delay of reVulnerableDelay: " + reVulnerableDelay);
	messageTo(hq, "handleDefenderRespawn", null, 5, false);
	activateHackAlarms(hq, false);
	cleanupHqSecurityTeam(hq);	//(if it exists, remove it)
	messageTo(hq, HANDLER_LOAD_VULNERABILITY, null, reVulnerableDelay, false);
	cleanUpHackAlarms(hq);
}


int getCurrentTimeInSecsNormalized()
{
	long now = System.currentTimeMillis();
	long curTime = ((now / 1000) - 1072224000);
	int currentTime = (int) curTime;
	return currentTime;
}


boolean canDisableObjective(obj_id hq, obj_id objective)
{
	//LOG("hq", "library.hq::boolean canDisableObjective(obj_id hq, obj_id objective) ********* entered function");	//=========================****************************************

	LOG("gcw", "checking canDisable Objective for "+hq+" and "+objective);
	if ( !isIdValid(hq) || !isIdValid(objective) )
		return false;

	if ( hasObjVar(objective, VAR_IS_DISABLED) )
		return false;
	LOG("gcw", "getNextObjective is "+getNextObjective(hq));
	if ( objective == getNextObjective(hq) )
		return true;

	return false;
}


obj_id getNextObjective(obj_id hq)
{
	//LOG("hq", "library.hq:: -- obj_id getNextObjective(obj_id hq) ********* entered function...");	//=========================****************************************

	obj_id[] objectives = getObjIdArrayObjVar(hq, VAR_OBJECTIVE_ID);
	if ( objectives == null || objectives.length == 0 )
		return null;

	obj_id[] disabled = getObjIdArrayObjVar(hq, VAR_OBJECTIVE_DISABLED);
	if ( disabled == null || disabled.length == 0 )
	{
		return objectives[0];
	}
	else
	{
		if ( disabled.length < objectives.length )
			return objectives[disabled.length];
	}

	return null;
}


obj_id getPriorObjective(obj_id hq, obj_id objective)
{
	//LOG("hq", "library.hq:: -- obj_id getPriorObjective(obj_id hq, obj_id objective) ********* entered function...");	//=========================****************************************

	obj_id[] objectives = getObjIdArrayObjVar(hq, VAR_OBJECTIVE_ID);
	if ( objectives == null || objectives.length == 0 )
		return null;

	int idx = utils.getElementPositionInArray(objectives, objective);
	if ( idx > 0 && idx < objectives.length )
		return objectives[idx - 1];

	return null;
}


void disableObjective(obj_id hq, obj_id objective)
{
	//LOG("hq", "library.hq:: -- void disableObjective(obj_id hq, obj_id objective) ********* entered function...");	//=========================****************************************

	if ( canDisableObjective(hq, objective) )
	{
		//LOG("hq", "library.hq::disableObjective ********* passed 'canDisableObjective'. Proceeding...");	//=========================****************************************

		resizeable obj_id[] disabled = getResizeableObjIdArrayObjVar(hq, VAR_OBJECTIVE_DISABLED);
		disabled = utils.addElement(disabled, objective);
		setObjVar(hq, VAR_OBJECTIVE_DISABLED, disabled);

		setObjVar(objective, VAR_IS_DISABLED, true);

		messageTo(objective, "handleObjectiveDisabled", null, 1, false);
		activateHackAlarms(hq, true);
		reportHackAlarmToPlanet(hq);
		//spawnRovingSecurityTeam(hq);
	}
}


void disableObjective(obj_id objective)
{
	//LOG("hq", "library.hq:: -- void disableObjective(obj_id objective) ********* entered function...");	//=========================****************************************

	obj_id hq  = null;
	if(hasObjVar(objective, "objParent"))
	{
		hq = getObjIdObjVar(objective, "objParent");

	}
	else
	{
		hq = getTopMostContainer(objective);
	}
	if ( isIdValid(hq) )
		disableObjective(hq, objective);
	else
		LOG("hq", "library.hq::disableObjective(obj_id objective) ********* hq obj_id came in as invalid");	//=========================****************************************
}


void detonateHq(obj_id hq)
{
	float maxDist = getFloatObjVar(hq, "poi.fltSize") - 20f;

	location here = getLocation(hq);

	//move ppl out of building
	obj_id[] players = player_structure.getPlayersInBuilding(hq);
	if ( players != null && players.length > 0 )
	{
		location ejectLoc = getBuildingEjectLocation(hq);
		location worldLoc = getWorldLocation(hq);

		for ( int i = 0; i < players.length; i++ )
			pclib.sendToAnyLocation(players[i], ejectLoc, worldLoc);
	}

	location[] locs = new location[rand(5,9)];
	for ( int i = 0; i < locs.length; i++ )
	{
		location tmpLoc = utils.getRandomLocationInRing(here, 5f, maxDist);
		if ( tmpLoc != null )
		{
			tmpLoc.y = getHeightAtLocation(tmpLoc.x, tmpLoc.z) + rand(0f, 5f);
			locs[i] = tmpLoc;
		}
	}

	dictionary d = new dictionary();
	d.put("locs", locs);

	messageTo(hq, "handleHqDetonation", d, rand(0.1f, 1f), true);
}


void validateDefenseTracking(obj_id hq)
{
	if ( !isIdValid(hq) )
		return;

	if ( !hasObjVar(hq, VAR_DEFENSE_BASE) )
		return;

	obj_var_list ovl = getObjVarList(hq, VAR_DEFENSE_BASE);
	if ( ovl == null )
		return;

	string filename = utils.getTemplateFilenameNoPath(hq);
	if ( filename != null && !filename.equals("") )
	{
		string tbl = TBL_DEFENSE_PATH + filename;
		string[] data = dataTableGetStringColumnNoDefaults(tbl, "TURRET");

		obj_id[] properTurretData = new obj_id[data.length];
		obj_id[] currentTurretData = getObjIdArrayObjVar(hq, VAR_DEFENSE_BASE + ".turret");

		if((currentTurretData != null && properTurretData != null) && currentTurretData.length != properTurretData.length)
		{
			for(int i = 0; i < properTurretData.length; i++)
			{
				if(i < currentTurretData.length)
					properTurretData[i] = currentTurretData[i];
				else
					properTurretData[i] = obj_id.NULL_ID;
			}

			setObjVar(hq, VAR_DEFENSE_BASE + ".turret", properTurretData);
		}
	}

	int numType = ovl.getNumItems();
	for ( int i = 0; i < numType; i++ )
	{
		obj_var ov = ovl.getObjVar(i);
		obj_id[] defenses = ov.getObjIdArrayData();
		if ( defenses != null && defenses.length > 0 )
		{
			for ( int x = 0; x < defenses.length; x++ )
			{
				if (isIdValid(defenses[x]))
				{
					if (!exists(defenses[x]) || (getHitpoints(defenses[x]) < 1))
					{
						dictionary d = new dictionary();
						d.put("sender", defenses[x]);
						messageTo(hq, "handleRemoveDefense", d, 1f, false);
					}
					else if (hasScript(defenses[x], "systems.turret.turret_ai"))
					{
						dictionary d = new dictionary();
						d.put("sender", defenses[x]);
						messageTo(hq, "handleResetTurretControl", d, 1f, false);
					}
				}
			}
		}
	}
	obj_id[] numTur = getObjIdArrayObjVar(hq, "hq.defense.turret");
	if ( numTur == null || numTur.length == 0 )
	{
		detachScript(hq, "faction_perk.hq.base_block");
	}
	int pos = utils.getFirstValidIdIndex(numTur);
	if ( pos > -1 )
	{
		attachScript(hq, "faction_perk.hq.base_block");
	}

	if(hasObjVar(hq, "mines"))
	{
		int[] mines = getIntArrayObjVar(hq, "mines");

		if(mines.length < MAX_MINE_TYPES)
			messageTo(hq, "handleMinefieldValidation", null, 10f, false);
	}
	else
		messageTo(hq, "handleMinefieldValidation", null, 10f, false);
}


void sealEntrance(obj_id hq)
{
	if (!isIdValid(hq) )
		return;

	if (!hasObjVar(hq, VAR_DEFENSE_BASE) )
		return;

	attachScript(hq, "faction_perk.hq.base_block");
}

void ejectEnemyFactionOnLogin(obj_id player)
{
	obj_id structure = getTopMostContainer( player );
	if ( !isIdValid(structure) )
		return;

	int myFac = pvpGetAlignedFaction(structure);
	int tFac = pvpGetAlignedFaction(player);
	if ( isPlayer( player) && pvpGetType( player ) == PVPTYPE_NEUTRAL )
		tFac = 0;

	if (pvpAreFactionsOpposed(myFac, tFac))
	{
		//debugSpeakMsg(item, "Building ID is " + building);
		if (isIdValid(structure))
		{
			string_id warning = new string_id ("faction_perk","destroy_turrets");
			sendSystemMessage (player, warning);
			{
				location there = getBuildingEjectLocation(structure);
				//debugSpeakMsg(item, "Building eject loc is " + there);
					if ( there == null )
						return;

					//setLocation(self, there);
				dictionary params = new dictionary();
				params.put("player", player);
				params.put("loc", there);
				messageTo(structure, "ejectPlayer", params, 1f, false);
			}
		}
		return;
	}
}


void loadFullTimeVulnerability(obj_id hq)
{
	if ( hasObjVar(hq,VAR_OBJECTIVE_ID))
	{
		obj_id[] oldObjectives = getObjIdArrayObjVar(hq, VAR_OBJECTIVE_ID);
		removeObjVar(hq, VAR_OBJECTIVE_TRACKING);
		if ( oldObjectives != null && oldObjectives.length > 0 )
		{
			for ( int i = 0; i < oldObjectives.length; i++ )
			{
				if ( isIdValid(oldObjectives[i]))
					destroyObject(oldObjectives[i]);
			}
		}
	}

	obj_id[] objectives = loadObjectives(hq);
	if ( objectives != null && objectives.length > 0 )
	{
		setObjVar(hq, VAR_OBJECTIVE_ID, objectives);
		//LOG("hq", "library.hq -- loadFullTimeVulnerability(obj_id self): ********* OBJECTIVES LOADED...");
	}

	return;
}



void planetMapVulnerabilityStatusChange(obj_id hq, int newStatus)
{
	//This code block adjusts the faction base to look 'active' on the planetary map
	map_location maploc = getPlanetaryMapLocation(hq);
	//LOG("hq", "planetMapVulnerabilityStatusChange *********************** addPlanetaryMapLocation data: hq= "+hq);
	//LOG("hq", "planetMapVulnerabilityStatusChange **********************  maploc.getLocationName= "+maploc.getLocationName());
	//LOG("hq", "planetMapVulnerabilityStatusChange ***********************  (int)maploc.getX()= "+(int)maploc.getX());
	//LOG("hq", "planetMapVulnerabilityStatusChange *********************  (int)maploc.getY()= "+(int)maploc.getY()+" maploc.getCategory()= "+maploc.getCategory());
	//LOG("hq", "planetMapVulnerabilityStatusChange ***********************  maploc.getSubCategory()= "+maploc.getSubCategory()+" MLT_STATIC");

	//LOG("hq", "planetMapVulnerabilityStatusChange ***********************  newStatus passed in was: "+newStatus);

	byte statusFlag = MLF_INACTIVE;
	if ( newStatus == 1 )
		statusFlag = MLF_ACTIVE;

	//LOG("hq", "planetMapVulnerabilityStatusChange ======================= addPlanetaryMapLocation data: hq= "+hq+" status was flagged as: "+statusFlag);

	addPlanetaryMapLocation(hq, maploc.getLocationName(), (int)maploc.getX(), (int)maploc.getY(),	maploc.getCategory(), maploc.getSubCategory(), MLT_STATIC, statusFlag);
	//LOG("hq", "planetMapVulnerabilityStatusChange +++++++++++++++++ think I just fired  = addPlanetaryMapLocation");
	return;
}




void refundFactionBaseLots(obj_id base)
{
	if ( hasObjVar(base, "lotsRefunded2" ))
		return;

	obj_id baseOwner = getOwner(base);

	string base_template = getTemplateName(base);
	string base_fp_template = player_structure.getFootprintTemplate( base_template );
	if ( base_fp_template == null || base_fp_template.equals("") )
		return;



	int base_lot_cost = (getNumberOfLots(base_fp_template) / 4);
	if (base_lot_cost < 1)
		base_lot_cost = 1;

	int base_lot_refund = base_lot_cost;

	dictionary outparams = new dictionary();
	outparams.put( "baseLotRefund", base_lot_refund );
	//LOG("hq", "library.hq ////--\\\\ Storing lots to refund. Number of lots refunded = : "+base_lot_refund);

	float faction_point_refund = 60000f;
	if ( hasObjVar(base, "lotsRefunded" ))	//already given them faction points, so don't give any more.
		faction_point_refund = 0f;
	outparams.put( "baseFactionRefund", faction_point_refund );
	int baseFaction = pvpGetAlignedFaction(base);
	outparams.put( "baseFaction", baseFaction );
	//LOG("hq", "library.hq ////--\\\\ Storing faction for the base. Value stored was = : "+baseFaction);
	gcw.incrementGCWScore (base);
	setObjVar(base, "lotsRefunded2", 1);

	messageTo(baseOwner, "factionBaseLotRefund", outparams, 1f, true);

	return;
}


void refundBaseUnit(obj_id base)
{
	//LOG("hq", "refundBaseUnit ======================= entered refundBaseUnit. Base obj_id being refunded is "+base);

	obj_id baseOwner = getOwner(base);
	messageTo(baseOwner, "factionBaseUnitRefund", null, 1f, true);
	return;
}


boolean isPvpFactionBase(obj_id base)
{
	if ( hasObjVar(base,"isPvpBase" ))
	{
		return true;
	}
	return  false;
}


void removeCovertDetector(obj_id base)
{
	if ( hasObjVar(base,"hq.defense.covert_detector" ))
		removeObjVar(base,"hq.defense.covert_detector" );
	return;
}






void loadAlarmUnits(obj_id hq)
{
	LOG("hq","loadAlarmUnits entered...");

	string filename = utils.getTemplateFilenameNoPath(hq);
	if ( filename != null && !filename.equals("") )
		spawnAlarmUnits(hq);
}


void spawnAlarmUnits(obj_id hq)
{

	cleanupBaseAlarmUnits(hq);

	string filename = utils.getTemplateFilenameNoPath(hq);
	if ( filename == null || filename.equals("") )
		return;

	if ( filename.indexOf ("hq_s01") != -1 )
		filename = "hq_s01.iff";
	else if ( filename.indexOf ("hq_s02") != -1 )
		filename = "hq_s02.iff";
	else if ( filename.indexOf ("hq_s03") != -1 )
		filename = "hq_s03.iff";
	else if ( filename.indexOf ("hq_s04") != -1 )
		filename = "hq_s04.iff";

	string tbl = "datatables/faction_perk/hq/alarm/"+filename;


 	int numRows = dataTableGetNumRows(tbl);

	location here = getLocation(hq);

	resizeable obj_id[] hackAlarms = new obj_id[0];
	resizeable obj_id[] destructAlarms = new obj_id[0];
	for ( int i = 0; i < numRows; i++ )
	{
		dictionary row = dataTableGetRow(tbl, i);

		string alarmType = row.getString("ALARM");
		LOG("hq","hq::spawnAlarmUnits: (" + i + ") alarmType = " + alarmType);

		if ( alarmType != null && !alarmType.equals("") )
		{
			float x = row.getFloat("X");
			float y = row.getFloat("Y");
			float z = row.getFloat("Z");
			float yaw = row.getFloat("YAW");
			string cellName = row.getString("CELL");

			obj_id alarmUnit = null;
			if ( cellName != null && !cellName.equals(""))
			{
				obj_id cellId = getCellId(hq, cellName);
				if ( isIdValid(cellId) )
				{
					location loc = new location(x, y, z, here.area, cellId);
					alarmUnit = createObjectInCell(alarmType, hq, cellName, loc);

					setLocation(alarmUnit, loc);	//desperation move to get these things off the floor!... 'some testing later' -- WTF. It worked!
					setYaw(alarmUnit, yaw);
					//double degreePitch = Math.PI;
					transform alarmTransform = getTransform_o2p(alarmUnit);
					if ( alarmType.indexOf ("alarm_hack") != -1)
						alarmTransform = alarmTransform.pitch_l((float)((Math.PI)/2));
					else
						alarmTransform = alarmTransform.pitch_l((float)Math.PI);
					setTransform_o2p(alarmUnit, alarmTransform);

					if ( isIdValid(alarmUnit) )
					{
						if ( alarmType.indexOf ("hack") != -1 )
							utils.addElement(hackAlarms, alarmUnit);
						else if ( alarmType.indexOf ("destruct") != -1 )
							utils.addElement(destructAlarms, alarmUnit);
						else
							destroyObject(alarmUnit);
					}
				}
			}
		}
	}
	if ( hackAlarms.length > 0 )
		setObjVar(hq, "hq.alarm.hack", hackAlarms);
	if ( destructAlarms.length > 0 )
		setObjVar(hq, "hq.alarm.destruct", destructAlarms);

	return;
}


void activateHackAlarms(obj_id hq, boolean activate)
{
	if ( hasObjVar(hq, "hq.alarm.hack" ))
	{
		resizeable obj_id[] hackAlarmList = getResizeableObjIdArrayObjVar(hq, "hq.alarm.hack");
		for(int i = 0; i< hackAlarmList.length; i++)
		{
			if ( activate == true )
			{
				setCondition(hackAlarmList[i], CONDITION_ON);
				messageTo(hq, "handleAlarmMute", null, 600, false);
			}
			else
				clearCondition(hackAlarmList[i], CONDITION_ON);
		}
	}
	return;
}


void activateDestructAlarms(obj_id hq, boolean activate)
{
	if ( hasObjVar(hq, "hq.alarm.destruct" ))
	{
		resizeable obj_id[] destructAlarmList = getResizeableObjIdArrayObjVar(hq, "hq.alarm.destruct");
		for(int i = 0; i< destructAlarmList.length; i++)
		{
			if ( activate == true )
				setCondition(destructAlarmList[i], CONDITION_ON);
			else
			{
				clearCondition(destructAlarmList[i], CONDITION_ON);
				cleanUpHackAlarms(hq);
			}
		}
	}
	return;
}


void cleanupBaseAlarmUnits(obj_id hq)
{
	if ( hasObjVar(hq, "hq.alarm.hack" ))
	{
		resizeable obj_id[] hackAlarms = getResizeableObjIdArrayObjVar(hq, "hq.alarm.hack");
		if (hackAlarms.size () > 0)
		{
			obj_id[] hackAlarmList = new obj_id[hackAlarms.size()];
			hackAlarms.toArray (hackAlarmList);
			utils.destroyObjects(hackAlarmList);
			removeObjVar(hq, "hq.alarm.hack" );
		}
	}
	if ( hasObjVar(hq, "hq.alarm.destruct" ))
	{
		resizeable obj_id[] destructAlarms = getResizeableObjIdArrayObjVar(hq, "hq.alarm.destruct");
		if (destructAlarms.size () > 0)
		{
			obj_id[] destructAlarmList = new obj_id[destructAlarms.size()];
			destructAlarms.toArray (destructAlarmList);
			utils.destroyObjects(destructAlarmList);
			removeObjVar(hq, "hq.alarm.destruct" );
		}
	}
}



void spawnRovingSecurityTeam(obj_id hq)
{
	string hqTemplate = utils.getTemplateFilenameNoPath(hq);
	int sizeOfBase = 1;

	if ( hqTemplate.indexOf ("hq_s02") != -1 )
		sizeOfBase = 2;
	else if ( hqTemplate.indexOf ("hq_s03") != -1 )
		sizeOfBase = 3;
	else if ( hqTemplate.indexOf ("hq_s04") != -1 )
		sizeOfBase = 4;

	location start = getGoodLocation(hq, "entry");
	string[] base_cells = getCellNames(hq);
	location[] locs = new location [base_cells.length];
	for(int i = 0; i< base_cells.length; i++)
		locs[i] = getGoodLocation(hq, base_cells[i]);

	int numRespondersCheck = rand(0,5);
	int numResponders = 0;
	switch (numRespondersCheck)
	{
		case 5:
			numResponders = 3*sizeOfBase;
			break;

		case 4:
			numResponders = 2*sizeOfBase;
			break;

		case 3:
			numResponders = sizeOfBase;
			break;
	}

	if ( numResponders == 0 )
		return;

	loadReinforcementSpawn(hq);	//This is a major sub-module. If we spawn roving guards, we also spawn an outdoor 'reinforcement' continegent. This call handles that.

	dictionary params = new dictionary();
	params.put( "locs", locs );
	params.put( "start", start );


	for ( int i = 0; i < numResponders; i++ )
	{
		string guard = guardKeyPicker(hq);
		params.put( "guard", guard );
		messageTo(hq, "handleSpawnSecurityRover", params, rand(i,i+5), false);
	}

	return;
}



string guardKeyPicker(obj_id hq)
{
	int spawnType = ST_SMALL;

	string template = utils.getTemplateFilenameNoPath(hq);
	LOG("hq","hq::guardKeyPicker -- parent template = " + template);
	if ( template == null || template.equals("") )
		return null;

	string tbl = TBL_SPAWN_EGG_PATH + template;
	LOG("hq","hq::guardKeyPicker -- tbl = " + tbl);

	string[] spawnList = null;
	spawnList = dataTableGetStringColumnNoDefaults(tbl, "small");

	if ( spawnList == null || spawnList.length == 0 )
	{
		LOG("hq","hq::guardKeyPicker -- spawnList returned from datatable with invalid data...");
		return null;
	}

	string spawnKey = spawnList[rand(0,spawnList.length - 1)];
	LOG("hq","hq::guardKeyPicker -- spawnKey = " + spawnKey);
	if ( spawnKey == null || spawnKey.equals("") )
		return null;

	return spawnKey;
}



void cleanupHqSecurityTeam(obj_id hq)
{
	if ( utils.hasScriptVar(hq, "hq.spawn.security" ))
	{
		resizeable obj_id[] securityTeam = utils.getResizeableObjIdArrayScriptVar(hq, "hq.spawn.security");
		if (securityTeam.size () > 0)
		{
			obj_id[] securityDetail = new obj_id[securityTeam.size()];
			securityTeam.toArray (securityDetail);
			utils.destroyObjects(securityDetail);
		}
	}
}


void loadReinforcementSpawn(obj_id hq)		//WORK ON EXTERIOR REINFORCEMENT SPAWNER
{
	//LOG("hq","hq.loadReinforcementSpawn entered...");

	if ( utils.hasScriptVar(hq, SCRIPTVAR_SPAWN_REINFORCEMENT))
		return; //we've already spawned reinforcements. No more. :-)

	string filename = utils.getTemplateFilenameNoPath(hq);
	if ( filename != null && !filename.equals(""))
	{
		if ( filename.indexOf( "_pvp" ) != -1 )
		{
			/*
			int intIndex = filename.indexOf("_pvp");
			string strNewString = filename.subString(0, intIndex));
			filename = strNewString;
			 */
			int idx = filename.indexOf("_pvp");
			if(idx >= 0)
				filename = filename.substring(idx-1);
		}
		obj_id reinforcementSpawner = spawnReinforcements(hq, TBL_SPAWN_EXTERIOR_PATH + filename);	//change this to 'spawnReinforcementWithShuttle' if I ever get that scripted
		if ( isIdValid(reinforcementSpawner))
			utils.setScriptVar(hq, SCRIPTVAR_SPAWN_REINFORCEMENT, reinforcementSpawner);	//CHANGE THIS TO THE REINFORCEMENT TRACKING OBJVARS
	}
}


obj_id spawnReinforcements(obj_id hq, string tbl)
{
	//LOG("hq","hq::spawnReinforcements entered...");
	if ( !isIdValid(hq) || tbl == null || tbl.equals("") )
		return null;

	string myFac = factions.getFaction(hq);
	if ( myFac == null || myFac.equals("") )
		return null;

	location reinforcementSpawnLoc = utils.findLocInFrontOfTarget(hq, (float)(rand(30.0f,50.0f)));

   	if ( reinforcementSpawnLoc != null )
   	{
   		obj_id spawn = create.object(TEMPLATE_SPAWN_EGG, reinforcementSpawnLoc);  //change this to 'spawnReinforcementWithShuttle' if I ever get that scripted
   		//LOG("hq","hq::spawnReinforcements: spawn egg id = " + spawn);
   		if ( isIdValid(spawn) )
   		{
   			setObjVar(spawn, VAR_SPAWN_TYPE, ST_LARGE);
   			setObjVar(spawn, VAR_SPAWN_PARENT, hq);
			setObjVar(spawn, "hq.spawn.reinforcements", 1);
   			factions.setFaction(spawn, myFac);
   			messageTo(spawn, "handleSpawnRequest", null, rand(1,5), false);
			return spawn;
		}
	}

	return null;
}

void createMinefield(obj_id hq)
{
	string filename = utils.getTemplateFilenameNoPath(hq);
	string table = TBL_DEFENSE_PATH + "minefield.iff";

	float dx = dataTableGetFloat(table, filename, "x");
	float dz = dataTableGetFloat(table, filename, "z");
	float radius = dataTableGetFloat(table, filename, "radius");

	location here = getLocation(hq);
	float yaw = getYaw(hq);

	location there = player_structure.transformDeltaWorldCoord(here, dx, dz, yaw);
	there.y = here.y;

	obj_id minefield = createObject("object/tangible/faction_perk/faction_base_item/minefield.iff", there);

	if(isIdValid(minefield))
	{
		attachScript(minefield, "faction_perk.minefield.advanced_minefield");
		attachScript(minefield, SCRIPT_DEFENSE_OBJECT);

		factions.setFaction(minefield, factions.getFaction(hq));

		setObjVar(minefield, "pvpCanAttack", 1);
		setInvulnerable(minefield, false);
		persistObject(minefield);

		setObjVar(minefield, VAR_DEFENSE_PARENT, hq);
		setOwner(minefield, hq);

		obj_id[] data = new obj_id[1];
		data[0] = minefield;
		setObjVar(hq, VAR_DEFENSE_BASE + ".minefield", data);
	}
}

int getTotalMines(obj_id hq)
{
	if(!hasObjVar(hq, "mines"))
		return 0;

	int[] mines = getIntArrayObjVar(hq, "mines");
	int total = 0;

	if(mines == null || mines.length == 0)
		return 0;

	for(int i = 0; i < mines.length; i++)
		total += mines[i];

	return total;
}

float getMinefieldRadius(obj_id hq)
{
	string filename = utils.getTemplateFilenameNoPath(hq);
	string table = TBL_DEFENSE_PATH + "minefield.iff";

	return dataTableGetFloat(table, filename, "radius");
}

int getMaxMines(obj_id hq)
{
	string filename = utils.getTemplateFilenameNoPath(hq);
	string table = TBL_DEFENSE_PATH + "minefield.iff";

	return dataTableGetInt(table, filename, "max");
}

int getRandomMineType(obj_id hq)
{
	if(!hasObjVar(hq, "mines"))
		return -1;

	int[] mines = getIntArrayObjVar(hq, "mines");
	if(mines == null || mines.length == 0)
		return -1;

	int max = getTotalMines(hq);
	if(max == 0)
		return -1;

	int roll = rand(1, 100);
	int base_chance = 0;
	int type_counter = 0;
	int type = -1;

	while(type < 0 && type_counter < mines.length)
	{
		if(type_counter == (mines.length - 1))
			type = (mines.length - 1);
		else
		{
			int chance = (int)(((float)mines[type_counter] / (float)max) * 100f);
			base_chance += chance;

			if(roll <= base_chance)
				type = type_counter;
		}

		type_counter++;
	}

	mines[type]--;
	if(mines[type] < 0)
		mines[type] = 0;

	setObjVar(hq, "mines", mines);

	return type;
}

void clearMinefield(obj_id hq)
{
	if(!hasObjVar(hq, "mines"))
		return;

	int[] mines = getIntArrayObjVar(hq, "mines");
	if(mines == null || mines.length == 0)
		return;

	for(int i = 0; i < mines.length; i++)
		mines[i] = 0;

	setObjVar(hq, "mines", mines);
}

//This puts a scriptvar directly one the planet object so the
//Publish GCW Terminal Gift can display data about a HQ under attack
boolean reportHackAlarmToPlanet(obj_id hq)
{
	if(!isValidId(hq))
		return false;

	blog("inside reportHackAlarmToPlanet");

	string myFac = factions.getFaction(hq);
	int intFac = myFac.equals("Rebel") ? gcw.FACTION_REBEL : gcw.FACTION_IMPERIAL;

	blog("reportHackAlarmToPlanet "+intFac);

	location baseLocation = getLocation(hq);
	string planet = baseLocation.area;
	
	if(planet == null || planet.equals(""))
		return false;

	blog("reportHackAlarmToPlanet "+planet);

	obj_id planetId = getPlanetByName(planet);
	if(!isIdValid(planetId))
		return false;

	blog("reportHackAlarmToPlanet "+planetId);

	string treePrefix = ".hq_";
	string treeSuffix = "";	

	int maxBasesOnPlanet = gcw.getCurrentPlanetaryFactionBaseMaxPlanet(planet);
	if(maxBasesOnPlanet <= 0)
		return false;
	
	blog("reportHackAlarmToPlanet "+maxBasesOnPlanet);
	dictionary baseDic = new dictionary();
	if(utils.hasScriptVarTree(planetId, gcw.VAR_BASE_HACK_DICTIONARY))
	{
		for(int i = 1; i < maxBasesOnPlanet; i++)
		{
			if(utils.hasScriptVar(planetId, gcw.VAR_BASE_HACK_DICTIONARY+treePrefix+i))
			{
				baseDic = utils.getDictionaryScriptVar(planetId, gcw.VAR_BASE_HACK_DICTIONARY+treePrefix+i);
				blog("reportHackAlarmToPlanet baseid: "+baseDic.getObjId("id"));
				blog("reportHackAlarmToPlanet hq id: "+hq);
				
				if(baseDic.getObjId("id") == hq)
					return false;					
	
				continue;
			}
			treeSuffix = ""+i;
			break;
		}
	}
	else
	{
		treeSuffix = "1";
	}

	blog("reportHackAlarmToPlanet "+treeSuffix);

	dictionary baseData = new dictionary();
	baseData.put("id", hq);
	baseData.put("faction", intFac);
	baseData.put("location", baseLocation);
	utils.setScriptVar(planetId, gcw.VAR_BASE_HACK_DICTIONARY+treePrefix+treeSuffix, baseData);

	blog("reportHackAlarmToPlanet set script var: "+gcw.VAR_BASE_HACK_DICTIONARY+treePrefix+treeSuffix);

	return true;
}

//This removes any hack alarms when the HQ is saved or destroyed
boolean cleanUpHackAlarms(obj_id hq)
{
	if(!isValidId(hq))
		return false;
	blog("in cleanUpHackAlarms ");
		
	location baseLocation = getLocation(hq);
	string planet = baseLocation.area;
	obj_id planetId = getPlanetByName(planet);
	if(!isIdValid(planetId))
	 return false;

	blog("cleanUpHackAlarms planet: "+planet);	
	blog("cleanUpHackAlarms planetId: "+planetId);	 
	 
	if(!utils.hasScriptVarTree(planetId, gcw.VAR_BASE_HACK_DICTIONARY))
		return false;

	blog("cleanUpHackAlarms hasScriptVarTree");	 

	int maxBasesOnPlanet = gcw.getCurrentPlanetaryFactionBaseMaxPlanet(planet);
	if(maxBasesOnPlanet <= 0)
		return false;

	blog("cleanUpHackAlarms hasScriptVarTree maxBasesOnPlanet: "+maxBasesOnPlanet);	 

	string treePrefix = ".hq_";

	dictionary baseDic = new dictionary();
	for(int i = 1; i < maxBasesOnPlanet; i++)
	{
		baseDic = utils.getDictionaryScriptVar(planetId, gcw.VAR_BASE_HACK_DICTIONARY+treePrefix+i);
		if(baseDic == null)
		{
			blog("cleanUpHackAlarms hasScriptVarTree baseDic: "+baseDic);	 		
			return false;
		}	
		else if(baseDic.getObjId("id") != hq)
			continue;
		
		utils.removeScriptVar(planetId, gcw.VAR_BASE_HACK_DICTIONARY+treePrefix+i);
		blog("cleanUpHackAlarms removeScriptVar: "+gcw.VAR_BASE_HACK_DICTIONARY+treePrefix+i); 		
	}
	return true;
}

boolean blog(string msg)
{
	//LOG("gcw_terminal",msg);
	return true;
}
