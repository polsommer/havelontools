//******************************************************
// Copyright (c) ©2000,2001 Sony Online Entertainment Inc.
// All Rights Reserved
//
// Title:        qa.scriptlib
// Description:  Collection of QA functions
// @author       $Author: Jesse Benjamin, Jeff Haskell & James Michener$
// @version      $Revision: #2 $
//*******************************************************

//************** INCLUDES ********************************

include java.util.Arrays;
include java.util.HashSet;
include library.buff;
include library.dump;
include library.features;
include library.jedi;
include library.skill;
include library.static_item;
include library.sui;
include library.utils;

//QATool Menu
const string[] QATOOL_MAIN_MENU	= dataTableGetStringColumn( "datatables/test/qa_tool_menu.iff", "main_tool" );
const string QATOOL_TITLE = "QA Tools";
const string QATOOL_PROMPT = "Choose the tool you want to use";

const string[] SPACE_QUEST_TYPES =
{
	"assassinate",
	"delivery",
	"delivery_no_pickup",
	"destroy",
	"destroy_duty",
	"destroy_surpriseattack",
	"escort",
	"escort_duty",
	"inspect",
	"patrol",
	"recovery",
	"recovery_duty",
	"rescue",
	"rescue_duty",
	"space_battle",
	"survival"
};

const string[] GRANT_SPACE_SKILLS = 
{	"_novice",
	"_droid_01",
	"_procedures_01",
	"_weapons_01",
	"_starships_01",
	"_droid_02",
	"_procedures_02",
	"_weapons_02",
	"_starships_02",
	"_droid_03",
	"_procedures_03",
	"_weapons_03",
	"_starships_03",
	"_droid_04",
	"_procedures_04",
	"_weapons_04",
	"_starships_04",
	"_master"
};

const string[] REVOKE_SPACE_SKILLS =
{
	"_master",
	"_starships_04",
	"_weapons_04",
	"_procedures_04",
	"_droid_04",
	"_starships_03",
	"_weapons_03",
	"_procedures_03",
	"_droid_03",
	"_starships_02",
	"_weapons_02",
	"_procedures_02",
	"_droid_02",
	"_starships_01",
	"_weapons_01",
	"_procedures_01",
	"_droid_01",
	"_novice"
};

const string[][] KNOWN_CHARACTER_SLOTS =
{
	{
		"hat",
		"earring_l",
		"earring_r",
		"eyes",	
		"neck",	
		"chest1",
		"chest2",
		"chest3_l",
		"chest3_r",
		"back",
		"cloak",
		"bicep_l",
		"bicep_r",	
		"bracer_upper_r",
		"bracer_lower_r",
		"bracer_upper_l",
		"bracer_lower_l",
		"wrist_l",
		"wrist_r",
		"gloves",	
		"hold_r",
		"hold_l",
		"ring_l",
		"ring_r",
		"utility_belt",
		"pants1",
		"pants2",
		"shoes"
	}
	,
	{
		"Hat: ",
		"Left ear ring: ",
		"Right ear ring: ",
		"Eyes: ",	
		"Neck: ",	
		"Primary chest: ",
		"Secondary chest: ",
		"Trinary chest left",
		"Trinary chest right",
		"Back:",
		"Cloak: ",
		"Left bicep: ",
		"Right bicep: ",	
		"Upper right bracer: ",
		"Lower right bracer: ",
		"Upper left bracer: ",
		"Left lower bracer: ",
		"Left wrist: ",
		"Right wrist: ",
		"Gloves: ",	
		"Holding right hand: ",
		"Holding left hand: ",
		"Left ring: ",
		"Right ring: ",
		"Belt: ",
		"Primary pants: ",
		"Secondary pants: ",
		"Shoes: "
	}
	
};

const string DAMAGE_PID_SCRIPTVAR = "doDamage.pid";
const string DAMAGE_SCRIPTVAR = "doDamageVar";
const string HEAL_PID_SCRIPTVAR = "healDamage.pid";
const string HEAL_SCRIPTVAR = "healDamageVar";
const string HEAL_TOOL_PROMPT = "Give the amount you want to heal the target for.  This tool will heal in the amount you specify as long as it doesn't exceed the target's maximum health.";
const string HEAL_TOOL_TITLE = "HEAL AMOUNT";
const string DAMAGE_TOOL_PROMPT = "Give the amount you want to damage the target for.  This tool will cause damage in the amount you specify.  ARMOR AND OTHER MITIGATION WILL NOT BE CONSIDERED.  Use the Mitigation Tool to test Mitigation.";
const string DAMAGE_TOOL_TITLE = "DAMAGE AMOUNT";
const string FROG_STRING = "object/tangible/terminal/terminal_character_builder.iff"; // frog template name
const string KASHYYYK_FROG_STRING = "object/tangible/terminal/terminal_kashyyyk_content.iff"; // kashyyyk content tool name
//********************** Functions ************************************************

//****************QATool Main Menu*************************************************
//
//
//*********************************************************************************
void qaToolMainMenu(obj_id player)
{
	qa.refreshMenu(player, QATOOL_PROMPT, QATOOL_TITLE, QATOOL_MAIN_MENU, "toolMainMenu", true, "qatool.pid");
}

//**************** Refresh Menu ***************************************************
// Draws the SUI window.  Takes players obj_id, the prompt, title, array of options,
// message handler and a boolean value wether you want it to have the cancel button
//
//*********************************************************************************
void refreshMenu ( obj_id player, string prompt, string title, string[] options, string myHandler, boolean cancel, string PIDVar)
{
	obj_id self = getSelf();
	closeOldWindow(player, PIDVar);

	int pid = sui.listbox(self, player, prompt, sui.OK_CANCEL, title, options, myHandler, false, false);
	//do you want a cancel button?  if not a back button is drawn instead
	if (cancel == false)
		setSUIProperty(pid, sui.LISTBOX_BTN_CANCEL, sui.PROP_TEXT,"Back");
	sui.showSUIPage(pid);
	setWindowPid(player, pid, PIDVar);
}

//**************** Refresh Menu **************************************************
// Draws the SUI window.  Takes players obj_id, the prompt, title, array of options,
// message handler and a boolean value wether you want it to have the cancel button.
// This function takes the SUI PID as well as a scriptVar you want to attach to the tester.
//*********************************************************************************
void refreshMenu ( obj_id player, string prompt, string title, string[] options, string myHandler, boolean cancel, string PIDVar, string scriptVar)
{
	//obj_id self = getSelf();
	closeOldWindow(player, scriptVar);

	int pid = sui.listbox(player, player, prompt, sui.OK_CANCEL, title, options, myHandler, false, false);
	//do you want a cancel button?  if not a back button is drawn instead
	if (cancel == false)
		setSUIProperty(pid, sui.LISTBOX_BTN_CANCEL, sui.PROP_TEXT,"Back");
	sui.showSUIPage(pid);
	setWindowPid( player, pid, PIDVar );
	utils.setScriptVar( player, scriptVar, options );
}

//this version allows you to have an OK, Cancel, and a Back button.
void refreshMenu ( obj_id player, string prompt, string title, string[] options, string myHandler, string scriptVar, int btnConfig)
{
	//obj_id self = getSelf();
	closeOldWindow(player, scriptVar);

	int pid = sui.listbox(player, player, prompt, btnConfig, title, options, myHandler, false, false);
	sui.listboxUseOtherButton(pid, "Back");
	sui.showSUIPage(pid);
	setWindowPid(player, pid, scriptVar);
}

//this version allows you to have an OK, Cancel, and a Back button.  You may also designate the pidvar
void refreshMenu ( obj_id player, string prompt, string title, string[] options, string myHandler, string PIDVar, string scriptVar, int btnConfig)
{
	closeOldWindow(player, scriptVar);

	int pid = sui.listbox(player, player, prompt, btnConfig, title, options, myHandler, false, false);
	sui.listboxUseOtherButton(pid, "Back");
	sui.showSUIPage(pid);
	setWindowPid( player, pid, PIDVar );
	utils.setScriptVar( player, scriptVar, options );
}

//**************** Refresh Menu for 2 Dimensional Arrays***************************
// Draws the SUI window with the first column or dimension of the 2 dimensional array.  
// Accepts player's obj_id, the SUI prompt, SUI title, 2 dimensional array of options,
// message handler and a boolean value wether you want it to have the cancel button.
// This function takes the SUI PID as well as a scriptVar you want to attach to the 
// tester.
//*********************************************************************************
void refreshMenu(obj_id player, string prompt, string title, string[][] options, string myHandler, boolean cancel, string PIDVar, string scriptVar)
{
	//obj_id self = getSelf();
	closeOldWindow(player, scriptVar);

	string[] firstDimension = new string[options[0].length];
	for (int i = 0; i < options[0].length; i++)
	{
		firstDimension[i] = options[0][i];
	}
	if (firstDimension.length > 0)
	{
		int pid = sui.listbox(player, player, prompt, sui.OK_CANCEL, title, firstDimension, myHandler, false, false);
		//do you want a cancel button?  if not a back button is drawn instead
		if (cancel == false)
			setSUIProperty(pid, sui.LISTBOX_BTN_CANCEL, sui.PROP_TEXT,"Back");
		sui.showSUIPage(pid);
		setWindowPid(player, pid, PIDVar);
		utils.setScriptVar(player, scriptVar, options);
	}
}

//************ showConfirmationSui *******************************************
//A library version of the SUI Confirmation YES/NO Popup
//****************************************************************************
void showConfirmationSui(obj_id self, string titleText, string confirmationMessage, string handler) 
{	
	int pid = sui.msgbox(self, self, confirmationMessage, sui.YES_NO, titleText, handler);
}

//************ CheckParams ***************************************************
//standard param and index checks uses for nearly all SUI's
//****************************************************************************
void checkParams (dictionary params, string scriptVar)
{
	obj_id player = sui.getPlayerId(params);

	if(( params == null) || (params.isEmpty()))
	{
		sendSystemMessageTestingOnly(player, "Failing, params were empty!");
		removeScriptVars(player, scriptVar);
		return;
	}

	int btn = sui.getIntButtonPressed(params);
	int idx = sui.getListboxSelectedRow(params);

	if ( idx == -1)
	{

		removeScriptVars(player, scriptVar);
		return;
	}

}

//overloaded version that allows you to not check index
void checkParams (dictionary params, string scriptVar, boolean chkIndex)
{
	obj_id player = sui.getPlayerId(params);

	if(( params == null) || (params.isEmpty()))
	{
		sendSystemMessageTestingOnly(player, "Failing, params were empty!");
		utils.removeScriptVarTree(player, scriptVar);
		return;
	}

	int btn = sui.getIntButtonPressed(params);
	int idx = sui.getListboxSelectedRow(params);
	if( chkIndex == true)
	{
		if ( idx == -1)
		{

			utils.removeScriptVarTree(player, scriptVar);
			return;
		}
	}
}

//*************** closeOldWindow ******************************************
// closes old SUI window
// Pass it the players obj_id, and the scripvar you attached to track the
// SUI commands
//*************************************************************************
void closeOldWindow(obj_id player, string scriptVar)
{
	if ( utils.hasScriptVar(player, scriptVar))
	{
		int oldpid = utils.getIntScriptVar(player, scriptVar);
		forceCloseSUIPage (oldpid);
		utils.removeScriptVarTree(player, scriptVar);
	}
}

//********** SetWindowPid *************************************************
// sets a SUI scriptvar so you can track it.
// Pass it the players obj_id and the scripvar.pid you are using to track
// the SUI use
//*************************************************************************
void setWindowPid(obj_id player, int pid, string scriptVar)
{
    	if (pid > -1)
    	{
		utils.setScriptVar(player, scriptVar, pid);
	}
}

//************************ Populate Array ***************************************************
// Takes player id, datatable name, your badge choice, and two column names
// finds the matching cell in column 2for each case of the badge choice in column 1
// creates a HashSet with this value, the converts the Set to an array and returns that array
//*******************************************************************************************

String[] populateArray(obj_id player, string datatableName, string choice, string column1, string column2)
{
	//finds the column numbers for both columns passed as strings
	int firstColumn = dataTableFindColumnNumber(datatableName, column1);
	int secondColumn = dataTableFindColumnNumber(datatableName, column2);
	//create a string arrays that have all the values of from the columns
	string[] firstColumnArray = dataTableGetStringColumn(datatableName,firstColumn);
	string[] secondColumnArray = dataTableGetStringColumn(datatableName,secondColumn);

	HashSet theSet = new HashSet();

	if(firstColumnArray == null || secondColumnArray == null)
		return null;

	//find all the matching choices in the first column and assign the corresponding
	//values in the second column to the set
	for (int y = 0; y < firstColumnArray.length; y++)
	{

		if( choice == firstColumnArray[y])
		{
			if (secondColumnArray[y] != "")
				theSet.add(secondColumnArray[y]);

		}
	}
	//convert the set to a string array
	string[] menuArray = new string[theSet.size()];
	theSet.toArray(menuArray);
	Arrays.sort(menuArray);
	return menuArray;
}

//*********************** Populate array ***************************************************
// Takes in players id, the column header you need, the datatable
// creates a dynamic array that holds all the unique values in the passed column
//*******************************************************************************************

String[] populateArray (obj_id player, string col, string datatableName)
{
	String[] errorZeroLengthArray = {"The Array was empty, could be that you passed the wrong type"};
	//create an array of the values in the datatable columns
	string[] arrayList = dataTableGetStringColumn(datatableName,col);

	if (arrayList.length == 0)
	{
		sendSystemMessageTestingOnly(player, "Tool Not Functioning because the Datatable Rows equal ZERO!");
		return errorZeroLengthArray;
	}


	int listingLength = arrayList.length;
	HashSet theSet = new HashSet();
	//loop thru array and add items to the set
	for (int y = 0; y < listingLength; y++)
		theSet.add(arrayList[y]);
	//convert set to a string array
	string[] menuArray = new string[theSet.size()];
	theSet.toArray(menuArray);
	Arrays.sort(menuArray);
	return menuArray;
}

//overloaded to allow you to omit one type in the column
String[] populateArray (obj_id player, string col, string datatableName, string noNeed)
{
	String[] errorZeroLengthArray = {"The Array was empty, could be that you passed the wrong type"};
	//create an array of the values in the datatable columns
	string[] arrayList = dataTableGetStringColumn(datatableName,col);

	if (arrayList.length == 0)
	{
		sendSystemMessageTestingOnly(player, "Tool Not Functioning because the Datatable Rows equal ZERO!");
		return errorZeroLengthArray;
	}


	int listingLength = arrayList.length;
	HashSet theSet = new HashSet();
	//loop thru array and add items to the set
	for (int y = 0; y < listingLength; y++)
	{
		if( arrayList[y] != noNeed)
			//we dont need this
			theSet.add(arrayList[y]);
	}
	//convert set to a string array
	string[] menuArray = new string[theSet.size()];
	theSet.toArray(menuArray);
	Arrays.sort(menuArray);
	return menuArray;
}

String[] populateArrayDoNotSort ( obj_id player, string col, string datatableName )
{
	//create an array of the values in the datatable column
	string[] menu = dataTableGetStringColumn( datatableName, col);

	Vector theVectorData = new Vector();
	for (int i = 0; i < menu.length; i++)
	{
		if (menu[i] != "")
		{
			theVectorData.addElement(menu[i]);
		}
	}
	string[] menuArray = new string[theVectorData.size()];
	theVectorData.toArray(menuArray);
	return menuArray;
}

//**************************************************************************
// Remove ScriptVars.  Use this function to remove your scriptvars, and it
// Automatically remove the slash commands scriptvars as well.
//**************************************************************************

void removeScriptVars(obj_id player, string scriptVar)
{
	utils.removeScriptVarTree(player,"qatool");
	utils.removeScriptVarTree(player, scriptVar);
}

/********************Removes Scriptvars -- player **************************
***********************receives an error message****************************
***************************************************************************/
void removePlayer(obj_id player, string SCRIPTVAR, string err)
{
	sendSystemMessageTestingOnly(player, err);
	qa.removeScriptVars(player, SCRIPTVAR);
	utils.removeScriptVarTree(player, SCRIPTVAR);
}

//**************** createInputBox **************************************************
// Draws the SUI Input Box and assigns UI PID
//*********************************************************************************

void createInputBox ( obj_id player, string prompt, string title, string myHandler, string scriptVar )
{
	//sendSystemMessageTestingOnly(player, "Running Inputbox Function");
	qa.closeOldWindow(player, scriptVar);	
	int pid = sui.inputbox( player, player, prompt, sui.OK_CANCEL, title, sui.INPUT_NORMAL, null, myHandler, null );

	sui.showSUIPage(pid);
	
	setWindowPid( player, pid, scriptVar );
	utils.setScriptVar( player, scriptVar, player );
}

//**************** createMsgBox **************************************************
// Draws the SUI YES or NO Popup Msg Box and assigns UI PID
//*********************************************************************************

void createMsgBox(obj_id player, string prompt, string title, string myHandler, string scriptVar)
{
	//sendSystemMessageTestingOnly(player, "Running Popup box Function");
	qa.closeOldWindow(player, scriptVar);	
	int pid = sui.msgbox(player, player, prompt, sui.YES_NO, title, myHandler); 

	sui.showSUIPage(pid);
	
	setWindowPid( player, pid, scriptVar );
	utils.setScriptVar( player, scriptVar, player );
}

//**************** spawnStaticItemInInventory **************************************************
// Spawns items from the static item data table into tester inventory
//*********************************************************************************

void spawnStaticItemInInventory(obj_id self, string staticItemString, string altMessage)
{
	//sendSystemMessageTestingOnly( self, "altMessage "+altMessage );
	string messageString = "";
	if (altMessage != "none")
	{
		messageString = altMessage;
	}
	else
	{
		messageString = staticItemString;	
	}
	
	obj_id inv = utils.getInventoryContainer( self );
	if( isIdValid(inv) )
	{
		obj_id[] objContents = utils.getContents(inv, true);

		if( objContents.length >= 80 )
		{
			sendSystemMessageTestingOnly(self, "Empty your inventory before trying to spawn more items");
		}
		else
		{
			static_item.createNewItemFunction(staticItemString, inv);
			sendSystemMessageTestingOnly(self, messageString+" was placed in your inventory");
			CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has spawned (" + staticItemString + ") using a QA Tool or command.");
		}
	}
}

//**************** spawnStaticItemInInventory **************************************************
// Spawns items from the static item data table into tester inventory
// Overloaded with a boolean in case no system message is desired
// Returns obj_id of static item
//*********************************************************************************

obj_id spawnStaticItemInInventory(obj_id self, string staticItemString, string altMessage, boolean silent)
{
	//sendSystemMessageTestingOnly( self, "altMessage "+altMessage );
	string messageString = "";
	if (altMessage != "none")
	{
		messageString = altMessage;
	}
	else
	{
		messageString = staticItemString;	
	}
	
	obj_id inv = utils.getInventoryContainer( self );
	if( isIdValid(inv) )
	{
		obj_id[] objContents = utils.getContents(inv, true);

		if( objContents.length >= 80 )
		{
			sendSystemMessageTestingOnly(self, "Empty your inventory before trying to spawn more items");
		}
		else
		{
			obj_id staticItemId = static_item.createNewItemFunction(staticItemString, inv);
			if (!silent)
				sendSystemMessageTestingOnly(self, messageString+" was placed in your inventory");
			CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has spawned (" + staticItemString + ") using a QA Tool or command.");
			return staticItemId;
		}
	}
	return null;
}

//**************** findTarget **************************************************
// Looks for a valid player lookAtTarget obj_id.  
// If none found, returns the instantiator as the valid obj_id
//*********************************************************************************

obj_id findTarget(obj_id self)
{	
	obj_id intendedTarget = getIntendedTarget(self);
	obj_id lookAtTarget = getLookAtTarget(self);
	obj_id finalTarget = null;

	if (isIdValid(intendedTarget))
	{
		finalTarget = intendedTarget;
	}
	else if (isIdValid(lookAtTarget))
	{
		finalTarget = lookAtTarget;
	}
	else 
	{
		finalTarget = self;
	}
	if (!isIdNull(finalTarget))
	{
		return finalTarget;
	}
	return self;
}

// Finds item stat mods and returns the data
// USED FOR THE QA DUMP LIBRARY
string getObjectVariables(obj_id self, obj_id item)
{
	string objvariable = "";
	
	string strObjVars = getPackedObjvars(item);
	string[] strSplit = split(strObjVars, '|');
	if(strSplit.length>2)
	{
		for(int intI = 0; intI < strSplit.length-2; intI++)
		{
			objvariable += "\t";
			objvariable += strSplit[intI];
			objvariable += "=";
			objvariable += strSplit[intI+2];
			objvariable += "\n\r";

			intI = intI+2;
		}
	}
	return objvariable;
}

//**************** qaTargetDump **************************************************
// Collects all relevent object data and returns a combined string.  
// Library uses UI Text Color Codes to help differentiate between data and categories
// The library Color Codes are left out if the data is exported to text
//*********************************************************************************
string qaTargetDump(obj_id self, obj_id objTarget, boolean colorFlag)
{
	//@BUILD / BRANCH
	string strTest = "";
	strTest += "OBJECT ID: \t\t\t"; 	
	strTest += objTarget + "\r\n";
 	strTest += "TEMPLATE NAME: \t\t";
 	strTest += getTemplateName(objTarget) + "\r\n";
 	
 	//Display the static item name of a non-player/creature
 	if (!isMob(objTarget) && !isPlayer(objTarget))
 	{
 		if (getStaticItemName(objTarget) != null)
 		{
	 		strTest += "STATIC ITEM NAME: \t"; 
	 		strTest += getStaticItemName(objTarget)+"\r\n";
		}
	}

 	strTest += "SERVER CLUSTER: \t\t";
	strTest += getClusterName()+"\r\n";
 	strTest += "LOCATION: \t\t\t";
	strTest += getLocation(objTarget)+"\r\n";
 	
 	if (isMob(objTarget) && !isPlayer(objTarget))
 	{
		string codeString = getCreatureName(objTarget);
		string localizedString = localize(new string_id("mob/creature_names", codeString));
		if (localizedString == null)
		{
			localizedString = getEncodedName(objTarget);		
		}

 		strTest += "CREATURE NAME: \t\t";
 		strTest += localizedString + "\r\n";
   		strTest += "CREATURE CODE: \t\t";
 		strTest += codeString + "\r\n";				

 	}
 	
 	if (isPlayer(objTarget))
 	{
		string playerFullName = getName(objTarget);
		string playerCodeString = getPlayerName(objTarget);
 		strTest += "PLAYER FULL NAME: \t";
 		strTest += playerFullName + "\r\n";
  		strTest += "INTERNAL NAME: \t\t";
 		strTest += playerCodeString + "\r\n";
  		strTest += "LOTS USED: \t\t\t" + getAccountNumLots(objTarget)+ "\r\n\r\n";		
 	}
 	
 	if (isMob(objTarget) || isPlayer(objTarget))
 	{
		int healthMax = getMaxAttrib(objTarget, HEALTH);
		int healthCurrent = getAttrib(objTarget, HEALTH);
		int actionMax = getMaxAttrib(objTarget, ACTION);
		int actionCurrent = getAttrib(objTarget, ACTION);
		int mindMax = getMaxAttrib(objTarget, MIND);
		int mindCurrent = getAttrib(objTarget, MIND);

		strTest += "STATS: \r\n\t\tHEALTH - \tMAX: \t";
		strTest += healthMax + "\t";
		strTest += "CURRENT: \t";
		strTest += healthCurrent + "\r\n";
		strTest += "\t\tACTION - \tMAX: \t";
		strTest += actionMax + " \t";
		strTest += "CURRENT: \t";
		strTest += actionCurrent + "\r\n";
		strTest += "\t\tMIND - \t\tMAX: \t";
		strTest += mindMax + "\t\t";
		strTest += "CURRENT: \t";
		strTest += mindCurrent + "\r\n";

		if (isPlayer(objTarget))
		{
			strTest += "\r\nGUILD:\r\n";					
			int guildId = getGuildId(objTarget);
			if (guildId != 0)
			{
				strTest += "Guild ID: " + guildId + "\r\n";
				strTest += "Guild Name: " + guildGetName(guildId) + "\r\n";
				strTest += "Guild Abbrev.: " + guildGetAbbrev(guildId) + "\r\n";
				strTest += "Guild Leader Name & OID: " + getName(guildGetLeader(guildId)) + " " + guildGetLeader(guildId) + "\r\n";
			}
			else
			{
				strTest += "No guild\r\n";
			}
			
			strTest += "\r\nPROFESSION AND WORKING SKILL:\r\n";
			strTest += getSkillTemplate(objTarget) + "\r\n";
			strTest += getWorkingSkill(objTarget) + "\r\n";
			
			strTest += "\r\nBASE SKILL STATS:\r\n";
			strTest += "(Review expertise and skill modifier sections below to see skill stat modifier data)\r\n";
			string[] allSkillModsList = dataTableGetStringColumn("datatables/expertise/skill_mod_listing.iff", "skill_mod");
			int arrayLength = allSkillModsList.length;
			if (allSkillModsList != null)
			{	
				if(arrayLength > 0)
				{
					for(int x = 0; x < arrayLength; x++)
					{
						if (allSkillModsList[x].indexOf("_modified") > 0)
						{
							int underscoreIdx = allSkillModsList[x].indexOf("_");
							string nonModifiedSkillname = allSkillModsList[x].substring(0,underscoreIdx);
							strTest += localize(new string_id( "stat_n", allSkillModsList[x])) + ": " + getSkillStatisticModifier(objTarget, nonModifiedSkillname) + "\r\n";				
						}					
					}
				}
			}

			strTest += "\r\nEXPERTISE:\r\n";

			if (allSkillModsList != null)
			{	
				if(arrayLength > 0)
				{
					for(int x = 0; x < arrayLength; x++)
					{						
						if (allSkillModsList[x].indexOf("expertise_") == 0)
						{
							if (getSkillStatisticModifier(objTarget, allSkillModsList[x]) > 0)
							{
								strTest += localize(new string_id( "stat_n", allSkillModsList[x])) + ": " + getSkillStatisticModifier(objTarget, allSkillModsList[x]) + "\r\n";				
							}
						}					
					}
				}
			}

			strTest += "\r\nSKILL MODIFIERS:\r\n";
			if (allSkillModsList != null)
			{
				if(arrayLength > 0)
				{
					for(int x = 0; x < arrayLength; x++)
					{
						if (getEnhancedSkillStatisticModifierUncapped(objTarget, allSkillModsList[x]) > 0)
						{
							//sendSystemMessageTestingOnly(self, "" + allSkillModsList[x] + ": " + getEnhancedSkillStatisticModifierUncapped(self, allSkillModsList[x]));
							strTest +=  localize(new string_id("stat_n", allSkillModsList[x])) + " ( " +allSkillModsList[x] + " ): " + getEnhancedSkillStatisticModifierUncapped(objTarget, allSkillModsList[x]) + "\r\n";
						}			
					}
				}
			}

			//GCW INFO
			strTest += "\r\nGCW INFO:\r\n";
			int intPlayerFaction = pvpGetAlignedFaction(objTarget);
			if(intPlayerFaction==##"Imperial")
			{
				strTest += "current faction: Imperial \r\n";
			}
			else if(intPlayerFaction==##"Rebel")
			{
				strTest += "current faction: Rebel \r\n";
			}
			else
			{
				strTest += "current faction: Neutral \r\n";
			}


			strTest += "current GCW points: " + pvpGetCurrentGcwPoints(objTarget) + "\r\n";
			strTest += "current GCW rating: " + pvpGetCurrentGcwRating(objTarget) + "\r\n";
			strTest += "current GCW rank: " + pvpGetCurrentGcwRank(objTarget) + "\r\n";
			//strTest += "current GCW rank progress: \r\n"; //+ pvpGetNextGcwRatingCalcTime(objTarget) + "\r\n";

			strTest += "current PvP kills: " + pvpGetCurrentPvpKills(objTarget) + "\r\n";
			strTest += "lifetime GCW points: " + pvpGetLifetimeGcwPoints(objTarget) + "\r\n";
			strTest += "max GCW imperial rating: " + pvpGetMaxGcwImperialRating(objTarget) + "\r\n";
			strTest += "max GCW imperial rank: " + pvpGetMaxGcwImperialRank(objTarget) + "\r\n";
			strTest += "max GCW rebel rating: " + pvpGetMaxGcwRebelRating(objTarget) + "\r\n";
			strTest += "max GCW rebel rank: " + pvpGetMaxGcwRebelRank(objTarget) + "\r\n";
			strTest += "lifetime PvP kills: " + pvpGetLifetimePvpKills(objTarget) + "\r\n";
			strTest += "next GCW rating calculation time: " + pvpGetNextGcwRatingCalcTime(objTarget) + "\r\n";

			//BUFF INFO
			strTest += "\r\nBUFFS/STATES/DoTs, etc.:\r\n";
			
			int[] buffs = _getAllBuffs(objTarget);
			if (buffs != null && buffs.length != 0)
			{		
				for (int i = 0; i < buffs.length; i++)
				{
					obj_id buffOwner = null;
					string buffName = buff.getBuffNameFromCrc(buffs[i]);
					float duration = buff.getDuration(buffName);
					boolean debuff = buff.isDebuff(buffName);
					boolean groupBuff = buff.isGroupBuff(buffName);
					boolean ownedBuff = buff.isOwnedBuff(buffName);
					if (ownedBuff)
						buffOwner = buff.getBuffOwner(objTarget, buffName);
	
					strTest += buffName + "\r\nDuration: " + duration + "\r\n";	
					
					if (debuff)
						strTest += "Debuff: " + debuff + "\r\n";
					if (groupBuff)
						strTest += "Group buff: " + debuff + "\r\n";	
					if (ownedBuff)
					{
						strTest += "Owned buff: " + ownedBuff + "\r\n";
						if (isIdValid(buffOwner))
							strTest += "Buff Owner: " + getName(buffOwner) + "\r\n";
						strTest += "Owner OID: " + buffOwner + "\r\n";
					}
				}
			}
			else
			{
				strTest += "No buffs" + "\r\n";
			}
		}
	}
	
	string readableScripts = dump.getReadableScripts(objTarget);
	if (readableScripts != "<>" && readableScripts != "" && readableScripts.length() > 5)
	{
		strTest += "\n\rATTACHED SCRIPTS:\r\n";
		strTest += readableScripts;					
 		strTest += "\n\r";		
	}

	string objVars = dump.getReadableObjVars(objTarget);
	if (objVars != "<>" && objVars != "" && objVars.length() > 5)
	{
		strTest += "OBJVARS:\r\n";
		strTest += objVars;			
 		strTest += "\n\r";		
	}
	
	string scriptVars = dump.getReadableScriptVars(objTarget);
	if (scriptVars != "<>" && scriptVars != "" && scriptVars.length() > 5)
	{
		strTest += "SCRIPTVARS:\r\n";
		strTest += scriptVars;
 		strTest += "\n\r";				
	}
	
	string localVars = dump.getReadableLocalVars(objTarget);
 	if (localVars != "<>" && localVars != "" && localVars.length() > 5)
 	{
		strTest += "LOCALVARS:\r\n";
		strTest += localVars;
		strTest += "\n\r";
 		sendSystemMessageTestingOnly(self, "LOCALVARS:"+localVars);
	}

	if (isPlayer(objTarget))
	{
		string[] skillList = getSkillListingForPlayer(objTarget);	
		if (skillList != null && skillList.length > 0)
		{
			strTest += "\r\nSKILLS:\r\n";

			for (int i = 0; i < skillList.length; i++)
			{
				strTest += skillList[i] + "\r\n";
			}
		}
		else
		{
			strTest += "\r\nSKILLS:\r\n";
			strTest += "none\r\n";
		}

		string[] allQuests = getAllQuests(self);
		if (allQuests != null && allQuests.length > 0)
		{
			strTest += "\r\nGROUND AND SPACE QUESTS:\r\n";
			strTest += "A = active, C = completed\r\n";

			for (int i = 0; i < allQuests.length; i++)
			{
				strTest += allQuests[i] + "\r\n";
			}
		}
		else
		{
			strTest += "\r\nGROUND AND SPACE QUESTS:\r\n";
			strTest += "none\r\n";
		}

		//Wearables
		strTest += "\r\nWEARABLES:\r\n";
		if (KNOWN_CHARACTER_SLOTS != null)
		{	
			for (int i = 0; i < KNOWN_CHARACTER_SLOTS[0].length; i++)
			{
				//sendSystemMessageTestingOnly(self, " " + KNOWN_CHARACTER_SLOTS[0].length);
				//sendSystemMessageTestingOnly(self, " " + KNOWN_CHARACTER_SLOTS[1][i]);

				obj_id item = getObjectInSlot(objTarget, KNOWN_CHARACTER_SLOTS[0][i]);
				if (isIdValid(item))
				{
					strTest += KNOWN_CHARACTER_SLOTS[1][i] + "\r\n";

					if (getStaticItemName(item) != null)
					{
						strTest += "\tStatic Item Name: " + getStaticItemName(item) + "\r\n";
						//strTest += getWearableSkillMod(self, item);
					}

					if (getTemplateName(item) != null)
					{
						strTest += "\tTemplate: " + getTemplateName(item) + "\r\n";
						strTest += "\tOID: " + item + "\r\n";
						strTest += getObjectVariables(self, item);
						if (jedi.isLightsaber(item))
						{
							obj_id saberInv = getObjectInSlot(item, "saber_inv");							
							obj_id[] saberContents = utils.getContents(saberInv, true);
							if (saberContents != null && saberContents.length > 0)
							{
								for (int s = 0; s < saberContents.length; s++)
								{
									if (isIdValid(saberContents[s]))
									{
										if (getTemplateName(saberContents[s]) != null)
										{
											strTest += "SABER SLOT " + (s+1) + "\r\n";
											strTest += "\tTemplate: " + getTemplateName(saberContents[s]) + "\r\n";
											strTest += "\tOID: " + saberContents[s] + "\r\n";
											strTest += getObjectVariables(self, saberContents[s]);
											strTest += "\r\n";
										}
									}
								}
							}
							else
							{
								strTest += "nothing in saber.\r\n";
							}
						}						
					}
				}
			}
		}
		
		strTest += "\r\nPLAYER DATAPAD:\r\n";
		obj_id targetDatapad = utils.getPlayerDatapad(objTarget);
		if (isIdValid(targetDatapad))
		{
			obj_id[] objContents = utils.getContents(targetDatapad, true);
			
			if (objContents != null && objContents.length > 0)
			{
				for (int i = 0; i < objContents.length; i++)
				{
					if (isIdValid(objContents[i]))
					{
						if (getTemplateName(objContents[i]) != null)
						{
							strTest += "\tTemplate: " + getTemplateName(objContents[i]) + "\r\n";
							strTest += "\tOID: " + objContents[i] + "\r\n";
							strTest += getObjectVariables(self, objContents[i]);
							strTest += "\r\n";
						}
					}
				}
			}
			else
			{
				strTest += "no datpad items.\r\n";
			}
		}

		strTest += "\r\nENEMY FLAGS:\r\n";
		string enemyFlags = dump.getReadableEnemyFlags(objTarget);
		if (enemyFlags != "<>" && enemyFlags != "" && enemyFlags.length() > 5)
		{
			strTest += enemyFlags;
			strTest += "\n\r";			
		}
		else
		{
			strTest += "none\n\r";	
		}		
		
		strTest += "\r\nBOUNTY MISSIONS:\r\n";
		string playerBountyMissions = dump.getReadableBountyMissions(objTarget);
		if (playerBountyMissions != "<>" && playerBountyMissions != "" && playerBountyMissions.length() > 5)
		{
			strTest += playerBountyMissions;
			strTest += "\n\r";			
		}
		else
		{
			strTest += "none\n\r";	
		}

		strTest += "\r\nBOUNTIES:\r\n";
		string playerBounties = dump.getReadableBounties(objTarget);
		if (playerBounties != "<>" && playerBounties != "" && playerBounties.length() > 5)
		{
			strTest += playerBounties;
			strTest += "\n\r";			
		}
		else
		{
			strTest += "none\n\r";	
		}

		strTest += "\r\nBOUNTY HUNTERS WITH BOUNTIES ON ME:\r\n";
		string huntersOfPlayer = dump.getReadableBountyHunters(objTarget);
		if (huntersOfPlayer != "<>" && huntersOfPlayer != "" && huntersOfPlayer.length() > 5)
		{
			strTest += huntersOfPlayer;
			strTest += "\n\r";			
		}
		else
		{
			strTest += "none\n\r";	
		}

		strTest += "\r\nFS QUESTS:\r\n";
		string fsQuestData = dump.getReadableFsQuests(objTarget);
		if (fsQuestData != "<>" && fsQuestData != "" && fsQuestData.length() > 5)
		{
			strTest += fsQuestData;
			strTest += "\n\r";			
		}
		else
		{
			strTest += "none\n\r";	
		}
		
		strTest += "\r\nFS BRANCHES UNLOCKED:\r\n";
		string fsBranchesUnlocked = dump.getReadableFsBranchesUnlocked(objTarget);
		if (fsBranchesUnlocked != "<>" && fsBranchesUnlocked != "" && fsBranchesUnlocked.length() > 5)
		{
			strTest += fsBranchesUnlocked;
			strTest += "\n\r";			
		}
		else
		{
			strTest += "none\n\r";	
		}

		// Subscription and Bit Expansion
 		strTest += "\r\nGAME SUBSCRIPTION FEATURES:\r\n"; 				
 		boolean boolHasCollectorEdition = features.hasCollectorEdition(objTarget);
		boolean boolhasSpaceExpansion = features.hasSpaceExpansion(objTarget);
		boolean boolhasSpaceExpansionPromotion = features.hasSpaceExpansionPromotion(objTarget);
		boolean boolhasJapaneseCollectorEdition = features.hasJapaneseCollectorEdition(objTarget);
		boolean boolhasEpisode3Expansion = features.hasEpisode3Expansion(objTarget);
		boolean boolhasEpisode3PreOrderDigitalDownload = features.hasEpisode3PreOrderDigitalDownload(objTarget);
		boolean boolhasEpisode3ExpansionRetail = features.hasEpisode3ExpansionRetail(objTarget);
		boolean boolhasTrialsOfObiwanExpansionRetail = features.hasTrialsOfObiwanExpansionRetail(objTarget);
		boolean boolhasTrialsOfObiwanExpansionPreorder = features.hasTrialsOfObiwanExpansionPreorder(objTarget);
		boolean boolhasTrialsOfObiwanExpansion = features.hasTrialsOfObiwanExpansion(objTarget);
		boolean boolhasMustafarExpansionRetail = features.hasMustafarExpansionRetail(objTarget);
		boolean boolhasFreeTrial = features.hasFreeTrial(objTarget);
		if (boolHasCollectorEdition)
	 		strTest += "\t\t\tCollector's Edition\r\n";
		if (boolhasSpaceExpansion)
	 		strTest += "\t\t\tJTL SpaceExpansion\r\n";
		if (boolhasSpaceExpansionPromotion)
	 		strTest += "\t\t\tJTL Space Expansion Promotion\r\n";
		if (boolhasJapaneseCollectorEdition)
	 		strTest += "\t\t\tJapanese Collector's Edition:\r\n";
		if (boolhasEpisode3Expansion)
	 		strTest += "\t\t\tEpisode 3 Expansion\r\n";
		if (boolhasEpisode3PreOrderDigitalDownload)
	 		strTest += "\t\t\tEpisode 3 Expansion Preorder\r\n";
		if (boolhasEpisode3ExpansionRetail)
	 		strTest += "\t\t\tEpisode 3 Expansion Retail\r\n";
		if (boolhasTrialsOfObiwanExpansionRetail)
	 		strTest += "\t\t\tTrials of Obiwan Expansion Retail\r\n";
		if (boolhasTrialsOfObiwanExpansionPreorder)
	 		strTest += "\t\t\tTrials of Obiwan Expansion Preorder\r\n";
		if (boolhasTrialsOfObiwanExpansion)
	 		strTest += "\t\t\tTrials of Obiwan Expansion\r\n";
		if (boolhasMustafarExpansionRetail)
	 		strTest += "\t\t\tMustafar Expansion Retail\r\n";
		if (boolhasFreeTrial)
	 		strTest += "\t\t\tFree Trial\r\n";			
		
	}

	if(space_utils.isShip(objTarget))
	{
		if(space_utils.isPlayerControlledShip(objTarget))
		{
			obj_id objPilot = getPilotId(objTarget);
			if(isIdValid(objPilot))
			{
				strTest+="PILOT BELOW HERE\r\n\r\n";
				strTest += "OBJECT IS: ";
				strTest += objPilot;
				strTest += "\n\r";				
				strTest += "Template of object is ";
				strTest += getTemplateName(objPilot);
				strTest += "\n\r";				
				strTest += "Location of object is ";
				strTest += getClusterName()+" "+getLocation(objPilot);
				strTest += "\n\r";				
				strTest += "SCRIPTS\r\n";
				strTest += dump.getReadableScripts(objPilot);
				strTest += "\n\r";				
				strTest += "OBJVARS\r\n";
				strTest += dump.getReadableObjVars(objPilot);
				strTest += "\n\r";				
				strTest += "SCRIPTVARS\r\n";
				strTest += dump.getReadableScriptVars(objPilot);
				strTest += "\n\r";				
 				strTest += "LOCALVARS\r\n";
				strTest += dump.getReadableLocalVars(objPilot);
				strTest += "\n\r";				
			}
		}
		strTest += "SHIP STATS BELOW\r\n";
		int[] intSlots = space_crafting.getShipInstalledSlots(objTarget);
		for(int intI = 0; intI < intSlots.length; intI++)
		{
			strTest += dump.getShipComponentDebugString(objTarget, intSlots[intI]);
			strTest += "\n\r";				
		}
	}

	string containmentTree = dump.getReadableContainmentTree(objTarget);
	if (containmentTree != "<>" && containmentTree != "" && containmentTree.length() > 5)
	{
		strTest += "\n\r";
		strTest += "TARGET CONTAINMENT:\r\n";
		strTest += containmentTree;					
 		strTest += "\n\r";				
	}	

	if ( utils.hasScriptVar( objTarget, "spawnedBy" ))
	{
		obj_id spawner = utils.getObjIdScriptVar( objTarget, "spawnedBy" );
		if ( isIdValid(spawner) && exists( spawner) && spawner.isLoaded() && spawner != objTarget )
		{
			strTest+="SPAWNER BELOW HERE\r\n";
			strTest+=dump.getTargetInfoString( spawner );
		}
	}
	//sendSystemMessageTestingOnly(self, "Returning");
	return strTest;
}

//**************** createCustomUI **************************************************
// Creates a Editable SUI that can display a large amount of data by default
// Accepts a string which is dsplayed in the edit box/area of SUI  
//*********************************************************************************

void createCustomUI(obj_id self, string combinedString)
{
	
	string uiTitle = "Target Data";
	int page = createSUIPage("/Script.messageBox", self, self);

	setSUIProperty(page, "Prompt.lblPrompt", "LocalText", combinedString);
	setSUIProperty(page, "bg.caption.lblTitle", "Text", uiTitle);
	setSUIProperty(page, "Prompt.lblPrompt", "Editable", "true");
	setSUIProperty(page, "Prompt.lblPrompt", "GetsInput", "true");
	setSUIProperty(page, "btnCancel", "Visible", "true");
	setSUIProperty(page, "btnRevert", "Visible", "false");
	setSUIProperty(page, "btnOk", sui.PROP_TEXT, "Create File");
	//If tester hits ok button renamed to Create File, send to message handler
	subscribeToSUIEvent(page, sui_event_type.SET_onClosedOk, "%button0%", "exportFile");
	subscribeToSUIEvent(page, sui_event_type.SET_onClosedCancel, "%button0%", "exportFile");

	showSUIPage(page);
	flushSUIPage(page);
}

//**************** findOrCreateAndEquipQABag **************************************************
// Looks for a QA Magic Bag.  If one doesnt exist it is created
// When a bag is found/created, the tester's current inventory is moved into the bag
//*********************************************************************************************

void findOrCreateAndEquipQABag(obj_id self, obj_id testerInventoryId, boolean moveContents)
{
	//obj_id testerInventoryId = utils.getInventoryContainer(self);
	obj_id[] invAndEquip = getInventoryAndEquipment(self);

	if (invAndEquip != null && invAndEquip.length > 0)
	{
		//This block gets the tester a magic QA Bag and equips it on their back
		obj_id firstBag = getObjectInSlot(self, "back");
		//sendSystemMessageTestingOnly(self,"First bags objId = "+firstBag);
		boolean hasBag = false;
		obj_id myBag = null;

		string firstBagTemp = getTemplateName(firstBag);

		//if the tester already has a backpack and it isnt the magic QA Bag, put it in the tester inventory 
		//to make room for the magic QA bag
		if(firstBagTemp != null && firstBagTemp != "object/tangible/test/qabag.iff" )
		{
			putInOverloaded(firstBag, testerInventoryId);
		}

		for(int i = 0; i < invAndEquip.length; i++)
		{
			string templateName = getTemplateName(invAndEquip[i]);
			if(templateName == "object/tangible/test/qabag.iff")
			{
				hasBag = true;
				myBag = invAndEquip[i];
			}
		}
		if(hasBag == false)
		{
			myBag = createObjectInInventoryAllowOverload("object/tangible/test/qabag.iff", self);
		}
		equip(myBag, self,"back");

		obj_id[] invItems = getContents(testerInventoryId);
		Vector itemsVector = new Vector();
		if (moveContents == true && invItems.length >= 1)
		{
			for(int k = 0; k < invItems.length; k++)
			{
				// get template names of items in player's inventory
				string templateName = getTemplateName(invItems[k]);
				// if -- frog or kashyyyk frog do not move
				if (!templateName == FROG_STRING && !templateName == KASHYYYK_FROG_STRING)
				{
					//add obj_id of the item 
					itemsVector.add(invItems[k]);				
				}
			}
			//convert Vector to stringArray
			obj_id[] tempArray = new obj_id[itemsVector.size()];
			itemsVector.toArray(tempArray);
			moveObjects(tempArray, myBag);
		}
	}
	else
	{
		//If the tester has absolutely nothing, spawn a bag
		obj_id myBag = createObjectInInventoryAllowOverload("object/tangible/test/qabag.iff", self);
		equip(myBag, self,"back");		
	}
}

//**************** getAllValidWaypoints *******************************************************
// Looks at tester datapad and returns a list of valid waypoint obj_ids
//*********************************************************************************************

obj_id[] getAllValidWaypoints(obj_id tester)
{
	HashSet waypointSet = new HashSet();
	obj_id[] datapadWaypoints = getWaypointsInDatapad(tester);
	
	if (datapadWaypoints != null)
	{
		for (int i=0; i < datapadWaypoints.length; i++)
		{

			if (isIdValid(datapadWaypoints[i]))			
			{
				// ADD WAYPOINT TO HASHSET
				waypointSet.add(datapadWaypoints[i]);
			}
		}
	}
	obj_id[] waypointArray = new obj_id[waypointSet.size()];
	waypointSet.toArray(waypointArray);

	return waypointArray;
}

//**************** getMenuList ****************************************************************
// Looks at a list of obj_ids, grabs the data and returns a list of strings based on the 
// objectType variable
//*********************************************************************************************

string[] getMenuList(obj_id tester, obj_id objList[], string objectType)
{
	if (objList.length > -1)
	{
		string[] returnedList = new string[objList.length];

		for ( int x=0; x < objList.length; x++ )
		{
			string stringData = "";

			if (objectType == "waypoint menu")
			{
				location reusedLocation = getWaypointLocation(objList[x]);
				if (reusedLocation != null)
				{
					stringData = getWaypointName(objList[x])+" "+reusedLocation.area+" "+reusedLocation.x+" "+reusedLocation.y+" "+reusedLocation.z;
				}
			}
			if (stringData != "")
			{
				returnedList[x] = stringData;
			}
			else
			{
				returnedList[x] = "There was an error in the object type condition";
			}
		}
		return returnedList;
	}
	sendSystemMessageTestingOnly(tester, "No menu options received.  Tool Failed. ");
	return null;	
}

//**************** getLocationList ************************************************************
// Looks at a list of location obj_ids then returns list of locations
//*********************************************************************************************

location[] getLocationList(obj_id tester, obj_id waypointList[])
{
	if (waypointList.length > -1)
	{
		location[] waypointLocations = new location[waypointList.length];

		for ( int x=0; x < waypointList.length; x++ )
		{
			location reusedLocation = getWaypointLocation(waypointList[x]);
			if (reusedLocation != null)
			{
				waypointLocations[x] = reusedLocation;
			}
		}
		return waypointLocations;
	}
	sendSystemMessageTestingOnly(tester, "No locations received.  Tool Failed. ");
	return null;
}

//**************** templateObjectSpawner ************************************************************
// spawns an object into the specified inventory with the object's template
//*********************************************************************************************

void templateObjectSpawner(obj_id player, string templateData)
{
	obj_id inventoryContainer = utils.getInventoryContainer(player);
	if (getVolumeFree(inventoryContainer) <= 0)
	{
		sendSystemMessageTestingOnly(player, "Your Inventory is Full, please make room and try again.");
	}
	else
	{
		createObject(templateData, inventoryContainer, "");
		sendSystemMessageTestingOnly(player, "Item Issued.");
		CustomerServiceLog("qaTool","User: (" + player + ") " + getName(player) + " has spawned (" + templateData + ") using a QA Tool or command.");
	}
}


//**************** templateObjectSpawner ************************************************************
// spawns an object into the specified inventory with the object's template
//*********************************************************************************************

obj_id templateObjectSpawner(obj_id player, string templateData, boolean silent)
{
	obj_id inventoryContainer = utils.getInventoryContainer(player);
	if (getVolumeFree(inventoryContainer) <= 0)
	{
		sendSystemMessageTestingOnly(player, "Your Inventory is Full, please make room and try again.");
	}
	else
	{
		obj_id returnedId = createObject(templateData, inventoryContainer, "");
		if (!silent)
			sendSystemMessageTestingOnly(player, "Item Issued.");

		CustomerServiceLog("qaTool","User: (" + player + ") " + getName(player) + " has spawned (" + templateData + ") using a QA Tool or command.");
		
		return returnedId;
	}
	return null;
}

//**************** revokeAllSkills ************************************************************
// Function that revokes/removes all possible professions from the test character.
// This function was stolen from the Character Builder (FROG)
//*********************************************************************************************

void revokeAllSkills(obj_id player)
{
	string[] skillList = getSkillListingForPlayer(player);
	int attempts = skillList.length;

	if ((skillList != null) && (skillList.length != 0))
	{
		while(skillList.length > 0 && attempts > 0)
		{
			for (int i = 0; i < skillList.length; i++)
			{
				string skillName = skillList[i];
				if (!skillName.startsWith ("species_")&&  //don't revoke species skills
				!skillName.startsWith("social_language_")&&
				!skillName.startsWith("utility_")&&
				!skillName.startsWith("common_")&&
				!skillName.startsWith("demo_")&&
				!skillName.startsWith("force_title_")&&
				!skillName.startsWith("force_sensitive_")&&
				!skillName.startsWith("combat_melee_basic")&&
				!skillName.startsWith("pilot_")&&
				!skillName.startsWith("combat_ranged_weapon_basic"))
				{
					skill.revokeSkillSilent(player, skillName);
				}
			}

			// The new skill list is the remaining skills.
			skillList = getSkillListingForPlayer(player);

			// Prevent data from creating an infinite loop.
			--attempts;
		}
	}
	
	int currentCombatXp = getExperiencePoints(player, "combat_general");
	grantExperiencePoints(player, "combat_general", -currentCombatXp);
	
	skill.recalcPlayerPools(player, true);
	setSkillTemplate(player, "");
	setWorkingSkill(player, "");
	CustomerServiceLog("qaTool","User: (" + player + ") " + getName(player) + " has had their entire profession removed/revoked by using a QA Tool or command.");
	sendSystemMessageTestingOnly(player, "All Professions removed from character.");
}


	//THIS SECTION NEEDS TO BE REDONE AFTER I FIGURE HOW TO ITERATE BACKWARD IN ARRAYS
	

//**************** revokePilotingSkills ************************************************************
//FUNTION THAT REVOKES THE PILOTING SKILLS
//*********************************************************************************************

void revokePilotingSkills (obj_id player)
{
	if(hasSkill(player, "pilot_rebel_navy_novice") || hasSkill(player, "pilot_imperial_navy_novice") || hasSkill(player, "pilot_neutral_novice"))
	{
		string pilotFaction = "";
		
		//we don't want the warning popup to happen.  This scriptvar assists in removing the piloting skills without
		//needing godmode level 50. Refer to space_skill.scriptlib and base_player.script (OnSkillAboutToBeRevoked)		
		if (!utils.hasScriptVar(player, "revokePilotSkill"))
		{
			utils.setScriptVar(player, "revokePilotSkill", 1);
		}

		//SNIFF OUT THE ACTUAL PILOT SKILL THE PLAYER HAS
		if(hasSkill(player, "pilot_rebel_navy_novice"))
		{
			pilotFaction = "rebel_navy";
		}
		else if (hasSkill(player, "pilot_imperial_navy_novice"))
		{
			pilotFaction = "imperial_navy";
		}
		else if (hasSkill(player, "pilot_neutral_novice"))
		{
			pilotFaction = "neutral";
		}
		else
		{
			pilotFaction = "";
		}
		
		if (pilotFaction != "")
		{
			for (int i = 0; i < REVOKE_SPACE_SKILLS.length; i++)
			{ 
				//BASE JAVA
				skill.revokeSkill(player, "pilot_" + pilotFaction + REVOKE_SPACE_SKILLS[i]);
			}
			//remove script var for warning/retirement popup
			utils.removeScriptVar(player, "revokePilotSkill");
			//removeObjVar(player, "space_quest");
		}
	}
}

boolean revokeAndGrantPilot(obj_id self, string factionType)
{
	if (toLower(factionType) == "rebel" || factionType == "Rebel Ships")
	{
		//FORCING REMOVAL OF ANY OTHER FACTION PILOT SKILLS
		revokePilotingSkills (self);
		//GRANTING PILOT SKILL NEEDED						
		grantPilotingSkills (self, "rebel_navy");				
		sendSystemMessageTestingOnly(self, "Rebel Pilot Granted.");
		CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has attained Master Rebel Pilot by using a QA Tool or command.");				
		return true;
	}
	else if (factionType == "Imperial Ships" || toLower(factionType) == "imperial")
	{
		//FORCING REMOVAL OF ANY OTHER FACTION PILOT SKILLS
		revokePilotingSkills (self);
		//GRANTING PILOT SKILL NEEDED					
		grantPilotingSkills (self, "imperial_navy");		
		sendSystemMessageTestingOnly(self, "Imperial Pilot Granted.");
		CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has attained Master Imperial Pilot by using a QA Tool or command.");		
		return true;		
	}
	else if (factionType == "Neutral/Freelancer Ships" || toLower(factionType) == "neutral")
	{
		//FORCING REMOVAL OF ANY OTHER FACTION PILOT SKILLS
		revokePilotingSkills (self);						
		//GRANTING PILOT SKILL NEEDED
		grantPilotingSkills (self, "neutral");
		sendSystemMessageTestingOnly(self, "Neutral Pilot Granted.");
		CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has attained Master Neutral Pilot by using a QA Tool or command.");
		return true;
	}
	else
	{
		sendSystemMessageTestingOnly(self, "The revokeAndGrantPilot function was not used properly. Exiting.");		
	}
	return false;
}

void grantPilotingSkills (obj_id self, string factionToggle)
{
	for (int i = 0; i < GRANT_SPACE_SKILLS.length; i++)
	{ 
		//BASE JAVA
		grantSkill(self, "pilot_" + factionToggle + GRANT_SPACE_SKILLS[i]);
	}
}

//Used to get a client buff name
string getClientBuffName(obj_id self, string buffCommand)
{
	//sendSystemMessageTestingOnly(self, "" + buffCommand);
	if (buffCommand != "")
	{
		string buffString = "null";
		
		//buffString = localize(new string_id("ui_buff", buffCommand));	
		buffString = utils.packStringId(new string_id ("ui_buff", buffCommand));
		if (buffCommand != "")
		{
			return buffString;
		}
		else
		{
			return buffCommand;
		}
	}
	return "null";
}

//Used to give tester a buff
void applyBuffOption(obj_id self, string buffArg, string buffName)
{
	if (buffName != "")
	{
		buff.applyBuff(self, self, buffArg);
		sendSystemMessageTestingOnly(self, "Applying Buff");
		sendSystemMessageTestingOnly(self, buffName);
		CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has used the buff (" + buffName + ") attained from a QA Tool or command.");
	}
}

//Being Called by QA Internal Scripts 
/*********************this was moved from qa_ai_helper_attach**************************/
void stopCreatureCombat(obj_id self, obj_id tester)
{
	stopCombat(self);
	ai_lib.setDefaultCalmBehavior(self, ai_lib.BEHAVIOR_SENTINEL);
	removeTriggerVolume(ai_lib.ALERT_VOLUME_NAME);
	removeTriggerVolume(ai_lib.AGGRO_VOLUME_NAME);
	utils.removeScriptVarTree(self,"ai.combat");
	detachScript(self, "ai.creature_combat");							
}

//Being Called by QA Internal Scripts 
/*********************this was moved from qa_ai_helper_attach**************************/
void followTester(obj_id self, obj_id tester)
{
	float testerSpeed = getRunSpeed(tester);
	ai_lib.aiFollow(self, tester);
	setMovementRun(self);
	setBaseRunSpeed(self, (testerSpeed*2));
	sendSystemMessageTestingOnly(tester, "Follow command given to mobile.");
}

//Damage Tool main function
//this function passes the data on to a message handler in a different script
void damageMobTool(obj_id self)
{			
	obj_id finalTarget = findTarget(self);
	if (!isIdNull(finalTarget))
	{
		if (finalTarget == self)
		{
			sendSystemMessageTestingOnly(self, "Damaging self.");
		}
		int targetCurrentHealth = getAttrib(finalTarget, HEALTH);

		utils.setScriptVar(self, DAMAGE_SCRIPTVAR + ".lookAtTarget", ""+finalTarget);
		int pid = sui.transfer(self, self, DAMAGE_TOOL_PROMPT, DAMAGE_TOOL_TITLE, "Available", targetCurrentHealth, "Amount", 0, "doTheDamage");
		sui.showSUIPage(pid);
		utils.setScriptVar(self, DAMAGE_PID_SCRIPTVAR, pid);
	}
	else
	{
		sendSystemMessageTestingOnly(self, "You must have a valid mob or player targeted.  If the mob is moving, you may want to type /qatool damage while targeting the mob/player.");
	}	
}

//Heal Tool main function
//this function passes the data on to a message handler in a different script
void healMobTool(obj_id self)
{			
	obj_id finalTarget = findTarget(self);
	if (!isIdNull(finalTarget))
	{
		if (finalTarget == self)
		{
			sendSystemMessageTestingOnly(self, "Healing self.");
		}
	
		int targetCurrentHealth = getAttrib(finalTarget, HEALTH);
		int targetMaxHealth = getMaxHealth(finalTarget);

		int healthDifference = targetMaxHealth - targetCurrentHealth;
		if (healthDifference > 0)
		{
			utils.setScriptVar(self, HEAL_SCRIPTVAR + ".lookAtTarget", ""+finalTarget);
			int pid = sui.transfer(self, self, HEAL_TOOL_PROMPT, HEAL_TOOL_TITLE, "Available", healthDifference, "Amount", 0, "healDamage");
			sui.showSUIPage(pid);
			utils.setScriptVar(self, HEAL_PID_SCRIPTVAR, pid);
		}
		else
		{
			sendSystemMessageTestingOnly(self, "The target health pool is maximum and cannot be healed.");
		}
	}
	else
	{
		sendSystemMessageTestingOnly(self, "You must have a valid mob or player targeted.  If the mob is moving, you may want to type /qatool heal while targeting the mob/player.");

	}
}

boolean checkGodLevel(obj_id tester)
{			
	if(getGodLevel(tester) < 10)
	{
		return false;
	}
	return true;
}

//Show Quest Function that copiles a list of both active and completed quests 
string[] getAllQuests(obj_id player)
{
	if (!isIdNull(player))
	{
		string[] allActive = getAllActiveQuests(player);
		string[] allComplete = getAllCompletedQuests(player);
		Vector allQuestStringsCombined = new Vector();

		if (allActive != null)
		{
			//allQuestStringsCombined.add("All Active Quests");
			for (int i = 0; i < allActive.length; i++)
			{
				allQuestStringsCombined.add(allActive[i]);
			}
		}
		
		if (allComplete != null)
		{
			//allQuestStringsCombined.add("\nAll Completed Quests");
			for (int i = 0; i < allComplete.length; i++)
			{
				allQuestStringsCombined.add(allComplete[i]);
			}
		}
		if (allActive == null && allComplete == null)
		{
			allQuestStringsCombined.add("No Active or Completed Quests to Display.");
		}
		else
		{
			if (allQuestStringsCombined.size() > 0)
			{
				string[] allQuests = new string[allQuestStringsCombined.size()];
				allQuestStringsCombined.toArray(allQuests);		
				return allQuests;
			}
		}
	}
	return null;
}

//Function that gets all active quests (both ground and space)
//Function also grabs the quest title string and returns both the quest and title. 
string[] getAllActiveQuests(obj_id player)
{
	int[] activeQuestIds = questGetAllActiveQuestIds(player);
	if (activeQuestIds.length > -1)
	{
		HashSet allQuestStringsFound = new HashSet();
		string activeQuestString = "";
	
		for (int i = 0; i < activeQuestIds.length; i++)
		{
			activeQuestString = questGetQuestName(activeQuestIds[i]);
			if (activeQuestString != "")
			{
				if (activeQuestString.indexOf("quest/") == 0)
				{
					string groundCodeAndTitle = getGroundQuestStringAndTitle(player, activeQuestString);
					//allQuestStringsFound.add("(A) " + groundCodeAndTitle + " ["+ activeQuestIds[i] +"]");
					allQuestStringsFound.add("(A) " + groundCodeAndTitle);
				}
				else if (activeQuestString.indexOf("spacequest/") == 0)
				{
					string spaceCodeAndTitle = getSpaceQuestStringAndTitle(player, activeQuestString);
					//allQuestStringsFound.add("(A) " + spaceCodeAndTitle + " ["+ activeQuestIds[i] +"]");
					allQuestStringsFound.add("(A) " + spaceCodeAndTitle);
				}
			}
		}
		if (allQuestStringsFound.size() > 0)
		{
			string[] allActiveQuests = new string[allQuestStringsFound.size()];
			allQuestStringsFound.toArray(allActiveQuests);		
			Arrays.sort(allActiveQuests);
			return allActiveQuests;
		}
	}
	return null;
}

//Function that gets all completed quests (both ground and space)
//Function also grabs the quest title string and returns both the quest and title.
string[] getAllCompletedQuests(obj_id player)
{	
	int[] completedQuestIds = questGetAllCompletedQuestIds(player);
	
	if (completedQuestIds.length > -1)
	{
		HashSet allQuestStringsFound = new HashSet();
		string completedQuestString = "";
	
		for (int i = 0; i < completedQuestIds.length; i++)
		{
			completedQuestString = questGetQuestName(completedQuestIds[i]);
			if (completedQuestString != "")
			{
				if (completedQuestString.indexOf("quest/") == 0)
				{
					string groundCodeAndTitle = getGroundQuestStringAndTitle(player, completedQuestString);
					//allQuestStringsFound.add("(C) " + groundCodeAndTitle + " ["+ completedQuestIds[i] +"]");
					allQuestStringsFound.add("(C) " + groundCodeAndTitle);
				}
				else if (completedQuestString.indexOf("spacequest/") == 0)
				{
					string spaceCodeAndTitle = getSpaceQuestStringAndTitle(player, completedQuestString);
					//allQuestStringsFound.add("(C) " + spaceCodeAndTitle + " ["+ completedQuestIds[i] +"]");
					allQuestStringsFound.add("(C) " + spaceCodeAndTitle);
				}
			}
		}
		if (allQuestStringsFound.size() > 0)
		{			
			string[] allCompletedQuests = new string[allQuestStringsFound.size()];
			allQuestStringsFound.toArray(allCompletedQuests);		
			Arrays.sort(allCompletedQuests);
			return allCompletedQuests;
		}
	}
	return null;
}

//Retrieves the displayed Quest Title for the quest and combines it with the code string fro display
string getGroundQuestStringAndTitle(obj_id player, string questString)
{
	//Capture the Ground Quest String and return it
	string localizeThis = questString.substring(6);
	string questStringLoc = "quest/ground/" + localizeThis;
	string questTitle = localize(new string_id(questStringLoc, "journal_entry_title"));				
	return questString + " - " + questTitle;
}

//Retrieves the displayed Quest Title for the quest and combines it with the code string fro display
string getSpaceQuestStringAndTitle(obj_id self, string questString)
{	
	//Capture the Space Quest String and return it
	string questTitle = localize(new string_id(questString, "title"));
	return questString + " - " + questTitle;
}

//This is called when a tester manually inputs a ground quest string or a test function
void grantGroundQuest(obj_id self, string questString)
{
	groundquests.requestGrantQuest(self, questString, true);
}

//This is called when a tester manually inputs a space quest string
boolean grantSpaceQuest(obj_id self, string questType, string questName)
{
	boolean questSuccess = space_quest.grantQuest(self, questType, questName);
	return questSuccess;
}

//This function parses out the space quest type and returns it. Another function will verify quest type validity
string getSpaceQuestType(obj_id self, string questString)
{
	if (questString.indexOf("spacequest/") == 0)
	{	
		string questType = questString.substring(11);
		int slashIdx = questType.indexOf("/");
		questType = questType.substring(0,slashIdx);
		boolean checkType = checkQuestType(self, questType);
		if (checkType)
		{
			return questType;
		}
		else
		{
			sendSystemMessageTestingOnly(self, "The quest type was typed incorrectly");
		}
	}
	return "Error";
}

//This function returns the space quest name AKA the last section of the quest type
string getSpaceQuestName(obj_id self, string questString)
{
	if (questString.indexOf("spacequest/") == 0)
	{	
		string questName = questString.substring(11);
		int slashIdx = questName.indexOf("/");		
		questName = questName.substring(slashIdx+1);
		return questName;
	}
	return "Error";
}

//This function checks to make sure the user manually entered the quest type correctly
boolean checkQuestType(obj_id self, string questType)
{
	if (questType != "")
	{	
		for (int i = 0; i < SPACE_QUEST_TYPES.length; i++)
		{
			if (questType == SPACE_QUEST_TYPES[i])
			{
				return true;
			}
		}
	}
	return false;
}

//This function completes (or wins) either ground or space quests
boolean completeActiveQuest(obj_id self, string questString)
{	
	if (questString.indexOf("spacequest/") == 0)
	{	
		if (space_quest.hasQuest(self))
		{
			obj_id datapad = utils.getPlayerDatapad(self);
			if (isIdValid(datapad))
			{
				obj_id[] dpobjs = getContents(datapad);
				for (int i=0; i<dpobjs.length; i++)
				{
					if (hasObjVar(dpobjs[i], space_quest.QUEST_TYPE) && hasObjVar(dpobjs[i], space_quest.QUEST_NAME))
						space_quest.setQuestWon(self, dpobjs[i]);
				}
				return true;
			}
		}
	}
	else
	{
		int questid = questGetQuestId(questString);	
		if ((questid != 0) && questIsQuestActive(questid, self))
		{
			int questCompleted = questCompleteQuest(questid, self);
			sendSystemMessageTestingOnly(self, "Quest completion function completed.");
			return true;
		}
	}
	return false;
}

//This function aborts or clears a ground or space quest
boolean clearQuest(obj_id self, string questString)
{		
	if (questString.indexOf("spacequest/") == 0)
	{	
		if (space_quest.hasQuest(self))
		{
			obj_id datapad = utils.getPlayerDatapad(self);
			if (isIdValid(datapad))
			{
				obj_id[] dpobjs = getContents(datapad);
				for (int i=0; i<dpobjs.length; i++)
				{
					if (hasObjVar(dpobjs[i], space_quest.QUEST_TYPE) && hasObjVar(dpobjs[i], space_quest.QUEST_NAME))
					{
						space_quest.setQuestAborted( self, dpobjs[i]);
						
						string questType = "";
						string questName = "";

						questType = getSpaceQuestType(self, questString);
						
						if (questType != "Error" && questType != "")			
							questName = getSpaceQuestName(self, questString);
						if (questName != "Error" && questName != "")							
						{
							string spaceObjVar = "space_quest." + questType + "." + questName;
							//sendSystemMessageTestingOnly(self, "Removing: " + spaceObjVar);
							blowOutObjVars(self, spaceObjVar);
							sendSystemMessageTestingOnly(self, "Space quest ObjVar removed.");
						}
					}
				}
			}
		}
	}
	//we still need to do the follwoing in case the space quest was already flagged completed 
	int questid = questGetQuestId(questString);
	if (questid != 0)
	{
		questClearQuest(questid, self);
		//sendSystemMessageTestingOnly(self, "Quest clear function completed.");
		return true;
	}
	return false;
}

boolean evalSpaceQuestThenGrant(obj_id self, string spaceString)
{
	string questType = "";
	string questName = "";

	if (spaceString != "")
	{
		questType = getSpaceQuestType(self, spaceString);
		if (questType != "Error" && questType != "")
		{
			questName = getSpaceQuestName(self, spaceString);
			if (questType != "Error" && questType != "")
			{
				boolean grantComplete = grantSpaceQuest(self, questType, questName);
				if (grantComplete)
				{
					return true;							
				}
				else
				{
					sendSystemMessageTestingOnly(self, "The was a problem granting: " + spaceString);					
					return false;
				}
			}
		}
		else
		{
			sendSystemMessageTestingOnly(self, "Unknown quest string: " + spaceString);
		}

	}
	return false;
}

//This is a function that assists in the removal of objvars, specifically space quests
boolean blowOutObjVars(obj_id self, string objVar)
{
	if (objVar == "space")
	{
		removeObjVar(self, "space_quest");
	}
	if (objVar == "all")
	{
		removeObjVar(self, "space_quest");
		removeObjVar(self, "quest");		
	}	
	else
	{
		removeObjVar(self, objVar);	
	}
	return true;	
}


//This function works in conjunction with the space pilot roadmap scripts to grant one or more skills to the 
//pilot.  If there is more than one skill to be rewarded the skills are separated by a semicolon.
boolean grantPilotSkill(obj_id self, string skillStringData)
{
	string[] allSkillStrings = split(skillStringData, ';');
	//sendSystemMessageTestingOnly(self, "allSkillStrings: " + allSkillStrings.length);
	for (int i = 0; i < allSkillStrings.length; i++)
	{
		skill.noisyGrantSkill(self, allSkillStrings[i]);
		messageTo(self, "delay", null, 1, false);	
	}
	return true;
}

//This function works with the space pilot roadmap and quest scripts to grant or clear a quest.
//This function works with space quests
boolean grantOrClearSpaceQuest(obj_id self, string questData, string fateSwitch)
{
	string[] allData = split(questData, ';');
	for (int i = 0; i < allData.length; i++)
	{
		if (fateSwitch == "clear")
		{
			clearQuest(self, allData[i]);
		}
		else if (fateSwitch == "grant")
		{
			evalSpaceQuestThenGrant(self, allData[i]);
			messageTo(self, "delay", null, 4, false);
			qa.completeActiveQuest(self, allData[i]);
			string questType = getSpaceQuestType(self, questData);
			if (questType != "Error" && questType != "")
			{
				string questName = getSpaceQuestName(self, questData);
				if (questType != "Error" && questType != "")		
				{
					if (!space_quest.hasWonQuest(self, questType, questName))
					{
						evalSpaceQuestThenGrant(self, allData[i]);
						messageTo(self, "delay", null, 4, false);
						qa.completeActiveQuest(self, allData[i]);			
					}	
				}
			}
		}	
	}
	return true;
}

//Creates a waypoint in the tester datapad
boolean createAQaWaypointInDataPad(obj_id self, location waypointData, string waypointName)
{
	obj_id wayp = createWaypointInDatapad(self, waypointData);

	string playerArea = getLocation(self).area;
	if ( playerArea != null && playerArea.equals(waypointData.area))
		setWaypointActive(wayp, true);

	setWaypointName(wayp, waypointName);
	return true;
}

//This function works with the egg spawner tool to spawn a random mob specified by the spawner egg itself
void forceEggSpawn(obj_id self)
{
	obj_id lookAtTarget = qa.findTarget(self);
	if(hasScript(lookAtTarget, "systems.spawning.spawner_area"))
	{
		int intGoodLocationSpawner = getIntObjVar(lookAtTarget, "intGoodLocationSpawner");
		string strSpawnType = getStringObjVar(lookAtTarget, "strSpawns");
		float fltSize = 8.0f;
		float fltRadius = getFloatObjVar(lookAtTarget, "fltRadius");
		location locTest = spawning.getRandomLocationInCircle(getLocation(lookAtTarget), fltRadius);
		string strSpawn = strSpawnType;
		string strFileName = "datatables/spawning/ground_spawning/types/"+strSpawnType+".iff";
		if (dataTableOpen(strFileName))
		{
			string[] strSpawns = dataTableGetStringColumnNoDefaults(strFileName, "strItem");
			float[] fltSizes= dataTableGetFloatColumn(strFileName, "fltSize");

			if( strSpawns==null || strSpawns.length==0 )
			{
				setName(self, "Mangled spawner. strFileName is "+strFileName+" I couldnt find any spawns in that file.");
			}

			int intRoll = rand(0, strSpawns.length-1);
			fltSize = fltSizes[intRoll];
			strSpawn = strSpawns[intRoll];
		}
		
		fltSize = getClosestSize(fltSize);
		if(intGoodLocationSpawner > 0)
		{
			requestLocation(lookAtTarget, strSpawn, locTest, rand(100, 200), fltSize, true, true);
		}
		else
		{
			createSpawnerMobNow(self, strSpawn, null, locTest, fltRadius, lookAtTarget);
		}

	}
	else
	{
		sendSystemMessageTestingOnly(self, "Not recognized as a spawner.  Tool failed.");
	}
}

//spawns the mobile per information attained by the forceEggSpawn function.  The spawner carries out the spawn
//immediately without selecting a random spawn timer
void createSpawnerMobNow(obj_id self, string strId, obj_id objLocationObject, location locLocation, float fltRadius, obj_id lookAtTarget)
{
	float spawnerYaw = getYaw(lookAtTarget);

	// the string is actuallywaht we spawn.
	int intIndex = strId.indexOf(".iff");
	float fltRespawnTime = 0.0f;
	if(intIndex>-1)
	{
		// template
		obj_id objTemplate = createObject(strId, locLocation);

		if(!isIdValid(objTemplate))
		{
			return;
		}
		spawning.incrementSpawnCount(lookAtTarget);
		spawning.addToSpawnDebugList(lookAtTarget, objTemplate);
		setObjVar(objTemplate, "objParent", lookAtTarget);
		setObjVar(objTemplate, "fltRespawnTime", fltRespawnTime);
		attachScript(objTemplate, "systems.spawning.spawned_tracker");

		setYaw(objTemplate, spawnerYaw);
	}
	else
	{
		obj_id objMob = create.object(strId, locLocation);
		if(!isIdValid(objMob))
		{

			setName(lookAtTarget , "BAD MOB OF TYPE "+strId);
			return;
		}
		int intBehavior = getIntObjVar(lookAtTarget, "intDefaultBehavior");
		ai_lib.setDefaultCalmBehavior(objMob, intBehavior);

		spawning.incrementSpawnCount(lookAtTarget);
		spawning.addToSpawnDebugList(lookAtTarget, objMob);
		setObjVar(objMob, "objParent", lookAtTarget);
		setObjVar(objMob, "fltRespawnTime", fltRespawnTime);
		attachScript(objMob, "systems.spawning.spawned_tracker");

		setYaw(objMob, spawnerYaw);

	}
	if(!spawning.checkSpawnCount(lookAtTarget))
	{
		return;
	}
	messageTo(lookAtTarget, "doSpawnEvent", null, fltRespawnTime, false);
	return;
}

//function used in conjunction with the createSpawnerMobNow to attain the spawner egg size
float getClosestSize(float fltOriginalSize)
{
	if(fltOriginalSize<=4.0f)
	{
		return 4.0f;
	}
	if(fltOriginalSize<=8.0f)
	{
		return 8.0f;
	}
	if(fltOriginalSize<=12.0f)
	{
		return 12.0f;
	}
	if(fltOriginalSize<=16.0f)
	{
		return 16.0f;
	}

	if(fltOriginalSize<=32.0f)
	{
		return 32.0f;
	}
	else if(fltOriginalSize <= 48.0f)
	{
		return 48.0f;
	}
	else if(fltOriginalSize <= 64.0f)
	{
		return 64.0f;
	}
	else if(fltOriginalSize <= 80.0f)
	{
		return 80f;
	}
	else if(fltOriginalSize <= 96.0f)
	{
		return 96f;
	}
	return 32f;
}
