/**
 * Copyright (c)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        corpse.scriptlib
 * Description:  scriptlib for corpse related functions
 * @author       $Author:$
 * @version      $Revision:$
 */

/***** INCLUDES ********************************************************/

include library.collection;
include library.group;
include library.npe;
include library.prose;
include library.static_item;
include library.utils;

/***** CONSTANTS *******************************************************/

const string SCRIPT_PLAYER_CORPSE				= "corpse.player_corpse";
const string SCRIPT_AI_CORPSE					= "corpse.ai_corpse";
const string SCRIPT_AI_CORPSE_INVENTORY				= "corpse.ai_corpse_inventory";

const string TEMPLATE_PLAYER_CORPSE				= "object/tangible/container/corpse/player_corpse.iff";

const string VAR_CORPSE_WAYPOINT				= "waypoint";
const string VAR_TIME_CREATED					= "create_time";

const string VAR_HAS_RESOURCE					= "hasResource";
const string VAR_BEEN_HARVESTED					= "beenHarvested";

const string GROUP_CONSENTED					= "consented";

const string DICT_PLAYER_ID					= "playerId";
const string DICT_CORPSE_ID					= "corpseId";
const string DICT_CORPSE_LOC					= "corpseLoc";
const string DICT_CORPSE_WAYPOINT				= "waypoint";

const string DICT_PLAYER_NAME					= "playerName";

const string DICT_COINS						= "coins";

const string DICT_LOOTERS					= "looters";

const int AI_CORPSE_EXPIRATION_TIME				= 120;
const int AI_CORPSE_EMPTY_TIME					= 5;

const int PLAYER_CORPSE_EXPIRATION_TIME				= 604800; //8hours=28800, 7days=604800

const string HANDLER_CORPSE_EXPIRE				= "handleCorpseExpire";
const string HANDLER_ADD_CONSENTED				= "handleAddConsentedUser";
const string HANDLER_REMOVE_CONSENTED				= "handleRemoveConsentedUser";

const string HANDLER_CORPSE_CLEANUP				= "handleCorpseCleanup";

const string HANDLER_CORPSE_WAYPOINT_UPDATE			= "handleCorpseWaypointUpdate";

const string HANDLER_REQUEST_COIN_LOOT				= "handleRequestCoinLoot";

const string HANDLER_COINS_LOOTED				= "handleCorpseCoinLoot";
const string HANDLER_COINLOOT_FAILED				= "handleCorpseCoinLootFailed";

const string HANDLER_CORPSE_EMPTY				= "handleCorpseEmpty";

const string HANDLER_PERMISSIONS_INITIALIZED			= "handleCorpsePermInit";

const string HANDLER_CORPSE_DEPOSIT_SUCCESS			= "handleCorpseDepositSuccess";
const string HANDLER_CORPSE_DEPOSIT_FAIL			= "handleCorpseDepositFail";

const string HANDLER_DESTROY_SELF				= "handleDestroySelf";

const string_id SID_LOOT_ALL					= new string_id("sui", "loot_all");
const string_id SID_HARVEST_CORPSE				= new string_id("sui", "harvest_corpse");
const string_id SID_HARVEST_MEAT				= new string_id("sui", "harvest_meat");
const string_id SID_HARVEST_BONE				= new string_id("sui", "harvest_bone");
const string_id SID_HARVEST_HIDE				= new string_id("sui", "harvest_hide");

const string_id SID_CORPSE_LOOTED				= new string_id("base_player", "corpse_looted");

const string_id PROSE_ITEM_LOOTED_SELF				= new string_id("base_player", "prose_item_looted_self");
const string_id PROSE_ITEM_LOOTED_OTHER				= new string_id("base_player", "prose_item_looted_other");

const string_id SID_CORPSE_EMPTY				= new string_id("error_message","corpse_empty");

const string_id SID_REMOVE_ONLY_CONTAINER			= new string_id("error_message","remove_only");
const string_id SID_REMOVE_ONLY_CORPSE				= new string_id("error_message","remove_only_corpse");

const string_id SID_CORPSE_DRAG_INTO				= new string_id("error_message","corpse_drag_into");
const string_id SID_CORPSE_DRAG_INSIDE				= new string_id("error_message","corpse_drag_inside");
const string_id SID_CORPSE_DRAG_RANGE				= new string_id("error_message","corpse_drag_range");

const string_id SID_CANNOT_LOOT_ALL				= new string_id("error_message","cannot_loot_all");

const string_id PROSE_INCOMPLETE_LOOT				= new string_id("error_message","prose_incomplete_loot");
const string_id SID_INV_FULL					= new string_id("error_message","inv_full");

const string_id SID_CLEANUP_AFTER_TRANSACTION			= new string_id("base_player","corpse_transaction_pending");

const string_id PROSE_HARVESTED_ON_CORPSE			= new string_id("error_message","harvested_on_corpse");
const string_id PROSE_RARE_HARVEST_ON_CORPSE			= new string_id("error_message","rare_harvest_on_corpse");

const string_id SID_CORPSE_HARVEST_SUCCESS			= new string_id("skl_use","corpse_harvest_success");

const string_id SID_CREATURE_QUALITY_FAT			= new string_id("skl_use","creature_quality_fat");
const string_id SID_CREATURE_QUALITY_MEDIUM			= new string_id("skl_use","creature_quality_medium");
const string_id SID_CREATURE_QUALITY_SKINNY			= new string_id("skl_use","creature_quality_skinny");
const string_id SID_CREATURE_QUALITY_SCRAWNY			= new string_id("skl_use","creature_quality_scrawny");
const string_id SID_GROUP_CONSERVE				= new string_id("skl_use","group_conserve");
const string_id SID_GROUP_HARVEST_BONUS				= new string_id("skl_use","group_harvest_bonus");
const string_id SID_GROUP_HARVEST_BONUS_SCOUT			= new string_id("skl_use","group_harvest_bonus_scout");
const string_id SID_GROUP_HARVEST_BONUS_MASTERSCOUT		= new string_id("skl_use","group_harvest_bonus_masterscout");

const string_id SID_NOTHING_TO_HARVEST				= new string_id("skl_use","nothing_to_harvest");

const string DATATABLE_SPECIES					= "datatables/mob/creatures.iff";

const string DATATABLE_COL_HAS_RESOURCE				= "hasResources";

const string DATATABLE_COL_MEAT_AMT				= "meat";
const string DATATABLE_COL_MEAT_TYPE				= "meatType";

const string DATATABLE_COL_HIDE_AMT				= "hide";
const string DATATABLE_COL_HIDE_TYPE				= "hideType";

const string DATATABLE_COL_BONE_AMT				= "bone";
const string DATATABLE_COL_BONE_TYPE				= "boneType";

const string DATATABLE_COL_RARE_AMT				= "rare";
const string DATATABLE_COL_RARE_TYPE				= "rareType";

const string[] DATATABLE_COL					={
								DATATABLE_COL_MEAT_AMT,
								DATATABLE_COL_HIDE_AMT,
								DATATABLE_COL_BONE_AMT,
								DATATABLE_COL_RARE_AMT
								};

//Creature Corpse Resource (CCR) defines
const int CCR_MEAT						= 0;
const int CCR_HIDE						= 1;
const int CCR_BONE						= 2;
const int CCR_RARE						= 3;

const int CCR_MAX						= 4;	//this should be last entry + 1

const float GROUP_BONUS_NONE 					= 1.0f;
const float GROUP_BONUS 					= 1.2f;
const float GROUP_BONUS_SCOUT 					= 1.3f;
const float GROUP_BONUS_MASTERSCOUT 				= 1.4f;

/***** FUNCTIONS ********************************************************/
/************************************************************************
 * @brief 	spawns a corpse for the designated player and attaches any
 *			system necessities
 *
 * @param 	obj_id	player
 *
 * @return 	obj_id; null on error
 ***********************************************************************/
obj_id spawnPlayerCorpse(obj_id player)
{
	if ( (player == null) || (!isPlayer(player)) )
	{
		return null;
	}

	location loc = getLocation(player);
	obj_id corpse = createObject(TEMPLATE_PLAYER_CORPSE, loc);
	if ( (corpse == null) || (corpse == obj_id.NULL_ID) )
	{
		sendSystemMessageTestingOnly(player, "spawnPlayerCorpse: unable to spawn a corpse at your location");
		sendSystemMessageTestingOnly(player, "spawnPlayerCorpse: loc = " + loc.toString());
		return null;
	}
	else
	{
		persistObject(corpse);
		setYaw(corpse, getYaw(player));

		string pname = getAssignedName(player);
		if ( pname == null || pname.equals("") )
		{
			setName(corpse, "Corpse of Unknown Player");
		}
		else
		{
			setName(corpse, "Corpse of " + pname);
		}

		setOwner(corpse, player);
		setObjVar(corpse, utils.VAR_OWNER, player);
		setObjVar(corpse, VAR_TIME_CREATED, getGameTime());
		initializeCorpsePermissions(corpse, null);
		attachScript(corpse, SCRIPT_PLAYER_CORPSE);
		grantCorpseConsent(corpse, player);

		if ( hasObjVar(player, pclib.VAR_CONSENT_TO_ID) )
		{
			obj_id[] consented = getObjIdArrayObjVar(player, pclib.VAR_CONSENT_TO_ID);
			if ( (consented != null) && (consented.length > 0) )
			{
				for ( int i = 0; i < consented.length; i++ )
				{
					//debugSpeakMsg(player, "spawnPlayerCorpse: grantCorpseConsent -> (" + consented[i] + ") " + consentedName[i]);
					if ( !grantCorpseConsent(corpse, consented[i]) )
					{
						//debugSpeakMsg(player, "spawnPlayerCorpse: unable to auto-consent to " + consented[i]);
					}
				}
			}
		}

 		messageTo(corpse, HANDLER_CORPSE_EXPIRE, null, PLAYER_CORPSE_EXPIRATION_TIME, true);
	}

	return corpse;
}

/************************************************************************
 * @brief 	sets up corpse permissions with default permissions granted to
 *			the obj_id array (DICT_LOOTERS) in passed dictionary params
 *
 * @param 	obj_id	corpse
 * @param 	dictionary params
 *
 * @return 	boolean
 ***********************************************************************/
boolean initializeCorpsePermissions(obj_id corpse, dictionary params)
{
	if ( !isIdValid(corpse) )
	{
		return false;
	}

	boolean litmus = true;
	litmus &= permissions.initializePermissions(corpse);
 	litmus &= permissions.createPermissionsGroup(corpse, GROUP_CONSENTED);
 	litmus &= permissions.grantGroupPermission(corpse, GROUP_CONSENTED, permissions.canOpen);

 	messageTo(corpse, HANDLER_PERMISSIONS_INITIALIZED, params, 1f, isObjectPersisted(corpse));

 	return litmus;
}

/************************************************************************
 * @brief 	grants corpse permissions for the specified corpse to obj_id
 *			"player" with name "name"
 *
 * @param 	obj_id	corpse
 * @param 	obj_id	player
 *
 * @return 	boolean
 ***********************************************************************/
boolean grantCorpseConsent(obj_id corpse, obj_id player)
{
	//debugSpeakMsg(corpse, "grantCorpseConsent: corpse = " + corpse + " player = " + player + " name = " + name);
	if ( !isIdValid(corpse) || !isIdValid(player) )
	{
		return false;
	}

	dictionary d = new dictionary();
	d.put(DICT_PLAYER_ID, player);

		//debugSpeakMsg(player, "grantCorpseConsent: sending add msg to corpse...");
	return messageTo(corpse, HANDLER_ADD_CONSENTED, d, 1f, isObjectPersisted(corpse));
}

/************************************************************************
 * @brief 	grantCorpseConsent overload: allows multiple corpse permissions
 *			granting
 *
 * @param 	obj_id[]	corpses
 * @param 	obj_id	player
 * @param 	string	name (player name)
 *
 * @return 	boolean
 ***********************************************************************/
boolean grantCorpseConsent(obj_id[] corpses, obj_id player)
{
	if ( (corpses == null) || (corpses.length == 0) || !isIdValid(player) )
	{
		return false;
	}

	boolean litmus = true;
	for (int i =0; i < corpses.length; i++ )
	{
		litmus &= grantCorpseConsent(corpses[i], player);
	}
	return litmus;
}

/************************************************************************
 * @brief 	revokes corpse permissions for the specified corpse frm obj_id
 *			"player"
 *
 * @param 	obj_id	corpse
 * @param 	obj_id	player
 *
 * @return 	boolean
 ***********************************************************************/
boolean revokeCorpseConsent(obj_id corpse, obj_id player)
{
	if ( !isIdValid(corpse) || !isIdValid(player) )
	{
		return false;
	}

	dictionary d = new dictionary();
	d.put(DICT_PLAYER_ID, player);

	return messageTo(corpse, HANDLER_REMOVE_CONSENTED, d, 1f, isObjectPersisted(corpse));
}

/************************************************************************
 * @brief 	revokeCorpseConsent overload:allows multiple corpse permissions
 *			revocation
 *
 * @param 	obj_id[]	corpse
 * @param 	obj_id	player
 *
 * @return 	boolean
 ***********************************************************************/
boolean revokeCorpseConsent(obj_id[] corpses, obj_id player)
{
	if ( (corpses == null) || (corpses.length == 0) || !isIdValid(player) )
	{
		return false;
	}

	boolean litmus = true;
	for (int i =0; i < corpses.length; i++ )
	{
		litmus &= revokeCorpseConsent(corpses[i], player);
	}
	return litmus;
}

/************************************************************************
 * @brief 	revokes all consents granted by obj_id owner for all corpses
 *
 * @param 	obj_id	owner
 *
 * @return 	boolean
 ***********************************************************************/
boolean revokeAllCorpseConsent(obj_id owner)
{
	if ( !isIdValid(owner) )
	{
		return false;
	}

	obj_id[] corpses = utils.getObjIdBatchObjVar(owner, pclib.VAR_CORPSE_ID);
	obj_id[] consented = getObjIdArrayObjVar(owner, pclib.VAR_CONSENT_TO_ID);
	if ( (corpses == null) || (consented == null) )
	{
		return false;
	}

	boolean litmus = true;
	for ( int i = 0; i < corpses.length; i++ )
	{
		for ( int n = 0; n < consented.length; n++ )
		{
			litmus &= revokeCorpseConsent(corpses[i], consented[n]);
		}
	}
	return litmus;
}

/************************************************************************
 * @brief 	handles player corpse cleanup activites
 *
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean cleanUpPlayerCorpse(obj_id corpse)
{
	return cleanUpPlayerCorpse( corpse, true );
}

boolean cleanUpPlayerCorpse(obj_id corpse, boolean withDestroyMessage )
{
	obj_id owner = getObjIdObjVar(corpse, utils.VAR_OWNER);

	obj_id waypoint = getObjIdObjVar(corpse, VAR_CORPSE_WAYPOINT);

	dictionary d = new dictionary();
	d.put(DICT_CORPSE_ID, corpse);
	d.put(DICT_CORPSE_WAYPOINT, waypoint);

	messageTo(owner, HANDLER_CORPSE_CLEANUP, d, 1, true);

	int cash = getCashBalance(corpse);
	if ( cash > 0 )
	{
		dictionary dictCoin = new dictionary();
		dictCoin.put(DICT_COINS, cash);

		depositCashToBank(corpse, cash, HANDLER_CORPSE_DEPOSIT_SUCCESS, HANDLER_CORPSE_DEPOSIT_FAIL, dictCoin);
		return true;
	}

	//messageTo(corpse, HANDLER_DESTROY_SELF, null, 0, isObjectPersisted(corpse));
	if ( withDestroyMessage )
		destroyObject( corpse );
	return true;
}

/************************************************************************
 * @brief 	for /corpse command: moves corpse to player if allowed
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean dragPlayerCorpse(obj_id player, obj_id corpse, boolean giveFeedback)
{
	if ( (player == null) || (corpse == null) )
	{
		return false;
	}

	if ( canDragPlayerCorpse(player, corpse, giveFeedback) )
	{
		location playerLoc = getLocation(player);
		obj_id[] stuff = getObjectsInRange(playerLoc, 20.0f);

		for(int i = 0; i < stuff.length; i++)
		{
			if(isPlayer(stuff[i]) )
			{
				playClientEffectLoc(stuff[i], "clienteffect/medic_drag.cef", getLocation(corpse), 0.0f);
			}
		}

		setLocation(corpse, getLocation(player));
		updateCorpseOwnerWaypoint(player, corpse);
		return true;
	}

	return false;
}

boolean dragPlayerCorpse(obj_id player, obj_id corpse)
{
	return dragPlayerCorpse(player, corpse, true);
}

/************************************************************************
 * @brief 	for /corpse command: moves corpse to player if allowed
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
obj_id[] dragPlayerCorpse(obj_id player, obj_id[] corpses)
{
	if ( !isIdValid(player) || (corpses == null) || (corpses.length == 0) )
	{
		return null;
	}

	resizeable obj_id[] moved = new obj_id[0];

	for ( int i = 0; i < corpses.length; i++ )
	{
		if ( dragPlayerCorpse(player, corpses[i], false) )
		{
			moved = utils.addElement(moved, corpses[i]);
		}
	}

	if ( (moved == null) || (moved.length == 0) )
	{
		return null;
	}

	return moved;
}

boolean isPlayerCorpse(obj_id objectInQuestion)
{
	if(isPlayer(objectInQuestion) && getPosture(objectInQuestion) == POSTURE_DEAD)
	{
		return true;
	}

	return false;
}

obj_id[] getDraggableCorpsesInRange(obj_id player, boolean feedback)
{
	resizeable obj_id[] corpses = new obj_id[0];
	obj_id[] stuff = getObjectsInRange(player, 100.0f);

	for(int i = 0; i < stuff.length; i++)
	{
		if(isPlayerCorpse(stuff[i]) )
		{
			if(canDragPlayerCorpse(player, stuff[i], true) )
			{
				corpses = utils.addElement(corpses, stuff[i]);
			}
		}
	}

	if(corpses == null || corpses.length == 0)
	{
		sendSystemMessage(player, new string_id("spam", "drag_none_in_range") );
	}

	return corpses;
}

/************************************************************************
 * @brief 	validates if the specified player can move the specified corpse
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean canDragPlayerCorpse(obj_id player, obj_id corpse, boolean giveFeedback)
{
	if ( (player == null) || (corpse == null) )
	{
		return false;
	}

	location pLoc = getLocation(player);
	location cLoc = getLocation(corpse);
	if ( cLoc == null )
		return false;

	obj_id owner = getOwner(corpse);
	if ( !isIdValid(owner) )
		return false;

	if ( player != owner && !group.inSameGroup(player, owner) && !isGod(player) )
	{
		sendSystemMessage(player, permissions.SID_NO_CORPSE_PERMISSION);
		return false;
	}

	/*//TEMP HACK!!
	if (cLoc.cell != obj_id.NULL_ID )
	{
		sendSystemMessageTestingOnly(player, "You cannot drag a corpse that is inside a structure");
		return false;
	}*/

	//debugSpeakMsg(player, "pLoc = " + pLoc.toString());
	//debugSpeakMsg(player, "cLoc = " + cLoc.toString());

	if ( cLoc.area.equals(pLoc.area) )	//same scene?
	{
		if ( cLoc.cell == pLoc.cell )	//same cell?
		{
			float dist = utils.getDistance2D(pLoc, cLoc);
			//debugSpeakMsg(player, "distance = " + dist);
			if ( dist <= pclib.RANGE_CORPSE_DRAG_NORMAL )
			{
				return true;
			}
			else
			{
				if ( giveFeedback )
				{
					sendSystemMessage(player, SID_CORPSE_DRAG_RANGE);
				}

				return false;
			}
		}
		else
		{
			//determine who is inside
			obj_id corpseContainer = structure.getContainingBuilding(corpse);
			if ( corpseContainer == null )
			{
				//corpse is outside & player is inside... cannot drag corpses into buildings
				if ( giveFeedback )
				{
					sendSystemMessage(player, SID_CORPSE_DRAG_INTO);
				}

				return false;
			}
			else
			{
				//corpse inside... is the player?
				obj_id playerContainer = structure.getContainingBuilding(player);
				if ( playerContainer == null )
				{
					//corpse inside & player is outside - warp corpse outside
					location bLoc = getLocation(corpseContainer);
					if ( utils.getDistance2D(pLoc, bLoc) <= pclib.RANGE_CORPSE_DRAG_INTERIOR )
					{
						return true;
					}
				}
				else
				{
					//corpse inside & player inside.. same building?
					if ( corpseContainer == playerContainer )
					{
						if ( giveFeedback )
						{
							sendSystemMessage(player, SID_CORPSE_DRAG_INSIDE);
						}

						return false;
					}
				}
			}
		}
	}

	return false;
}

/************************************************************************
 * @brief 	method for updating the location of a corpse waypoint
 *			typically used after /corpse command to update owner waypoints
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean updateCorpseOwnerWaypoint(obj_id player, obj_id corpse)
{
	if ( (player == null) || (corpse == null) )
	{
		return false;
	}

	obj_id waypoint = getObjIdObjVar(corpse, VAR_CORPSE_WAYPOINT);
	obj_id owner = getObjIdObjVar(corpse, utils.VAR_OWNER);

	if ( (waypoint == null) || (owner == null) )
	{
		return false;
	}

	location corpseLoc = getLocation(corpse);
	if ( corpseLoc == null )
	{
		return false;
	}

	dictionary d = new dictionary();
	d.put(DICT_CORPSE_LOC,corpseLoc);
	d.put(DICT_CORPSE_WAYPOINT, waypoint);

	return messageTo(owner, HANDLER_CORPSE_WAYPOINT_UPDATE, d, 0, false);
}

 /***********************************************************************
 * @brief 	requests that the player (or player's group object) broker
 *			looting of coins from specified corpse
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean lootCorpseCoins(obj_id player, obj_id corpse)
{
	if ( !isIdValid(player) || !isIdValid(corpse) )
	{
		return false;
	}

	int cash = getCashBalance(corpse);
	LOG("grouping","lootCorpseCoins: corpse cash = " + cash);
	if ( cash > 0 )
	{
		dictionary d= new dictionary();
		d.put(DICT_CORPSE_ID, corpse);
		d.put(DICT_PLAYER_ID, player);
		d.put(DICT_COINS, cash);

		messageTo(player, HANDLER_REQUEST_COIN_LOOT, d, 1f, isObjectPersisted(corpse));
		return true;
	}

	return false;
}

/************************************************************************
 * @brief 	handles opening player corpse objects
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean openPlayerCorpse(obj_id player, obj_id corpse)
{
	boolean lootedCoins = lootCorpseCoins(player, corpse);

	boolean canLootItems = true;
	obj_id[] corpseContents = getContents(corpse);
	if ( (corpseContents == null) || (corpseContents.length == 0) )
		canLootItems = false;

	if ( !lootedCoins && !canLootItems )
	{
		sendSystemMessage(player, SID_CORPSE_EMPTY);
		return false;
	}

	return true;
}

/************************************************************************
 * @brief 	handles non-open looting of a player corpse
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean lootPlayerCorpse(obj_id player, obj_id corpse)
{
	if ( !isIdValid(player) || !isIdValid(corpse) )
		return false;

	if ( getOwner(corpse) != player && !isGod(player) )
		return false;

	if ( openPlayerCorpse(player, corpse) )
	{
		obj_id[] corpseContents = getContents(corpse);
		if ( (corpseContents == null) || (corpseContents.length == 0) )
			return false;

		obj_id pInv = utils.getInventoryContainer(player);
		if ( !isIdValid(pInv) )
			return false;

		int moved = moveObjects(corpseContents, pInv);
		if ( moved < corpseContents.length )
		{
			obj_id[] leftContents = getContents(corpse);
			if ( (leftContents == null) || (leftContents.length == 0) )
			{
			}
			else
			{
				int itemSize = getVolume(leftContents[0]);
				int freeVol = getVolumeFree(pInv);

				if ( itemSize > freeVol )
				{
					sendSystemMessage(player, SID_INV_FULL);
				}
			}

			int itemsLeft = corpseContents.length - moved;
			prose_package pp = prose.getPackage(PROSE_INCOMPLETE_LOOT, null, corpse, itemsLeft);
			sendSystemMessageProse(player, pp);
			return false;
		}

		sendSystemMessage(player, SID_CORPSE_LOOTED);

		if ( getCashBalance(corpse) == 0 )
		{
			cleanUpPlayerCorpse(corpse);
		}
		else
		{
			//sendSystemMessage(player, SID_CLEANUP_AFTER_TRANSACTION);
			if( !hasObjVar(corpse, "cleanupStamp") )
			{
				messageTo(corpse, "handleAttemptCorpseCleanup", null, 300, isObjectPersisted(corpse));
			}
		}

		return true;
	}

	return false;
}

/************************************************************************
 * @brief 	handles opening AI "corpse" objects
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean openAICorpse(obj_id player, obj_id corpse)
{
	obj_id[] corpseContents = getContents(utils.getInventoryContainer(corpse));
	if ( (corpseContents == null) || (corpseContents.length == 0) )
	{
		LOG("grouping","openAICorpse: no corpse contents!");
		//messageTo(corpse, HANDLER_CORPSE_EMPTY, null, 0, isObjectPersisted(corpse));
		sendSystemMessage(player, SID_CORPSE_EMPTY);
		return false;
	}

	return true;
}

/************************************************************************
 * @brief 	handles non-open looting of an AI "corpse"
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean lootAICorpse(obj_id player, obj_id corpse)
{
	//debugSpeakMsg (player, "" + player + " is trying to loot (in LootAICorpse)" + corpse);
	if ( !isIdValid(player) || !isIdValid(corpse) )
		return false;

	LOG("grouping","lootAICorpse: entered...");
	if ( openAICorpse(player, corpse) )
	{
		LOG("grouping","lootAICorpse: successfully opened corpse");
		if ( lootAICorpseContents(player, corpse) )
		{
			LOG("grouping","lootAICorpse: successfully looted contents");
			messageTo(corpse, HANDLER_CORPSE_EMPTY, null, 1f, isObjectPersisted(corpse));
		}
	}

	LOG("grouping","lootAICorpse: returning false");
	return false;
}

/************************************************************************
 * @brief 	transfers the contents of the corpse to the player if possible
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean lootAICorpseContents(obj_id player, obj_id corpse)
{
	boolean grouped = false;
	boolean movedAll = true;

	if (group.isGrouped (player))
	{
		grouped = true;
	}

	//debugSpeakMsg (player, "" + player + " is trying to loot " + corpse);
	if ( !isIdValid(player) || !isIdValid(corpse) )
		return false;

	obj_id cInv = utils.getInventoryContainer(corpse);
	if ( !isIdValid(cInv) )
		return false;

	obj_id[] corpseContents = getValidLootContents(getContents(cInv));
	if ( (corpseContents == null) || (corpseContents.length == 0) )
		{
			messageTo(corpse, "handleCorpseExpire", null, 5, true);
			return false;
		}

	obj_id pInv = utils.getInventoryContainer(player);
	if ( !isIdValid(pInv) )
		return false;

	int moved = moveObjects(corpseContents, pInv);
	obj_id[] leftContents = getContents(cInv);

	if (grouped)
	{
		obj_id gid = getGroupObject(player);
		if ( isIdValid(gid) )
		{
			resizeable obj_id[] movedContents = utils.removeElements(corpseContents, leftContents);
			if ( movedContents != null && movedContents.length > 0 )
			{
				for (int z = 0; z < movedContents.length; z ++)
				{
					group.notifyItemLoot(gid, player, corpse, movedContents[z]);
				}
			}
		}
	}

	if (leftContents.length > 0)
	{
		if (grouped)
		{
			loot.sendGroupLootSystemMessage (leftContents[0], player, group.GROUP_STF, "full_inventory");
			// Sending a message to the group, we'll make the first item in the inventory
			// the one we send the name of to the group (corpseContents[0]
		}

		prose_package pp = prose.getPackage(PROSE_INCOMPLETE_LOOT, null, corpse, leftContents.length);
		sendSystemMessageProse(player, pp);

		return false;
	}

	sendSystemMessage(player, SID_CORPSE_LOOTED);
	return true;
}

obj_id[] getValidLootContents(obj_id[] corpseContents)
{
	if (corpseContents == null || corpseContents.length == 0)
		return null;

	resizeable obj_id[] validContents = new obj_id[0];

	for (int i=0;i<corpseContents.length;i++)
	{
		if (!utils.hasScriptVar(corpseContents[i], "isCreatureWeapon"))
			utils.addElement(validContents, corpseContents[i]);
		else
			trial.cleanupObject(corpseContents[i]);
	}

	return validContents;
}
/************************************************************************
 * @brief 	determines if a corpse should have resources
 *
 * @param 	string	mobType
 *
 * @return 	int[];null on none/error
 ***********************************************************************/
int[] hasResource(string mobType)
{
	if ( (mobType == null) || (mobType.equals("")) )
	{
		return null;
	}

	int val = dataTableGetInt(DATATABLE_SPECIES, mobType, DATATABLE_COL_HAS_RESOURCE);
	if ( val == 1 )
	{
		int[] ret = new int[CCR_MAX];

		int badCnt = 0;
		for ( int i = 0; i < CCR_MAX; i++ )
		{
			string type = dataTableGetString( DATATABLE_SPECIES, mobType, DATATABLE_COL[i]+"Type" );
			if ( type != "none" && type != null )
				ret[i] = 1;
			else
				ret[i] = 0;
			if ( ret[i] < 1 )
				badCnt++;
		}

		if ( badCnt == ret.length )	// if no resources... return null
			return null;
		else if ( (badCnt == ret.length - 1) && (ret[CCR_RARE] > 0) )	//if only rare resource... return null
			return null;

		return ret;
	}

	return null;
}


/************************************************************************
 * @brief 	determines if a corpse should have resources
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/
boolean hasResource(obj_id corpse)
{
	if ( corpse == null )
	{
		return false;
	}

	return ( hasResource(ai_lib.getCreatureName(corpse)) != null );
}

/************************************************************************
 * @brief 	harvests a creature corpse
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/

// Player harvesting removed, resources are now loot on the creature.

boolean harvestCreatureCorpse( obj_id player, obj_id corpse, string restype )
{

	// Get inventory refs.
	obj_id pInv = utils.getInventoryContainer(player);
	obj_id cInv = utils.getInventoryContainer(corpse);
	if ( (pInv == null) || (cInv == null) )
		return false;

	int freeVol = getVolumeFree(pInv);

	if (1 > freeVol)
	{
		sendSystemMessage(player, SID_INV_FULL);
		return false;
	}

	// This var is set as a multiplier for being grouped (and possible additional bonus if grouped with Rangers)
	float inGroupBonusMultiplier = GROUP_BONUS_NONE;

	// Valid parameters.
	if ( (player == null) || (corpse == null) )
		return false;

	// Does the corpse have resources?
	if ( !hasObjVar(corpse, VAR_HAS_RESOURCE) )
		return false;

	// Only allow us to harvest if we haven't yet.
	if ( utils.hasScriptVar( corpse, "harvestedBy." + player ) )
		return false;

	// Check to see if we are close enough.
	if ( getDistance(getLocation(player), getLocation(corpse)) > 15.0f )
		return false;
	utils.setScriptVar( corpse, "harvestedBy." + player, 1 );

	// Find list of harvestable resources.
	string mobType = ai_lib.getCreatureName(corpse);
	dictionary params = null;
	if ( restype == "" )
		params = getRandomHarvestCorpseResources( player, corpse, 1 );
	else
		params = getHarvestCorpseResources( player, corpse, restype );
	if ( (params == null) || (params.isEmpty()) )
		return false;

	int sklMod =  getSkillStatMod( player, "creature_harvesting" );




	// Calculate bonus percent of resources, based on skill.
	float bonusHarvest = sklMod / 100.0f;
	float skillEfficiency = ((sklMod * 10f) + 500f) / 2000f;

	boolean litmus = true;
	int harvestXP = 0;
	int successCount = 0;
	java.util.Enumeration keys = params.keys();
	int amt = 0;
	string type = null;
	int actualAmount = 0;

	while ( keys.hasMoreElements() )
	{
		// Determine max amount to harvest.
		string resourceType = (string)(keys.nextElement());
		amt = params.getInt(resourceType);
		amt += amt * bonusHarvest;

		// Scale harvest amount down based on harvest skill level
		amt = (int)(amt * skillEfficiency);

		if (group.isGrouped(player))
		{
			obj_id[] groupMembers = getGroupMemberIds(getGroupObject(player));
			for (int i=0; i < groupMembers.length; i++)
			{
				// Only concerned with real players that are not the player in question and actually exist on this server (or proxy)
				// Don't want to include pets in this group check
				if (isIdValid(groupMembers[i]) && exists(groupMembers[i]) && isPlayer(groupMembers[i]) && groupMembers[i] != player)
				{
					// check if this group member is within 256m
					float dist = getDistance(player, groupMembers[i]);
					if( dist != -1 && dist <= 64 )
					{
						// get a 20% bonus unless a higher bonus has already been set.
						if( inGroupBonusMultiplier == GROUP_BONUS_NONE )
							inGroupBonusMultiplier = GROUP_BONUS;

						// get a 30% bonus for having a Scout nearby unless a higher bonus has been set
						if( hasSkill(groupMembers[i], "outdoors_scout_novice") && inGroupBonusMultiplier < GROUP_BONUS_SCOUT )
							inGroupBonusMultiplier = GROUP_BONUS_SCOUT;

						// get a 40% bonus for having a Master Scout nearby
						if( hasSkill(groupMembers[i], "outdoors_scout_master") )
							inGroupBonusMultiplier = GROUP_BONUS_MASTERSCOUT;
					}
				}
			}

			amt *= inGroupBonusMultiplier;
		}

		// Clamp resources.
		if ( amt <= 0 )
			amt = 1;

		// Adjust resource name for the current planet.

		// 4/25/05 (wwallace):  This now checks a datatable that maps scene names to planet names.
		// This was done so that all 7 Kashyyyk zones could use a single "_kashyyyk" resource type
		// instead of a resource type for each zone.
		// kashyyyk_dead_forest maps to kashyyyk, etc...
		// Scene names for the original 10 planets map to themselves.

		string sceneName = getCurrentSceneName();
		string rsrcMapTable = "datatables/creature_resource/resource_scene_map.iff";
		string correctedPlanetName = dataTableGetString(rsrcMapTable, sceneName, 1);

		if ( correctedPlanetName == null || correctedPlanetName == "" )
		{
			correctedPlanetName = "tatooine";
		}

		type = resourceType + "_" + correctedPlanetName;

		if ( amt > 0 )
		{
			// NPE rule:  If the creature is marked as being an NPE harvestable creature, get special resources instead of these
			if (hasObjVar(corpse, "npe.harvestable"))
			{
				// make the resource

				actualAmount = npe.harvestNpeResourceStack(player, type, amt);

			}

			else
			{
				// Extract the resource.
				actualAmount = extractCorpseResource( type, amt, getLocation(getTopMostContainer(corpse)), pInv, cInv, 1 );
			}

			// Guarantee that the creature always has at least one resource for the newbie sample mission
			if ( (actualAmount <= 0) && hasObjVar(player, "newbie_handoff.mission.harvest") )
				actualAmount = 1;

			if ( actualAmount > 0 )
			{
				params.put( resourceType, actualAmount );

				// Everyone can harvest, no more xp
				//// Get the harvest XP amount from the corpse
				//harvestXP = utils.getIntScriptVar(corpse, "corpse.harvestXP."+player);

				successCount++;

				if ( hasScript(player, "theme_park.new_player.new_player") )
				{
					dictionary webster = new dictionary();
					webster.put("resourceType", resourceType);
					webster.put("amount", actualAmount);
					messageTo(player, "handleNewPlayerScoutAction", webster, 1, false);
				}
			}
			else
				litmus &= false;
		}
		else
			litmus &= false;
	}

	// Determine if the harvester is grouped.
	obj_id groupId = getGroupObject(player);

	if ( litmus && actualAmount > 0 )
	{
		// Indicate to player the quality of the animal.
		type = resource.getResourceName( type );
		prose_package pp = null;
		pp = prose.getPackage( new string_id("skl_use", "harvest_success"), null, type, null, null, null, null, null, null, null, actualAmount, 0.f );
		sendSystemMessageProse( player, pp );

		// let them know they received a group harvest bonus
		if( inGroupBonusMultiplier == GROUP_BONUS_MASTERSCOUT )
			sendSystemMessage(player, SID_GROUP_HARVEST_BONUS_MASTERSCOUT);
		if( inGroupBonusMultiplier == GROUP_BONUS_SCOUT )
			sendSystemMessage(player, SID_GROUP_HARVEST_BONUS_SCOUT);
		if( inGroupBonusMultiplier == GROUP_BONUS )
			sendSystemMessage(player, SID_GROUP_HARVEST_BONUS);

		if ( isIdValid(groupId) )
			group.notifyHarvest( groupId, player, corpse, type, actualAmount );
	}

	if ( successCount == 0 )
		sendSystemMessage( player, SID_NOTHING_TO_HARVEST );
	else
	{
		if ( hasObjVar(player, "newbie_handoff.mission.harvest") )
			messageTo( player, "missionHarvestComplete", null, 0, true );
	}

	//if ( harvestXP > 0 )
		//xp.grantCombatStyleXp( player, xp.SCOUT, harvestXP );

	messageTo(corpse, HANDLER_CORPSE_EMPTY, null, 1f, isObjectPersisted(corpse));
	return litmus;
}


void setCreatureHarvestXp(obj_id corpse, obj_id player)
{
	// Everyone can harvest, no more harvest xp
	//// Calculate and store the harvest XP
	//float targetDiff = (float) getLevel(player) + combat.getAiLevelDiff(corpse, player);
	//int harvestXP = (int) (Math.pow( targetDiff, 1.75f ) * 2.2f + 66.f);
	//if ( harvestXP > 6000 )
	//	harvestXP = 6000;
	//
	//utils.setScriptVar(corpse, "corpse.harvestXP."+player, harvestXP);
}

  /************************************************************************
 * @brief 	harvests a creature corpse
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/

dictionary getHarvestCorpseResources( obj_id player, obj_id corpse, string restype )
{
	if ( (player == null) || (corpse == null) )
		return null;

	dictionary d = new dictionary();
	string mobType = ai_lib.getCreatureName( corpse );
	if ( mobType == null )
		return null;

	// Here is the equation for determining how many resources creatures drop.
  	int amt = (int) (Math.pow( ai_lib.getLevel( corpse ), 1.65f ) * 0.4f + 2.f);
  	amt += 25;
	if ( amt < 1 )
		amt = 1;
	if ( amt > 700 )
		amt = 700;
	if ( restype != "" )
	{
		string typeName = utils.dataTableGetString( DATATABLE_SPECIES, mobType, restype + "Type" );
		if ( (typeName == null) || (typeName.equals("")) || (typeName.equals("none")) )
		{
		}
		else
		{
			d.put( typeName, amt );
		}
	}
	else
	{
		for ( int i = 0; i <= CCR_BONE; i++ )
		{
			string typeName = utils.dataTableGetString( DATATABLE_SPECIES, mobType, DATATABLE_COL[i] + "Type" );
			if ( (typeName == null) || (typeName.equals("")) || (typeName.equals("none")) )
			{
			}
			else
			{
				d.put( typeName, amt );
			
			}
		}
	}

	return d;
}

/************************************************************************
 * @brief 	harvests a creature corpse
 *
 * @param 	obj_id	player
 * @param 	obj_id	corpse
 *
 * @return 	boolean
 ***********************************************************************/

dictionary getRandomHarvestCorpseResources(obj_id player, obj_id corpse, int maxTypes)
{
	if ( (player == null) || (corpse == null) || (maxTypes < 1) )
	{
		return null;
	}

	dictionary params = getHarvestCorpseResources(player, corpse, "");
	if ( (params == null) || (params.isEmpty()) )
	{
		LOG("harvestCorpse","getRandomHarvestCorpseResources -> no corpse resources!");
		return null;
	}

	dictionary ret = new dictionary();

	for ( int n = 0; n < maxTypes; n++ )
	{
		if ( !params.isEmpty() )
		{
			java.util.Enumeration keys = params.keys();

			int size = params.size();
			int idx = rand(0, size - 1);

			for ( int i = 0; i < idx; i++ )
			{
				string temp = (string)keys.nextElement();
			}

			string type = (string)keys.nextElement();
			int amt = params.getInt(type);

			ret.put(type, amt);

			params.remove(type);
		}
	}

	if ( (ret == null) || (ret.isEmpty()) )
	{
		LOG("harvestCorpse","getRandomHarvestCorpseResources -> no returnable resources!");
		return null;
	}

	return ret;
}

dictionary getRandomHarvestCorpseResources(obj_id player, obj_id corpse)
{
	return getRandomHarvestCorpseResources(player, corpse, 1);
}

/************************************************************************
 * @brief 	wrapper for future extractResourceFromRandomPool
 *
 * @param 	string	resourceClass
 * @param 	int		amt
 * @param 	location loc
 * @param 	obj_id 	pInv	(player inventory)
 * @param 	obj_id 	cInv	(corpse inventory)
 *
 * @return 	boolean
 ***********************************************************************/
int extractCorpseResource( string resourceClass, int amt, location loc, obj_id pInv, obj_id cInv, int min )
{
	
	if ( (resourceClass.equals("")) || (amt < 1) || (loc == null) || (pInv == null) || (cInv == null) )
	{
		LOG("harvestCorpse","ERROR: extractCorpseResource -> invalid parameters!!");
		return -1;
	}

	obj_id playerId = obj_id.NULL_ID; //getContainedBy( pInv );
	obj_id corpseId = getContainedBy( cInv );

	obj_id[] crates = resource.createRandom( resourceClass, amt, loc, cInv, playerId, min);
	
	/*Collection - Resource Harvesting - Meat Bone Hide*/
	obj_id player = utils.getContainingPlayer(pInv);
	collection.collectionResource(player, resourceClass);
	
	if ( (crates == null) || (crates.length == 0) )
	{
		LOG("harvestCorpse","ERROR: extractCorpseResource -> unable to create random resources!!   " + resourceClass);
		return -1;
	}

	int total = 0;
	for ( int i = 0; i < crates.length; i++ )
	{
		total += getResourceContainerQuantity( crates[i] );
	}

// Player harvesting removed, resources are now loot on the creature.

	boolean movefail = false;
	for ( int i = 0; i < crates.length; i++ )
	{
		if ( !putIn( crates[i], pInv, playerId ) )
			movefail = true;
	}

	if ( movefail )
	{
		prose_package pp = prose.getPackage( PROSE_HARVESTED_ON_CORPSE, corpseId );
		sendSystemMessageProse( playerId, pp );
	}

	return total;
}

boolean isCorpseEmpty(obj_id objCorpse)
{
	//this function checks to see if a corpse is empty of all resources, loot, and cash
	//and returns true if it is.
	//This is used in corpse.corpse_fast_recycle, which is a fast recycle script used in the NPE

	obj_id inv = utils.getInventoryContainer(objCorpse);
	if ( isIdValid(objCorpse) )
	{
		obj_id[] contents = getContents(inv);
		LOG("corpse_debug", "contents are " + contents);
		if ( (contents == null) || (contents.length == 0) )
		{
			int cash = getCashBalance(objCorpse);
			if ( cash == 0 )
			{
				LOG("corpse_debug", "cash is 0");
				if ( hasObjVar(objCorpse, "hasResource") )
				{
					LOG("corpse_debug", "resources is very yes");
					return false;
				}
				else
				{
					LOG("corpse_debug", "no resources here");
					return true;
				}
			}
		}
	}
	return false;
}

boolean hasLootPermissions(obj_id corpse, obj_id player)
{
	obj_id killCredit = getObjIdObjVar(corpse, xp.VAR_TOP_GROUP);

	//Any member of the story can loot from the corpse
	if ( exists(corpse) && hasObjVar(corpse, "storytellerid") )
	{
		obj_id playerstorytellerId = utils.getObjIdScriptVar(player, "storytellerid");
		obj_id corpsestorytellerId = getObjIdObjVar(corpse, "storytellerid");
		if ( isIdValid(playerstorytellerId) && playerstorytellerId == corpsestorytellerId )
		{
			return true;
		}
		else if (isGod(player))
		{
			sendSystemMessageTestingOnly(player, "GOD MODE: Granting access to storyteller loot container that you do not have permission for.");
			return true;
		}
		return false;
	}

	if (player == killCredit)
		return true;

	if (group.isGroupObject(killCredit))
	{
		obj_id[] killList = getGroupMemberIds(killCredit);
		for (int i = 0; i < killList.length; i++)
		{
			if (player == killList[i])
				return true;
		}
	}

	if (isGod(player))
	{
		sendSystemMessageTestingOnly(player, "GOD MODE: Granting access to loot container that you do not have permission for.");
		return true;
	}

	return false;
}

void showLootMeParticle(obj_id corpse)
{
	obj_id killCredit = getObjIdObjVar(corpse, xp.VAR_TOP_GROUP);
	obj_id[] killList;
	if (group.isGroupObject(killCredit))
	{
		killList = getGroupMemberIds(killCredit);
	}
	else
	{
		killList = new obj_id[1];
		killList[0] = killCredit;
	}

	transform offset = transform.identity.setPosition_p(0f, getObjectCollisionRadius(corpse), 0);
	playClientEffectObj(killList, "appearance/pt_loot_disc.prt", corpse, "", offset, "lootMe");
	//playClientEffectLoc(killList, "appearance/pt_loot_disc.prt", getLocation(corpse), getObjectCollisionRadius(corpse), "lootMe");
}

void clearLootMeParticle(obj_id corpse)
{
	obj_id killCredit = getObjIdObjVar(corpse, xp.VAR_TOP_GROUP);
	obj_id[] killList;
	if (group.isGroupObject(killCredit))
	{
		killList = getGroupMemberIds(killCredit);
	}
	else
	{
		killList = new obj_id[1];
		killList[0] = killCredit;
	}

	stopClientEffectObjByLabel(killList, corpse, "lootMe", false);
}
