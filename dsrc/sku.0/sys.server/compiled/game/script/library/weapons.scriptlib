include library.combat;
include library.factions;
include library.heavyweapons;
include library.powerup;
include library.smuggler;
include library.trace;
include library.utils;


// Weapon creation library

////////////////////////
// Weapon Info
////////////////////////

// Misc
const string WEAPON_DATA_TABLE 				= "datatables/crafting/weapon_schematics.iff";
const string COL_SCHEMATIC_NAME 			= "schematic_name";
const string COL_CRAFTING_SCRIPT 			= "crafting_script";
const string COL_ITEMS_PER_CONTAINER 			= "items_per_container";
const string COL_NUM_COMPONENTS				= "slots";
const string COL_COMPLEXITY 				= "complexity";
const string COL_XP					= "xp";
const string COL_XP_TYPE 				= "xp_type";
const string COL_TEMPLATE 				= "crafted_object_template";
const string COL_TEMPLATE_HASH				= "crafted_object_template_hash";

// Damage
const string COL_MIN_DMG_LOW 				= "min_damage_low";
const string COL_MIN_DMG_HIGH 				= "min_damage_high";
const string COL_MAX_DMG_LOW 				= "max_damage_low";
const string COL_MAX_DMG_HIGH 				= "max_damage_high";

// These values are used to determine crafting caps
const string COL_MIN_DMG_HIGH_CAP			= "min_damage_high_cap";
const string COL_MAX_DMG_HIGH_CAP			= "max_damage_high_cap";

const string COL_MIN_DMG_LOW_CAP			= "min_damage_low_cap";
const string COL_MAX_DMG_LOW_CAP			= "max_damage_low_cap";

// Speed
const string COL_SPEED_LOW				= "attack_speed_low";
const string COL_SPEED_HIGH				= "attack_speed_high";

// Wound chances
const string COL_WOUND_CHANCE_LOW			= "wound_chance_low";
const string COL_WOUND_CHANCE_HIGH			= "wound_chance_high";

// Hitpoints
const string COL_HP_LOW					= "hit_points_low";
const string COL_HP_HIGH				= "hit_points_high";

// Accuracy modifiers
const string COL_ACCURACY_LOW				= "min_accuracy_low";
const string COL_ACCURACY_HIGH				= "min_accuracy_high";

const string COL_MIN_RANGE_DISTANCE			= "min_range_distance";
const string COL_MAX_RANGE_DISTANCE			= "max_range_distance";

// Specials costs
const string COL_ATTACK_COST_LOW			= "special_attack_cost_low";
const string COL_ATTACK_COST_HIGH			= "special_attack_cost_high";

// Damage Types
const string COL_DAMAGE_TYPE				= "damage_type";
const string COL_ELEMENTAL_TYPE				= "elemental_type";
const string COL_ELEMENTAL_VALUE_LOW			= "elemental_value_low";
const string COL_ELEMENTAL_VALUE_HIGH			= "elemental_value_high";

/////////////////////
// Component info
/////////////////////

const string COL_SLOT_TYPE				= "slot_type"; // resource or template
const string COL_SLOT_OPTIONAL				= "optional";
const string COL_SLOT_NAME_KEY				= "slot_name";
const string COL_INGREDIENT				= "slot_ingredient_name";
const string COL_INGREDIENT_COUNT			= "slot_ingredient_count";

////////////////////
//         MISC
////////////////////

const int VIA_TEMPLATE					= 1;
const int VIA_SCHEMATIC					= 2;

const int DEFAULT_VALUE					= 10; 	// used for any int value thats not defined in the table
const string WEAPONS					= "weapons";

const float MIN_AOE_PERCENT				= 0.1f; // 10% damage done to secondary targets at MAX_WEAPON_RANGE
const float MAX_AOE_PERCENT				= 1f; 	// 100% damage done to secondary targets at MIN_WEAPON_RANGE
const float MAX_WEAPON_RANGE				= 64;	// 64 meters

const float MAX_STAT_VALIDATION_INTENSITY   		= 1.00f;  // use 100% stat validation to provide a slight buffer so the float conversions do not alter players weapons

const string OBJVAR_NEW_WP				= "newWeapon";
const string OBJVAR_NEW_WP_COMPONENT			= OBJVAR_NEW_WP + ".component";
const string OBJVAR_NEW_WP_WEAPON			= OBJVAR_NEW_WP + ".weapon";
const string OBJVAR_WP_LEVEL				= OBJVAR_NEW_WP + ".coreLevel";
const string OBJVAR_WP_CORE_QUALITY_MIN			= OBJVAR_NEW_WP + ".coreQualityMin";
const string OBJVAR_WP_CORE_QUALITY_MAX			= OBJVAR_NEW_WP + ".coreQualityMax";
const string OBJVAR_MODIFIER_GAS_QUALITY_MIN		= OBJVAR_NEW_WP + ".gasQualityMin";
const string OBJVAR_MODIFIER_GAS_QUALITY_MAX		= OBJVAR_NEW_WP + ".gasQualityMax";
const string OBJVAR_MODIFIER_MELEE_QUALITY_MIN		= OBJVAR_NEW_WP + ".meleeQualityMin";
const string OBJVAR_MODIFIER_MELEE_QUALITY_MAX		= OBJVAR_NEW_WP + ".meleeQualityMax";
const string OBJVAR_MODIFIER_COMPONENT_BONUS_MIN	= OBJVAR_NEW_WP + ".componentBonusMin";
const string OBJVAR_MODIFIER_COMPONENT_BONUS_MAX	= OBJVAR_NEW_WP + ".componentBonusMax";
const string OBJVAR_MODIFIER_APPEARANCE_BONUS_MIN	= OBJVAR_NEW_WP + ".appearanceBonusMin";
const string OBJVAR_MODIFIER_APPEARANCE_BONUS_MAX	= OBJVAR_NEW_WP + ".appearanceBonusMax";
const string OBJVAR_ELEMENTAL_VALUE			= OBJVAR_NEW_WP + ".elementalValue";
const string OBJVAR_ELEMENTAL_TYPE			= OBJVAR_NEW_WP + ".elementalType";
const string OBJVAR_CRIT_BONUS_RANGED			= OBJVAR_NEW_WP + ".critBonusRanged";
const string OBJVAR_CRIT_BONUS_MELEE			= OBJVAR_NEW_WP + ".critBonusMelee";



const int NEW_COMPONENT_MODIFIER			= 1000;
const int WP_CORE_MODIFIER				= 10;
const float NEW_COMPONENT_CAP				= .075f;
const float NEW_WP_DAMAGE_CAP				= 1.50f;


const string[] WEAPON_TYPES				=
{
	"none",
	"rifle",
	"carbine",
	"pistol",
	"heavy",
	"melee",
	"directional",
	"component"
};

const string[] ATTRIBUTES				=
{
	"HEALTH",
	"CONSTITUTION",
	"ACTION",
	"STAMINA",
	"MIND",
	"WILLPOWER"
};

const string WEAPON_CORE_TABLE				= "datatables/crafting/weapon_core.iff";
const string WEAPON_APP_TABLE				= "datatables/crafting/weapon_appearance.iff";
const string WEAPON_APP_BONUS_TABLE			= "datatables/crafting/appearance_bonus.iff";

const string WEAPON_CORE_LEVEL_COL			= "core_level";

const string WEAPON_APP_TYPE				= "type";
const string WEAPON_APP_TEMPLATE			= "crafted_object_template";
const string WEAPON_APP_SPEED				= "attack_speed_high";
const string WEAPON_APP_WOUND				= "wound_chance_high";
const string WEAPON_APP_COST				= "special_attack_cost_high";
const string WEAPON_APP_DAMAGE_TYPE			= "damage_type";
const string WEAPON_APP_ELEMENT_TYPE			= "elemental_type";
const string WEAPON_APP_ACC				= "accuracy_high";
const string WEAPON_APP_MAX_RANGE			= "max_range_distance";
const string WEAPON_APP_MIN_RANGE			= "min_range_distance";

const int NUM_DAMAGE_TYPES				= 13;

const string_id SID_WEAPON_TO_SCHEM			= new string_id("spam", "weapon_to_schem");
const string_id SID_CONVERT_PROMPT			= new string_id("spam", "weapon_to_schem_prompt");
const string_id SID_CONVERT_TITLE 			= new string_id("spam", "weapon_to_schem_title");
const string_id SID_CONVERT_CONVERT_FAIL		= new string_id("spam", "weapon_to_schem_failure");
const string_id SID_CONVERT_CONVERT_SUCCESS		= new string_id("spam", "weapon_to_schem_success");
const string_id SID_CONVERT_INVALID_RESPONSE		= new string_id("spam", "weapon_to_schem_invalid_response");
const string_id SID_MIN_DAMAGE_GREATER_THAN_MAX		= new string_id("spam", "min_damage_greater_than_max");


const String[] DAMAGE_TYPE_NAMES			= new String[NUM_DAMAGE_TYPES];


//Updating this will force all weapons to redo the click combat conversion process
const int CONVERSION_VERSION				= 14;
const int CORED_WEAPON_CONVERSION_VERSION		= 3;

///////////////////////////////////////////////////////////////////////////////////////
//////////////////////////// Implementation ///////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////


// @col = the attribute value we want to return
// @searchArg is the name of the weapon
// @VIA_what denotes wether @searchArg refers to the template or the schematic name
int _GetTableValue(string col, string searchArg, int VIA_what)
{
	string searchCol = COL_SCHEMATIC_NAME;
	int row = -1;

	if(VIA_what == VIA_TEMPLATE)
	{
		searchCol = COL_TEMPLATE_HASH;
		row = dataTableSearchColumnForInt(getStringCrc(searchArg), searchCol, WEAPON_DATA_TABLE);
	}
	else
	{
		row = dataTableSearchColumnForString(searchArg, searchCol, WEAPON_DATA_TABLE);
	}

	if(row < 0)
	{
		return DEFAULT_VALUE;
	}

	return dataTableGetInt(WEAPON_DATA_TABLE, row, col);
}

// Damage
int getMinDamageLow(dictionary dic)
{
	if(!dic.containsKey(COL_MIN_DMG_LOW))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MIN_DMG_LOW);
}

int getMinDamageLow(string weaponName, int VIA_what)
{
	return _GetTableValue(COL_MIN_DMG_LOW, weaponName, VIA_what);
}

int getMinDamageHigh(dictionary dic)
{
	if(!dic.containsKey(COL_MIN_DMG_HIGH))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MIN_DMG_HIGH);
}

int getMinDamageHighCap(dictionary dic)
{
	if(!dic.containsKey(COL_MIN_DMG_HIGH_CAP))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MIN_DMG_HIGH_CAP);
}

int getMinDamageLowCap(dictionary dic)
{
	if(!dic.containsKey(COL_MIN_DMG_LOW_CAP))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MIN_DMG_LOW_CAP);
}

int getMinDamageHigh(string name, int VIA_what)
{
	return _GetTableValue(COL_MIN_DMG_HIGH, name, VIA_what);
}

int getMinDamageHighCap(string name, int VIA_what)
{
	return _GetTableValue(COL_MIN_DMG_HIGH_CAP, name, VIA_what);
}

int getMaxDamageLow(dictionary dic)
{
	if(!dic.containsKey(COL_MAX_DMG_LOW))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MAX_DMG_LOW);
}

int getMaxDamageLow(string name, int VIA_what)
{
	return _GetTableValue(COL_MAX_DMG_LOW, name, VIA_what);
}

int getMaxDamageHigh(dictionary dic)
{
	if(!dic.containsKey(COL_MAX_DMG_HIGH))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MAX_DMG_HIGH);

}

int getMaxDamageHighCap(dictionary dic)
{
	if(!dic.containsKey(COL_MAX_DMG_HIGH_CAP))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MAX_DMG_HIGH_CAP);
}

int getMaxDamageLowCap(dictionary dic)
{
	if(!dic.containsKey(COL_MAX_DMG_LOW_CAP))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MAX_DMG_LOW_CAP);
}

int getMaxDamageHigh(string name, int VIA_what)
{
	return _GetTableValue(COL_MAX_DMG_HIGH, name, VIA_what);
}

int getMaxDamageHighCap(string name, int VIA_what)
{
	return _GetTableValue(COL_MAX_DMG_HIGH_CAP, name, VIA_what);
}

// Speed
int getSpeedLow(dictionary dic)
{
	if(!dic.containsKey(COL_SPEED_LOW))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_SPEED_LOW);

}

int getSpeedLow(string name, int VIA_what)
{
	return _GetTableValue(COL_SPEED_LOW, name, VIA_what);
}

int getSpeedHigh(dictionary dic)
{
	if(!dic.containsKey(COL_SPEED_HIGH))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_SPEED_HIGH);

}

int getSpeedHigh(string name, int VIA_what)
{
	return _GetTableValue(COL_SPEED_HIGH, name, VIA_what);
}


// Wounds
int getWoundChanceLow(dictionary dic)
{
	if(!dic.containsKey(COL_WOUND_CHANCE_LOW))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_WOUND_CHANCE_LOW);
}

int getWoundChanceLow(string name, int VIA_what)
{
	return _GetTableValue(COL_WOUND_CHANCE_LOW, name, VIA_what);
}

int getWoundChanceHigh(dictionary dic)
{
	if(!dic.containsKey(COL_WOUND_CHANCE_HIGH))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_WOUND_CHANCE_HIGH);
}

int getWoundChanceHigh(string name, int VIA_what)
{
	return _GetTableValue(COL_WOUND_CHANCE_HIGH, name, VIA_what);
}


// Hit points
int getHPLow(dictionary dic)
{
	if(!dic.containsKey(COL_HP_LOW))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_HP_LOW);
}

int getHPLow(string name, int VIA_what)
{
	return _GetTableValue(COL_HP_LOW, name, VIA_what);
}


int getHPHigh(dictionary dic)
{
	if(!dic.containsKey(COL_HP_HIGH))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_HP_HIGH);
}

int getHPHigh(string name, int VIA_what)
{
	return _GetTableValue(COL_HP_HIGH, name, VIA_what);
}


// Min Max Range and Accuracy
int getAccuracyLow(dictionary dic)
{
	if(!dic.containsKey(COL_ACCURACY_LOW))
	{
		return 0;
	}

	return dic.getInt(COL_ACCURACY_LOW);
}

int getAccuracyLow(string name, int VIA_what)
{
	return _GetTableValue(COL_ACCURACY_LOW, name, VIA_what);
}

int getAccuracyHigh(dictionary dic)
{
	if(!dic.containsKey(COL_ACCURACY_HIGH))
	{
		return 0;
	}

	return dic.getInt(COL_ACCURACY_HIGH);
}

int getAccuracyHigh(string name, int VIA_what)
{
	return _GetTableValue(COL_ACCURACY_HIGH, name, VIA_what);
}

int getMinRangeDistance(dictionary dic)
{
	if(!dic.containsKey(COL_MIN_RANGE_DISTANCE))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MIN_RANGE_DISTANCE);
}

int getMinRangeDistance(string name, int VIA_what)
{
	return _GetTableValue(COL_MIN_RANGE_DISTANCE, name, VIA_what);
}

int getMaxRangeDistance(dictionary dic)
{
	if(!dic.containsKey(COL_MAX_RANGE_DISTANCE))
	{
		return DEFAULT_VALUE;
	}

	return dic.getInt(COL_MAX_RANGE_DISTANCE);
}

int getMaxRangeDistance(string name, int VIA_what)
{
	return _GetTableValue(COL_MAX_RANGE_DISTANCE, name, VIA_what);
}


// Special Cost
int getAttackCostLow(dictionary dic)
{
	if(!dic.containsKey(COL_ATTACK_COST_LOW))
	{
		return 0;
	}

	return dic.getInt(COL_ATTACK_COST_LOW);
}

int getAttackCostLow(string name, int VIA_what)
{
	return _GetTableValue(COL_ATTACK_COST_LOW, name, VIA_what);
}

int getAttackCostHigh(dictionary dic)
{
	if(!dic.containsKey(COL_ATTACK_COST_HIGH))
	{
		return 0;
	}

	return dic.getInt(COL_ATTACK_COST_HIGH);
}

int getAttackCostHigh(string name, int VIA_what)
{
	return _GetTableValue(COL_ATTACK_COST_HIGH, name, VIA_what);
}

// Damage Types
int getDamageType(dictionary dic)
{
	if(!dic.containsKey(COL_DAMAGE_TYPE))
	{
		return -1;
	}

	return dic.getInt(COL_DAMAGE_TYPE);
}

int getDamageType(string name, int VIA_what)
{
	return _GetTableValue(COL_DAMAGE_TYPE, name, VIA_what);
}

int getElementalType(dictionary dic)
{
	if(!dic.containsKey(COL_ELEMENTAL_TYPE))
	{
		return 0;
	}

	return dic.getInt(COL_ELEMENTAL_TYPE);
}

int getElementalType(string name, int VIA_what)
{
	return _GetTableValue(COL_ELEMENTAL_TYPE, name, VIA_what);
}

int getElementalValueLow(dictionary dic)
{
	if(!dic.containsKey(COL_ELEMENTAL_VALUE_LOW))
	{
		return 0;
	}

	return dic.getInt(COL_ELEMENTAL_VALUE_LOW);
}

int getElementalValueLow(string name, int VIA_what)
{
	return _GetTableValue(COL_ELEMENTAL_VALUE_LOW, name, VIA_what);
}

int getElementalValueHigh(dictionary dic)
{
	if(!dic.containsKey(COL_ELEMENTAL_VALUE_HIGH))
	{
		return 0;
	}

	return dic.getInt(COL_ELEMENTAL_VALUE_HIGH);
}

int getElementalValueHigh(string name, int VIA_what)
{
	return _GetTableValue(COL_ELEMENTAL_VALUE_HIGH, name, VIA_what);
}

obj_id _createFromDictionary(dictionary dat, obj_id container, float speed, float damage, float effeciency, float elementalVal)
{
	return _createFromDictionary(dat, container, speed, damage, effeciency, elementalVal, false);
}

obj_id _createFromDictionary(dictionary dat, obj_id container, float speed, float damage, float effeciency, float elementalVal, boolean overloadInv)
{
	obj_id obj = null;

	// base object
	if(!dat.containsKey(COL_TEMPLATE))
	{
		return obj;
	}

	if ( overloadInv )
	{
		obj = createObjectOverloaded(dat.getString(COL_TEMPLATE), container);
	}
	else
	{
		obj = createObject(dat.getString(COL_TEMPLATE), container, "");
	}

	if(obj == null)
	{
		return obj;
	}

	setWeaponAttributes(obj, dat, speed, damage, effeciency, elementalVal);

	return obj;

}

// the dictionary needs to be a row from the WEAPON_TEMPLATE data table.
obj_id _createFromDictionary(dictionary dat, obj_id container, float percentOfMax)
{
	return _createFromDictionary(dat, container, percentOfMax, percentOfMax, percentOfMax, percentOfMax);
}

void setWeaponAttributes(obj_id weapon, dictionary dat, float speedPercent, float damagePercent, float effeciencyPercent, float elementalValPercent)
{
	// Damage
	int damageLow = (int)((float)getMinDamageHighCap(dat) * damagePercent);
	int minDamageLow = getMinDamageLow(dat);
	if(damageLow < minDamageLow)
	{
		damageLow = minDamageLow;
	}

	int damageHigh = (int)((float)getMaxDamageHighCap(dat) * damagePercent);
	int minDamageHigh = getMaxDamageLow(dat);
	if(damageHigh < minDamageHigh)
	{
		damageHigh = minDamageHigh;
	}

	// Speed
	int minSpeed = getSpeedLow(dat);     // 100
	int maxSpeed = getSpeedHigh(dat);    // 200
	int diff = maxSpeed - minSpeed;      // 100
	// LOG("weapons", "speedPercent=" + speedPercent);
	diff = Math.round((diff * (1.0f - speedPercent)));  // 1.0 - 0.8 = 0.2 * 100 = 20
	int speed = minSpeed + diff;         // 120

	if(speed < minSpeed)
	{
		speed = minSpeed;
	}

	// Wounds
	int woundChance = (int)((float)getWoundChanceHigh(dat) * damagePercent);
	int minWoundChance = getWoundChanceLow(dat);
	if(woundChance < minWoundChance)
	{
		woundChance = minWoundChance;
	}

	// HP
	int hp = (int)((float)getHPHigh(dat) * 0.3f); // HP in the datatable are 3X of where they should come out
	int minHp = getHPLow(dat);
	if(hp < minHp)
	{
		hp = minHp;
	}

	// Accuracy
	int accuracy = (int)((float)getAccuracyHigh(dat) * damagePercent);
	int minAccuracy = getAccuracyLow(dat);
	if(accuracy < minAccuracy)
	{
		accuracy = minAccuracy;
	}

	// Ranges - never modify
	int minRange = getMinRangeDistance(dat);
	int maxRange = getMaxRangeDistance(dat);

	// Attack Cost
	int minAttackCost = getAttackCostLow(dat);
	int maxAttackCost = getAttackCostHigh(dat);

	int valueRange = maxAttackCost - minAttackCost;
	valueRange = (int)((float)valueRange * effeciencyPercent);
	int attackCost = maxAttackCost - valueRange;

	// Elemental Damage
	int elementalType = getElementalType(dat);
	int elementalValue = (int)((float)getElementalValueHigh(dat) * elementalValPercent);
	int minElementalValue = getElementalValueLow(dat);
	if(elementalValue < minElementalValue)
	{
		elementalValue = minElementalValue;
	}

	// damage type
	int damType = getDamageType(dat);
	if(damType == -1)
	{
		damType = DAMAGE_KINETIC;
	}

	////////////// set the actual values
	setWeaponMinDamage(weapon, damageLow);
	setWeaponMaxDamage(weapon, damageHigh);
	setWeaponAttackSpeed(weapon, (float)speed/100.0f);
	setWeaponWoundChance(weapon, (float)woundChance/10.0f);
	setMaxHitpoints(weapon, (int)(hp));
	setHitpoints(weapon, (int)(hp));
	setWeaponAccuracy(weapon, accuracy);

	setWeaponDamageType(weapon, damType);


	//setWeaponRangeInfo(weapon, (float)minRange, (float) maxRange);
	setWeaponAttackCost(weapon, attackCost);
	setWeaponElementalDamage(weapon, elementalType, elementalValue);
	setHeavyWeaponAoeSplashPercent(weapon);
	return;
}

void setWeaponAttributes(obj_id weapon, dictionary dat, float percentOfMax)
{
	setWeaponAttributes(weapon, dat, percentOfMax, percentOfMax, percentOfMax, percentOfMax);
}

dictionary getWeaponDat(string weapon)
{
	//CustomerServiceLog("jedi_saber", "WEAPON TEMPLATE: from getWeaponDat: "+weapon);
	int row = dataTableSearchColumnForInt(getStringCrc(weapon), COL_TEMPLATE_HASH, WEAPON_DATA_TABLE);
	//CustomerServiceLog("jedi_saber", "Returning Weapon Data Column "+row);
	if(row < 0)
	{
		return null;
	}
	dictionary dic = dataTableGetRow(WEAPON_DATA_TABLE, row);
	return dic;
}

dictionary getWeaponDat(obj_id weapon)
{
	string template = getTemplateName(weapon);
	return getWeaponDat(template);
}

//gets data from weapon core table
dictionary getWeaponCoreData(int coreLevel)
{
	//LOG("weapon_crafting", "getWeaponCoreData::start");
	//LOG("weapon_crafting", "getWeaponCoreData::coreLevel " + coreLevel);
	int row = dataTableSearchColumnForInt(coreLevel, WEAPON_CORE_LEVEL_COL, WEAPON_CORE_TABLE);
	//LOG("weapon_crafting", "getWeaponCoreData::row " + row);
	if(row < 0)
	{
		//LOG("weapon_crafting", "getWeaponCoreData::row was less than 0 bailing out");
		return null;
	}
	//LOG("weapon_crafting", "getWeaponCoreData::we have the row, returning it now");
	dictionary dict = dataTableGetRow(WEAPON_CORE_TABLE, row);

	//LOG("weapon_crafting", "getWeaponCoreData::is the dictionary null? " + (dict == null));

	return dict;
}



// creates an object as a weapon if need be
obj_id createPossibleWeapon(string name, obj_id container, float percentOfMax)
{
	return createPossibleWeapon(name, container, percentOfMax, percentOfMax, percentOfMax, percentOfMax);
}

obj_id createPossibleWeapon(string name, obj_id container, float speed, float damage, float effeciency, float elementalVal)
{
	obj_id thing = null;
	if(name.startsWith("object/weapon/"))
	{
		thing = createWeapon(name, container, VIA_TEMPLATE, speed, damage, effeciency, elementalVal);
	}

	if(!isIdValid(thing))
	{	// if we didn't create a successful weapon, create from the template
		thing = createObject(name, container, "");
	}

	return thing;
}

obj_id createWeapon(string name, obj_id container, float percentOfMax)
{
	return createWeapon(name, container, VIA_TEMPLATE, percentOfMax);
}

obj_id createWeapon(string name, obj_id container, float speed, float damage, float effeciency, float elementalVal)
{
	return createWeapon(name, container, VIA_TEMPLATE, speed, damage, effeciency, elementalVal);
}

obj_id createWeapon(string name, obj_id container, int VIA_what, float speed, float damage, float effeciency, float elementalVal)
{
	return createWeapon(name, container, VIA_what, speed, damage, effeciency, elementalVal, false);
}

obj_id createWeaponOverloaded(string name, obj_id container, float speed, float damage, float effeciency, float elementalVal)
{
	return createWeapon(name, container, VIA_TEMPLATE, speed, damage, effeciency, elementalVal, true);
}

obj_id createWeapon(string name, obj_id container, int VIA_what, float speed, float damage, float effeciency, float elementalVal, boolean overloadInv)
{
	string col = COL_SCHEMATIC_NAME;

	int row = -1;

	if(VIA_what == VIA_TEMPLATE)
	{
		col = COL_TEMPLATE_HASH;
		row = dataTableSearchColumnForInt(getStringCrc(name), col, WEAPON_DATA_TABLE);
	}
	else
	{
		row = dataTableSearchColumnForString(name, col, WEAPON_DATA_TABLE);
	}

	LOG("weapons", "Found " + name + " at row " + row);
	if(row < 0)
	{
		return null;
	}

	if(isPlayer(container))
	{
		container = utils.getInventoryContainer(container);
	}

	dictionary dic = dataTableGetRow(WEAPON_DATA_TABLE, row);
	obj_id weapon = _createFromDictionary(dic, container, speed, damage, effeciency, elementalVal, overloadInv);
	if(weapon != null && name.indexOf("component") > -1)
	{
		attachScript(weapon, "item.special.serialize_component");
	}

	weapons.setWeaponData(weapon);
	return weapon;
}

obj_id createWeapon(string name, obj_id container, int VIA_what, float percentOfMax)
{
	return createWeapon(name, container, VIA_what, percentOfMax, percentOfMax, percentOfMax, percentOfMax);
}

Vector getWeaponIdsForType(string fragment)
{
	string type = toLower(fragment);
	string[] allWeaps = dataTableGetStringColumn(WEAPON_DATA_TABLE, COL_TEMPLATE);

	string lookFor = "all";
	if(type.equals("melee"))
	{
		lookFor = "special";
	}

	Vector names = new Vector();
	string template = "";
	for(int i = 0; i < allWeaps.length; i++)
	{
		template = dataTableGetString(WEAPON_DATA_TABLE, i, COL_TEMPLATE);
		if(template != null && (type.equals("all") || template.indexOf(type) > -1))
		{
			if(template.indexOf("component") > -1)
			{
				continue;
			}

			names.add(dataTableGetString(WEAPON_DATA_TABLE, i, COL_SCHEMATIC_NAME));
		}
	}

	return names;
}

int createOneOfEach(string nameFragment, obj_id container, int VIA_what, float percentOfMax)
{
	string col = COL_SCHEMATIC_NAME;
	if(VIA_what == VIA_TEMPLATE)
	{
		col = COL_TEMPLATE;
	}

	if(isPlayer(container))
	{
		container = utils.getInventoryContainer(container);
	}

	nameFragment = toLower(nameFragment);

	string[] allWeaps = dataTableGetStringColumn(WEAPON_DATA_TABLE, col);

	if(allWeaps == null || allWeaps.length < 1)
	{
		return -1;
	}

	int numCreated = 0;
	dictionary dic = null;
	for(int i = 0; i < allWeaps.length; i++)
	{
		dic = dataTableGetRow(WEAPON_DATA_TABLE, i);
		if(nameFragment.equals("all") || dic.getString(col).indexOf(nameFragment) > -1)
		{
			numCreated = (_createFromDictionary(dic, container, percentOfMax) != null? numCreated+1 : numCreated);
		}
	}

	return numCreated;
}


void grantOrDenyAllWeaponSchematics(string nameFragment, obj_id player, int VIA_what, boolean grant)
{
	string col = COL_SCHEMATIC_NAME;
	if(VIA_what == VIA_TEMPLATE)
	{
		col = COL_TEMPLATE;
	}

	nameFragment = toLower(nameFragment);

	string[] allEntries = dataTableGetStringColumnNoDefaults(WEAPON_DATA_TABLE, col);
	trace.log(WEAPONS, "Got " + allEntries.length + " schematic entries from col " + col);

	for(int i = 0; i < allEntries.length; i++)
	{
		if(!nameFragment.equals("all") && toLower(allEntries[i]).indexOf(nameFragment) < 0)
		{
			trace.log(WEAPONS, allEntries[i] + " does will not be adjusted.");
			continue;
		}

		trace.log(WEAPONS, allEntries[i] + " will be " + (grant? "granted" : "revoked"));
		string path = "object/draft_schematic/weapon/";
		if((grant? grantSchematic(player, path+allEntries[i]+".iff") : revokeSchematic(player, path+allEntries[i]+".iff")))
		{
			sendSystemMessageTestingOnly(player, "Schematic " + (grant? "granted: " : "revoked: ") + allEntries[i]);
		}
	}

	return;
}

obj_id createLimitedUseSchematic(string name, int numUses, obj_id container, string schematicNameKey)
{
	return createLimitedUseSchematic(name, VIA_TEMPLATE, numUses, container, schematicNameKey);
}

obj_id createLimitedUseSchematic(string name, int VIA_what, int numUses, obj_id container, string schematicNameKey)
{
	return createLimitedUseSchematic(name, VIA_what, numUses, container, schematicNameKey, "class_munitions_phase4_master");
}

obj_id createLimitedUseSchematic(string name, int VIA_what, int numUses, obj_id container, string schematicNameKey, string skillRequired)
{
	if(toLower(name).indexOf("component") > -1)
	{
		return null;
	}

	string col = COL_SCHEMATIC_NAME;
	int row = -1;

	if(VIA_what == VIA_TEMPLATE)
	{
		col = COL_TEMPLATE_HASH;
		row = dataTableSearchColumnForInt(getStringCrc(name), col, WEAPON_DATA_TABLE);
	}
	else
	{
		row = dataTableSearchColumnForString(name, col, WEAPON_DATA_TABLE);
	}

	if(row < 0)
	{
		return null;
	}

	if(isPlayer(container))
	{
		container = utils.getInventoryContainer(container);
	}

	string schematicName = dataTableGetString(WEAPON_DATA_TABLE, row, COL_SCHEMATIC_NAME);
	obj_id obj = createObject("object/tangible/loot/loot_schematic/generic_limited_use.iff", container, "");
	if(obj == null)
	{
		return obj;
	}

	setObjVar(obj, "loot_schematic.schematic", "object/draft_schematic/weapon/" + schematicName + ".iff");
	setObjVar(obj, "loot_schematic.uses", numUses);
	setObjVar(obj, "loot_schematic.skill_req", skillRequired);
	attachScript(obj, "item.loot_schematic.loot_schematic");
	setName(obj, new string_id("craft_weapon_ingredients_n", "sch_" + schematicNameKey));
	return obj;
}

float setHeavyWeaponAoeSplashPercent(obj_id weapon)
{
	if(getWeaponType(weapon) == WEAPON_TYPE_HEAVY)
	{
		int weaponType = heavyweapons.getHeavyWeaponType(weapon);
		range_info rangeData = getWeaponRangeInfo(weapon);
		switch(weaponType)
		{
			case heavyweapons.TYPE_LAUNCHER_PISTOL:
			case heavyweapons.TYPE_LAVA_CANNON:
			case heavyweapons.TYPE_FLAME_THROWER:
			case heavyweapons.TYPE_HEAVY_FLAME_THROWER:
			case heavyweapons.TYPE_HEAVY_PARTICLE_BEAM:
			case heavyweapons.TYPE_HEAVY_ACID_BEAM:
			case heavyweapons.TYPE_LIGHTNING_BEAM_CANON:
				float rangeRatio = rangeData.maxRange / MAX_WEAPON_RANGE;
				float aoePercent = MAX_AOE_PERCENT - ((MAX_AOE_PERCENT - MIN_AOE_PERCENT) * rangeRatio);

				if(aoePercent > MAX_AOE_PERCENT)
				{
					aoePercent = MAX_AOE_PERCENT;
				}
				else if(aoePercent < MIN_AOE_PERCENT)
				{
					aoePercent = MIN_AOE_PERCENT;
				}
				setObjVar(weapon, "intAOEDamagePercent", aoePercent);
				return aoePercent;
				//break;
		}
	}

	return 0;
}

void clickCombatWeaponConversion(obj_id weapon)
{
	dictionary weaponDat = getWeaponDat(weapon);
	if(weaponDat == null)
	{
		CustomerServiceLog("weap_conversion_bad", "POSSIBLE :BROKEN WEAPON: TRIED TO CONVERT BUT COULD NOT GET WEAPONDATA FOR "+weapon);
		string template = getTemplateName(weapon);
		CustomerServiceLog("weap_conversion_bad", "WEAPON TEMPLATE IS: "+template);
		return;
	}

	if(jedi.isLightsaber(weapon))
	{
	 	validateLightsaberData(weapon, weaponDat);
	}
	else
	{	//remove all Powerups
		if(powerup.hasPowerUpInstalled(weapon))
		{
			powerup.cleanupWeaponPowerup(weapon);
		}
		//go validate weapon numbers
		validateWeaponData(weapon, weaponDat);
	}

	return;
}

boolean coredWeaponConversion(obj_id weapon)
{
	int coreLevel = getCoreLevel(weapon);

	if(coreLevel <= 0)
	{
		CustomerServiceLog("weap_conversion_bad", "POSSIBLE :BROKEN WEAPON: TRIED TO CONVERT BUT COULD NOT GET WEAPONDATA FOR "+weapon);
		CustomerServiceLog("weap_conversion_bad", "Core level was "+coreLevel);
		return false;
	}

	dictionary weaponCoreDat = getWeaponCoreData(coreLevel);

	if(weaponCoreDat == null || weaponCoreDat.isEmpty())
	{
		CustomerServiceLog("weap_conversion_bad", "POSSIBLE :BROKEN WEAPON: TRIED TO CONVERT BUT COULD NOT GET WEAPONDATA FOR "+weapon);
		string template = getTemplateName(weapon);
		CustomerServiceLog("weap_conversion_bad", "WEAPON TEMPLATE IS: "+template);
		return false;
	}
	int damageType		= 0;
	int elementalType	= 0;
	int elementalValue	= 0;
	int accuracy		= 0;
	float coreBonus		= 0.0f;
	float craftedBonus 	= 0.0f;

	// Minimum Damage
	coreBonus = getWeaponCoreQualityMin(weapon);
	craftedBonus = coreBonus + getWeaponComponentBonusesMinDamage(weapon);
	int tableMin = getCoreMinDamage(weapon, weaponCoreDat);
	float minDamage = tableMin * craftedBonus;

	//verify our damage is in range of the table
	CustomerServiceLog("new_weap_conversion", "minDamage pre-VerifyDamageRangeMin on weapon " + weapon + "("+getTemplateName(weapon)+") " + minDamage);
	minDamage = verifyDamageRangeMin(weapon, minDamage, weaponCoreDat);
	CustomerServiceLog("new_weap_conversion", "minDamage post-VerifyDamageRangeMin on weapon " + weapon + "("+getTemplateName(weapon)+") " + minDamage);

	setWeaponMinDamage(weapon, (int)minDamage);

	// Maximum Damage
	coreBonus = getWeaponCoreQualityMax(weapon);
	craftedBonus = coreBonus + getWeaponComponentBonusesMaxDamage(weapon);
	int tableMax = getCoreMaxDamage(weapon, weaponCoreDat);
	float maxDamage = tableMax * craftedBonus;

	//verify our damage is in range of the table
	CustomerServiceLog("new_weap_conversion", "maxDamage pre-VerifyDamageRangeMin on weapon " + weapon + "("+getTemplateName(weapon)+") " + maxDamage);
	maxDamage = verifyDamageRangeMax(weapon, maxDamage, weaponCoreDat);
	CustomerServiceLog("new_weap_conversion", "maxDamage post-VerifyDamageRangeMin on weapon " + weapon + "("+getTemplateName(weapon)+") " + maxDamage);

	setWeaponMaxDamage (weapon, (int)maxDamage);

	// Attack Speed
	// weapon speed is stored in the schematic template as 10 times the actual value, so we scale it back down here
	setWeaponAttackSpeed (weapon, getWeaponSpeed(weapon) / 100.0f);

	// Wound Chance
	setWeaponWoundChance (weapon, getNewWeaponWoundChance(weapon));

	// Accuracy
	accuracy = getNewWeaponAccuracy(weapon);
	setWeaponAccuracy(weapon, accuracy);

	// Attack Cost
	setWeaponAttackCost(weapon, getNewWeaponAttackCost(weapon));

	// Damage Type
	damageType = getNewWeaponDamageType(weapon);
	setWeaponDamageType(weapon, damageType);

	// Elemental Type
	int tableElementalType = getNewWeaponTableElementType(weapon);
	elementalType = (int)getNewWeaponElementalType(weapon);

	if(tableElementalType != -1)
	{
		elementalType = tableElementalType;
	}

	// Elemental Value
	craftedBonus = getNewWeaponElementalValue(weapon);
	int tableValue = getNewWeaponTableElementalValue(weapon, weaponCoreDat);
	elementalValue = (int)(tableValue * craftedBonus);

	//get any appearance bonuses
	if(elementalValue > 0)
	{
		CustomerServiceLog("new_weap_conversion", "elementalValue on prototype " + weapon + "("+getTemplateName(weapon)+") before Appearance bonus " + elementalValue);
		elementalValue += getElementalAppearanceBonus(weapon);
		CustomerServiceLog("new_weapon_crafting", "elementalValue on prototype " + weapon + "("+getTemplateName(weapon)+") after Appearance bonus " + elementalValue);
	}
	if(elementalType >= 0 && elementalValue > 0)
	{
		setWeaponElementalType(weapon, elementalType);
		setWeaponElementalValue(weapon, elementalValue);
	}

	//range data
	base_class.range_info rangeData = new base_class.range_info();
	rangeData.minRange = getNewWeaponMinRange(weapon);
	rangeData.maxRange = getNewWeaponMaxRange(weapon);
	setObjVar(weapon, "weapon.original_max_range", rangeData.maxRange);
	setWeaponRangeInfo(weapon, rangeData);

	setHeavyWeaponAoeSplashPercent(weapon);

	//use new objvar for versioning on new cored weapons
	setConversionId(weapon,CORED_WEAPON_CONVERSION_VERSION);

	return true;
}


void staticDynamicWeaponConversion(obj_id weapon)
{
	int level = 1;

	if(hasObjVar(weapon, "dynamic_item.intLevelRequired"))
		level = getIntObjVar(weapon, "dynamic_item.intLevelRequired");

	dictionary weaponData = dataTableGetRow("datatables/item/dynamic_item/root_balance_data/weapon_data.iff", level);
	static_item.setupDynamicWeapon(weapon, "", level, weaponData, new dictionary(), false);
}


void validateWeaponData(obj_id weapon, dictionary weaponDat)
{
	//I didnt want to do this but Jeff and Dave thought it was lame if all weapons converted to the same value, feel free to yank the randomfunmeter at any point
	float randomMeter = rand(0.95f, 1.00f);
	int currentMinDamage = getWeaponMinDamage(weapon);
	int currentMaxDamage = getWeaponMaxDamage(weapon);
	int clickMasterMinDamageHigh = getMinDamageHighCap(weaponDat);
	int clickMasterMaxDamageHigh = getMaxDamageHighCap(weaponDat);
	int clickMasterMinDamageLow = getMinDamageLowCap(weaponDat);
	int clickMasterMaxDamageLow = getMaxDamageLowCap(weaponDat);

	int finalMinDamage = currentMinDamage;
	int finalMaxDamage = currentMaxDamage;

	//if Min damage is greater or less than the master table, set it to master table min
	if(finalMinDamage > clickMasterMinDamageHigh || finalMinDamage < clickMasterMinDamageLow)
		finalMinDamage = (int)(clickMasterMinDamageHigh*randomMeter);

	//if Max damage is greater or less than the master table, set it to master table max
	if(finalMaxDamage > clickMasterMaxDamageHigh || finalMaxDamage < clickMasterMaxDamageLow)
		finalMaxDamage = (int)(clickMasterMaxDamageHigh*randomMeter);

	//sets the Damage values
	setWeaponMinDamage(weapon, finalMinDamage);
	setWeaponMaxDamage(weapon, finalMaxDamage);

	//set to speed constant from the master table
	float clickMasterSpeed = getSpeedLow(weaponDat) / 100.0f;
	setWeaponAttackSpeed(weapon, clickMasterSpeed);

	//set action to action from master table
	int clickMasterActionCost = getAttackCostLow(weaponDat);
	setWeaponAttackCost(weapon, clickMasterActionCost);

	//set wound to wound from master table
	int clickMasterWoundChance = getWoundChanceLow(weaponDat);
	setWeaponWoundChance(weapon, (float) clickMasterWoundChance);

	//range validator
	validateWeaponRange(weapon, weaponDat);

	//check weapon damage type
	validateWeaponDamageType(weapon, weaponDat);

	//check weapon elemental damage type
	if (getWeaponElementalType(weapon) > 0)
	{
		int currentElementalDamageType = getWeaponElementalType(weapon);
		int clickMasterDamageType = getElementalType(weaponDat);
		int currentElementalDamage = getWeaponElementalValue(weapon);

		int minElementalDamage = getElementalValueLow(weaponDat);
		int maxElementalDamage = getElementalValueHigh(weaponDat);

		if(currentElementalDamageType != clickMasterDamageType);
		{
			setWeaponElementalType(weapon, clickMasterDamageType);
		}

		if( currentElementalDamage < minElementalDamage || currentElementalDamage > maxElementalDamage)
		{
			randomMeter = rand(0.95f, 1.00f);
			setWeaponElementalValue(weapon, (int)(maxElementalDamage * randomMeter) );
		}
	}
	else
	{
		int clickMasterDamageType = getElementalType(weaponDat);

		if(clickMasterDamageType > 0)
		{
			int clickMasterElementalDamage = ((getElementalValueLow(weaponDat) + getElementalValueHigh(weaponDat))/2);
			setWeaponElementalType(weapon, clickMasterDamageType);
			setWeaponElementalValue(weapon, clickMasterElementalDamage);
		}
	}

	setConversionId(weapon,CONVERSION_VERSION);
	weapons.setWeaponData(weapon);
	removeObjVar(weapon, "slicing");
	setHeavyWeaponAoeSplashPercent(weapon);

	//make sure we are a player before generating a log
	obj_id player = utils.getContainingPlayer(weapon);
	if(isIdValid(player) && isPlayer(player))
	{
		string template = getTemplateName(weapon);
		CustomerServiceLog("jedi_saber", "WEAPON TEMPLATE CONVERTED!: "+template);
		CustomerServiceLog("jedi_saber", "Converting Weapon ("+weapon+") - OLD MIN DAMAGE:"+currentMinDamage+" - NEW MIN DAMAGE - "+finalMinDamage);
		CustomerServiceLog("jedi_saber", "Converting Weapon ("+weapon+") - OLD MAX DAMAGE:"+currentMaxDamage+" - NEW MAX DAMAGE - "+finalMaxDamage);
		CustomerServiceLog("jedi_saber", "Converting Weapon ("+weapon+") - NEW SPEED - "+clickMasterSpeed);
		CustomerServiceLog("jedi_saber", "Converting Weapon ("+weapon+") - NEW ACTION - "+clickMasterActionCost);
	}

}


//this sets the sabers base stats stored in objvars on the weapon to new correct values
void validateLightsaberData(obj_id saber, dictionary weaponDat)
{
	int baseMinDamage = getIntObjVar(saber, jedi.VAR_SABER_DEFAULT_STATS + "." + jedi.VAR_MIN_DMG);
	int baseMaxDamage = getIntObjVar(saber, jedi.VAR_SABER_DEFAULT_STATS + "." + jedi.VAR_MAX_DMG);

	int clickMasterMinDamage = getMinDamageHighCap(weaponDat);
	int clickMasterMaxDamage = getMaxDamageHighCap(weaponDat);
	int clickMasterLowMinDamage = getMinDamageLowCap(weaponDat);
	int clickMasterLowMaxDamage = getMaxDamageLowCap(weaponDat);

	int finalMinDamage = 0;
	int finalMaxDamage = 0;

	//happy holidays old players, enjoy having good sabers below level 80 for not cancelling on us
	finalMinDamage = (int)(clickMasterLowMinDamage +((clickMasterMinDamage - clickMasterLowMinDamage) * .99f));
	finalMaxDamage = (int)(clickMasterLowMaxDamage +((clickMasterMaxDamage - clickMasterLowMaxDamage) * .99f));

	setObjVar(saber, jedi.VAR_SABER_DEFAULT_STATS + "." + jedi.VAR_MIN_DMG, finalMinDamage);
	setObjVar(saber, jedi.VAR_SABER_DEFAULT_STATS + "." + jedi.VAR_MAX_DMG, finalMaxDamage);

	//set to speed constant from the master table
	float clickMasterSpeed = getSpeedLow(weaponDat) / 100.0f;
	setWeaponAttackSpeed(saber, clickMasterSpeed);
	setObjVar(saber, jedi.VAR_SABER_DEFAULT_STATS + "." + jedi.VAR_SPEED, clickMasterSpeed);

	//set action to action from master table
	int clickMasterActionCost = getAttackCostLow(weaponDat);
	setObjVar(saber, jedi.VAR_SABER_DEFAULT_STATS + "." + jedi.VAR_ATTACK_COST, clickMasterActionCost);

	//setting force costs to 0
	removeObjVar(saber, jedi.VAR_SABER_DEFAULT_STATS + "." + jedi.VAR_FORCE);
	removeObjVar(saber, jedi.VAR_SABER_BASE + "." + jedi.VAR_FORCE);


	//set wound to wound from master table
	int clickMasterWoundChance = getWoundChanceLow(weaponDat);
	setObjVar(saber, jedi.VAR_SABER_DEFAULT_STATS + "." + jedi.VAR_WOUND, clickMasterWoundChance);

	//range validator
	validateWeaponRange(saber, weaponDat);

	setConversionId(saber,CONVERSION_VERSION);
	weapons.setWeaponData(saber);

	string template = getTemplateName(saber);
	CustomerServiceLog("jedi_saber", "LIGHTSABER TEMPLATE CONVERTED!: "+template);
	CustomerServiceLog("jedi_saber", "Converting LightSaber ("+saber+") - OLD MIN DAMAGE:"+baseMinDamage+" - NEW MIN DAMAGE - "+finalMinDamage);
	CustomerServiceLog("jedi_saber", "Converting LightSaber ("+saber+") - OLD MAX DAMAGE:"+baseMaxDamage+" - NEW MAX DAMAGE - "+finalMaxDamage);
	CustomerServiceLog("jedi_saber", "Converting LightSaber ("+saber+") - NEW SPEED - "+clickMasterSpeed);
	CustomerServiceLog("jedi_saber", "Converting LightSaber ("+saber+") - NEW ACTION - "+clickMasterActionCost);

	//recalc the saber contents after 2 seconds to let everything settle
	messageTo(saber, "handleResetSaberStats", null, 2.0f, false);

}

void validateWeaponRange(obj_id weapon)
{
// In GU5 we changed weapon crafting. We need to make sure range checks handle the new system
	if(hasObjVar(weapon, OBJVAR_NEW_WP))
	{
		range_info rangeData = getWeaponRangeInfo(weapon);

		boolean rangeAltered = false;
		float currentMinRange = rangeData.minRange;
		float currentMaxRange = rangeData.maxRange;

		int minRange = getNewWeaponMinRange(weapon);
		int maxRange = getNewWeaponMaxRange(weapon);

		if (currentMinRange > minRange)
		{
			rangeData.minRange=minRange;
			rangeAltered = true;
		}

		if (currentMaxRange != maxRange)
		{
			rangeData.maxRange=maxRange;
			rangeAltered = true;
		}

		if(rangeAltered)
			setWeaponRangeInfo(weapon, rangeData);
	}
	else
	{
		validateWeaponRange(weapon, getWeaponDat(weapon));
	}
}

void validateWeaponRange(obj_id weapon, dictionary weaponDat)
{

//validate dictionary
	if (weaponDat == null)
		return;

//validate the min/max weapon ranges
	range_info rangeData = getWeaponRangeInfo(weapon);

	boolean rangeAltered = false;
	float currentMinRange = rangeData.minRange;
	float currentMaxRange = rangeData.maxRange;

	int minRange = getMinRangeDistance(weaponDat);
	int maxRange = getMaxRangeDistance(weaponDat);

	if (currentMinRange > minRange)
	{
		rangeData.minRange=minRange;
		rangeAltered = true;
	}

	if (currentMaxRange != maxRange)
	{
		rangeData.maxRange=maxRange;
		rangeAltered = true;
	}

	if(rangeAltered)
		setWeaponRangeInfo(weapon, rangeData);

}

//this verifys the objvars on the factory crate and sets them to correct values if out of range
void validateWeaponFacoryCrateRange(obj_id crate, dictionary weaponDat)
{

	float baseMinDamage	= getFloatObjVar(crate, "crafting_attributes.crafting:minDamage");
	float baseMaxDamage	= getFloatObjVar(crate, "crafting_attributes.crafting:maxDamage");
	int clickMasterMinDamageHigh = getMinDamageHighCap(weaponDat);
	int clickMasterMaxDamageHigh = getMaxDamageHighCap(weaponDat);
	int clickMasterMinDamageLow = getMinDamageLowCap(weaponDat);
	int clickMasterMaxDamageLow = getMaxDamageLowCap(weaponDat);

	//if Min damage is greater or less than the master table, set it to master table min
	if(baseMinDamage > clickMasterMinDamageHigh || baseMinDamage < clickMasterMinDamageLow)
		setObjVar(crate, "crafting_attributes.crafting:minDamage", (float)(clickMasterMinDamageHigh));

	//if Max damage is greater or less than the master table, set it to master table max
	if(baseMaxDamage > clickMasterMaxDamageHigh || baseMaxDamage < clickMasterMaxDamageLow)
		setObjVar(crate, "crafting_attributes.crafting:maxDamage", (float)(clickMasterMaxDamageHigh));

	//set to speed constant from the master table
	int clickMasterSpeed = getSpeedLow(weaponDat);
	setObjVar(crate, "crafting_attributes.crafting:attackSpeed", (float)(clickMasterSpeed));

	//set action to action from master table
	int clickMasterActionCost = getAttackCostLow(weaponDat);
	setObjVar(crate, "crafting_attributes.crafting:attackCost", (float)(clickMasterActionCost));

	//set wound to wound from master table
	int clickMasterWoundChance = getWoundChanceLow(weaponDat);
	setObjVar(crate, "crafting_attributes.crafting:woundChance", (float)(clickMasterWoundChance));

	//range validator
	int clickMasterMaxRange = getMaxRangeDistance(weaponDat);
	setObjVar(crate, "crafting_attributes.crafting:maxRange", (float)(clickMasterMaxRange));

	//check weapon damage type
	float currentDamageType = getFloatObjVar(crate, "crafting_attributes.crafting:damageType");
	int clickMasterDamageType = getDamageType(weaponDat);
	if(currentDamageType != clickMasterDamageType);
	{
		setObjVar(crate, "crafting_attributes.crafting:damageType", (float)(clickMasterDamageType));
	}

	float weaponElementalType = getFloatObjVar(crate, "crafting_attributes.crafting:elementalType");

	//check weapon elemental damage type
	if (weaponElementalType > 0 )
	{
		//int currentElementalDamageType = getWeaponElementalType(weapon);
		int clickMasterElementalDamageType = getElementalType(weaponDat);
		float currentElementalDamage = getFloatObjVar(crate, "crafting_attributes.crafting:elementalValue");
		int clickMasterElementalDamage = ((getElementalValueLow(weaponDat) + getElementalValueHigh(weaponDat))/2);

		if(weaponElementalType != clickMasterElementalDamageType);
		{
			setObjVar(crate, "crafting_attributes.crafting:elementalType", (float)(clickMasterElementalDamageType));
		}

		if( currentElementalDamage > clickMasterElementalDamage)
		{
			setObjVar(crate, "crafting_attributes.crafting:elementalValue", (float)(clickMasterElementalDamage));
		}
	}

	setConversionId(crate,CONVERSION_VERSION);
	recomputeCrateAttributes(crate);
}

//helper function to verify master version number
boolean isVersionCurrent(obj_id object)
{
	int currentVersion = getConversionId(object);
	int masterVersion = CONVERSION_VERSION;
	//LOG("jedi_saber", "WEAPON VALIDATION:CURRENT VERSION " +object+ " VERSION " + currentVersion);
	//LOG("jedi_saber", "WEAPON VALIDATION:MASTER VERSION " +object+ " VERSION " + CONVERSION_VERSION);
	if (currentVersion == masterVersion)
		return true;
	else
		return false;
}

//we use this in several crafting scripts to make sure they have been fixed post click era
void validateWeaponFactoryCrateFromSchematic(obj_id crate)
{
	int draftSchematicObjectTemplateCrc = getIntObjVar(crate, "draftSchematic");
	if(draftSchematicObjectTemplateCrc != 0)
	{
		string draftSchematicObjectTemplate = getObjectTemplateName(draftSchematicObjectTemplateCrc);
		if(draftSchematicObjectTemplate !=  null && draftSchematicObjectTemplate != "")
		{
			string weaponObjectTemplate = getTemplateCreatedFromSchematic(draftSchematicObjectTemplate);
			if(weaponObjectTemplate !=  null && weaponObjectTemplate != "")
			{
				dictionary weaponDat = getWeaponDat(weaponObjectTemplate);
				if(weaponDat == null)
					return;
				else
					validateWeaponFacoryCrateRange(crate, weaponDat);
			}
		}
	}
}
//check to see if we pass version check and then validate us if we are a crate or destory if a schematic
void initalizeWeaponFactoryCrateManufacturingSchematics(obj_id self)
{
	if(!weapons.isVersionCurrent(self))
	{
		//LOG("jedi_saber", "WEAPON VALIDATION:I FAILED CURRENT VERSION " +self);
		//check to see if we are a factory crate, if we are fix stats
		if (isGameObjectTypeOf(getGameObjectType(self), GOT_misc_factory_crate))
			weapons.validateWeaponFactoryCrateFromSchematic(self);
		//check to see if we are a Manufaturing Schematic, if we are destroy object
		if (isGameObjectTypeOf(getGameObjectType(self), GOT_data_manufacturing_schematic))
		{
			//LOG("jedi_saber", "WEAPON VALIDATION:I AM A MANUFATURING SCHEMATIC" +self);
			if(!hasObjVar(self, craftinglib.OBJVAR_IN_CRAFTING_SESSION))
			{
				destroyObject(self);
				//LOG("jedi_saber", "WEAPON VALIDATION:OBJECT DELETED " +self);
			}
		}
	}
}


weapon_data getNewWeaponData(obj_id objWeapon)
{
	if(!utils.hasScriptVar(objWeapon, "dctWeaponStats"))
	{
		return null;
	}
	dictionary dctWeaponStats = utils.getDictionaryScriptVar(objWeapon, "dctWeaponStats");
	return fillWeaponData(objWeapon, dctWeaponStats);
}

weapon_data fillWeaponData(obj_id weapon, combat_data dat)
{
	weapon_data weaponData = new weapon_data();
	weaponData.id = weapon;
	weaponData.minDamage = dat.overloadWeaponMinDamage;
	weaponData.maxDamage=  dat.overloadWeaponMaxDamage;
	weaponData.maxRange=  dat.overloadWeaponMaxRange;
	//Hack to allow melee only procs to fire
	//current the default weapon type is pistol
	if(!dat.specialLine.equals("no_proc"))
	{
		weaponData.weaponType =  dat.overloadWeaponType;
		weaponData.weaponCategory = dat.overloadWeaponCategory;
	}
	else
	{
		weapon_data default_data = getWeaponData(weapon);
		weaponData.weaponType =  default_data.weaponType;
		weaponData.weaponCategory = default_data.weaponCategory;
	}
	weaponData.damageType =  dat.overloadWeaponDamageType;
	weaponData.elementalType=  dat.overloadWeaponElementalType;
	weaponData.elementalValue=  dat.overloadWeaponElementalValue;
	weaponData.attackSpeed =  dat.overloadWeaponAttackSpeed;
	weaponData.damageRadius=  dat.overloadWeaponDamageRadius;
	return weaponData;
}

weapon_data fillWeaponData(obj_id objWeapon, dictionary dctWeaponStats)
{
	weapon_data weaponData = new weapon_data();
	weaponData.id = objWeapon;
	weaponData.minDamage = dctWeaponStats.getInt("minDamage");
	weaponData.maxDamage= dctWeaponStats.getInt("maxDamage");
	weaponData.maxRange= dctWeaponStats.getFloat("maxRange");
//	LOG("npe", "weapon Range from dct is "+weaponData.maxRange);
	weaponData.weaponType = dctWeaponStats.getInt("weaponType");
	weaponData.weaponCategory = dctWeaponStats.getInt("weaponCategory");
	weaponData.damageType = dctWeaponStats.getInt("damageType");
	weaponData.elementalType= dctWeaponStats.getInt("elementalType");
	weaponData.elementalValue= dctWeaponStats.getInt("elementalValue");
	weaponData.attackSpeed = dctWeaponStats.getFloat("attackSpeed");
	weaponData.damageRadius= dctWeaponStats.getFloat("damageRadius");
	return weaponData;
}

void setWeaponData(obj_id objWeapon)
{
	dictionary dctWeaponStats = new dictionary();
	dctWeaponStats.put("id", objWeapon);
	dctWeaponStats.put("minDamage", getWeaponMinDamage(objWeapon));
	dctWeaponStats.put("maxDamage", getWeaponMaxDamage(objWeapon));
	dctWeaponStats.put("maxRange", getMaxRange(objWeapon));
//	LOG("npe", "set weapon range to "+getMaxRange(objWeapon));
	dctWeaponStats.put("weaponType", getWeaponType(objWeapon));
	dctWeaponStats.put("weaponCategory",  combat.getWeaponCategory(getWeaponType(objWeapon)));
	dctWeaponStats.put("damageType", getWeaponDamageType(objWeapon));
	dctWeaponStats.put("elementalType", getWeaponElementalType(objWeapon));
	dctWeaponStats.put("elementalValue",getWeaponElementalValue(objWeapon));
	dctWeaponStats.put("attackSpeed", getWeaponAttackSpeed(objWeapon));
	dctWeaponStats.put("damageRadius", getWeaponDamageRadius(objWeapon));
	utils.setScriptVar(objWeapon, "dctWeaponStats", dctWeaponStats);
}

void setWeaponData(obj_id objWeapon, int intMinDamage, int intMaxDamage, float fltMaxRange, int intWeaponType, int intDamageType, int intElementalType, int intElementalValue, float fltAttackSpeed, float fltDamageRadius)
{

	dictionary dctWeaponStats = new dictionary();
	dctWeaponStats.put("id", objWeapon);
	dctWeaponStats.put("minDamage", intMinDamage);
	dctWeaponStats.put("maxDamage", intMaxDamage);
	dctWeaponStats.put("maxRange", fltMaxRange);
//	LOG("npe", "set weapon 2 range to "+fltMaxRange);
	dctWeaponStats.put("weaponType", intWeaponType);
	dctWeaponStats.put("weaponCategory",  combat.getWeaponCategory(intWeaponType));
	dctWeaponStats.put("damageType", intDamageType);
	dctWeaponStats.put("elementalType", intElementalType);
	dctWeaponStats.put("elementalValue",intElementalValue);
	dctWeaponStats.put("attackSpeed", fltAttackSpeed);
	dctWeaponStats.put("damageRadius", fltDamageRadius);
	utils.setScriptVar(objWeapon, "dctWeaponStats", dctWeaponStats);
	return;

}

void adjustWeaponRangeForExpertise(obj_id player, obj_id self, boolean modify)
{
	if(!hasObjVar(self, "weapon.original_max_range") )
		return;

	range_info rangeData = getWeaponRangeInfo(self);
	float originalRange = getFloatObjVar(self, "weapon.original_max_range");

	if(modify)
	{
		int weaponType = getWeaponType(self);
		float rangeMod = getSkillStatisticModifier(player, "expertise_range_bonus_all");
		rangeMod += getSkillStatisticModifier(player, "expertise_range_bonus_" + combat.getWeaponStringType(weaponType));

		if (combat.isRangedWeapon(self) || combat.isHeavyWeapon(self))
			rangeMod +=getSkillStatisticModifier(player, "expertise_range_bonus_ranged");
		if (combat.isMeleeWeapon(self))
			rangeMod +=getSkillStatisticModifier(player, "expertise_range_bonus_melee");

		// Smuggler Rank range bonus
		rangeMod += getSkillStatisticModifier(player, "expertise_sm_rank_range_bonus");

		float adjustedMaxRange = rangeMod + originalRange;

		if(adjustedMaxRange > 64)
		{
			adjustedMaxRange = 64;
		}

		rangeData.maxRange = adjustedMaxRange;
	}
	else
	{
		rangeData.maxRange = originalRange;
	}

	setWeaponRangeInfo(self, rangeData);
	setWeaponData(self);
}


void validateWeaponDamageType(obj_id weapon)
{
// in GU5 we changed weapon crafting. we need to validate based on the new weapon objvars
	if(hasObjVar(weapon, OBJVAR_NEW_WP))
	{
		//check weapon damage type
		int currentDamageType = getWeaponDamageType(weapon);
		int damageType = getNewWeaponDamageType(weapon);
		if(currentDamageType != damageType);
		{
			setWeaponDamageType(weapon, damageType);
		}
	}
	else
	{
		validateWeaponDamageType(weapon, getWeaponDat(weapon));
	}
}


void validateWeaponDamageType(obj_id weapon, dictionary weaponDat)
{
	//validate dictionary
	if (weaponDat == null)
		return;

	//check weapon damage type
	int currentDamageType = getWeaponDamageType(weapon);
	int damageType = getDamageType(weaponDat);
	if(currentDamageType != damageType);
	{
		setWeaponDamageType(weapon, damageType);
	}

}

int getCoreLevel(obj_id prototype)
{
	if(hasObjVar(prototype, OBJVAR_WP_LEVEL))
		return getIntObjVar(prototype, OBJVAR_WP_LEVEL);
	else
		return (int)getFloatObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreLevel");
}

float getWeaponCoreQualityMin(obj_id prototype)
{
	return getFloatObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MIN);
}

float getWeaponCoreQualityMax(obj_id prototype)
{
	return getFloatObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MAX);
}

float getNewWeaponElementalType(obj_id prototype)
{
	if(hasObjVar(prototype, OBJVAR_ELEMENTAL_TYPE))
		return getFloatObjVar(prototype, OBJVAR_ELEMENTAL_TYPE);

	//we dont have an elemental type.
	return -1;
}

float getNewWeaponElementalValue(obj_id prototype)
{
	return getFloatObjVar(prototype, OBJVAR_ELEMENTAL_VALUE);
}

float getWeaponGasQualityMin(obj_id prototype)
{
	return getFloatObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MIN);
}

float getWeaponGasQualityMax(obj_id prototype)
{
	return getFloatObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MAX);
}

//some weapons have an inherent elemental bonus
//this function returns that bonus.
//some weapons also have an inherent elemental penalty
int getElementalAppearanceBonus(obj_id prototype)
{
	if(!isIdValid(prototype) || !exists(prototype))
	{
		return 0;
	}

	string template = getTemplateName(prototype);
	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_BONUS_TABLE);
	if(row < 0)
	{
		return 0;
	}

	int appBonus = dataTableGetInt(WEAPON_APP_BONUS_TABLE, row, "ele_bonus");

	return appBonus;
}


//function for getting the core data from the table for the prototype

int getCoreMinDamage(obj_id prototype, dictionary weaponDat)
{
	if(!isIdValid(prototype) || !exists(prototype))
	{
		return -1;
	}

	if(weaponDat == null || weaponDat.isEmpty())
	{
		return -1;
	}

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getCoreMinDamage::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return -1;
	}

	int wpType = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_TYPE);

	string weaponType = WEAPON_TYPES[wpType];
	int minDamage = weaponDat.getInt(weaponType + "_min_damage");
	return minDamage;
}

int getCoreMaxDamage(obj_id prototype, dictionary weaponDat)
{
	if(!isIdValid(prototype) || !exists(prototype))
	{
		return -1;
	}

	if(weaponDat == null || weaponDat.isEmpty())
	{
		return -1;
	}

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getCoreMaxDamage::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return -1;
	}

	int wpType = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_TYPE);

	string weaponType = WEAPON_TYPES[wpType];

	int maxDamage = weaponDat.getInt(weaponType + "_max_damage");

	return maxDamage;
}


int getWeaponSpeed(obj_id prototype)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return 1;

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getWeaponSpeed::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return 1;
	}

	int speed = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_SPEED);

	return speed;
}

int getNewWeaponWoundChance(obj_id prototype)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return 0;

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getNewWeaponWoundChance::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return 0;
	}

	int woundChance = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_WOUND);

	return woundChance;
}

int getNewWeaponAttackCost(obj_id prototype)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return 0;

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getNewWeaponAttackCost::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return 0;
	}

	int attackCost = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_COST);

	return attackCost;
}

int getNewWeaponAccuracy(obj_id prototype)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return 0;

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getNewWeaponAccuracy::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return 0;
	}

	int wpnAcc = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_ACC);

	return wpnAcc;
}

int getNewWeaponTableElementType(obj_id prototype)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return -1;

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getNewWeaponTableElementType::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return -1;
	}

	int elementType = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_ELEMENT_TYPE);

	return elementType;
}
//
int getNewWeaponTableElementalValue(obj_id prototype, dictionary weaponDat)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return -1;

	if(weaponDat == null || weaponDat.isEmpty())
		return -1;

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getNewWeaponTableElementalValue::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return -1;
	}

	int wpType = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_TYPE);

	string weaponType = WEAPON_TYPES[wpType];

	int elementalValue = weaponDat.getInt("elemental_" + weaponType + "_average_damage");

	return elementalValue;
}

int getNewWeaponDamageType(obj_id prototype)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return -1;

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getNewWeaponDamageType::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return -1;
	}

	int damageType = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_DAMAGE_TYPE);

	return damageType;
}

int getNewWeaponMaxRange(obj_id prototype)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return -1;

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getNewWeaponMaxRange::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return -1;
	}

	int maxRange = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_MAX_RANGE);

	return maxRange;
}

int getNewWeaponMinRange(obj_id prototype)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return -1;

	string template = getTemplateName(prototype);

	int row = dataTableSearchColumnForString(template, WEAPON_APP_TEMPLATE, WEAPON_APP_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("weaponsCraftingError", "getNewWeaponMinRange::Could not find template("+template+") in weapon appearance table for prototype " + prototype);
		return -1;
	}

	int minRange = dataTableGetInt(WEAPON_APP_TABLE, row, WEAPON_APP_MIN_RANGE);

	return minRange;
}


boolean performSocketing(obj_id prototype, string[] expMods)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return false;

	if(expMods == null || expMods.length < 0)
		return false;

	// Bore us out some new fangled sockets provided we have some minimal skill.
	obj_id player = getOwner(prototype);
	int[] mods = getEnhancedSkillStatisticModifiers(player, expMods);

	if ( mods != null )
	{
		int sockets = 0;
		int experimentModTotal = 0;
		for ( int j = 0; j < mods.length; ++j )
		{
			experimentModTotal += mods[j];
		}

		if ( experimentModTotal > craftinglib.socketThreshold )
		{

			int chances = 1 + (experimentModTotal - craftinglib.socketThreshold) / craftinglib.socketDelta;

			for ( int j = 0; j < chances; ++j )
			{
				if ( rand(1, 100) > craftinglib.socketChance )
					++sockets;
			}

			if ( sockets > craftinglib.maxSockets )
				sockets = craftinglib.maxSockets;

			if ( sockets > 0 )
				setCondition(prototype, CONDITION_MAGIC_ITEM);
		}

		setSkillModSockets(prototype, sockets);
	}
	return true;
}
String getDamageTypeString(int type)
{
	boolean initializedDamageTypeNames = false;
	if(!initializedDamageTypeNames)
	{
		initializedDamageTypeNames = true;
		int next = 0;
		DAMAGE_TYPE_NAMES[next++] = "kinetic";
		DAMAGE_TYPE_NAMES[next++] = "energy";
		DAMAGE_TYPE_NAMES[next++] = "blast";
		DAMAGE_TYPE_NAMES[next++] = "stun";
		DAMAGE_TYPE_NAMES[next++] = "restraint";
		DAMAGE_TYPE_NAMES[next++] = "elemental_heat";
		DAMAGE_TYPE_NAMES[next++] = "elemental_cold";
		DAMAGE_TYPE_NAMES[next++] = "elemental_acid";
		DAMAGE_TYPE_NAMES[next++] = "elemental_electrical";
		DAMAGE_TYPE_NAMES[next++] = "environmental_heat";
		DAMAGE_TYPE_NAMES[next++] = "environmental_cold";
		DAMAGE_TYPE_NAMES[next++] = "environmental_acid";
		DAMAGE_TYPE_NAMES[next++] = "environmental_electrical";
	}
	int i = 0;
	int c = 1;
	while(c < type)
	{
		c *= 2;
		i++;
	}
	return DAMAGE_TYPE_NAMES[i];
}

boolean storeWeaponCraftingValues(obj_id prototype, obj_id schematicId, draft_schematic schematic)
{
	draft_schematic.slot[] slots = schematic.getSlots();
	draft_schematic.attribute[] objectAttribs = schematic.getAttribs();
	draft_schematic.attribute[] experimentalAttribs = schematic.getExperimentalAttribs();

	// set up an array of the object attribute names
	for ( int i = 0; i < slots.length; ++i )
	{
		obj_id componentId = slots[i].ingredients[0].ingredient;
		if(!isIdValid(componentId) || !exists(componentId))
		{
			//appears to be no slot here, lets see if we are coming from a crate.
			componentId = schematicId;
			if(!isIdValid(componentId) || !exists(componentId))
			{
				continue;
			}
		}


		//RE modifier attribute
		if(hasObjVar(componentId, "reverse_engineering.reverse_engineering_modifier"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar reverse_engineering.reverse_engineering_modifier");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting RE Bit data now on prototype " + prototype);

			string reStatMod = getStringObjVar(componentId, "reverse_engineering.reverse_engineering_modifier");
			int ratio = getIntObjVar(componentId, "reverse_engineering.reverse_engineering_ratio");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ratio " + ratio + " on prototype " + prototype);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::reStatMod " + reStatMod + " on prototype " + prototype);

			setObjVar(prototype, craftinglib.OBJVAR_RE_RATIO, ratio);
			setObjVar(prototype, craftinglib.OBJVAR_RE_STAT_MODIFIED, reStatMod);
		}
		//RE Power Mod attribute
		if(hasObjVar(componentId, "reverse_engineering.reverse_engineering_power"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar reverse_engineering.reverse_engineering_power");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting RE Bit data now on prototype " + prototype);

			float powerMod = getIntObjVar(componentId, "reverse_engineering.reverse_engineering_power");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::powerMod before modification of 40% " + powerMod + " on prototype " + prototype);

			powerMod *= craftinglib.RE_POWER_MODIFIER;

			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::powerMod after modification of 40% " + powerMod + " on prototype " + prototype);

			setObjVar(prototype, craftinglib.OBJVAR_RE_VALUE, powerMod);
		}
		//core quality min
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar" + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting coreQualityLow data now on prototype " + prototype);

			float coreQualityLow = getFloatObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::coreQualityLow " + coreQualityLow + " on prototype " + prototype);
			setObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MIN, coreQualityLow);
		}
		//core quality max
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar" + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting coreQualityHigh data now on prototype " + prototype);

			float coreQualityHigh = getFloatObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::coreQualityHigh " + coreQualityHigh + " on prototype " + prototype);
			setObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MAX, coreQualityHigh);
		}
		//Appearance Bonus Min
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "appearanceBonusLow"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar" + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "appearanceBonusLow");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting coreQuality data now on prototype " + prototype);

			float appBonus = getFloatObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "appearanceBonusLow");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::appearanceBonusLow " + appBonus + " on prototype " + prototype);
			setObjVar(prototype, OBJVAR_MODIFIER_APPEARANCE_BONUS_MIN, appBonus);
		}
		//Appearance Bonus Max
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "appearanceBonusHigh"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar" + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "appearanceBonusHigh");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting coreQuality data now on prototype " + prototype);

			float appBonus = getFloatObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "appearanceBonusHigh");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::appearanceBonusHigh " + appBonus+ " on prototype " + prototype);
			setObjVar(prototype, OBJVAR_MODIFIER_APPEARANCE_BONUS_MAX, appBonus);
		}
		//gasQuality min
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityLow"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityLow");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting gasQualityLow data now on prototype " + prototype);
			if(!hasObjVar(componentId, OBJVAR_MODIFIER_GAS_QUALITY_MIN))
			{
				float gasQualityLow = getIntObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityLow");
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::gasQualityLow " + gasQualityLow+ " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MIN, gasQualityLow);
			}
			else
			{
				float gasQualityLow = getIntObjVar(componentId, OBJVAR_MODIFIER_GAS_QUALITY_MIN);
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::gasQualityLow " + gasQualityLow + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MIN, gasQualityLow);
			}
		}
		//gasQuality max
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityHigh"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityHigh");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting gasQualityHigh data now on prototype " + prototype);
			if(!hasObjVar(componentId, OBJVAR_MODIFIER_GAS_QUALITY_MAX))
			{
				float gasQualityHigh = getIntObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityHigh");
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::gasQualityHigh " + gasQualityHigh + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MAX, gasQualityHigh);
			}
			else
			{
				float gasQualityHigh = getIntObjVar(componentId, OBJVAR_MODIFIER_GAS_QUALITY_MAX);
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::gasQualityHigh " + gasQualityHigh + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MAX, gasQualityHigh);
			}
		}
		//meleeQuality min
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityLow"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityLow");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting meleeComponentQualityLow data now on prototype " + prototype);
			if(!hasObjVar(componentId, OBJVAR_MODIFIER_MELEE_QUALITY_MIN))
			{
				float meleeQuality = getIntObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityLow");
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::meleeComponentQualityLow " + meleeQuality + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MIN, meleeQuality);
			}
			else
			{
				float meleeQuality = getIntObjVar(componentId, OBJVAR_MODIFIER_MELEE_QUALITY_MIN);
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::meleeComponentQualityLow " + meleeQuality + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MIN, meleeQuality);
			}
		}
		//meleeQuality max
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityHigh"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityHigh");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting meleeComponentQualityHigh data now on prototype " + prototype);
			if(!hasObjVar(componentId, OBJVAR_MODIFIER_MELEE_QUALITY_MAX))
			{
				float meleeQuality = getIntObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityHigh");
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::meleeComponentQualityHigh " + meleeQuality + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MAX, meleeQuality);
			}
			else
			{
				float meleeQuality = getIntObjVar(componentId, OBJVAR_MODIFIER_MELEE_QUALITY_MAX);
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::meleeComponentQualityHigh " + meleeQuality + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MAX, meleeQuality);
			}
		}
		//elemental Value
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "elementalValue"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "elementalValue");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting elementalValue data now on prototype " + prototype);

			float elementalValue = getFloatObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "elementalValue");
			if(elementalValue >= 0.0f)
			{
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::elementalValue " + elementalValue + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_ELEMENTAL_VALUE, elementalValue);
			}
		}
		//elemental Type
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "elementalType"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "elementalType");

			float elementalType = getFloatObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "elementalType");
			if(elementalType >= 0)
			{
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting elementalType data now on prototype " + prototype);
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::elementalType " + elementalType + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_ELEMENTAL_TYPE, elementalType);
			}
		}
		//RE modifier component
		if(hasObjVar(componentId, craftinglib.OBJVAR_RE_STAT_MODIFIED))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.OBJVAR_RE_STAT_MODIFIED);

			string statModified = getStringObjVar(componentId, craftinglib.OBJVAR_RE_STAT_MODIFIED);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting statModified data now on prototype " + prototype);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::statModified " + statModified + " on prototype " + prototype);
			setObjVar(prototype, craftinglib.OBJVAR_RE_STAT_MODIFIED, statModified);

			int ratio = getIntObjVar(componentId, craftinglib.OBJVAR_RE_RATIO);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting ratio data now on prototype " + prototype);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ratio " + ratio + " on prototype " + prototype);
			setObjVar(prototype, craftinglib.OBJVAR_RE_RATIO, ratio);
		}
		//RE Power Bit component
		if(hasObjVar(componentId, craftinglib.OBJVAR_RE_VALUE))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.OBJVAR_RE_VALUE);

			float powerBit = getFloatObjVar(componentId, craftinglib.OBJVAR_RE_VALUE);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting powerBit data now on prototype " + prototype);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::powerBit " + powerBit + " on prototype " + prototype);
			setObjVar(prototype, craftinglib.OBJVAR_RE_VALUE, powerBit);
		}
		//coreQuality component min
		if(hasObjVar(componentId, OBJVAR_WP_CORE_QUALITY_MIN))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + OBJVAR_WP_CORE_QUALITY_MIN);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting coreQualityLow data now on prototype " + prototype);

			float coreQuality = getFloatObjVar(componentId, OBJVAR_WP_CORE_QUALITY_MIN);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::coreQualityLow " + coreQuality + " on prototype " + prototype);
			setObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MIN, coreQuality);
		}
		//coreQuality component max
		if(hasObjVar(componentId, OBJVAR_WP_CORE_QUALITY_MAX))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + OBJVAR_WP_CORE_QUALITY_MAX);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting coreQualityHigh data now on prototype " + prototype);

			float coreQuality = getFloatObjVar(componentId, OBJVAR_WP_CORE_QUALITY_MAX);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::coreQualityHigh " + coreQuality + " on prototype " + prototype);
			setObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MAX, coreQuality);
		}
		//gasQuality component min
		if(hasObjVar(componentId, OBJVAR_MODIFIER_GAS_QUALITY_MIN))
		{
			float gasQuality = getFloatObjVar(componentId, OBJVAR_MODIFIER_GAS_QUALITY_MIN);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + OBJVAR_MODIFIER_GAS_QUALITY_MIN);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting gasQualityLow data now to " + gasQuality + " on prototype " + prototype);

			setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MIN, gasQuality);
		}
		//gasQuality component max
		if(hasObjVar(componentId, OBJVAR_MODIFIER_GAS_QUALITY_MAX))
		{
			float gasQuality = getFloatObjVar(componentId, OBJVAR_MODIFIER_GAS_QUALITY_MAX);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + OBJVAR_MODIFIER_GAS_QUALITY_MAX);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting gasQualityHigh data now to " + gasQuality + " on prototype " + prototype);

			setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MAX, gasQuality);
		}
		//elemental Value component
		if(hasObjVar(componentId, OBJVAR_ELEMENTAL_VALUE))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + OBJVAR_ELEMENTAL_VALUE);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting elementalValue data now on prototype " + prototype);

			float elementalValue = getFloatObjVar(componentId, OBJVAR_ELEMENTAL_VALUE);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::elementalValue " + elementalValue + " on prototype " + prototype);
			setObjVar(prototype, OBJVAR_ELEMENTAL_VALUE, elementalValue);
		}
		//elemental Type component
		if(hasObjVar(componentId, OBJVAR_ELEMENTAL_TYPE))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + OBJVAR_ELEMENTAL_TYPE);

			float elementalType = getFloatObjVar(componentId, OBJVAR_ELEMENTAL_TYPE);
			if(elementalType >= 0)
			{
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting elementalType data now on prototype " + prototype);
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::elementalType " + elementalType + " on prototype " + prototype);
				setObjVar(prototype, OBJVAR_ELEMENTAL_TYPE, elementalType);
			}
		}
		//coreLevel component
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreLevel"))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreLevel");

			int corelevel = (int)getFloatObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreLevel");
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting corelevel data now on prototype " + prototype);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::corelevel " + corelevel + " on prototype " + prototype);
			setObjVar(prototype, OBJVAR_WP_LEVEL, corelevel);
		}
		//scope, stock, vibroblade components min
		if(hasObjVar(componentId, weapons.OBJVAR_MODIFIER_COMPONENT_BONUS_MIN) && !hasObjVar(prototype, OBJVAR_NEW_WP_WEAPON))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::componentBonus::ingredient " + componentId + " has the objvar " + weapons.OBJVAR_MODIFIER_COMPONENT_BONUS_MIN);
			float previousBonus = getFloatObjVar(prototype, weapons.OBJVAR_MODIFIER_COMPONENT_BONUS_MIN);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::componentBonus::previousBonusMin " + previousBonus + " from prototype " + prototype);
			float componentBonus = getFloatObjVar(componentId, weapons.OBJVAR_MODIFIER_COMPONENT_BONUS_MIN);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::componentBonus::componentBonusMin " + componentBonus + " from slotObject " + componentId);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::componentBonus::setting componentBonus data now on prototype " + prototype);
			setObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MIN, (previousBonus + componentBonus));
		}
		//scope, stock, vibroblade components max
		if(hasObjVar(componentId, weapons.OBJVAR_MODIFIER_COMPONENT_BONUS_MAX) && !hasObjVar(prototype, OBJVAR_NEW_WP_WEAPON))
		{
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::componentBonus::ingredient " + componentId + " has the objvar " + weapons.OBJVAR_MODIFIER_COMPONENT_BONUS_MAX);

			float previousBonus = getFloatObjVar(prototype, weapons.OBJVAR_MODIFIER_COMPONENT_BONUS_MAX);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::componentBonus::previousBonusMax " + previousBonus + " from prototype " + prototype);
			float componentBonus = getFloatObjVar(componentId, weapons.OBJVAR_MODIFIER_COMPONENT_BONUS_MAX);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ccomponentBonus::omponentBonusMax " + componentBonus + " from slotObject " + componentId);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::componentBonus::setting componentBonus data now on prototype " + prototype);
			setObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MAX, (previousBonus + componentBonus));
		}
		//meleeQuality Component min
		if(hasObjVar(componentId, OBJVAR_MODIFIER_MELEE_QUALITY_MIN))
		{
			float meleeQuality = getFloatObjVar(componentId, OBJVAR_MODIFIER_MELEE_QUALITY_MIN);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + OBJVAR_MODIFIER_MELEE_QUALITY_MIN);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting meleeQuality_min data now to " + meleeQuality + " on prototype " + prototype);

			setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MIN, meleeQuality);
		}
		//meleeQuality Component max
		if(hasObjVar(componentId, OBJVAR_MODIFIER_MELEE_QUALITY_MAX))
		{
			float meleeQuality = getFloatObjVar(componentId, OBJVAR_MODIFIER_MELEE_QUALITY_MAX);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + OBJVAR_MODIFIER_MELEE_QUALITY_MAX);
			CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting meleeQuality_max data now to " + meleeQuality + " on prototype " + prototype);

			setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MAX, meleeQuality);
		}
		//weapon enhancers
		if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "combat_critical_ranged") || hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "combat_critical_melee"))
		{
			if(isRangedCore(prototype) || isMeleeCore(prototype) || isHeavyCore(prototype))
			{
				int critBonus = 0;
				if(hasObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "combat_critical_ranged"))
				{
					CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "combat_critical_ranged");
					critBonus = getIntObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "combat_critical_ranged");
					setObjVar(prototype, OBJVAR_CRIT_BONUS_RANGED, critBonus);
					CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting critBonus data now to " + critBonus + " on prototype " + prototype);
					setCategorizedSkillModBonus(prototype, "weapon", "combat_critical_ranged", critBonus);
				}
				else
				{
					CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "combat_critical_melee");
					critBonus = getIntObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "combat_critical_melee");
					setObjVar(prototype, OBJVAR_CRIT_BONUS_MELEE, critBonus);
					CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting critBonus data now to " + critBonus + " on prototype " + prototype);
					setCategorizedSkillModBonus(prototype, "weapon", "combat_critical_melee", critBonus);
				}
			}
		}
		//weapon augmentations
		if(hasObjVar(componentId, "attribute.bonus"))
		{
			LOG("sissynoid", "attribute.bonus found");

			int[] attribsModified = getAttributeBonuses(componentId);

			if(attribsModified != null && attribsModified.length > 0)
			{
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::ingredient " + componentId + " has an attribute bonus.");
				int[] attribBonus = new int[NUM_ATTRIBUTES];
				for(int j = 0; j < attribsModified.length; ++j)
				{
					if(attribsModified[j] > 0)
					{
						attribBonus[j] = attribsModified[j];
						CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting Attribute Bonus " + ATTRIBUTES[j] + " To " + attribsModified[j]);
					}
				}
				setAttributeBonuses(prototype, attribBonus);
			}
			
			/**********Cybernetic Components - If the Cybernetic has an Armor Core**********
			***********reduce armor value - armor value is reduced in the following*********
			***********systems.crafting.armor.crafting_new_cybernetics_final.script********/
			//these are attribute bonus modules - and they are adding armor cores to the item.
			if(hasObjVar(componentId, "attribute.bonus") && hasObjVar(prototype, "armor.general_protection"))
			{
				CustomerServiceLog("new_weapon_crafting", "Cybernetics: Component("+ componentId +") is being added to a Cybernetic("+ prototype +") that has an Armor Core; Armor Value Reduction will occur by design.");
				LOG("sissynoid", "Cybernetic has Armor Core and Modules - Nerf the Core: prototype: " + prototype);
				setObjVar(prototype, "modifyCyberneticArmorValue", true);
			}
		}
		//cybernetic special protection (layer) enhancement modules
		if(hasObjVar(componentId, "cybernetic.special_protection"))
		{
			LOG("sissynoid", "Cybernetic Protection Module found!");
			int protectionType = getIntObjVar(componentId, "cybernetic.special_protection");
			setObjVar(prototype, "cybernetic.special_protection.type", protectionType);
			float protectionValue = getFloatObjVar(componentId, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "cybernetic_electrical_resist_module");
			setObjVar(prototype, "cybernetic.special_protection.value", protectionValue);
			CustomerServiceLog("new_weapon_crafting", "Cybernetics: Component("+ componentId +") has Special Protection - Adding these to the Cybernetic("+ prototype +"): protection type: (" + protectionType + ") and Value: (" + protectionValue + ").");
			LOG("sissynoid", "WEAPON SCRIPTLIB: protection module type: " + protectionType + " and Value: " + protectionValue);
		}
		//weapon enhancers components
		if(hasObjVar(componentId, OBJVAR_CRIT_BONUS_MELEE) || hasObjVar(componentId, OBJVAR_CRIT_BONUS_RANGED))
		{
			if(hasObjVar(componentId, OBJVAR_CRIT_BONUS_MELEE))
			{
				int critBonus = getIntObjVar(componentId, OBJVAR_CRIT_BONUS_MELEE);
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting critBonus data now to " + critBonus + " on prototype " + prototype);
				setCategorizedSkillModBonus(prototype, "weapon", "combat_critical_melee", critBonus);
				setObjVar(prototype, OBJVAR_CRIT_BONUS_MELEE, critBonus);
			}
			if(hasObjVar(componentId, OBJVAR_CRIT_BONUS_RANGED))
			{
				int critBonus = getIntObjVar(componentId, OBJVAR_CRIT_BONUS_RANGED);
				CustomerServiceLog("new_weapon_crafting", "storeWeaponCraftingValues::setting critBonus data now to " + critBonus + " on prototype " + prototype);
				setCategorizedSkillModBonus(prototype, "weapon", "combat_critical_ranged", critBonus);
				setObjVar(prototype, OBJVAR_CRIT_BONUS_RANGED, critBonus);
			}
		}
	}
	return true;
}

boolean setComponentObjVars(obj_id prototype, draft_schematic.attribute[] itemAttributes)
{
	if(!isIdValid(prototype) || !exists(prototype))
		return false;


	for ( int i = 0; i < itemAttributes.length; ++i ) // go through all attributes
	{
		float attribValue = itemAttributes[i].currentValue;

		if(itemAttributes[i].name.getAsciiId().equals("gasQualityLow"))
		{
			//if we already have the objvar, we need to be using it.
			if(hasObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MIN))
			{
				if(!hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityLow"))
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") dont have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityLow");
					attribValue = getFloatObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MIN);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new gasQualityLow value is " + attribValue);
				}
				else
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityLow");
					attribValue /= NEW_COMPONENT_MODIFIER;
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new gasQualityLow value is " + attribValue);
				}

				if(attribValue > NEW_COMPONENT_CAP)
				{
					attribValue = NEW_COMPONENT_CAP;
					setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MIN, attribValue);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::gasQualityLow on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
				}

				setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MIN, attribValue);
			}
			else if(hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityLow"))
			{
					attribValue = getFloatObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityLow");

					attribValue /= NEW_COMPONENT_MODIFIER;
					//CustomerServiceLog("new_weapon_crafting", "modifiedValue " + modifiedValue);
					if(attribValue > NEW_COMPONENT_CAP)
					{
						attribValue = NEW_COMPONENT_CAP;
						CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::gasQualityLow on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
					}

					setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MIN, attribValue);
			}
		}

		if(itemAttributes[i].name.getAsciiId().equals("gasQualityHigh"))
		{
			//if we already have the objvar, we need to be using it.
			if(hasObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MAX))
			{
				if(!hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityHigh"))
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") dont have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityHigh");
					attribValue = getFloatObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MAX);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new gasQualityHigh value is " + attribValue);
				}
				else
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityHigh");
					attribValue /= NEW_COMPONENT_MODIFIER;
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new gasQualityHigh value is " + attribValue);
				}

				if(attribValue > NEW_COMPONENT_CAP)
				{
					attribValue = NEW_COMPONENT_CAP;
					setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MAX, attribValue);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::gasQualityHigh on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
				}

				setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MAX, attribValue);
			}
			else if(hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityHigh"))
			{
					attribValue = getFloatObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "gasQualityHigh");

					attribValue /= NEW_COMPONENT_MODIFIER;
					//CustomerServiceLog("new_weapon_crafting", "modifiedValue " + modifiedValue);
					if(attribValue > NEW_COMPONENT_CAP)
					{
						attribValue = NEW_COMPONENT_CAP;
						CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::gasQualityLow on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
					}

					setObjVar(prototype, OBJVAR_MODIFIER_GAS_QUALITY_MAX, attribValue);
			}
		}

		if(itemAttributes[i].name.getAsciiId().equals("componentBonusLow"))
		{
			if(hasObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MIN))
			{
				if(!hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusLow"))
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") dont have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusLow");
					attribValue = getFloatObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MIN);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new componentBonusLow value is " + attribValue);
				}
				else
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusLow");
					attribValue /= NEW_COMPONENT_MODIFIER;
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new componentBonusLow value is " + attribValue);
				}

				if(attribValue > NEW_COMPONENT_CAP)
				{
					attribValue = NEW_COMPONENT_CAP;
					setObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MIN, attribValue);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::componentBonusLow on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
				}

				setObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MIN, attribValue);
			}
			else if(hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusLow"))
			{
					attribValue = getFloatObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusLow");

					attribValue /= NEW_COMPONENT_MODIFIER;
					//CustomerServiceLog("new_weapon_crafting", "modifiedValue " + modifiedValue);
					if(attribValue > NEW_COMPONENT_CAP)
					{
						attribValue = NEW_COMPONENT_CAP;
						CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::gasQualityHigh on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
					}

					setObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MIN, attribValue);
			}
		}

		if(itemAttributes[i].name.getAsciiId().equals("componentBonusHigh"))
		{
			if(hasObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MAX))
			{
				if(!hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusHigh"))
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") dont have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusHigh");
					attribValue = getFloatObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MAX);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new componentBonusHigh value is " + attribValue);
				}
				else
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusHigh");
					attribValue /= NEW_COMPONENT_MODIFIER;
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new componentBonusHigh value is " + attribValue);
				}

				if(attribValue > NEW_COMPONENT_CAP)
				{
					attribValue = NEW_COMPONENT_CAP;
					setObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MAX, attribValue);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::componentBonusHigh on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
				}

				setObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MAX, attribValue);
			}
			else if(hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusHigh"))
			{
					attribValue = getFloatObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "componentBonusHigh");

					attribValue /= NEW_COMPONENT_MODIFIER;
					//CustomerServiceLog("new_weapon_crafting", "modifiedValue " + modifiedValue);
					if(attribValue > NEW_COMPONENT_CAP)
					{
						attribValue = NEW_COMPONENT_CAP;
						CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::gasQualityLow on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
					}

					setObjVar(prototype, OBJVAR_MODIFIER_COMPONENT_BONUS_MAX, attribValue);
			}
		}

		if(itemAttributes[i].name.getAsciiId().equals("meleeComponentQualityLow"))
		{
			if(hasObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MIN))
			{
				if(!hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityLow"))
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") dont have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityLow");
					attribValue = getFloatObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MIN);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new meleeComponentQualityLow value is " + attribValue);
				}
				else
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityLow");
					attribValue /= NEW_COMPONENT_MODIFIER;
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new meleeComponentQualityLow value is " + attribValue);
				}

				if(attribValue > NEW_COMPONENT_CAP)
				{
					attribValue = NEW_COMPONENT_CAP;
					setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MIN, attribValue);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::meleeComponentQualityLow on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
				}

				setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MIN, attribValue);
			}
			else if(hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityLow"))
			{
					attribValue = getFloatObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityLow");

					attribValue /= NEW_COMPONENT_MODIFIER;
					//CustomerServiceLog("new_weapon_crafting", "modifiedValue " + modifiedValue);
					if(attribValue > NEW_COMPONENT_CAP)
					{
						attribValue = NEW_COMPONENT_CAP;
						CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::gasQualityLow on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
					}

					setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MIN, attribValue);
			}
		}

		if(itemAttributes[i].name.getAsciiId().equals("meleeComponentQualityHigh"))
		{
			if(hasObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MAX))
			{
				if(!hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityHigh"))
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") dont have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityHigh");
					attribValue = getFloatObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MAX);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new meleeComponentQualityHigh value is " + attribValue);
				}
				else
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityHigh");
					attribValue /= NEW_COMPONENT_MODIFIER;
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new meleeComponentQualityHigh value is " + attribValue);
				}

				if(attribValue > NEW_COMPONENT_CAP)
				{
					attribValue = NEW_COMPONENT_CAP;
					setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MAX, attribValue);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::meleeComponentQualityHigh on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
				}

				setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MAX, attribValue);
			}
			else if(hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityHigh"))
			{
					attribValue = getFloatObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "meleeComponentQualityHigh");

					attribValue /= NEW_COMPONENT_MODIFIER;
					//CustomerServiceLog("new_weapon_crafting", "modifiedValue " + modifiedValue);
					if(attribValue > NEW_COMPONENT_CAP)
					{
						attribValue = NEW_COMPONENT_CAP;
						CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::gasQualityLow on prototype("+prototype+")was higher than the cap of " + NEW_COMPONENT_CAP + ", so we lowered it to the cap.");
					}

					setObjVar(prototype, OBJVAR_MODIFIER_MELEE_QUALITY_MAX, attribValue);
			}
		}
		if(itemAttributes[i].name.getAsciiId().equals("coreQualityLow"))
		{
			//if we already have the objvar, we need to be using it.
			if(hasObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MIN))
			{
				if(!hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow"))
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") dont have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow");
					attribValue = getFloatObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MIN);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new gasQualityLow value is " + attribValue);
				}
				else
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow");
					attribValue /= WP_CORE_MODIFIER;
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new coreQualityLow value is " + attribValue);
				}

				setObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MIN, attribValue);
				setObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow", attribValue);
			}
			else if(hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow"))
			{
					attribValue = getFloatObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow");

					attribValue /= WP_CORE_MODIFIER;
					//CustomerServiceLog("new_weapon_crafting", "modifiedValue " + modifiedValue);
					setObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MIN, attribValue);
			}
		}

		if(itemAttributes[i].name.getAsciiId().equals("coreQualityHigh"))
		{
			//if we already have the objvar, we need to be using it.
			if(hasObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MAX))
			{
				if(!hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh"))
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") dont have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh");
					attribValue = getFloatObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MAX);
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new gasQualityHigh value is " + attribValue);
				}
				else
				{
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::we("+prototype+") have the objvar " + craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh");
					attribValue /= WP_CORE_MODIFIER;
					CustomerServiceLog("new_weapon_crafting", "setComponentObjVars::new coreQualityHigh value is " + attribValue);
				}

				setObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MAX, attribValue);
				setObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh", attribValue);
			}
			else if(hasObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh"))
			{
					attribValue = getFloatObjVar(prototype, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh");

					attribValue /= WP_CORE_MODIFIER;

					setObjVar(prototype, OBJVAR_WP_CORE_QUALITY_MAX, attribValue);
			}
		}

	}
	return true;
}

boolean isCoredWeapon(obj_id weapon)
{
	if(!isIdValid(weapon) || !exists(weapon))
		return false;

	return hasObjVar(weapon, OBJVAR_NEW_WP_WEAPON);
}

float getWeaponComponentBonusesMinDamage(obj_id weapon)
{
	if(!isIdValid(weapon) || !exists(weapon))
		return 0.0f;

	float craftBonuses = 0.0f;

	if(hasObjVar(weapon, OBJVAR_MODIFIER_GAS_QUALITY_MIN))
	{
		//ranged weapon
		craftBonuses += getFloatObjVar(weapon, OBJVAR_MODIFIER_GAS_QUALITY_MIN);
	}
	else
	{
		//melee weapon
		craftBonuses += getFloatObjVar(weapon, OBJVAR_MODIFIER_MELEE_QUALITY_MIN);
	}

	if(hasObjVar(weapon, OBJVAR_MODIFIER_COMPONENT_BONUS_MIN))
	{
		//Scope, Stock, etc..
		craftBonuses += getFloatObjVar(weapon, OBJVAR_MODIFIER_COMPONENT_BONUS_MIN);
	}

	if(hasObjVar(weapon, OBJVAR_MODIFIER_APPEARANCE_BONUS_MIN))
	{
		//appearance bonus
		craftBonuses += getFloatObjVar(weapon, OBJVAR_MODIFIER_APPEARANCE_BONUS_MIN);
	}

	return craftBonuses;
}

float getWeaponComponentBonusesMaxDamage(obj_id weapon)
{
	if(!isIdValid(weapon) || !exists(weapon))
		return 0.0f;

	float craftBonuses = 0.0f;

	if(hasObjVar(weapon, OBJVAR_MODIFIER_GAS_QUALITY_MAX))
	{
		//ranged weapon
		craftBonuses += getFloatObjVar(weapon, OBJVAR_MODIFIER_GAS_QUALITY_MAX);
	}
	else
	{
		//melee weapon
		craftBonuses += getFloatObjVar(weapon, OBJVAR_MODIFIER_MELEE_QUALITY_MAX);
	}

	if(hasObjVar(weapon, OBJVAR_MODIFIER_COMPONENT_BONUS_MAX))
	{
		//Scope, Stock, etc..
		craftBonuses += getFloatObjVar(weapon, OBJVAR_MODIFIER_COMPONENT_BONUS_MAX);
	}

	if(hasObjVar(weapon, OBJVAR_MODIFIER_APPEARANCE_BONUS_MAX))
	{
		//appearance bonus
		craftBonuses += getFloatObjVar(weapon, OBJVAR_MODIFIER_APPEARANCE_BONUS_MAX);
	}

	return craftBonuses;
}

boolean isRangedCore(obj_id core)
{
	if(!isIdValid(core) || !exists(core))
		return false;

	string template = getTemplateName(core);

	if(template.equals("object/tangible/component/weapon/core/weapon_core_ranged_base.iff"))
		return true;
	else if(template.equals("object/tangible/component/weapon/core/weapon_core_ranged_advanced.iff"))
		return true;
	else if(template.equals("object/tangible/component/weapon/core/weapon_core_ranged_basic.iff"))
		return true;
	else if(template.equals("object/tangible/component/weapon/core/weapon_core_ranged_standard.iff"))
		return true;
	else
		return false;
}

boolean isHeavyCore(obj_id core)
{
	if(!isIdValid(core) || !exists(core))
		return false;

	string template = getTemplateName(core);

	if(template.equals("object/tangible/component/weapon/core/weapon_core_heavy_base.iff"))
		return true;
	else if(template.equals("object/tangible/component/weapon/core/weapon_core_heavy_advanced.iff"))
		return true;
	else if(template.equals("object/tangible/component/weapon/core/weapon_core_heavy_standard.iff"))
		return true;
	else
		return false;
}

boolean isMeleeCore(obj_id core)
{
	if(!isIdValid(core) || !exists(core))
		return false;

	string template = getTemplateName(core);

	if(template.equals("object/tangible/component/weapon/core/weapon_core_melee_base.iff"))
		return true;
	else if(template.equals("object/tangible/component/weapon/core/weapon_core_melee_basic.iff"))
		return true;
	else if(template.equals("object/tangible/component/weapon/core/weapon_core_melee_standard.iff"))
		return true;
	else if(template.equals("object/tangible/component/weapon/core/weapon_core_melee_advanced.iff"))
		return true;
	else
		return false;
}

//verify that the min damage does not exceed caps
float verifyDamageRangeMin(obj_id weapon, float currentDamage, dictionary coreData)
{
	if(!isIdValid(weapon) || !exists(weapon))
	{
		return 0.0f;
	}

	if(coreData == null || coreData.isEmpty())
	{
		return 0.0f;
	}

	int tableMin = getCoreMinDamage(weapon, coreData);

	float tableMinCap = tableMin * NEW_WP_DAMAGE_CAP;

	if(currentDamage > tableMinCap)
	{
		return tableMinCap;
	}

	return currentDamage;
}

//verify that the min damage does not exceed caps
float verifyDamageRangeMax(obj_id weapon, float currentDamage, dictionary coreData)
{
	if(!isIdValid(weapon) || !exists(weapon))
		return 0.0f;

	if(coreData == null || coreData.isEmpty())
		return 0.0f;

	int tableMax = getCoreMaxDamage(weapon, coreData);

	float tableMaxCap = tableMax * NEW_WP_DAMAGE_CAP;

	if(currentDamage > tableMaxCap)
		return tableMaxCap;

	return currentDamage;
}

boolean isProfWheelSchemWeapon(obj_id weapon)
{
	if(!isIdValid(weapon) || !exists(weapon))
	{
		CustomerServiceLog("new_weapon_conversion", "Invalid ids passed in");
		return true;
	}

	string template = getTemplateName(weapon);

	if(template == null || template.equals(""))
	{
		CustomerServiceLog("new_weapon_conversion", "Couldnt find a valid object template for weapon("+weapon+")");
		return true;
	}

	string schemGroupTable = "datatables/crafting/schematic_group.iff";

	int row = dataTableSearchColumnForString(template, "crafted_object_template", WEAPON_APP_BONUS_TABLE);

	if(row < 0)
	{
		CustomerServiceLog("new_weapon_conversion", "Couldnt find a valid draft schematic in appearance table for template("+template+") on weapon("+weapon+")");
		return true;
	}

	string schemName = dataTableGetString(WEAPON_APP_BONUS_TABLE, row, "schematic_name");

	if(schemName == null || schemName.equals(""))
	{
		CustomerServiceLog("new_weapon_conversion", "bad schematic name when searcing in weapons appearance table for template("+template+") on weapon("+weapon+")");
		return true;
	}

	//change schem name into full name
	schemName = "object/draft_schematic/weapon/appearance/" + schemName + ".iff";

	row = dataTableSearchColumnForString(schemName, "SchematicName", schemGroupTable);

	if(row >= 0)
	{
		CustomerServiceLog("new_weapon_conversion", "Schematic found in profession wheel for schematic("+schemName+") on template("+template+") on weapon("+weapon+")");
		return true;
	}

	CustomerServiceLog("new_weapon_conversion", "Schematic NOT found in profession wheel for schematic("+schemName+") on template("+template+") on weapon("+weapon+")");
	return false;
}

//function to turn pre-GU5 weapons into new appearance schems
boolean turnWeaponIntoSchem(obj_id player, obj_id weapon)
{
	if(!isIdValid(weapon) || !exists(weapon))
		return false;

	if(!isIdValid(player) || !exists(player))
		return false;

	string template = getTemplateName(weapon);

	int row = dataTableSearchColumnForString(template, "crafted_object_template", WEAPON_APP_BONUS_TABLE);

	if(row < 0)
		return false;

	string schemName = dataTableGetString(WEAPON_APP_BONUS_TABLE, row, "schematic_name");

	if(schemName == null || schemName.equals(""))
		return false;

	string limitedUseTemplate = "object/tangible/loot/loot_schematic/deconstructed_weapon_schematic.iff";

	obj_id pInv = utils.getInventoryContainer(player);

	obj_id newSchem = createObjectOverloaded(limitedUseTemplate, pInv);
	CustomerServiceLog("new_weapon_conversion", "New schematic("+schemName+") converted from weapon("+weapon+") for player "+getFirstName(player)+"("+player+")");

	if(!isIdValid(newSchem) || !exists(newSchem))
		return false;

	setName(newSchem, utils.packStringId(getNameFromTemplate(template)));
	setObjVar(newSchem, "loot_schematic.schematic", "object/draft_schematic/weapon/appearance/" + schemName + ".iff");
	setObjVar(newSchem, "loot_schematic.uses", 1);
	setObjVar(newSchem, "loot_schematic.skill_req", "class_munitions_phase1_master");

	//if it was a bioLinked weapon, we need to persist that.
	obj_id bioLink = getBioLink(weapon);
	if(isIdValid(bioLink))
	{
		setBioLink(newSchem, bioLink);
	}

	//if it is a no-trade item being deconstructed, it needs to bio-link to the deconstructor
	if(utils.isItemNoDrop(weapon))
	{
		setBioLink(newSchem, player);
	}

	attachScript(newSchem, "item.loot_schematic.loot_schematic");
	CustomerServiceLog("new_weapon_conversion", "Weapon("+weapon+") about to be destroyed on player "+getFirstName(player)+"("+player+") because it was converted into schematic "+schemName+"("+newSchem+")");

	//TODO add Bio-Link stuff

	return true;
}

//validate that our min is not more than our max
boolean validateDamage(obj_id player, obj_id item)
{
	if(!isCoredWeapon(item))
	{
		return false;
	}

	float coreBonus		= 0.0f;
	float craftedBonus 	= 0.0f;

	int coreLevel = getCoreLevel(item);
	if(coreLevel <= 0)
		return false;

	dictionary weaponCoreDat = getWeaponCoreData(coreLevel);
	if(weaponCoreDat == null || weaponCoreDat.isEmpty())
		return false;

	//min damage
	coreBonus = getWeaponCoreQualityMin(item);
	craftedBonus = coreBonus + getWeaponComponentBonusesMinDamage(item);
	int tableMin = weaponCoreDat.getInt("pistol_min_damage");
	float minDamage = tableMin * craftedBonus;

	// Maximum Damage
	coreBonus = getWeaponCoreQualityMax(item);
	craftedBonus = coreBonus + getWeaponComponentBonusesMaxDamage(item);
	int tableMax = weaponCoreDat.getInt("pistol_max_damage");
	float maxDamage = tableMax * craftedBonus;

	if(minDamage > maxDamage)
	{
		CustomerServiceLog("new_weapon_crafting", "player "+getFirstName(player)+"("+player+") crafted an invalid weapon item, their min damage("+minDamage+") was higher than their max("+maxDamage+")");
		CustomerServiceLog("new_weapon_crafting", "player "+getFirstName(player)+"("+player+") Their coreQuality min has been reset to coreQuality max - 1%");
		sendSystemMessage(player, SID_MIN_DAMAGE_GREATER_THAN_MAX);
		if(hasObjVar(item, OBJVAR_WP_CORE_QUALITY_MIN) && hasObjVar(item, OBJVAR_WP_CORE_QUALITY_MAX))
		{
			float coreMax = getFloatObjVar(item, OBJVAR_WP_CORE_QUALITY_MAX);
			setObjVar(item, OBJVAR_WP_CORE_QUALITY_MIN, (coreMax - 0.01f));
		}

		if(hasObjVar(item, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow") && hasObjVar(item, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh"))
		{
			float coreMax = getFloatObjVar(item, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityHigh");
			setObjVar(item, craftinglib.COMPONENT_ATTRIBUTE_OBJVAR_NAME + "." + "coreQualityLow", (coreMax - 0.01f));
		}

		coredWeaponConversion(item);
	}
	return true;
}

//function used to make sure that the schematics in factories have all
//the correct data for crafting new cored weapons
boolean setSchematicVariablesFromSchematic(obj_id schematic, obj_id prototype)
{
	boolean objvarsCopied = false;
	if(hasObjVar(prototype, OBJVAR_NEW_WP))
	{
		copyObjVar(prototype, schematic, OBJVAR_NEW_WP);
		objvarsCopied = true;
	}
	return objvarsCopied;

}

boolean setSchematicVariablesFromProtoType(obj_id schematic, obj_id prototype)
{
	boolean objvarsCopied = false;
	if(hasObjVar(schematic, OBJVAR_NEW_WP))
	{
		copyObjVar(schematic, prototype, OBJVAR_NEW_WP);
		objvarsCopied = true;
	}
	return objvarsCopied;

}

boolean checkForIllegalStorytellerWeapon(obj_id player, obj_id weapon)
{
	if ( isIdValid(player) && isIdValid(weapon) )
	{
		if ( isPlayer(player) )
		{
			if ( isWeapon(weapon) && getWeaponAttackSpeed(weapon) >= 2.0f )
			{
				return true;
			}
		}
	}
	return false;
}

void handleIllegalStorytellerWeapon(obj_id player, obj_id weapon, string source)
{
	if ( isIdValid(player) && isIdValid(weapon) )
	{
		string weaponTemplate = getTemplateName(weapon);
		if (  weaponTemplate.indexOf("grenade") <= -1 && !utils.hasScriptVar(weapon, "illegalStorytellerWeapon") )
		{
			string msg = "Weapon gained from a storyteller NPC via an exploit was detected in "+source+". Player ("+player+") and weapon | "+ getName(weapon) + " | "+ weaponTemplate +" | ("+weapon+").";
			CustomerServiceLog("storyteller_weapon_exploit", msg);
			CustomerServiceLog("storyteller_weapon_exploit", logWeaponStats(weapon));

			obj_id playerInv = utils.getInventoryContainer(player);
			if ( isIdValid(playerInv) )
			{
				//putInOverloaded(weapon, playerInv);
				//destroyObject(weapon);
			}
		}
	}
	return;
}

string logWeaponStats(obj_id weapon)
{
	string logMsg = "Storyteller Exploited Weapon Stats: ";

	// Default weapon name and template
	string weaponTemplate = getTemplateName(weapon);
	logMsg += localize(getNameFromTemplate(weaponTemplate)) + "(" + weaponTemplate + ") - ";

	// weapon stats
	combat_engine.weapon_data weaponData = getWeaponData(weapon);

	logMsg += "Spd (" + weaponData.attackSpeed + "), ";
	logMsg += "Dmg (" + weaponData.minDamage + "-" + weaponData.maxDamage + "), ";

	logMsg += "DmgType (";
	if ((weaponData.damageType & DAMAGE_KINETIC) != 0)					logMsg += "KINETIC, ";
	if ((weaponData.damageType & DAMAGE_ENERGY) != 0)					logMsg += "ENERGY, ";
	if ((weaponData.damageType & DAMAGE_BLAST) != 0)					logMsg += "BLAST, ";
	if ((weaponData.damageType & DAMAGE_STUN) != 0)						logMsg += "STUN, ";
	if ((weaponData.damageType & DAMAGE_RESTRAINT) != 0)				logMsg += "RESTRAINT, ";
	if ((weaponData.damageType & DAMAGE_ELEMENTAL_HEAT) != 0)			logMsg += "ELEMENTAL_HEAT, ";
	if ((weaponData.damageType & DAMAGE_ELEMENTAL_COLD) != 0)			logMsg += "ELEMENTAL_COLD, ";
	if ((weaponData.damageType & DAMAGE_ELEMENTAL_ACID) != 0)			logMsg += "ELEMENTAL_ACID, ";
	if ((weaponData.damageType & DAMAGE_ELEMENTAL_ELECTRICAL) != 0)		logMsg += "ELEMENTAL_ELECTRICAL, ";
	if ((weaponData.damageType & DAMAGE_ENVIRONMENTAL_HEAT) != 0)		logMsg += "ENVIRONMENTAL_HEAT, ";
	if ((weaponData.damageType & DAMAGE_ENVIRONMENTAL_COLD) != 0)		logMsg += "ENVIRONMENTAL_COLD, ";
	if ((weaponData.damageType & DAMAGE_ENVIRONMENTAL_ACID) != 0)		logMsg += "ENVIRONMENTAL_ACID, ";
	if ((weaponData.damageType & DAMAGE_ENVIRONMENTAL_ELECTRICAL) != 0)	logMsg += "ENVIRONMENTAL_ELECTRICAL, ";
	logMsg += "), ";

	logMsg += "Range (" + weaponData.minRange + ", " + weaponData.maxRange + "), ";
	logMsg += "Cost (" + weaponData.attackCost + ")";
	logMsg += "Wound (" + weaponData.woundChance + ")";
	logMsg += "Accuracy (" + weaponData.accuracy + ")";

	return logMsg;
}
