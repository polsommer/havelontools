/**
 * Copyright (C)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        scriptlib
 * Description:  A library containing public general utility functions.
 * @author       $Author: rpalacio $
 * @version      $Revision: #13 $
 */

/***** INCLUDES ********************************************************/
include java.util.Arrays;
include java.lang.System;
include java.lang.Math;

//include java.lang.reflect.Arrays;
include java.util.Arrays;
include java.util.Enumeration;
include java.util.HashSet;
include java.util.Iterator;
include java.util.List;
include java.util.Vector;

include java.io.ByteArrayInputStream;
include java.io.ByteArrayOutputStream;
include java.io.IOException;
include java.io.ObjectInputStream;
include java.io.ObjectOutputStream;

include script_entry;

include library.player_structure;
include library.healing;
include library.ai_lib;
include library.pclib;
include library.armor;
include library.chat;
include library.performance;
include library.trial;
include library.cloninglib;
include library.static_item;

/***** CONSTANTS *******************************************************/
const string VERSION = "v0.01.00";

const string VAR_OWNER                        		= "owner";
const string VAR_COOWNERS                     		= "coowners";

const string SLOT_INVENTORY				= "inventory";
const string SLOT_DATAPAD				= "datapad";
const string SLOT_HANGAR				= "hangar";
const string SLOT_BANK					= "bank";
const string SLOT_MISSION_BAG				= "mission_bag";

const string FREE_TRIAL					= "free_trial";
const string TIP					= FREE_TRIAL+".tip";
const string TIP_OUT_NUM				= TIP + ".tip_out_num";
const string TIP_OUT_AMMOUNT				= TIP + ".tip_out_ammount";
const string TIP_IN_NUM					= TIP + ".tip_in_num";
const string TIP_IN_AMMOUNT				= TIP + ".tip_in_ammount";
const string TIP_IN_THACK				= TIP + ".tip_in_timeHack";
const string TIP_OUT_THACK				= TIP + ".tip_out_timeHack";

const string TRIAL_STRUCTURE				= FREE_TRIAL+".trial_structure";

const int TIP_NUM_MAX					= 25;
const int TIP_AMT_MAX					= 100000;

const string NO_TRADE_SCRIPT			= "item.special.nomove";

// retroactive CTS history
const string CTS_OBJVAR_HISTORY         = "ctsRetroHistory";

const int BIT_LIST_SIZE							= 32;

const string_id SID_OBJECT_NOT_ACTIVE      		= new string_id("error_message", "object_not_active");

const string[] WAYPOINT_COLORS				={
								waypoint_colors.blue,
								waypoint_colors.green,
								waypoint_colors.orange,
								waypoint_colors.yellow,
								waypoint_colors.purple,
								waypoint_colors.white
							};

const string_id SID_SECONDS				= new string_id("spam", "seconds");
const string_id SID_MINUTES				= new string_id("spam", "minutes");
const string_id SID_HOURS				= new string_id("spam", "hours");
const string_id SID_DAYS				= new string_id("spam", "days");
const string_id SID_OUT_OF_RANGE			= new string_id("spam", "out_of_range");

const int COMMANDO 					= 1;
const int SMUGGLER 					= 2;
const int MEDIC 					= 3;
const int OFFICER 					= 4;
const int SPY 						= 5;
const int BOUNTY_HUNTER 				= 6;
const int FORCE_SENSITIVE 				= 7;
const int TRADER 					= 8;
const int ENTERTAINER 					= 9;

// Constants for gifts
const string LIFEDAY_OWNER				= "lifeday.owner";
const string XMAS_RECEIVED_V1				= "gift.xmas05";
const string XMAS_RECEIVED_V2				= "gift.xmas05v2";

const string XMAS_RECEIVED_VI1				= "gift.xmas06";
const string XMAS_RECEIVED_VI2				= "gift.xmas06v2";

const string XMAS_RECEIVED_VII1				= "gift.xmas07";
const string XMAS_RECEIVED_VII2				= "gift.xmas07v2";
const string XMAS_NOT_RECEIVED_TUTORIAL			= "gift.xmas06_inTutorialFail";

const string XMAS_RECEIVED_VIII1			= "gift.xmas08";
const string XMAS_RECEIVED_VIII2			= "gift.xmas08v2";

const string XMAS_RECEIVED_IX_01			= "gift.xmas09";

const string EMPIRE_DAY_RECEIVED_VI			= "gift.empire08";

const string_id GIFT_GRANTED 				= new string_id("system_msg", "gift_granted");
const string_id GIFT_GRANTED_SUB 			= new string_id("system_msg", "gift_granted_sub");

// House clean up code constants

const int HOUSE_CURRENT = 0;
const int HOUSE_HISTORY = 1;
const int HOUSE_MAX 	= 2;

// this value comes from TangibleObject.cpp. DO NOT CHANGE!
const obj_id OBJ_ID_BIO_LINK_PENDING = obj_id.getObjId(1);


const string VENDOR_SCRIPT = "terminal.vendor";
const string BAZAAR_SCRIPT = "terminal.bazaar";

/***** FUNCTIONS *******************************************************/
/**
 * @brief return iValue clipped within the specified min/max range
 *
 * @param iValue
 * @param iClipMin
 * @param iClipMax
 *
 * @return integer value clipped within the min/max range
 */
int clipRange( int iValue, int iClipMin, int iClipMax )
{
	return ( iValue < iClipMin ) ? iClipMin : ( iValue > iClipMax ) ? iClipMax : iValue;
}

/**
 * @brief retrieve a location a random angle and distance away from pos, using pos as the locus
 *
 * Note: This function works if either fMaxRadius >= or <= fMinRadius
 *
 * @param pos
 * @param fMinRadius
 * @param fMaxRadius
 *
 * @return a random location within the specified radii from pos
 */
location getRandomAwayLocation( location pos, float fMinRadius, float fMaxRadius )
{
	float fTheta = rand() * (2f * (float)Math.PI);
	float fRadius = Math.min(fMinRadius, fMaxRadius) + rand() * Math.abs(fMaxRadius - fMinRadius);

	pos.x += fRadius * Math.cos(fTheta);
	pos.z += fRadius * Math.sin(fTheta);
	return pos;
}

/**
 * @brief   return the floating point distance between two locations in 2D (elevation/Y is not taken into account)
 *
 * @param location  locTarget1
 * @param location  locTarget2
 *
 * @return float    distance in meters between two locations, -1.00f for invalid result
 */
/*float getDistance2D( location locTarget1, location locTarget2 )
{
	if ( locTarget1 == null || locTarget2 == null)
		return -1.00f;

	float dx = locTarget1.x - locTarget2.x;
	float dz = locTarget1.z - locTarget2.z;

	return (float)Math.sqrt(dx * dx + dz * dz);
}*/

float getDistance2D( location locTarget1, location locTarget2 )
{
	if ( locTarget1 == null || locTarget2 == null)
		return -1.00f;

	location loc1 = locTarget1;
	loc1.y = 0f;

	location loc2 = locTarget2;
	loc2.y = 0f;

	return getDistance(loc1, loc2);
}

float getDistance2D( obj_id hereTarget, obj_id thereTarget )
{
	if ( !isIdValid(hereTarget) || !isIdValid(thereTarget) )
		return -1.00f;

	return getDistance2D(getWorldLocation(hereTarget), getWorldLocation(thereTarget));
}

attrib_mod[] addMindAttribToStim(int power)
{
	attrib_mod[] am = new attrib_mod[2];

	//create attribute mods for HEALTH 0 and ACTION 3 and MIND 6
	for (int i = 0; i < 2; i++)
	{
		am[i] = createHealDamageAttribMod(i * 2, power);
	}
	return am;
}

/**
 * @brief   return an index to random-weighted array of values.
 *
 * Note: An empty or single element array will result in a return value of 0.
 *
 * @param float[]  fArray
 *
 * @return int an index to one of the passed values
 */
int randix( float[] fArray )
{
	// only need processing for multi-element arrays
	if ( fArray.length > 1 )
	{
		// initialize sum and calculate sum of all elements
		float fSum = 0.0f;
		for ( int i = 0; i < fArray.length; i++ )
			fSum += fArray[i];

		// pick a random value in the range of sum
		float fRandom = rand() * fSum;

		// find the array index for the range that value fRandom falls into
		fSum = 0.0f;
		for ( int i = 0; i < fArray.length; i++ )
		{
			fSum += fArray[i];
			if ( fRandom <= fSum )
				return i;
		}
	}

	// return index 0 for single element array, empty array, or first element check
	return 0;
}

//
//  removes all uncerted weapons and armor pieces from the player and sends system messages
//  when something was unequip.  Inventory may be overloaded by this function.
//  returns the number of items that were unequipped
//

boolean isMando (obj_id armor)
// check to see if we are wearing mandalorian armor
{

	if( isIdValid(armor))
	{
		string template = getTemplateName(armor);

		if (template.endsWith("armor_mandalorian_belt.iff") ||
		    template.endsWith("armor_mandalorian_bicep_l.iff")||
		    template.endsWith("armor_mandalorian_bicep_r.iff")||
		    template.endsWith("armor_mandalorian_bracer_l.iff")||
		    template.endsWith("armor_mandalorian_bracer_r.iff")||
		    template.endsWith("armor_mandalorian_chest_plate.iff")||
		    template.endsWith("armor_mandalorian_helmet.iff")||
		    template.endsWith("armor_mandalorian_leggings.iff")||
		    template.endsWith("armor_mandalorian_shoes.iff")||
		    template.endsWith("armor_mandalorian_gloves.iff") )
		 {
			return true;
		 }
	}

	return false;
}



boolean hasSpecialSkills (obj_id player)
// check to see if we have the skills necessary to wear mandalorian armor
{
	boolean skillCheck = false;

	if (hasSkill (player, "class_commando_phase4_master"))
	{
		skillCheck = true;
	}

	if (hasSkill (player, "class_bountyhunter_phase4_master"))
	{
		skillCheck = true;
	}

	return skillCheck;
}

int unequipAndNotifyUncerted(obj_id player)
{
	int totalUnequipped = 0;
	string[] armorSlots = new string[]
		{
			"hat",
			"chest2",
			"bicep_r",
			"bicep_l",
			"bracer_upper_r",
			"bracer_lower_r",
			"bracer_upper_l",
			"bracer_lower_l",
			"gloves",
			"pants2",
			"shoes",
			"chest1",
			"pants1",
			"utility_belt"
		};

	obj_id curArmor = null;
	obj_id inv = utils.getInventoryContainer(player);
	string classTemplate = getSkillTemplate(player);

	for(int i = 0; i < armorSlots.length; i++)
	{
		curArmor = getObjectInSlot(player, armorSlots[i]);
		if ( (isIdValid(curArmor) && !armor.isArmorCertified(player, curArmor))

	       	   ||(isMando(curArmor) && !hasSpecialSkills(player)) )

		{
			totalUnequipped++;
			prose_package pp = new prose_package();
			pp = prose.setStringId(pp, new string_id("spam", "armor_lost_cert"));
			pp = prose.setTT(pp, curArmor);
			sendSystemMessageProse(player, pp);
			putInOverloaded(curArmor, inv);
		}

		if(!isIdNull(curArmor) && hasObjVar(curArmor, "armor.fake_armor") && hasObjVar(curArmor, "dynamic_item.required_skill") )
		{
			string requiredSkill = getStringObjVar(curArmor, "dynamic_item.required_skill");
			if (classTemplate != null && classTemplate != "")
			{
				if (!classTemplate.startsWith(requiredSkill))
				{
					totalUnequipped++;
					prose_package pp = new prose_package();
					pp = prose.setStringId(pp, new string_id("spam", "armor_lost_cert"));
					pp = prose.setTT(pp, curArmor);
					sendSystemMessageProse(player, pp);
					putInOverloaded(curArmor, inv);
				}
			}
		}

	}

	obj_id[] equipSlots = metrics.getWornItems(player);
		if (equipSlots != null && equipSlots.length > 0)
		{
			for(int i = 0; i < equipSlots.length; i++)
			{
				//check to see if we no longer meet level requirements to wear item
				if(!static_item.validateLevelRequired(player,(equipSlots[i])))
				{
					totalUnequipped++;
					prose_package pp = new prose_package();
					pp = prose.setStringId(pp, new string_id("spam", "item_lost_cert"));
					pp = prose.setTT(pp, equipSlots[i]);
					sendSystemMessageProse(player, pp);
					putInOverloaded(equipSlots[i], inv);
				}
				//check to see if we can wear the item but no longer meet the level for the effect
				else if(!static_item.validateLevelRequiredForWornEffect(player,(equipSlots[i])))
				{
					static_item.removeWornBuffs(equipSlots[i], player);
					prose_package pp = new prose_package();
					pp = prose.setStringId(pp, new string_id("spam", "item_lost_cert_effect"));
					pp = prose.setTT(pp, equipSlots[i]);
					sendSystemMessageProse(player, pp);
				}
			}
		}

	// check if still certed for equipped weapon.  unequip if not
	obj_id weapon = getCurrentWeapon(player);
	if(isIdValid(weapon) && !combat.hasCertification(player, weapon))
	{
		totalUnequipped++;
		prose_package pp = new prose_package();
		pp = prose.setStringId(pp, new string_id("spam", "weapon_lost_cert"));
		pp = prose.setTT(pp, weapon);
		sendSystemMessageProse(player, pp);
		putInOverloaded(weapon, inv);
	}

	obj_id hold_l = getObjectInSlot(player, "hold_l");
	obj_id hold_r = getObjectInSlot(player, "hold_r");

	// check left hand dance prop
	if (isIdValid(hold_l) && !performance.isDancePropCertified(player, hold_l))
	{
		totalUnequipped++;
		prose_package pp = new prose_package();
		pp = prose.setStringId(pp, new string_id("spam", "prop_lost_cert"));
		pp = prose.setTT(pp, hold_l);
		sendSystemMessageProse(player, pp);
		putInOverloaded(hold_l, inv);
		hold_l = obj_id.NULL_ID;
	}

	// check right hand dance prop
	if (isIdValid(hold_r) && !performance.isDancePropCertified(player, hold_r))
	{
		totalUnequipped++;
		prose_package pp = new prose_package();
		pp = prose.setStringId(pp, new string_id("spam", "prop_lost_cert"));
		pp = prose.setTT(pp, hold_r);
		sendSystemMessageProse(player, pp);
		putInOverloaded(hold_r, inv);
		hold_r = obj_id.NULL_ID;
	}

	// check dance prop dual wielding
	if(performance.isValidDanceProp(hold_l) && performance.isValidDanceProp(hold_r) && !hasCommand(player, "prop_dual_wield"))
	{
		totalUnequipped++;
		prose_package pp = new prose_package();
		pp = prose.setStringId(pp, new string_id("spam", "dual_prop_lost_cert"));
		pp = prose.setTT(pp, hold_l);
		sendSystemMessageProse(player, pp);
		putInOverloaded(hold_l, inv);
		hold_l = obj_id.NULL_ID;
	}

	// Appearance items
	obj_id [] appearanceItems = getAllItemsFromAppearanceInventory(player);
	if (appearanceItems != null && appearanceItems.length > 0)
	{
		for(int i = 0; i < appearanceItems.length; ++i)
		{
			curArmor = appearanceItems[i];

			if ( (isIdValid(curArmor) && !armor.isArmorCertified(player, curArmor))
			   ||(isMando(curArmor) && !hasSpecialSkills(player)) )
			{
				totalUnequipped++;
				prose_package pp = new prose_package();
				pp = prose.setStringId(pp, new string_id("spam", "armor_lost_cert"));
				pp = prose.setTT(pp, curArmor);
				sendSystemMessageProse(player, pp);
				putInOverloaded(curArmor, inv);
			}
			if(!isIdNull(curArmor) && hasObjVar(curArmor, "armor.fake_armor") && hasObjVar(curArmor, "dynamic_item.required_skill") )
			{
				string requiredSkill = getStringObjVar(curArmor, "dynamic_item.required_skill");
				if (classTemplate != null && classTemplate != "")
				{
					if (!classTemplate.startsWith(requiredSkill))
					{
						totalUnequipped++;
						prose_package pp = new prose_package();
						pp = prose.setStringId(pp, new string_id("spam", "armor_lost_cert"));
						pp = prose.setTT(pp, curArmor);
						sendSystemMessageProse(player, pp);
						putInOverloaded(curArmor, inv);
					}
				}
			}
			//check to see if we no longer meet level requirements to wear item
			if(!static_item.validateLevelRequired(player,curArmor))
			{
				totalUnequipped++;
				prose_package pp = new prose_package();
				pp = prose.setStringId(pp, new string_id("spam", "item_lost_cert"));
				pp = prose.setTT(pp, curArmor);
				sendSystemMessageProse(player, pp);
				putInOverloaded(curArmor, inv);
			}
			//check to see if we can wear the item but no longer meet the level for the effect
			else if(!static_item.validateLevelRequiredForWornEffect(player,curArmor))
			{
				static_item.removeWornBuffs(curArmor, player);
				prose_package pp = new prose_package();
				pp = prose.setStringId(pp, new string_id("spam", "item_lost_cert_effect"));
				pp = prose.setTT(pp, curArmor);
				sendSystemMessageProse(player, pp);
			}

		}
	}

	return totalUnequipped;
}

/**
 * Finds an integer obj_var with a given name on an object.
 * @param object	 the object to search
 * @param name		 the objvar name to search for
 * @param intDefault the integer to return if no objvar exists
 *
 * @return the integer, or 0 if not found
 */
int getIntObjVar( obj_id object, string name, int intDefault )
{
	if ( !hasObjVar( object, name ) )
		return intDefault;
	return getIntObjVar( object, name );
}

/**
 * Finds an integer array obj_var with a given name on an object.
 * @param object	the object to search
 * @param name		the objvar name to search for
 * @param intArrayDefault    the array of integers to return if no objvar exists
 *
 * @return the integer array, or null if not found
 */
int[] getIntArrayObjVar( obj_id object, string name, int[] intArrayDefault )
{
	if ( !hasObjVar( object, name ) )
		return intArrayDefault;
	return getIntArrayObjVar( object, name );
}

/**
 * Finds a float obj_var with a given name on an object.
 * @param object	the object to search
 * @param name		the objvar name to search for
 * @param fltDefault the float to return if no objvar exists
 *
 * @return the float, or 0 if not found
 */
float getFloatObjVar( obj_id object, string name, float fltDefault )
{
	if ( !hasObjVar( object, name ) )
		return fltDefault;
	return getFloatObjVar( object, name );
}

/**
 * Finds a float array obj_var with a given name on an object.
 * @param object	the object to search
 * @param name		the objvar name to search for
 * @param fltArrayDefault    the array of floats to return if no objvar exists
 *
 * @return the float array, or null if not found
 */
float[] getFloatArrayObjVar( obj_id object, string name, float[] fltArrayDefault )
{
	if ( !hasObjVar( object, name ) )
		return fltArrayDefault;
	return getFloatArrayObjVar( object, name );
}

/**
 * Finds a string obj_var with a given name on an object.
 * @param object    the object to search
 * @param name      the objvar name to search for
 * @param strDefault the string to return if no objvar exists
 *
 * @return the string, or null if not found
 */
string getStringObjVar( obj_id object, string name, string strDefault )
{
	if ( !hasObjVar( object, name ) )
		return strDefault;
	return getStringObjVar( object, name );
}

/**
 * Finds a string array obj_var with a given name on an object.
 * @param object	the object to search
 * @param name		the objvar name to search for
 * @param strArrayDefault the array of strings to return if no objvar exists
 *
 * @return the string array, or null if not found
 */
string[] getStringArrayObjVar( obj_id object, string name, string[] strArrayDefault )
{
	if ( !hasObjVar( object, name ) )
		return strArrayDefault;
	return getStringArrayObjVar( object, name );
}

/**
 * Finds an obj_id obj_var with a given name on an object.
 * @param object	the object to search
 * @param name		the objvar name to search for
 * @param idDefault the obj_id to return if no objvar exists
 *
 * @return the obj_id, or null if not found
 */
obj_id getObjIdObjVar( obj_id object, string name, obj_id idDefault )
{
	if ( !hasObjVar( object, name ) )
		return idDefault;
	return getObjIdObjVar( object, name );
}

/**
 * Finds an obj_id array obj_var with a given name on an object.
 * @param object	the object to search
 * @param name		the objvar name to search for
 * @param idArrayDefault the array of obj_id to return if no objvar exists
 *
 * @return the obj_id array, or null if not found
 */
obj_id[] getObjIdArrayObjVar( obj_id object, string name, obj_id[] idArrayDefault )
{
	if ( !hasObjVar( object, name ) )
		return idArrayDefault;
	return getObjIdArrayObjVar( object, name );
}

/**
 * Finds a location obj_var with a given name on an object.
 * @param object	the object to search
 * @param name		the objvar name to search for
 * @param locDefault the location to return if no objvar exists
 *
 * @return the location, or null if not found
 */
location getLocationObjVar( obj_id object, string name, location locDefault )
{
	if ( !hasObjVar( object, name ) )
		return locDefault;
	return getLocationObjVar( object, name );
}

/**
 * Finds a location array obj_var with a given name on an object.
 * @param object	the object to search
 * @param name		the objvar name to search for
 * @param locArrayDefault the array of locations to return if no objvar exists
 *
 * @return the location array, or null if not found
 */
location[] getLocationArrayObjVar( obj_id object, string name, location[] locArrayDefault )
{
	if ( !hasObjVar( object, name ) )
		return locArrayDefault;
	return getLocationArrayObjVar( object, name );
}

/**
 * Finds an boolean obj_var with a given name on an object. Note that since
 * we don't have real boolean objvars we get the value as an int and convert it.
 * @param object	the object to search
 * @param name		the objvar name to search for
 * @param bDefault  the boolean to return if no objvar exists
 *
 * @return the boolean value
 */
boolean getBooleanObjVar( obj_id object, string name, boolean bDefault )
{
	if ( !hasObjVar( object, name ) )
		return bDefault;

	return getBooleanObjVar( object, name );
}

/**
 * @brief Checks to see if an obj_id is in an obj_id array
 *
 * CAUTION! ONLY FINDS THE FIRST OCURRENCE OF THE OBJ_ID
 *
 * @param obj_id[] objArray
 * @param obj_id objTarget
 *
 * @return boolean true if objTarget is found in objIdArray
 */
boolean isObjIdInArray( obj_id[] objIdArray, obj_id objTarget )
{
	if ( objIdArray == null || objIdArray.length == 0 )
		return false;

	for ( int i = 0; i < objIdArray.length; i++ )
		if( objIdArray[ i ] == objTarget )
			return true;

	return false;
}

/**
 * @brief Checks to see if an obj_id is in an obj_id array
 *
 * CAUTION! ONLY FINDS THE FIRST OCURRENCE OF THE OBJ_ID
 *
 * @param obj_id[] objArray
 * @param obj_id objTarget
 *
 * @return boolean true if objTarget is found in objIdArray
 */
boolean isElementInArray( Vector objIdArray, Object objTarget )
{
	if ( objIdArray == null || objIdArray.isEmpty() )
		return false;

	return objIdArray.contains(objTarget);
}

int getElementPositionInArray( Vector array, Object element )
{
	if ( array == null )
		return -1;

	return array.indexOf(element);
}

int getElementPositionInArray( obj_id[] array, obj_id element )
{
	if ( array == null || array.length == 0 )
		return -1;

	for ( int i = 0; i < array.length; i++ )
		if( array[ i ] == element )
			return i;

	return -1;
}

int getElementPositionInArray( int[] array, int element )
{
	if ( array == null || array.length == 0 )
		return -1;

	for ( int i = 0; i < array.length; i++ )
		if( array[ i ] == element )
			return i;

	return -1;
}

int getElementPositionInArray( float[] array, float element )
{
	if ( array == null || array.length == 0 )
		return -1;

	for ( int i = 0; i < array.length; i++ )
		if( array[ i ] == element )
			return i;

	return -1;
}

int getElementPositionInArray( boolean[] array, boolean element )
{
	if ( array == null || array.length == 0 )
		return -1;

	for ( int i = 0; i < array.length; i++ )
		if( array[ i ] == element )
			return i;

	return -1;
}

int getElementPositionInArray( string[] array, string element )
{
	if ( array == null || array.length == 0 )
		return -1;

	for ( int i = 0; i < array.length; i++ )
		if( array[ i ].equals(element) )
			return i;

	return -1;
}

int getElementPositionInArray( region[] array, region element )
{
	if ( array == null || array.length == 0 )
		return -1;

	for ( int i = 0; i < array.length; i++ )
		if( array[ i ] == element )
			return i;

	return -1;
}

int getElementPositionInArray( location[] array, location element )
{
	if ( array == null || array.length == 0 )
		return -1;

	for ( int i = 0; i < array.length; i++ )
		if( array[ i ] == element )
			return i;

	return -1;
}

int getElementPositionInArray( string_id[] array, string_id element )
{
	if ( array == null || array.length == 0 )
		return -1;

	for ( int i = 0; i < array.length; i++ )
		if( array[ i ] == element )
			return i;

	return -1;
}

int getElementPositionInArray( attrib_mod[] array, attrib_mod element )
{
	if ( array == null || array.length == 0 )
		return -1;

	for ( int i = 0; i < array.length; i++ )
		if( array[ i ] == element )
			return i;

	return -1;
}


/**
 * @brief copy the contents of an obj_id array to another obj_id array
 *
 * copy's an array to another array. Useful for resizing an array
 *
 * @param obj_id[] objSourceArray
 * @param obj_id[] objDestinationArray
 *
 * @return obj_id[] on success: objDestinationArray, on failure: null
 */
obj_id[] copyObjIdArray( obj_id[] objSourceArray, obj_id[] objDestinationArray )
{
	// check for error conditions:
	// -- source or destination are null
	// -- source or destination length are invalid
	// -- source is larger than destination
	if ( objSourceArray == null || objDestinationArray == null
		|| objSourceArray.length == 0 || objDestinationArray.length == 0
		|| objSourceArray.length > objDestinationArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < objSourceArray.length; i++ )
		objDestinationArray[ i ] = objSourceArray[ i ];

	return objDestinationArray;
}

obj_id[] copyArray( obj_id[] oldArray, obj_id[] newArray )
{
	if ( oldArray == null || newArray == null
		|| oldArray.length == 0 || newArray.length == 0
		|| oldArray.length > newArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < oldArray.length; i++ )
		newArray[ i ] = oldArray[ i ];

	return newArray;
}

int[] copyArray( int[] oldArray, int[] newArray )
{
	if ( oldArray == null || newArray == null
		|| oldArray.length == 0 || newArray.length == 0
		|| oldArray.length > newArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < oldArray.length; i++ )
		newArray[ i ] = oldArray[ i ];

	return newArray;
}

float[] copyArray( float[] oldArray, float[] newArray )
{
	if ( oldArray == null || newArray == null
		|| oldArray.length == 0 || newArray.length == 0
		|| oldArray.length > newArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < oldArray.length; i++ )
		newArray[ i ] = oldArray[ i ];

	return newArray;
}

boolean[] copyArray( boolean[] oldArray, boolean[] newArray )
{
	if ( oldArray == null || newArray == null
		|| oldArray.length == 0 || newArray.length == 0
		|| oldArray.length > newArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < oldArray.length; i++ )
		newArray[ i ] = oldArray[ i ];

	return newArray;
}

string[] copyArray( string[] oldArray, string[] newArray )
{
	if ( oldArray == null || newArray == null
		|| oldArray.length == 0 || newArray.length == 0
		|| oldArray.length > newArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < oldArray.length; i++ )
		newArray[ i ] = oldArray[ i ];

	return newArray;
}

region[] copyArray( region[] oldArray, region[] newArray )
{
	if ( oldArray == null || newArray == null
		|| oldArray.length == 0 || newArray.length == 0
		|| oldArray.length > newArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < oldArray.length; i++ )
		newArray[ i ] = oldArray[ i ];

	return newArray;
}

location[] copyArray( location[] oldArray, location[] newArray )
{
	if ( oldArray == null || newArray == null
		|| oldArray.length == 0 || newArray.length == 0
		|| oldArray.length > newArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < oldArray.length; i++ )
		newArray[ i ] = oldArray[ i ];

	return newArray;
}

string_id[] copyArray( string_id[] oldArray, string_id[] newArray )
{
	if ( oldArray == null || newArray == null
		|| oldArray.length == 0 || newArray.length == 0
		|| oldArray.length > newArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < oldArray.length; i++ )
		newArray[ i ] = oldArray[ i ];

	return newArray;
}

attrib_mod[] copyArray( attrib_mod[] oldArray, attrib_mod[] newArray )
{
	if ( oldArray == null || newArray == null
		|| oldArray.length == 0 || newArray.length == 0
		|| oldArray.length > newArray.length )
		return null; // BAD DONT DO THAT!

	for ( int i = 0; i < oldArray.length; i++ )
		newArray[ i ] = oldArray[ i ];

	return newArray;
}

/**
 */

 string[] copyArrayOfRange(string[] oldArray, string[] newArray, int startIndex, int stopIndex)
 {
 	if ( oldArray == null || newArray == null
 		|| oldArray.length == 0 || newArray.length == 0
 		|| oldArray.length < stopIndex+1)
 		return null; // BAD DONT DO THAT!

 	int j = 0;
 	for ( int i = startIndex; i <= stopIndex; i++ )
 	{
 		newArray[ j ] = oldArray[ i ];
 		j++;
 	}

	return newArray;
 }


/**
 * @brief sets a bit in an int
 *
 * @param int      intBits
 * @param int      intPos
 *
 * @return int intBits where bit intPos is 1
 */
int setBit(int intBits, int intPos)
{
	if ( intPos < 0 || intPos > 31 )
	{
	 //BAD! invalid intPos!
	 return 0;
	}
	int posVal = 1 << intPos;
	return ( intBits |= posVal );
}

/**
 * @brief clears a bit in an int
 *
 * @param int      intBits
 * @param int      intPos
 *
 * @return int intBits where bit intPos is 0
 */
int clearBit(int intBits, int intPos)
{
	if ( intPos < 0 || intPos > 31 )
	{
	 //BAD! invalid intPos!
	 return ~0;
	}
	int posVal = 1 << intPos;
	return ( intBits &= ~posVal );
}

/**
 * @brief checks a bit in an int to see if it is 1
 *
 * @param int      intBits
 * @param int      intPos
 *
 * @return boolean - true, if bit set
 */
boolean checkBit(int intBits, int intPos)
{
	if ( intPos < 0 || intPos > 31 )
	{
	 //BAD! invalid intPos!
	 return false;
	}
	int posVal = 1 << intPos;
	return ((intBits & posVal) != 0 );
}

/**
 * @brief converts a string to its obj_id equivalent
 *
 * @param string    text
 *
 * @return obj_id
 */
obj_id stringToObjId(string text)
{
// bulletproofing this

	Long lngId;

	try
	{
		lngId = new Long(text); // convert the string to a long so we can make an obj_id
	} // try with error handling
	catch (NumberFormatException err)
	{
		//debugServerConsoleMsg(null, "Long Conversion Failed in stringToObjId");
		return null;
	}
	obj_id objObject = obj_id.getObjId(lngId.longValue()); // doesn't check if it's actually a valid object
	return objObject;
}

obj_id[] stringToObjId(string[] text)
{
 if ( (text == null) || (text.length == 0) )
 	return null;

 obj_id[] ids = new obj_id[text.length];

 for ( int i = 0; i < text.length; i++ )
 {
  ids[i] = stringToObjId(text[i]);
 }

 if ( ids.length == text.length )
 {
  return ids;
 }

 return null;
}

int stringToInt(string text)
{
	if ( text == null || text.equals("") )
		return -1;

	int amt;

	try
	{
		amt = Integer.parseInt(text);
	} // try with error handling
	catch (NumberFormatException err)
	{
		//debugServerConsoleMsg(null, "int conversion failed in stringToInt");
		return -1;
	}

	return amt;
}

long stringToLong(string text)
{
	if ( text == null || text.equals("") )
		return -1;

	long amt;

	try
	{
		amt = Long.parseLong(text);
	} // try with error handling
	catch (NumberFormatException err)
	{
		//debugServerConsoleMsg(null, "int conversion failed in stringToInt");
		return -1;
	}

	return amt;
}



float stringToFloat(string text)
{
	if ( text == null || text.equals("") )
		return Float.NEGATIVE_INFINITY;

	float amt;

	try
	{
		amt = Float.parseFloat(text);
	} // try with error handling
	catch (NumberFormatException err)
	{
		//debugServerConsoleMsg(null, "float conversion failed in stringToFloat");
		return Float.NEGATIVE_INFINITY;
	}

	return amt;
}

string objIdArrayToString(obj_id[] array)
{
	string text = "[ ";

	for (int i = 0; i < array.length; i++)
	{
		text += ""+array[i];

		if (i < array.length-1)
			text += ", ";
	}

	text += " ]";

	return text;
}

Vector removeElementAt( Vector array, int index )
{
	if ( array == null )
		return null;

	if ( index < 0 || index >= array.size() )
		return array;

	array.removeElementAt(index);
	return array;
}

Vector removeElement( Vector array, obj_id element )
{
	if (array == null)
		return null;

	if ( element == null )
		return array;

	array.removeElement(element);
	return array;
}

Vector removeElements( Vector array, obj_id[] elements )
{
	if (array == null)
		return null;

	if ( elements == null || elements.length == 0 )
		return array;

	List collection = Arrays.asList(elements);
	array.removeAll(collection);
	return array;
}

Vector removeElements( obj_id[] array, obj_id[] elements )
{
	if (array == null)
		return null;

	Vector ret = new Vector(Arrays.asList(array));
	if ( ret == null )
		return null;

	if ( elements == null || elements.length == 0 )
		return ret;

	List collection = Arrays.asList(elements);
	ret.removeAll(collection);
	return ret;
}

Vector removeElements( Vector array, Vector elements )
{
	if (array == null)
		return null;

	if ( elements == null || elements.size() == 0 )
		return array;

	array.removeAll(elements);
	return array;
}

Vector addElement( Vector array, Object element )
{
	if ( array == null )
		return addElement(new Vector(), element);

	if ( element == null )
		return array;

	array.add(element);
	return array;
}

Vector addElement( Vector array, boolean element )
{
	return addElement( array, new Boolean(element) );
}

Vector addElement( Vector array, int element )
{
	return addElement( array, new Integer(element) );
}

Vector addElement( Vector array, float element )
{
	return addElement( array, new Float(element) );
}


obj_id[] toStaticObjIdArray(Vector vector)
{
	if ( vector == null || vector.size() == 0 )
		return null;

	obj_id[] ret = new obj_id[vector.size()];
	vector.toArray(ret);
	return ret;
}

string[] toStaticStringArray(Vector vector)
{
	if ( vector == null || vector.size() == 0 )
		return null;

	string[] ret = new string[vector.size()];
	vector.toArray(ret);
	return ret;
}

location[] toStaticLocationArray(Vector vector)
{
	if ( vector == null || vector.size() == 0 )
		return null;

	location[] ret = new location[vector.size()];
	vector.toArray(ret);
	return ret;
}

boolean[] messageTo( obj_id[] targets, string messageName, dictionary params, float time, boolean guaranteed )
{
	if ( targets != null && targets.length > 0 )
	{
		boolean[] results = new boolean[ targets.length ];
		for ( int i = 0; i < targets.length; i++ )
			results[i] = messageTo( targets[i], messageName, params, time, guaranteed );
		return results;
	}
	return null;
}

/************************************************************
 * @brief determines if the location is at least the specified
 *        distance from the provided objects
 *
 * @param location loc
 * @param obj_id[] items
 * @param float    distance
 *
 * @return boolean
 ************************************************************/
boolean isLocSufficientDistanceFromObjects(location loc, obj_id[] items, float dist)
{
 if ( (items == null) || (dist < 0) )
 {
  return false;
 }

 for ( int i = 0; i < items.length; i++ )
 {
  if ( getDistance2D(loc, getLocation(items[i])) < dist )
  	return false;
 }

 return true;
}

/************************************************************
 * @brief concats two obj_id arrays
 *
 * @param obj_id array1
 * @param obj_id array2
 *
 * @return obj_id; null on error
 ************************************************************/
obj_id[] concatArrays(obj_id[] array1, obj_id[] array2)
{
	if(array1 == null)
 		return array2;

	else if(array2 == null)
		return array1;

	obj_id[] toPass = new obj_id[array1.length + array2.length];

	for(int i = 0; i < array1.length; i++)
		toPass[i] = array1[i];

	for(int i = 0; i < array2.length; i++)
		toPass[i + array1.length] = array2[i];

	return toPass;
}

/************************************************************
 * @brief concats two resizeable arrays
 *
 * @param Vector array1
 * @param Vector array2
 *
 * @return Vector; null on error
 ************************************************************/
Vector concatArrays(Vector array1, Vector array2)
{
	if ( array1 == null  )
 		return array2;
	else if (array2 == null)
		return array1;

	array1.addAll(array2);
	return array1;
}

/************************************************************
 * @brief concats a resizeable array and a normal array
 *
 * @param Vector array1
 * @param Vector array2
 *
 * @return Vector; null on error
 ************************************************************/
Vector concatArrays(Vector array1, Object[] array2)
{
	if ( array2 == null  )
 		return array1;

	if ( array1 == null )
		array1 = new Vector(array2.length + 10);

	array1.addAll(Arrays.asList(array2));
	return array1;
}

/************************************************************
 * @brief concats a resizeable array and a normal array
 *
 * @param Vector array1
 * @param Vector array2
 *
 * @return Vector; null on error
 ************************************************************/
Vector concatArrays(Vector array1, int[] array2)
{
	if ( array2 == null  )
 		return array1;

	Object[] toPass = new Object[array2.length];
	for ( int i = 0; i < array2.length; i++ )
		toPass[i] = new Integer(array2[i]);

	return concatArrays(array1, toPass);
}

/************************************************************
 * @brief concats a resizeable array and a normal array
 *
 * @param Vector array1
 * @param Vector array2
 *
 * @return Vector; null on error
 ************************************************************/
Vector concatArrays(Vector array1, float[] array2)
{
	if ( array2 == null  )
 		return array1;

	Object[] toPass = new Object[array2.length];
	for ( int i = 0; i < array2.length; i++ )
		toPass[i] = new Float(array2[i]);

	return concatArrays(array1, toPass);
}

/************************************************************
 * @brief concats a resizeable array and a normal array
 *
 * @param Vector array1
 * @param Vector array2
 *
 * @return Vector; null on error
 ************************************************************/
Vector concatArrays(Vector array1, boolean[] array2)
{
	if ( array2 == null  )
 		return array1;

	Object[] toPass = new Object[array2.length];
	for ( int i = 0; i < array2.length; i++ )
		toPass[i] = new Boolean(array2[i]);

	return concatArrays(array1, toPass);
}


string[] concatArrays(string[] array1, string[] array2)
{
	if ( array1 == null  )
 		return array2;

	if ( array2 == null  )
 		return array1;

	string[] toPass = new string[array1.length + array2.length];
	for ( int i = 0; i < array1.length; i++ )
		toPass[i] = array1[i];

	for ( int i = 0; i < array2.length; i++ )
		toPass[i+array1.length] = array2[i];

	return toPass;
}

/************************************************************
 * @brief validates that array2 is a subset of array1
 *
 * @param obj_id[] array1
 * @param obj_id[] array2
 *
 * @return boolean
 ************************************************************/
boolean isSubset( obj_id[] array1, obj_id[] array2 )
{
 if ( (array1 == null) || (array2 == null) )
	return false;

 Vector v1 = new Vector( Arrays.asList(array1) );
 Vector v2 = new Vector( Arrays.asList(array2) );

 return v1.containsAll(v2);
}

/************************************************************
 * @brief validates that array2 is a subset of array1
 *
 * @param string[] array1
 * @param string[] array2
 *
 * @return boolean
 ************************************************************/
boolean isSubset( string[] array1, string[] array2 )
{
 if ( (array1 == null) || (array2 == null) )
	return false;

 Vector v1 = new Vector( Arrays.asList(array1) );
 Vector v2 = new Vector( Arrays.asList(array2) );

 return v1.containsAll(v2);
}

/************************************************************
 * @brief validates that array2 is a subset of array1
 *
 * @param string_id[] array1
 * @param string_id[] array2
 *
 * @return boolean
 ************************************************************/
boolean isSubset( string_id[] array1, string_id[] array2 )
{
 if ( (array1 == null) || (array2 == null) )
	return false;

 Vector v1 = new Vector( Arrays.asList(array1) );
 Vector v2 = new Vector( Arrays.asList(array2) );

 return v1.containsAll(v2);
}

/************************************************************
 * @brief validates that array2 is a subset of array1
 *
 * @param region[] array1
 * @param region[] array2
 *
 * @return boolean
 ************************************************************/
boolean isSubset( region[] array1, region[] array2 )
{
 if ( (array1 == null) || (array2 == null) )
	return false;

 Vector v1 = new Vector( Arrays.asList(array1) );
 Vector v2 = new Vector( Arrays.asList(array2) );

 return v1.containsAll(v2);
}

/************************************************************
 * @brief validates that array2 is a subset of array1
 *
 * @param location[] array1
 * @param location[] array2
 *
 * @return boolean
 ************************************************************/
boolean isSubset( location[] array1, location[] array2 )
{
 if ( (array1 == null) || (array2 == null) )
	return false;

 Vector v1 = new Vector( Arrays.asList(array1) );
 Vector v2 = new Vector( Arrays.asList(array2) );

 return v1.containsAll(v2);
}

/************************************************************
 * @brief validates that array2 is a subset of array1
 *
 * @param location[] array1
 * @param location[] array2
 *
 * @return boolean
 ************************************************************/
boolean isSubset( attrib_mod[] array1, attrib_mod[] array2 )
{
 if ( (array1 == null) || (array2 == null) )
	return false;

 Vector v1 = new Vector( Arrays.asList(array1) );
 Vector v2 = new Vector( Arrays.asList(array2) );

 return v1.containsAll(v2);
}

/*****************************************************************
 * @brief make name list from obj_id's
 *
 * @param obj_id[] players
 *
 * @return string[]; null on error
 ******************************************************************/
string[] makeNameListFromPlayerObjIdList(obj_id[] players)
{
	 if ( players == null )
		return null;

	 resizeable string[] nameList = new string[0];

	 for ( int i = 0; i < players.length; i++ )
	 {
		  if ( isPlayer(players[i]) )
		  {
			   nameList = addElement(nameList, getName(players[i]));
		  }
	 }

	 if ( nameList.length == players.length )
	 {
		  return nameList;
	 }
	 else
	 {
		  return null;
	 }
}

/*****************************************************************
 * @brief make name list from obj_id's
 *
 * @param obj_id[] targets
 *
 * @return string[]; null on error
 ******************************************************************/
string[] makeNameList(obj_id[] targets)
{
	 if ( targets == null )
		return null;

	 resizeable string[] nameList = new string[0];

	 obj_id self = getSelf();

	 for ( int i = 0; i < targets.length; i++ )
	 {
		  if ( isIdValid(targets[i]) )
		  {
				string itemName = getEncodedName(targets[i]);
				if ( itemName != null )
				{
			   		nameList = addElement(nameList, itemName);
			   	}
		  }
	 }

	 if ( nameList.length == targets.length )
	 {
		  return nameList;
	 }
	 else
	 {
		  return null;
	 }
}

/*****************************************************************
 * @brief make name list from obj_id's
 *
 * @param Vector targets
 *
 * @return string[]; null on error
 ******************************************************************/
string[] makeNameList(Vector targets)
{
	if ( targets == null || targets.isEmpty() )
		return null;

	obj_id[] targetsArray = new obj_id[targets.size()];
	targetsArray = (obj_id[])targets.toArray(targetsArray);
	return makeNameList(targetsArray);
}


/*****************************************************************
 * @brief determines if the target object is owned by the player
 *
 * @param obj_id target
 * @param obj_id player
 *
 * @return boolean
 ******************************************************************/
boolean isOwner(obj_id target, obj_id player)
{
	if ( (!isIdValid(target)) || (!isIdValid(player)) )
		return false;

	if ( getOwner(target) == player )
	{
		return true;
	}

	if ( getObjIdObjVar(target, VAR_OWNER) == player )
	{
		return true;
	}

	return false;
}

/*****************************************************************
 * @brief determines if the target object is coowned by the player
 *
 * @param obj_id target
 * @param obj_id player
 *
 * @return boolean
 ******************************************************************/
boolean isCoOwner(obj_id target, obj_id player)
{
	 if ( (target == null) || (!isIdValid(player)) )
		return false;

	 obj_id[] coowners = getObjIdArrayObjVar(target, VAR_COOWNERS);
	 if ( coowners == null )
		return false;

	 if ( getElementPositionInArray(coowners, player) > -1 )
		return true;

	 return false;
}

/*****************************************************************
 * @brief optional recursion getContents()
 *
 * @param obj_id  container
 * @param boolean recurse
 *
 * @return obj_id[]; null on error/nothing found
 ******************************************************************/
obj_id[] getContents(obj_id container, boolean recurse, Vector excludedNodes)
{
	resizeable obj_id[] contents = getResizeableContents(container, recurse, excludedNodes);
	return contents;
}

/*****************************************************************
 * @brief optional recursion getContents()
 *
 * @param obj_id  container
 * @param boolean recurse
 *
 * @return obj_id[]; null on error/nothing found
 ******************************************************************/
obj_id[] getContents(obj_id container, boolean recurse)
{
	resizeable obj_id[] contents = getResizeableContents(container, recurse, null);
	return contents;
}

/*****************************************************************
 * @brief optional recursion getContents()
 *
 * @param obj_id  container
 * @param boolean recurse
 *
 * @return obj_id[]; null on error/nothing found
 ******************************************************************/
Vector getResizeableContents(obj_id container, boolean recurse, Vector excludedNodes)
{
	 if ( (!isIdValid(container)) || (getContainerType(container) == 0) )
	 {
		  return null;
	 }

	 if ( !recurse )
	 {
		  return getResizeableContents(container);
	 }
	 else
	 {
		  resizeable obj_id[] contents = getResizeableContents(container);
		  if ( contents == null )
			return null;

			boolean exclude = true;
		  	if ( (excludedNodes == null) || excludedNodes.isEmpty() )
		  	{
		  		exclude = false;
		  	}

		  for ( int i = 0; i < contents.length; i++ )
		  {
		  		obj_id item = contents[i];
		  		if ( isIdValid(item) )
		  		{

		  			boolean keepItem = true;
		  			if ( exclude )
		  			{
		  				int idx = excludedNodes.indexOf(item);
		  				if ( idx > -1 )
		  				{
		  					contents = removeElementAt(contents, i);
		  					i--;
		  					keepItem = false;
		  				}
					}

					if ( keepItem)
					{
						// don't recurse into the contents of a factory crate
						int itemGameObjectType = getGameObjectType(item);
						if ( itemGameObjectType != GOT_misc_factory_crate && itemGameObjectType != GOT_chronicles_quest_holocron )
						{
							int containerType = getContainerType(item);
							if ( containerType != 0 )
							{
								obj_id[] newContents = getContents(item);
								if ( newContents != null )
								{
								 	contents = concatArrays(contents, newContents);
								}
							}
						}
					}
				}
		  }
		  return contents;
	 }
}


/******************************************************************
* obj_id object the objects you want the same container objects for
*
* return obj_id[] shared container contents if any or null if object is not contained
*******************************************************************/

obj_id[] getSharedContainerObjects(obj_id object)
{
	if (!isIdValid(object) || !exists(object))
		return null;

	obj_id container = getContainedBy(object);
	if (!isIdValid(container) || !exists(container))
		return null;

	return getContents(container);
}

/*****************************************************************
 * @brief optional recursion getContents()
 *
 * @param obj_id  container
 * @param boolean recurse
 *
 * @return obj_id[]; null on error/nothing found
 ******************************************************************/
Vector getResizeableContents(obj_id container, boolean recurse)
{
	return getResizeableContents(container, recurse, null);
}

/*****************************************************************
 * @brief optional recursion getContents()
 *
 * @param obj_id  container
 *
 * @return obj_id[]; null on error/nothing found
 ******************************************************************/
obj_id[] getNonBankPlayerContents(obj_id player)
{
	if ( !isIdValid(player) )
	{
		return null;
	}

	obj_id bank = getPlayerBank(player);
	if ( !isIdValid(bank) )
	{
		return null;
	}

	resizeable obj_id[] toExclude = addElement(null, bank);
	obj_id[] contents = getContents(player, true, toExclude);
	return contents;
}

/*****************************************************************
 * @brief optional recursion getContents()
 *
 * @param obj_id  container
 *
 * @return obj_id[]; null on error/nothing found
 ******************************************************************/
obj_id[] getFilteredPlayerContents(obj_id player)
{
	if ( !isIdValid(player) )
	{
		return null;
	}

	resizeable obj_id[] toExclude = null;

	obj_id bank = getPlayerBank(player);
	if ( isIdValid(bank) )
	{
		toExclude = addElement(toExclude, bank);
	}

	obj_id missionBag = getMissionBag(player);
	if ( isIdValid(missionBag) )
	{
		toExclude = addElement(toExclude, missionBag);
	}

	obj_id datapad = getPlayerDatapad(player);
	if ( isIdValid(datapad) )
	{
		toExclude = addElement(toExclude, datapad);
	}

	return getContents(player, true, toExclude);
}

/*****************************************************************
 * @brief determines if the target object is coowned by the player
 *
 * @param obj_id  container
 * @param obj_id  player
 *
 * @return obj_id[]; null on error/nothing found
 ******************************************************************/
obj_id[] getAllContentsOwnedByPlayer(obj_id container, obj_id player)
{
	 if ( (!isIdValid(container)) || (container == obj_id.NULL_ID) || (!isIdValid(player)) )
		return null;

	 resizeable obj_id[] ownedObjects = new obj_id[0];
	 obj_id[] allObjects = getContents(container, true);

	 if ( allObjects == null )
		return null;

	 for ( int i = 0; i < allObjects.length; i++ )
	 {
		  if ( getObjIdObjVar(allObjects[i], VAR_OWNER) == player )
		  {
			   ownedObjects = addElement(ownedObjects, allObjects[i]);
		  }
	 }

	 if ( ownedObjects.length > 0 )
	 {
		  return ownedObjects;
	 }

	 return null;
}

boolean isNestedWithin(obj_id item, obj_id container)
{
	if ( !isIdValid(item) || !isIdValid(container) )
	{
		return false;
	}

	obj_id containedBy = getContainedBy(item);
	if ( !isIdValid(containedBy) )
	{
		return false;
	}
	else if ( containedBy == container )
	{
		return true;
	}

	return isNestedWithin(containedBy, container);
}

boolean isNestedWithinAPlayer(obj_id item)
{
	return isNestedWithinAPlayer(item, true);
}

//allows the search to not count the bank as part of the players inventory
boolean isNestedWithinAPlayer(obj_id item, boolean searchBank)
{
	if ( !isIdValid(item) )
	{
		return false;
	}

	if ( isIdValid(getContainingPlayer(item)) )
	{
		if(searchBank)
		{
			return true;
		}
		else
		{
			obj_id player = getContainingPlayer(item);
			obj_id bank = getPlayerBank(player);

			if(isIdValid(bank))
			{
				obj_id containedBy = getContainedBy(item);

				if(containedBy == bank)
				{
					return false;
				}
				else
				{
					return true;
				}
			}
			else
			{
				return true;
			}
		}
	}

	return false;
}

obj_id getContainingPlayer(obj_id item)
{
	obj_id containedBy = getContainedBy(item);
	if ( !isIdValid(containedBy) )
	{
		return null;
	}
	else if ( isPlayer(containedBy) )
	{
		return containedBy;
	}
	return getContainingPlayer(containedBy);
}


boolean isNestedWithinANpcCreature(obj_id item)
{
	if ( !isIdValid(item) )
	{
		return false;
	}

	if ( isIdValid(getContainingNpcCreature(item)) )
		return true;

	return false;
}

obj_id getContainingNpcCreature(obj_id item)
{
	obj_id containedBy = getContainedBy(item);
	if ( !isIdValid(containedBy) )
	{
		return null;
	}
	else if ( isNpcCreature(containedBy) )
	{
		return containedBy;
	}

	return getContainingNpcCreature(containedBy);
}

obj_id getContainingPlayerOrCreature(obj_id item)
{
	obj_id containedBy = getContainedBy(item);
	if ( !isIdValid(containedBy) )
	{
		return null;
	}
	else if ( isNpcCreature(containedBy) || isPlayer(containedBy))
	{
		return containedBy;
	}

	return getContainingPlayerOrCreature(containedBy);
}


// -------------------------------------
// Checking player for an item based on template name
//
// just checking player inventory
boolean playerHasItemByTemplate(obj_id objPlayer, string strTemplate)
{
	obj_id objInventory = getInventoryContainer(objPlayer);
	if( isIdValid(objInventory) )
	{
		obj_id[] objContents = getContents(objInventory, true);

		if( objContents != null )
		{
			for( int intI = 0; intI<objContents.length; intI++ )
			{
				string strItemTemplate = getTemplateName(objContents[intI]);
				if( strItemTemplate==strTemplate )
				{
					return true;
				}
			}
		}
	}
	return false;
}

boolean playerHasItemByTemplateInDataPad(obj_id objPlayer, string strTemplate)
{
	obj_id pDataPad = getPlayerDatapad(objPlayer);
	if( isIdValid(pDataPad) )
	{
		LOG("utils", "playerHasItemByTemplateInDataPad::pDataPad " + pDataPad);
		obj_id[] objContents = getContents(pDataPad, true);
		LOG("utils", "playerHasItemByTemplateInDataPad::objContents.length " + objContents.length);
		if( objContents != null )
		{
			for( int intI = 0; intI < objContents.length; intI++ )
			{
				string strItemTemplate = getTemplateName(objContents[intI]);
				LOG("utils", "playerHasItemByTemplateInDataPad::strItemTemplate " + strItemTemplate);
				LOG("utils", "playerHasItemByTemplateInDataPad::strTemplate " + strTemplate);
				if( strItemTemplate==strTemplate )
				{
					return true;
				}
			}
		}
	}
	else
		LOG("utils", "playerHasItemByTemplateInDataPad::Dpad was invalid");
	return false;
}

int playerHasHowManyItemByTemplateInDataPad(obj_id objPlayer, string strTemplate, boolean recurse)
{
	int count = 0;
	obj_id pDataPad = getPlayerDatapad(objPlayer);
	if( isIdValid(pDataPad) )
	{
		obj_id[] objContents = getContents(pDataPad, recurse);
		if( objContents != null )
		{
			for( int intI = 0; intI < objContents.length; intI++ )
			{
				string strItemTemplate = getTemplateName(objContents[intI]);
				if( strItemTemplate.equals(strTemplate) )
				{
					++count;
				}
			}
		}
	}

	return count;
}

boolean playerHasItemByTemplateInInventoryOrEquipped(obj_id player, string desiredTemplate)
{
	obj_id[] contents = getInventoryAndEquipment(player);

	if (contents != null)
	{
		for(int i = 0;i<contents.length;i++)
		{
			string inventoryObject = getTemplateName(contents[i]);
			if(inventoryObject.equals(desiredTemplate))
				return true;
		}
	}

	return false;
}

obj_id getItemByTemplateInInventoryOrEquipped(obj_id player, string desiredTemplate)
{
	obj_id[] contents = getInventoryAndEquipment(player);
	if(contents != null)
	{

		for(int i = 0;i<contents.length;i++)
		{
			string inventoryObject = getTemplateName(contents[i]);
			if(inventoryObject.equals(desiredTemplate))
				return contents[i];
		}
	}

	return null;
}

boolean playerHasItemWithObjVarInInventoryOrEquipped(obj_id player, string desiredObjVar)
{
	obj_id[] contents = getInventoryAndEquipment(player);

	if (contents != null)
	{
		for(int i = 0;i<contents.length;i++)
		{
			if(hasObjVar(contents[i], desiredObjVar))
				return true;
		}
	}
	return false;
}

boolean playerHasItemByTemplateWithObjVarInInventoryOrEquipped(obj_id player, string desiredTemplate, string desiredObjVar)
{
	obj_id[] contents = getInventoryAndEquipment(player);

	if (contents != null)
	{
		for(int i = 0;i<contents.length;i++)
		{
			string inventoryObject = getTemplateName(contents[i]);
			if(inventoryObject.equals(desiredTemplate))
			{
				if(hasObjVar(contents[i], desiredObjVar))
					return true;
			}
		}
	}
	return false;
}

// just checking player bank
boolean playerHasItemByTemplateInBank(obj_id objPlayer, string strTemplate)
{
	obj_id objBank = getPlayerBank(objPlayer);
	if( isIdValid(objBank) )
	{
		obj_id[] objContents = getContents(objBank, true);

		if( objContents != null )
		{
			for( int i = 0; i < objContents.length; i++ )
			{
				string strItemTemplate = getTemplateName(objContents[i]);
				if( strItemTemplate==strTemplate )
				{
					return true;
				}
			}
		}
	}
	return false;
}

// checking player bank and inventory
boolean playerHasItemByTemplateInBankOrInventory(obj_id objPlayer, string strTemplate)
{
	if ( playerHasItemByTemplate(objPlayer, strTemplate) )
		return true;

	else if ( playerHasItemByTemplateInBank( objPlayer, strTemplate) )
		return true;

	return false;
}

// checking player bank and inventory
boolean playerHasStaticItemInBankOrInventory(obj_id player, string staticItem)
{
	return (isIdValid(getStaticItemInBankOrInventory(player, staticItem)));
}

obj_id getStaticItemInBankOrInventory(obj_id player, string staticItem)
{
	obj_id[] contents = getInventoryAndEquipment(player);
	if (contents != null && contents.length > 0)
	{
		for(int i = 0;i < contents.length;i++)
		{
			string itemName = getStaticItemName(contents[i]);
			if (itemName != null && staticItem != null && staticItem.equals(itemName))
				return contents[i];
		}
	}

	obj_id bank = getPlayerBank(player);
	if (isIdValid(bank))
	{
		contents = getContents(bank, true);

		if (contents != null && contents.length > 0)
		{
			for (int i = 0; i < contents.length; i++ )
			{
				string itemName = static_item.getStaticItemName(contents[i]);
				if (itemName != null && staticItem != null && staticItem.equals(itemName))
					return contents[i];
			}
		}
	}

	return null;
}

// checking player bank and inventory
boolean playerHasStaticItemInAppearanceInventory(obj_id player, string staticItem)
{
	return (isIdValid(getStaticItemInAppearanceInventory(player, staticItem)));
}

obj_id getStaticItemInAppearanceInventory(obj_id player, string staticItem)
{
	obj_id [] contents = getAllItemsFromAppearanceInventory(player);
	{
		if(contents != null && contents.length > 0)
		{
			for(int i = 0;i < contents.length;i++)
			{
				string itemName = getStaticItemName(contents[i]);
				if (itemName != null && staticItem != null && staticItem.equals(itemName))
					return contents[i];
			}
		}
	}

	return null;
}

//gets all static items of the same type in the players inventory and returns them in an array

obj_id[] getAllStaticItemsInPlayerInventory(obj_id player, string staticItem)
{
	resizeable obj_id[] objectList = new Vector ();

	obj_id inventory = getInventoryContainer(player);
	if( isIdValid(inventory) )
	{
		obj_id[] contents = getInventoryAndEquipment(player);

		if( contents != null && contents.length > 0 )
		{
			for( int i = 0; i < contents.length; i++ )
			{
				if (contents[i] != null)
				{
					if (static_item.isStaticItem(contents[i]))
					{
						string itemName = getStaticItemName(contents[i]);
						if( itemName==staticItem )
						{
							objectList = addElement (objectList, contents[i]);
						}
					}
				}
			}
		}
	}

	if (objectList.size () > 0)
	{
		obj_id[] staticList = new obj_id[objectList.size()];
		objectList.toArray (staticList);
		return staticList;
	}

	return null;
}

obj_id getStaticItemInInventory(obj_id player, string staticItem)
{
	obj_id[] contents = getInventoryAndEquipment(player);
	if (contents != null && contents.length > 0)
	{
		for(int i = 0;i < contents.length;i++)
		{
			string itemName = getStaticItemName(contents[i]);
			if (itemName != null && staticItem != null && staticItem.equals(itemName))
				return contents[i];
		}
	}

	return null;
}
//gets the total amount of stackable objects from an array list

int countOfStackedItemsInArray(obj_id[] items)
{
	int totalCount = 0;

	for( int i = 0; i < items.length; i++ )
	{
		int itemCount = getCount(items[i]);
		totalCount = itemCount + totalCount;
	}
	return totalCount;
}

// just checking player inventory
obj_id getItemPlayerHasByTemplate(obj_id objPlayer, string strTemplate)
{
	obj_id objInventory = getInventoryContainer(objPlayer);
	if( isIdValid(objInventory) )
	{
		obj_id[] objContents = getContents(objInventory, true);

		if( objContents != null )
		{
			for( int i = 0; i < objContents.length; i++ )
			{
				string strItemTemplate = getTemplateName(objContents[i]);
				if( strItemTemplate==strTemplate )
				{
					return objContents[i];
				}
			}
		}
	}
	return null;
}

obj_id getItemPlayerHasByTemplateInDatapad(obj_id objPlayer, string strTemplate)
{
	obj_id pDataPad = getPlayerDatapad(objPlayer);
	if( isIdValid(pDataPad) )
	{
		obj_id[] objContents = getContents(pDataPad, true);

		if( objContents != null )
		{
			for( int i = 0; i < objContents.length; i++ )
			{
				string strItemTemplate = getTemplateName(objContents[i]);
				if( strItemTemplate==strTemplate )
				{
					return objContents[i];
				}
			}
		}
	}
	return null;
}


// just checking player bank
obj_id getItemPlayerHasByTemplateInBank(obj_id objPlayer, string strTemplate)
{
	obj_id objBank = getPlayerBank(objPlayer);
	if( isIdValid(objBank) )
	{
		obj_id[] objContents = getContents(objBank, true);

		if( objContents != null )
		{
			for( int i = 0; i < objContents.length; i++ )
			{
				string strItemTemplate = getTemplateName(objContents[i]);
				if( strItemTemplate==strTemplate )
				{
					return objContents[i];
				}
			}
		}
	}
	return null;
}

// checking player bank and inventory. Inventory checked first.
obj_id getItemPlayerHasByTemplateInBankOrInventory(obj_id objPlayer, string strTemplate)
{
	obj_id itemObj = getItemPlayerHasByTemplate(objPlayer, strTemplate);
	if ( isIdValid( itemObj ) )
	{
		return itemObj;
	}
	else
	{
		itemObj = getItemPlayerHasByTemplateInBank(objPlayer, strTemplate);
		if ( isIdValid(itemObj) )
		{
			return itemObj;
		}
	}
	return null;
}

// just checking player inventory
obj_id[] getAllItemsPlayerHasByTemplate(obj_id objPlayer, string strTemplate)
{
	obj_id objInventory = getInventoryContainer(objPlayer);
	if( isIdValid(objInventory) )
		return getAllItemsInContainerByTemplate( objInventory, strTemplate, true);
	else
		return null;
}

// just checking player bank
obj_id[] getAllItemsPlayerHasByTemplateInBank(obj_id objPlayer, string strTemplate)
{
	obj_id objBank = getPlayerBank(objPlayer);
	if( isIdValid(objBank) )
		return getAllItemsInContainerByTemplate( objBank, strTemplate, true );
	else
		return null;
}
obj_id[] getAllItemsInContainerByTemplate( obj_id container, string template, boolean recurse )
{
	return getAllItemsInContainerByTemplate(container, template, recurse, true);
}

obj_id[] getAllItemsInContainerByTemplate( obj_id container, string template, boolean recurse, boolean allowEquipped )
{
	resizeable obj_id[] objectList = new Vector ();
	if( isIdValid(container) )
	{
		obj_id[] objContents = getContents(container, recurse);
		if( objContents != null )
		{
			for( int intI = 0; intI<objContents.length; intI++ )
			{
				string itemTemplate = getTemplateName(objContents[intI]);
				if( itemTemplate == template )
				{
					if(!allowEquipped)
					{
						if(isEquipped(objContents[intI]))
							continue;
					}
					objectList = addElement (objectList, objContents[intI]);
				}
			}
		}
	}

	if (objectList.size () > 0)
	{
		obj_id[] staticList = new obj_id[objectList.size()];
		objectList.toArray (staticList);
		return staticList;
	}
	else
		return null;
}

// just checking player inventory for item templates that starts with
obj_id[] getAllItemsPlayerHasByTemplateStartsWith(obj_id objPlayer, string strTemplate)
{
	obj_id objInventory = getInventoryContainer(objPlayer);
	if( isIdValid(objInventory) )
		return getAllItemsInContainerByTemplateStartsWith( objInventory, strTemplate, true);
	else
		return null;
}

// just checking player bank for item templates that starts with
obj_id[] getAllItemsPlayerHasByTemplateInBankStartsWith(obj_id objPlayer, string strTemplate)
{
	obj_id objBank = getPlayerBank(objPlayer);
	if( isIdValid(objBank) )
		return getAllItemsInContainerByTemplateStartsWith( objBank, strTemplate, true );
	else
		return null;
}

obj_id[] getAllItemsInContainerByTemplateStartsWith( obj_id container, string template, boolean recurse )
{
	resizeable obj_id[] objectList = new Vector ();
	if( isIdValid(container) )
	{
		obj_id[] objContents = getContents(container, recurse);
		if( objContents != null )
		{
			for( int intI = 0; intI<objContents.length; intI++ )
			{
				string itemTemplate = getTemplateName(objContents[intI]);
				if( itemTemplate.startsWith (template))
				{
					objectList = addElement (objectList, objContents[intI]);
				}
			}
		}
	}

	if (objectList.size () > 0)
	{
		obj_id[] staticList = new obj_id[objectList.size()];
		objectList.toArray (staticList);
		return staticList;
	}
	else
		return null;
}

// checking player bank and inventory
obj_id[] getAllItemsPlayerHasByTemplateInBankAndInventory(obj_id objPlayer, string strTemplate)
{
	resizeable obj_id[] objectList = new Vector ();

	obj_id objInventory = getInventoryContainer(objPlayer);
	if( isIdValid(objInventory) )
	{
		obj_id[] objContents = getContents(objInventory, true);

		if( objContents != null )
		{
			for( int i = 0; i < objContents.length; i++ )
			{
				string strItemTemplate = getTemplateName(objContents[i]);
				if( strItemTemplate==strTemplate )
				{
					objectList = addElement (objectList, objContents[i]);
				}
			}
		}
	}

	obj_id objBank = getPlayerBank(objPlayer);
	if( isIdValid(objBank) )
	{
		obj_id[] objContents = getContents(objBank, true);

		if( objContents != null )
		{
			for( int j = 0; j < objContents.length; j++ )
			{
				string strItemTemplate = getTemplateName(objContents[j]);
				if( strItemTemplate==strTemplate )
				{
					objectList = addElement (objectList, objContents[j]);
				}
			}
		}
	}
	if (objectList.size () > 0)
	{
		obj_id[] staticList = new obj_id[objectList.size()];
		objectList.toArray (staticList);
		return staticList;
	}

	return null;
}

obj_id[] getAllItemsInBankAndInventory(obj_id objPlayer)
{
	resizeable obj_id[] objectList = new Vector ();

	obj_id[] objContents = getInventoryAndEquipment(objPlayer);

	if( objContents != null )
	{
		for( int i = 0; i < objContents.length; i++ )
		{
			objectList = addElement (objectList, objContents[i]);
		}
	}

	obj_id objBank = getPlayerBank(objPlayer);
	if( isIdValid(objBank) )
	{
		objContents = getContents(objBank, true);

		if( objContents != null )
		{
			for( int j = 0; j < objContents.length; j++ )
			{
				objectList = addElement (objectList, objContents[j]);
			}
		}
	}
	if (objectList.size () > 0)
	{
		obj_id[] staticList = new obj_id[objectList.size()];
		objectList.toArray (staticList);
		return staticList;
	}

	return null;
}

//
// -------------------------------------


location getRandomLocationInRing(location locOrigin, float fltMinDistance, float fltMaxDistance)
{


	// we need to calculate the distance
	// becuase rand only works with ints, we have to use the uglier float version
	float fltRand = rand();

	float fltDistance = (fltMaxDistance - fltMinDistance) * fltRand +fltMinDistance; // nasty
	obj_id objTest = null;
	debugServerConsoleMsg(objTest, "fltDistance is "+fltDistance);

	float fltAngle = rand(0, 360); // angle in degrees
	locOrigin = rotatePointXZ(locOrigin, fltDistance, fltAngle);


	return locOrigin;
}


location rotatePointXZ(location locOrigin, float fltDistance, float fltAngle)
{
	location locOffset = locOrigin;
	locOffset.x = locOrigin.x + fltDistance;
	locOffset.z = locOrigin.z;

	return rotatePointXZ(locOrigin, locOffset, fltAngle);
}

location rotatePointXZ(location locOrigin, location locPoint, float fltAngle)
{
	float dx = locPoint.x - locOrigin.x;
	float dz = locPoint.z - locOrigin.z;

	float fltRadians = (float)Math.toRadians(fltAngle);
	float fltC = (float)Math.cos(fltRadians);
	float fltS = (float) Math.sin(fltRadians);

  	location locNewOffset = locOrigin;
  	locNewOffset.x += (dx * fltS) - (dz * fltC);
  	locNewOffset.y = locPoint.y;
  	locNewOffset.z += (dx * fltC) + (dz * fltS);

	return locNewOffset;
}


location rotatePointXZ(location locPoint, float fltAngle)
{
	//LOG("player_spawner", "rotating point");
	float fltRadians = (float) Math.toRadians(fltAngle);
	float fltC = (float) Math.cos(fltRadians);
	float fltS = (float) Math.sin(fltRadians);
	//LOG("player_spawner", "locPoint is "+locPoint);
	location locNewPoint = locPoint;
	locNewPoint.x += (locPoint.x * fltC) - (locPoint.z * fltS);
	locNewPoint.z += (locPoint.x * fltS) + (locPoint.z * fltC);

	return locNewPoint;
}

float getHeadingToLocation(location here, location there)
{
	if ( here == null || there == null )
		return -1f;

	float dx = there.x - here.x;
	float dz = there.z - here.z;

	double radHeading = Math.atan2(-dx, dz);
	double degreeHeading = Math.toDegrees(radHeading);
	return (float)(degreeHeading);
}

/*****************************************************************
 * @brief determines the location at the proper location in front of target
 *
 * @param obj_id    target
 * @param distance  distance
 *
 * @return location, null on error
 ******************************************************************/
location findLocInFrontOfTarget(obj_id target, float distance)
{
	 if ( target == null || !exists(target))
		return null;

	location origin = getLocation(target);

	if(origin == null)
		return null;

	float yaw = getYaw(target);

	location newLoc = rotatePointXZ(origin, distance, yaw);

	return newLoc;
}

/*****************************************************************
 * @brief	creates an attrib modifier from its constituent parts
 *
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 * @param	float 	attack
 * @param	float 	decay
 *
 * @return    	attrib_mod
 *****************************************************************/
attrib_mod createAttribMod(int attrib, int value, float duration, float attack, float decay)
{
 	return new attrib_mod(attrib, value, duration, attack, decay);
}

/*****************************************************************
 * @brief	creates an attrib modifier from its constituent parts
 *
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 * @param	float 	attack
 * @param	float 	decay
 *
 * @return    	attrib_mod
 *****************************************************************/
attrib_mod createAttribMod(int attrib, int value, float duration, float attack)
{
 	return new attrib_mod(attrib, value, duration, attack, 0.0f);
}

/*****************************************************************
 * @brief	creates an attrib modifier from its constituent parts
 *
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 * @param	float 	attack
 *
 * @return    	attrib_mod
 *****************************************************************/
attrib_mod createAttribMod(int attrib, int value, float duration)
{
 	return new attrib_mod(attrib, value, duration, 0.0f, 0.0f);
}

/*****************************************************************
 * @brief	creates an attrib modifier from its constituent parts
 *
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 * @param	float 	attack
 *
 * @return    	attrib_mod
 *****************************************************************/
attrib_mod createHealDamageAttribMod(int attrib, int value)
{
	if ( (value < 1) || (attrib % 3 != 0) )
	{
		return null;
	}

 	return new attrib_mod(attrib, value, 0.0f, 0.0f, MOD_POOL);
}

/*****************************************************************
 * @brief	creates an attrib modifier from its constituent parts
 *
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 * @param	float 	attack
 *
 * @return    	attrib_mod
 *****************************************************************/
attrib_mod createHealWoundAttribMod(int attrib, int value)
{
	if ( value < 1 )
	{
		return null;
	}

 	return new attrib_mod(attrib, value, 0.0f, healing.AM_HEAL_WOUND, 0.0f);
}

/*****************************************************************
 * @brief	creates an attrib modifier from its constituent parts
 *
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 * @param	float 	attack
 *
 * @return    	attrib_mod
 *****************************************************************/
attrib_mod createHealShockAttribMod(int value)
{
	if ( value < 1 )
	{
		return null;
	}

	return new attrib_mod(0, value, 0.0f, healing.AM_HEAL_SHOCK, 0.0f);
}

/*****************************************************************
 * @brief	creates an attrib modifier from its constituent parts
 *
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 * @param	float 	attack
 *
 * @return    	attrib_mod
 *****************************************************************/
attrib_mod createAddShockAttribMod(int value)
{
	if ( value < 1 )
	{
		return null;
	}

	return new attrib_mod(0, value, 0.0f, healing.AM_ADD_SHOCK, 0.0f);
}

/*****************************************************************
 * @brief	creates an attrib modifier from its constituent parts
 *
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 * @param	float 	attack
 *
 * @return    	attrib_mod
 *****************************************************************/
attrib_mod createWoundAttribMod(int attrib, int value)
{
	if ( value < 1 )
	{
		return null;
	}

 	return new attrib_mod(attrib, value, 0.0f, 0.0f, MOD_WOUND);
}

/*****************************************************************
 * @brief	creates an attrib modifier from its constituent parts
 *
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 * @param	float 	attack
 *
 * @return    	attrib_mod
 *****************************************************************/
attrib_mod createAntidoteAttribMod(int attrib)
{
 	return new attrib_mod(attrib, 0, 0.0f, 0.0f, MOD_ANTIDOTE);
}

/*****************************************************************
 * @brief	overload function for addAttribModifier
 *
 * @param	obj_id	target
 * @param	int 	attrib
 * @param	int 	value
 * @param	float 	duration
 *
 * @return    	boolean; false on error
 *****************************************************************/
boolean addAttribMod(obj_id target, int attrib, int value, float duration)
{
 	return addAttribModifier(target, attrib, value, duration, 0.0f, 0.0f);
}

/*****************************************************************
 * @brief	overload function for addAttribMod
 *
 * @param	obj_id		player
 * @param	obj_id		target
 * @param	attrib_mod	am
 *
 * @return    	boolean; false on error
 *****************************************************************/
boolean addAttribMod(obj_id target, attrib_mod am)
{
	if(target == null || am == null)
		return false;

	boolean litmus = true;

	int attrib = am.getAttribute();
	float duration = am.getDuration();

	int amt = am.getValue();
	int attack = (int)(am.getAttack());
	int decay = (int)(am.getDecay());

	if ( attack < 0 )
	{
		switch (attack)
		{
			case (int)healing.AM_HEAL_WOUND:
				if ( amt < 0 )
				{
					amt = 0;
				}
				break;

			case (int)healing.AM_HEAL_SHOCK:
				if ( amt < 0 )
				{
					amt = 0;
				}
				litmus &= healShockWound(target, amt);
				break;

			case (int)healing.AM_ADD_SHOCK:
				if ( amt < 0 )
				{
					amt = 0;
				}
				litmus &= addShockWound(target, amt);
				break;
		}
	}
	/*else if ( decay < 0 )
	{
		switch (decay)
		{
			case (int)MOD_POOL:
			case (int)MOD_WOUND:
			case (int)MOD_ANTIDOTE:
				return addAttribModifier(target, am.getAttribute(), am.getValue(), am.getDuration(), am.getAttack(), am.getDecay());
		}
	}*/
	else
	{
		if (!addAttribModifier(target, attrib, amt, duration, am.getAttack(), am.getDecay()))
		{
			//debugSpeakMsg(target, "unable to add attrib mod...");
			litmus = false;
		}
	}
 	return litmus;
}


/*****************************************************************
 * @brief	applies each of the attrib mods in an attrib mod array
 *
 * @param	obj_id		target
 * @param	attrib_mod[]	am
 *
 * @return    	boolean; false on error
 *****************************************************************/
boolean addAttribMod(obj_id target, attrib_mod[] am)
{
 if ( (target == null) || (am == null) || (am.length == 0) )
 	return false;

 boolean ret = true;

 for ( int i = 0; i < am.length; i++ )
 {
  ret &= addAttribMod(target, am[i]);
 }

 return ret;
}


/*****************************************************************
 * @brief	rotates an object
 *
 * @param	obj_id		target
 * @param	float		heading (in degrees)
 *
 * @return    	boolean; false on error
 *****************************************************************/
boolean setHeading(obj_id target, float heading)
{
	if ( target == null )
		return false;

	return setYaw(target, heading);
}


/*****************************************************************
 * @brief	parses a string in the  format "<key1>=<val1>,<key2>=<val2>,..."
 *			NOTE: only use this function for STRING->INT key pair mappings
 *
 * @param	string	keyPairList
 * @param	string	delim
 *
 * @return 	dictionary; null on error
 *****************************************************************/
dictionary parseKeyPairList(string keyPairList, char delim)
{
	if ( keyPairList.equals("") )
	{
		return null;
	}

	dictionary d = new dictionary();

	string[] pairs = split(keyPairList, delim);
	if ( (pairs == null) || (pairs.length == 0) )
	{
		return null;
	}

	for ( int i = 0; i < pairs.length; i++ )
	{
		string[] tmp = split(pairs[i], '=');
		if ( (tmp != null) && (tmp.length == 2) )
		{
			int val = stringToInt(tmp[1]);
			if ( val != -1 )
			{
				d.put(tmp[0],val);
			}
		}
	}

	return d;
}

/*****************************************************************
 * @brief	overload for parseKeyPairList(string, char)
 *
 * @param	string	keyPairList
 *
 * @return 	dictionary; null on error
 *****************************************************************/
dictionary parseKeyPairList(string keyPairList)
{
	return parseKeyPairList(keyPairList, ',');
}

/*****************************************************************
 * @brief	attempts to put an item into a player's inventory
 *
 * @param	obj_id	player
 * @param	obj_id	item
 *
 * @return 	boolean; false on error
 *****************************************************************/
boolean putInPlayerInventory(obj_id player, obj_id item)
{
	if ( (!isIdValid(player)) || (!isPlayer(player)) || (item == null) )
	{
		return false;
	}

	obj_id inventory = getObjectInSlot(player, SLOT_INVENTORY);
	if ( inventory == null )
	{
		return false;
	}

	return putIn(item, inventory);
}


/*****************************************************************
 * @brief	attempts to put an item into a player's inventory
 *
 * @param	obj_id	player
 * @param	obj_id	item
 *
 * @return 	boolean; false on error
 *****************************************************************/
boolean putInPlayerDatapad(obj_id player, obj_id item)
{
	if ( (!isIdValid(player)) || (!isPlayer(player)) || (item == null) )
	{
		//debugSpeakMsg(player, "putInPlayerDatapad: invalid args");
		return false;
	}

	obj_id datapad = getObjectInSlot(player, SLOT_DATAPAD);
	if ( datapad == null )
	{
		//debugSpeakMsg(player, "putInPlayerDatapad: unable to determine player's datapad");
		return false;
	}

	return putIn(item, datapad);
}


/*****************************************************************
 * @brief	attempts to retrieve the obj_id of a mob's inventory container
 *
 * @param	obj_id	target
 *
 * @return 	obj_id; null on error
 *****************************************************************/
obj_id getInventoryContainer(obj_id target)
{
	if(!isIdValid(target))
	{
		return null;
	}

	return getObjectInSlot(target, SLOT_INVENTORY);
}

obj_id getDroidInventoryContainer(obj_id droid)
{
	if(!isIdValid(droid))
	{
		return null;
	}

	if(callable.hasCallableCD(droid))
	{
		return getObjectInSlot(callable.getCallableCD(droid), SLOT_INVENTORY);
	}
	else
	{
		return null;
	}

}

// GETS PLAYER MISSION BAG
obj_id getMissionBag(obj_id objPlayer)
{
	if(!isIdValid(objPlayer))
	{
		return null;
	}

	return getObjectInSlot(objPlayer, SLOT_MISSION_BAG);

}

/*****************************************************************
 * @brief	attempts to retrieve the obj_id of a player's datapad
 *
 * @param	obj_id	target
 *
 * @return 	obj_id; null on error
 *****************************************************************/
obj_id getDatapad(obj_id target)
{
	if(!isIdValid(target))
	{
		return null;
	}

	return getObjectInSlot(target, SLOT_DATAPAD);
}

/*****************************************************************
 * @brief	attempts to retrieve the obj_id of a player's datapad
 *
 * @param	obj_id	target
 *
 * @return 	obj_id; null on error
 *****************************************************************/
obj_id getPlayerDatapad(obj_id player)
{
	if(!isIdValid(player) || !isPlayer(player))
	{
		return null;
	}

	return getObjectInSlot(player, SLOT_DATAPAD);
}

/*****************************************************************
 * @brief	attempts to retrieve the obj_id of a player's hangar
 *
 * @param	obj_id	target
 *
 * @return 	obj_id; null on error
 *****************************************************************/
obj_id getPlayerHangar(obj_id player)
{
	if(!isIdValid(player) || !isPlayer(player))
	{
		return null;
	}

	return getObjectInSlot(player, SLOT_HANGAR);
}

/*****************************************************************
 * @brief	attempts to retrieve the obj_id of a player's datapad
 *
 * @param	obj_id	target
 *
 * @return 	obj_id; null on error
 *****************************************************************/
obj_id getPlayerBank(obj_id player)
{
	if(!isIdValid(player) || !isPlayer(player))
	{
		return null;
	}

	return getObjectInSlot(player, SLOT_BANK);
}

/*****************************************************************
 * @brief	wrapper for messaging that an object or item is not active
 *
 * @param	obj_id	target
 *
 * @return 	obj_id; null on error
 *****************************************************************/
boolean itemNotActive(obj_id player)
{
	if ( (!isIdValid(player)) || (!isPlayer(player))  )
	{
		return false;
	}

	sendSystemMessage(player, SID_OBJECT_NOT_ACTIVE);
	return true;
}


/*****************************************************************
 * @brief	wrapper for enqueueing a request to open a container
 *
 * @param	obj_id	target
 *
 * @return 	obj_id; null on error
 *****************************************************************/
boolean requestContainerOpen(obj_id player, obj_id container)
{
	if ( (!isIdValid(player)) || (!isPlayer(player)) || (!isIdValid(container)) || (getContainerType(container) == 0) )
	{
		return false;
	}

	queueCommand(player, ##"openContainer", container, "", COMMAND_PRIORITY_DEFAULT);
	return true;
}

// packs a string id into a format usable by the sui system
string packStringId(string_id strId)
{
	if(strId==null)
	{

		return null;
	}

	if ( !strId.isValid() )
	{
		return null;
	}

	string strPackedId = "@"+strId.getTable()+":"+strId.getAsciiId();
	return strPackedId;

}
string_id unpackString(string strId)
{
	if ( strId == null || strId.equals("") )
		return null;

	if ( strId.startsWith("@") )
		strId = strId.substring(1);

	string[] s = split(strId, ':');
	if ( s != null && s.length == 2 )
	{
		return new string_id(s[0], s[1]);
	}

	return null;
}

// ----------------------------------------------------------------------

obj_id getNearbyPlayerByName(obj_id actor, string name)
{
	java.util.StringTokenizer st = new java.util.StringTokenizer(name);
	if (st.hasMoreTokens())
	{
		string compareName = toLower(st.nextToken());

		obj_id[] players = getPlayerCreaturesInRange(actor, 128.0f);
		if (players != null)
		{
			for (int i = 0; i < players.length; ++i)
			{
				java.util.StringTokenizer st2 = new java.util.StringTokenizer(getName(players[i]));
				string playerName = toLower(st2.nextToken());
				if (compareName == playerName)
					return players[i];
			}
		}
	}
	return obj_id.NULL_ID;
}

void sendPostureChange(obj_id objCreature, int intPosture) // USE THIS TO CHANGE POSTURE AND SEND DOWN THE ANIMATION MESSAGE TO THE CLIENT.
{
	attacker_results cbtAttackerResults = new attacker_results();

	setPosture(objCreature, intPosture);
	string strPlayback = "change_posture";
	cbtAttackerResults.id = objCreature;
	cbtAttackerResults.endPosture = intPosture;
	cbtAttackerResults.weapon = null;
	doCombatResults(strPlayback, cbtAttackerResults, null);
	return;
}

/*****************************************************************
 * @brief	gets all objects with non-null getCellNames() returns
 *
 * @param	obj_id[]	items
 *
 * @return 	obj_id[]; null on error
 *****************************************************************/
obj_id[] getBuildingsInObjIdList(obj_id[] items)
{
	if ( (items == null) || (items.length == 0) )
	{
		return null;
	}

	resizeable obj_id[] buildings = new obj_id[0];

	for ( int i = 0; i < items.length; i++ )
	{
		if ( getCellNames(items[i]) == null )
		{
		}
		else
		{
			buildings = addElement(buildings, items[i]);
		}
	}

	if ( (buildings == null) || (buildings.length == 0) )
	{
		return null;
	}
	else
	{
		return buildings;
	}
}
/*****************************************************************
 * @brief	gets all objects with non-null getCellNames() returns
 *
 * @param	obj_id[]	items
 *
 * @return 	obj_id[]; null on error
 *****************************************************************/
obj_id[] getContainedGOTObjects(obj_id container, int got, boolean recurse, boolean allowDerived)
{
	if ( !isIdValid(container) || (got < 0) )
	{
		return null;
	}

	if ( getContainerType(container) == 0 )	//container type == CT_none
	{
		//not a container!
		return null;
	}

	obj_id[] contents = getContents(container, recurse);
	if ( (contents == null) || (contents.length == 0) )
	{
		return null;
	}

	resizeable obj_id[] ret = new obj_id[0];
	for ( int i = 0; i < contents.length; i++ )
	{
		int myType = getGameObjectType(contents[i]);
		if ( !allowDerived )
		{
			if ( myType == got )
			{
				ret = addElement(ret, contents[i]);
			}
		}
		else
		{
			if ( isGameObjectTypeOf(myType, got) )
			{
				ret = addElement(ret, contents[i]);
			}
		}
	}
	if ( (ret == null) || (ret.length == 0) )
		return null;
	return ret;
}

obj_id[] getContainedGOTObjects(obj_id container, int got, boolean recurse)
{
	return getContainedGOTObjects(container, got, recurse, false);
}

obj_id[] getContainedGOTObjects(obj_id container, int got)
{
	return getContainedGOTObjects(container, got, false);
}

obj_id[] getContainedObjectsWithObjVar(obj_id container, string var, boolean recurse)
{
	if(!isIdValid(container))
		return null;

	if(getContainerType(container) == 0)
		return null;

	if(var == null || var.equals(""))
		return null;

	obj_id[] contents = getContents(container, recurse);
	if(contents == null || contents.length == 0)
		return null;

	resizeable obj_id[] ret = new obj_id[0];
	for(int i = 0; i < contents.length; i++)
	{
		if(hasObjVar(contents[i], var))
			ret = addElement(ret, contents[i]);
	}

	if((ret == null) || (ret.length == 0))
		return null;

	return ret;
}

obj_id[] getContainedObjectsWithObjVar(obj_id container, string var)
{
	return getContainedObjectsWithObjVar(container, var, false);
}

obj_id[] getContainedObjectsWithScript(obj_id container, string script, boolean recurse)
{
	if(!isIdValid(container))
		return null;

	if(getContainerType(container) == 0)
		return null;

	if(script == null || script.equals(""))
		return null;

	obj_id[] contents = getContents(container, recurse);
	if(contents == null || contents.length == 0)
		return null;

	resizeable obj_id[] ret = new obj_id[0];
	for(int i = 0; i < contents.length; i++)
	{
		if(hasScript(contents[i], script))
			ret = addElement(ret, contents[i]);
	}

	if((ret == null) || (ret.length == 0))
		return null;

	return ret;
}

obj_id[] getContainedObjectsWithScript(obj_id container, string script)
{
	return getContainedObjectsWithScript(container, script, false);
}

/*************************************************************************************
 * @brief	Wrapper for sending Persistent chat messages (Emails)
 *
 * @params	string_id subject = The title of your email, saved in
 *		a stringfile, just like in a conversation.
 *
 *		string_id body = The actual message of your email, same as above
 *
 *		string to = The person receiving the mail.  Find this by using
 *		getFirstName (Obj_Id) of the person you want to send the mail to.
 *		Just use the first name, they're unique.
 *
 *		string from = Just a string.  Can be anything, Its just who the mail
 *		is from (Bib Fortuna, Jabba, Darth Vader, Joe the Butcher, etc.)
 *
 * @return 	void
 *
 * @Author	Tbailey (1/13/03) W/Help from J.Watson and M.Siverston
 ************************************************************************************/

void sendMail (string_id subject, string_id body, string to, string from)
{
	string body_oob    = chatMakePersistentMessageOutOfBandBody(null, body);
	string subject_str = "@" + subject.toString ();

	chatSendPersistentMessage( from, to, subject_str, null, body_oob );

	return;
}

//----------------------------------------------------------------------------------

void sendMail( string_id subject, string_id body, obj_id to, string from )
{
	string body_oob    = chatMakePersistentMessageOutOfBandBody(null, body);
	string subject_str = "@" + subject.toString ();

	chatSendPersistentMessage( from, to, subject_str, null, body_oob );
}

//----------------------------------------------------------------------------------

void sendMail( string_id subject, prose_package body, obj_id to, string from )
{
	string body_oob    = chatMakePersistentMessageOutOfBandBody(null, body);
	string subject_str = "@" + subject.toString ();

	chatSendPersistentMessage( from, to, subject_str, null, body_oob );
}

//----------------------------------------------------------------------------------

void sendMail( string_id subject, prose_package body, string to, string from )
{
	string body_oob    = chatMakePersistentMessageOutOfBandBody(null, body);
	string subject_str = "@" + subject.toString ();

	chatSendPersistentMessage( from, to, subject_str, null, body_oob );
}

//----------------------------------------------------------------------------------

boolean isNightTime()
{
	if (getLocalTime () < getLocalDayLength ())
	{
		//-- it's day time
		return false;
	}
	else
	{
		return true;
		//-- it's night time
	}
}

//--------------------------group system message function---------------------------
void sendSystemMessageTestingOnly(obj_id[] players, string message)
{
	if (players == null || players.length == 0)
		return;

	for (int i=0;i< players.length; i++)
	{
		if (isIdValid(players[i]) && exists(players[i]))
		{
			sendSystemMessageTestingOnly(players[i], message);
		}
	}
}

void sendSystemMessage(obj_id[] players, string_id message)
{
	if (players == null || players.length == 0)
		return;

	for (int i=0;i< players.length; i++)
	{
		if (isIdValid(players[i]) && exists(players[i]))
		{
			sendSystemMessage(players[i], message);
		}
	}
}

void sendSystemMessageProse(obj_id[] players, prose_package message)
{
	if (players == null || players.length == 0)
		return;

	for (int i=0;i< players.length; i++)
	{
		if (isIdValid(players[i]) && exists(players[i]))
		{
			sendSystemMessageProse(players[i], message);
		}
	}
}

void sendSystemMessagePob(obj_id pob, string_id message)
{
	obj_id[] players = trial.getPlayersInDungeon(pob);
	if (players != null && players.length > 0)
		utils.sendSystemMessage(players, message);
}

void sendSystemMessageProsePob(obj_id pob, prose_package message)
{
	obj_id[] players = trial.getPlayersInDungeon(pob);
	if (players != null && players.length > 0)
		utils.sendSystemMessageProse(players, message);
}

/**
* Wraps a string_id into a prose package and send the message in the space taunt window
*
* obj_id source			The NPC sending the message
* obj_id player			The player to message
* string_id message		The string to wrap
* string templateOverride	A template to use instead of the source
*
* return			void
**/
void messagePlayer(obj_id source, obj_id player, string_id message, string templateOverride)
{
	prose_package pp = new prose_package();
	pp.stringId = message;

	if (templateOverride.equals("none"))
		commPlayer(source, player, pp);
	else
		commPlayer(source, player, pp, templateOverride);
}

void messagePlayer(obj_id source, obj_id player, string_id message)
{
	messagePlayer(source, player, message, "none");
}

void messagePlayer(obj_id source, obj_id[] players, string_id message, string templateOverride)
{
	prose_package pp = new prose_package();
	pp.stringId = message;

	if (templateOverride.equals("none"))
		commPlayers(source, players, pp);
	else
		commPlayers(source, players, pp, templateOverride);
}

void messagePlayer(obj_id source, obj_id[] players, string_id message, string templateOverride, float duration)
{
	prose_package pp = new prose_package();
	pp.stringId = message;

	if(templateOverride.equals("none"))
	{
		commPlayers(source, players, pp);
		return;
	}

	if(duration <= 0.0f)
	{
		commPlayers(source, players, pp, templateOverride);
	}
	else
	{
		commPlayers(source, templateOverride, null, duration, players, pp);
	}
}

void messagePlayer(obj_id source, obj_id[] players, string_id message)
{
	messagePlayer(source, players, message, "none");
}

// OBJECT DICTIONARY FUNCTIONS
// These mirror LocalVars, but are not proxied. they are fast, but completely local, and wont work multiserver
boolean setLocalVar(obj_id target, string path, Vector val)
{
	// this function sucks
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;
	if ( val == null || val.isEmpty() )
		return false;
	// get a sample value from the vector so we can find out what type of data we've got
	Object sample = val.get(0);
	if ( sample == null )
		return false;

	// call a type-specific setLocalVar
	boolean result = false;
	if ( sample instanceof Integer )
	{
		int count = val.size();
		int[] tempVal = new int[count];
		for ( int i = 0; i < count; ++i )
			tempVal[i] = ((Integer)val.get(i)).intValue();
		result = setLocalVar(target, path, tempVal);
	}
	else if ( sample instanceof Boolean )
	{
		int count = val.size();
		boolean[] tempVal = new boolean[count];
		for ( int i = 0; i < count; ++i )
			tempVal[i] = ((Boolean)val.get(i)).booleanValue();
		result = setLocalVar(target, path, tempVal);
	}
	else if ( sample instanceof Float )
	{
		int count = val.size();
		float[] tempVal = new float[count];
		for ( int i = 0; i < count; ++i )
			tempVal[i] = ((Float)val.get(i)).intValue();
		result = setLocalVar(target, path, tempVal);
	}
	else if ( sample instanceof string )
	{
		string[] tempVal = new string[val.size()];
		tempVal = (string[])val.toArray(tempVal);
		result = setLocalVar(target, path, tempVal);
	}
	else if ( sample instanceof obj_id )
	{
		obj_id[] tempVal = new obj_id[val.size()];
		tempVal = (obj_id[])val.toArray(tempVal);
		result = setLocalVar(target, path, tempVal);
	}
	else if ( sample instanceof location )
	{
		location[] tempVal = new location[val.size()];
		tempVal = (location[])val.toArray(tempVal);
		result = setLocalVar(target, path, tempVal);
	}
	else if ( sample instanceof transform )
	{
		transform[] tempVal = new transform[val.size()];
		tempVal = (transform[])val.toArray(tempVal);
		result = setLocalVar(target, path, tempVal);
	}
	else if ( sample instanceof vector)
	{
		vector[] tempVal = new vector[val.size()];
		tempVal = (vector[])val.toArray(tempVal);
		result = setLocalVar(target, path, tempVal);
	}

	return result;
}


boolean setLocalVar(obj_id target, string path, location val)
{

	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Integer(val));
}
boolean setLocalVar(obj_id target, string path, location[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Integer(val));
}

boolean setLocalVar(obj_id target, string path, string val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Integer(val));
}
boolean setLocalVar(obj_id target, string path, string[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Integer(val));
}

boolean setLocalVar(obj_id target, string path, obj_id val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Integer(val));
}
boolean setLocalVar(obj_id target, string path, obj_id[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Integer(val));
}

boolean setLocalVar(obj_id target, string path, int val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Integer(val));
}
boolean setLocalVar(obj_id target, string path, int[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Integer(val));
}

boolean setLocalVar(obj_id target, string path, float val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Float(val));
}
boolean setLocalVar(obj_id target, string path, float[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
	//return setLocalVar(target, path, new Float(val));
}

boolean setLocalVar(obj_id target, string path, boolean val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
//	return setLocalVar(target, path, new Boolean(val));
}
boolean setLocalVar(obj_id target, string path, transform val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
}

boolean setLocalVar(obj_id target, string path, transform[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
}

boolean setLocalVar(obj_id target, string path, vector val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
}

boolean setLocalVar(obj_id target, string path, vector[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
}

boolean setLocalVar(obj_id target, string path, boolean[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val );
	return true;
//	return setLocalVar(target, path, new Boolean(val));
}

boolean setLocalVar(obj_id target, string path, dictionary val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	dictionary dd = target.getScriptDictionary();
	dd.put(path, val);
	return true;
}

boolean hasLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.containsKey(path);
}

boolean removeLocalVar(obj_id target, string path)
{
	if ( (target == null) || (target == obj_id.NULL_ID) )
	{
		return false;
	}

	if ( (path == null) || (path.equals("")) )
	{
		return false;
	}

	dictionary dd = target.getScriptDictionary();
	dd.remove(path);

	return true;
}

int getIntLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getInt(path);
}

int[] getIntArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getIntArray(path);
}

float getFloatLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getFloat(path);
}

float[] getFloatArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getFloatArray(path);
}

string getStringLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getString(path);
}

string[] getStringArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getStringArray(path);
}

transform[] getTransformArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getTransformArray(path);
}

boolean getBooleanLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getBoolean(path);
}

boolean[] getBooleanArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getBooleanArray(path);
}

location getLocationLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getLocation(path);
}

location[] getLocationArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getLocationArray(path);
}

obj_id getObjIdLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getObjId(path);
}

obj_id[] getObjIdArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getObjIdArray(path);
}

Vector getResizeableObjIdArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	obj_id[] objArray = dd.getObjIdArray(path);
	return new Vector(Arrays.asList(objArray));
}

Vector getResizeableLocationArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	location[] locArray = dd.getLocationArray(path);
	return new Vector(Arrays.asList(locArray));
}


Vector getResizeableIntArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	int[] intArray = dd.getIntArray(path);
	Vector rszArray = new Vector(intArray.length + 1);
	for ( int i = 0; i < intArray.length; ++i )
		rszArray.add(new Integer(intArray[i]));
	return rszArray;
}

Vector getResizeableFloatArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	float[] fltArray= dd.getFloatArray(path);
	Vector rszArray = new Vector(fltArray.length + 10);
	for ( int i = 0; i < fltArray.length; ++i )
		rszArray.add(new Float(fltArray[i]));
	return rszArray;
}

Vector getResizeableStringArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	string[] strArray = dd.getStringArray(path);
	return new Vector(Arrays.asList((String[])strArray));
}

Vector getResizeableTransformArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	transform[] trArray= dd.getTransformArray(path);
	Vector v1 = new Vector( Arrays.asList(trArray));

	return v1;
}

Vector getResizeableVectorArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	vector[] vctArray = dd.getVectorArray(path);
	Vector v1 = new Vector( Arrays.asList(vctArray));
	return v1;
}

string_id getStringIdLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getStringId(path);
}

string_id[] getStringIdArrayLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getStringIdArray(path);
}

dictionary getDictionaryLocalVar(obj_id target, string path)
{
	dictionary dd = target.getScriptDictionary();
	return dd.getDictionary(path);
}

// END LOCALVARS

/*****************************************************************
 * @brief	sets a scriptvar on a player
 *
 * @param	obj_id	target
 * @param	string	path
 * @param	Object	val
 *
 * @return 	boolean; false on error
 *****************************************************************/
/*boolean setScriptVar(obj_id target, string path, Object val)
{
	debugServerConsoleMsg(target, "utils:setScriptVar: entered...");
	if ( (target == null) || (target == obj_id.NULL_ID) )
	{
		return false;
	}

	if ( (path == null) || (path.equals("")) )
	{
		return false;
	}

	debugServerConsoleMsg(target, "utils:setScriptVar: retrieving scriptvars...");

	deltadictionary dd = target.getScriptVars();

	debugServerConsoleMsg(target, "utils:setScriptVar: attempting to set scriptvar " + path + " to " + val.toString());
	dd.put(path, val);

	return true;
}*/

boolean setScriptVar(obj_id target, string path, location val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, location[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, string val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, string[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, string[][] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val);
	return true;
}

boolean setScriptVar(obj_id target, string path, obj_id val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, obj_id[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, int val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, int[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, long val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, long[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, double val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, double[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, float val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, float[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, boolean val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, transform val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, transform[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, vector val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, vector[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, boolean[] val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val );
	return true;
}

boolean setScriptVar(obj_id target, string path, Vector val)
{
	// this function sucks
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;
	if ( val == null || val.isEmpty() )
		return false;
	// get a sample value from the vector so we can find out what type of data we've got
	Object sample = val.get(0);
	if ( sample == null )
		return false;

	// call a type-specific setScriptVar
	boolean result = false;
	if ( sample instanceof Integer )
	{
		int count = val.size();
		int[] tempVal = new int[count];
		for ( int i = 0; i < count; ++i )
			tempVal[i] = ((Integer)val.get(i)).intValue();
		result = setScriptVar(target, path, tempVal);
	}
	else if ( sample instanceof Boolean )
	{
		int count = val.size();
		boolean[] tempVal = new boolean[count];
		for ( int i = 0; i < count; ++i )
			tempVal[i] = ((Boolean)val.get(i)).booleanValue();
		result = setScriptVar(target, path, tempVal);
	}
	else if ( sample instanceof Float )
	{
		int count = val.size();
		float[] tempVal = new float[count];
		for ( int i = 0; i < count; ++i )
			tempVal[i] = ((Float)val.get(i)).intValue();
		result = setScriptVar(target, path, tempVal);
	}
	else if ( sample instanceof string )
	{
		string[] tempVal = new string[val.size()];
		tempVal = (string[])val.toArray(tempVal);
		result = setScriptVar(target, path, tempVal);
	}
	else if ( sample instanceof obj_id )
	{
		obj_id[] tempVal = new obj_id[val.size()];
		tempVal = (obj_id[])val.toArray(tempVal);
		result = setScriptVar(target, path, tempVal);
	}
	else if ( sample instanceof location )
	{
		location[] tempVal = new location[val.size()];
		tempVal = (location[])val.toArray(tempVal);
		result = setScriptVar(target, path, tempVal);
	}
	else if ( sample instanceof transform )
	{
		transform[] tempVal = new transform[val.size()];
		tempVal = (transform[])val.toArray(tempVal);
		result = setScriptVar(target, path, tempVal);
	}
	else if ( sample instanceof vector)
	{
		vector[] tempVal = new vector[val.size()];
		tempVal = (vector[])val.toArray(tempVal);
		result = setScriptVar(target, path, tempVal);
	}

	return result;
}

boolean setScriptVar(obj_id target, string path, dictionary val)
{
	if ( !isIdValid(target) )
		return false;
	if ( (path == null) || (path.equals("")) )
		return false;

	deltadictionary dd = target.getScriptVars();
	dd.put(path, val);
	return true;
}

/*****************************************************************
 * @brief	checks whether a scriptvar exists on the target
 *
 * @param	obj_id	target
 * @param	string	path
 *
 * @return 	boolean; false on error
 *****************************************************************/
boolean hasScriptVar(obj_id target, string path)
{
	return target.hasScriptVar( path );
}

/*****************************************************************
 * @brief	checks whether a scriptvar tree exists on the target
 *
 * @param	obj_id	target
 * @param	string	path
 *
 * @return 	boolean; false on error
 *****************************************************************/
boolean hasScriptVarTree(obj_id target, string path)
{
	if ( (target == null) || (target == obj_id.NULL_ID) )
	{
		return false;
	}

	if ( (path == null) || (path.equals("")) )
	{
		return false;
	}

	deltadictionary dd = target.getScriptVars();
	Enumeration keys = dd.keys();
	while ( keys.hasMoreElements() )
	{
		string key = (string)(keys.nextElement());
		if ( key.equals(path) || key.startsWith(path + ".") )
			return true;
	}

	return false;
}

/*****************************************************************
 * @brief	removes a scriptvar from a player
 *
 * @param	obj_id	target
 * @param	string	path
 *
 * @return 	boolean; false on error
 *****************************************************************/
boolean removeScriptVar(obj_id target, string path)
{
	if ( (target == null) || (target == obj_id.NULL_ID) )
	{
		return false;
	}

	if ( (path == null) || (path.equals("")) )
	{
		return false;
	}

	deltadictionary dd = target.getScriptVars();
	dd.remove(path);

	return true;
}

/*****************************************************************
 * @brief	removes a scriptvar from a player
 *
 * @param	obj_id	target
 * @param	string	path
 *
 * @return 	boolean; false on error
 *****************************************************************/
boolean removeScriptVarTree(obj_id target, string path)
{
	if ( (target == null) || (target == obj_id.NULL_ID) )
	{
		return false;
	}

	if ( (path == null) || (path.equals("")) )
	{
		return false;
	}

	deltadictionary dd = target.getScriptVars();
	Enumeration keys = dd.keys();
	while ( keys.hasMoreElements() )
	{
		string key = (string)(keys.nextElement());
		if ( key.equals(path) || key.startsWith(path + ".") )
			dd.remove(key);
	}

	return true;
}

/*****************************************************************
 * @brief	gets a scriptvar from a player
 *
 * @param	obj_id	target
 * @param	string	path
 *
 * @return 	boolean; false on error
 *****************************************************************/
int getIntScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getInt(path);
}

int[] getIntArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getIntArray(path);
}

float getFloatScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getFloat(path);
}

float[] getFloatArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getFloatArray(path);
}

long getLongScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getLong(path);
}

long[] getLongArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getLongArray(path);
}

double getDoubleScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getDouble(path);
}

double[] getDoubleArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getDoubleArray(path);
}

string getStringScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getString(path);
}

string[] getStringArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getStringArray(path);
}

string[][] getStringArrayArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getStringArrayArray(path);
}

transform[] getTransformArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getTransformArray(path);
}

transform getTransformScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getTransform(path);
}
boolean getBooleanScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getBoolean(path);
}

boolean[] getBooleanArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getBooleanArray(path);
}

location getLocationScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getLocation(path);
}

location[] getLocationArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getLocationArray(path);
}

obj_id getObjIdScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getObjId(path);
}

obj_id[] getObjIdArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getObjIdArray(path);
}

Vector getResizeableObjIdArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getResizeableObjIdArray(path);
}

Vector getResizeableLocationArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getResizeableLocationArray(path);
}

Vector getResizeableIntArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getResizeableIntArray(path);
}

Vector getResizeableFloatArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getResizeableFloatArray(path);
}

Vector getResizeableStringArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getResizeableStringArray(path);
}

Vector getResizeableTransformArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getResizeableTransformArray(path);
}

Vector getResizeableVectorArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getResizeableVectorArray(path);
}

string_id getStringIdScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getStringId(path);
}

string_id[] getStringIdArrayScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getStringIdArray(path);
}

dictionary getDictionaryScriptVar(obj_id target, string path)
{
	deltadictionary dd = target.getScriptVars();
	return dd.getDictionary(path);
}

/*****************************************************************
 * @brief	empties a container of all objects
 *
 * @param	obj_id	target
 *
 * @return 	boolean; false on error
 *****************************************************************/
boolean emptyContainer(obj_id target)
{
	if ( (target == null) || (target == obj_id.NULL_ID) )
	{
		return false;
	}

	obj_id[] contents = getContents(target);
	if ( (contents == null) || (contents.length == 0) )
	{
		return false;
	}

	for ( int i = 0; i < contents.length; i++ )
	{
		destroyObject(contents[i]);
	}

	return true;
}

boolean emptyContainerExceptStorytellerLoot(obj_id target)
{
	if ( (target == null) || (target == obj_id.NULL_ID) )
	{
		return false;
	}

	obj_id[] contents = getContents(target);
	if ( (contents == null) || (contents.length == 0) )
	{
		return false;
	}

	for ( int i = 0; i < contents.length; i++ )
	{
		obj_id contentsItem = contents[i];
		if ( !utils.hasScriptVar(contentsItem, "storytellerLoot") )
		{
			destroyObject(contentsItem);
		}
	}

	return true;
}

/*
	3 arguments, middle angle, 1/2 size of arc (left/right size), and distance out from the start location
*/
location getLocationInArc(obj_id objPlayer, float fltStartAngle, float fltArcSize, float fltDistance)
{

	location locHeading = getHeading(objPlayer);
	location locCenter = getLocation(objPlayer);

	locHeading.x  = locHeading.x * fltDistance;
	locHeading.z  = locHeading.z * fltDistance; // pushed out along the correct scale since it's 0 based

	locHeading.y = locCenter.y;
	locHeading.cell = locCenter.cell;
	locHeading.area = locCenter.area;


	float fltAngle = rand(fltStartAngle - fltArcSize, fltStartAngle + fltArcSize);
	//LOG("spawn_player", "locHEading is "+locHeading);

	location locNewHeading = rotatePointXZ(locHeading, fltAngle);

	locNewHeading.x = locCenter.x + locNewHeading.x;
	locNewHeading.z = locCenter.z + locNewHeading.z;

	return locNewHeading;

}


float getHeadingDegrees(obj_id objTarget) // gets heading in degrees.. duh
{
	location locStart = getLocation(objTarget);
	location locHeading = getHeading(objTarget);
	locHeading.x = locStart.x + locHeading.x;
	locHeading.z = locStart.z + locHeading.z;
	locHeading.y = locStart.y + locHeading.y;

	float fltAngle = thetaDegrees(locStart, locHeading);
	return fltAngle;

}

float thetaDegrees (location direction)
{
	return (float) Math.toDegrees (Math.atan2 (direction.x, direction.z));
}

float thetaDegrees (location start, location end)
{
	location direction = new location ();
	direction.x = end.x - start.x;
	direction.y = end.y - start.y;
	direction.z = end.z - start.z;

	return thetaDegrees (direction);
}

int countSubStringObjVars(obj_id[] objObjects, string strObjVar, string strSubString)
{ // this looks for all of our objects it checks a speciufic objvar vfor a specific substring and returns the count
	if(objObjects==null)
	{

		return 0; // NONE!
	}
	int intCount = 0;
	for(int intI = 0; intI<objObjects.length; intI++)
	{
		string strString = getStringObjVar(objObjects[intI], strObjVar);
		if(strString!=null)
		{
			int intIndex = strString.indexOf(strSubString);
			if(intIndex>-1)
			{
				intCount = intCount +1; // we found one
			}
		}
	}
	return intCount;
}

dictionary addObjVarToDictionary(obj_var ov, dictionary d, string basePath)
{
	if ( ov == null || d == null )
	{
		return d;
	}

	if ( basePath == null )
	{
		basePath = "";
	}

	Object dta = ov.getData();
	if ( dta == null )
	{
		return d;
	}

	string name = ov.getName();
	string path = basePath + name;

	if ( dta instanceof int )
	{
		int iVal = ov.getIntData();
		int iCur = d.getInt(path);

		iVal += iCur;

		d.put(path, iVal);
	}
	else if ( dta instanceof float )
	{
		float fVal = ov.getFloatData();
		float fCur = d.getFloat(path);

		fVal += fCur;

		d.put(path, fVal);
	}
	else if ( dta instanceof int[] )
	{
		int[] iaVal = ov.getIntArrayData();
		int[] iaCur = d.getIntArray(path);
		if ( (iaCur == null) || (iaCur.length == 0) )
		{
			d.put(path, iaVal);
		}
		else
		{
			if ( iaVal.length == iaCur.length )
			{
				for ( int z = 0; z < iaVal.length; z++ )
				{
					iaVal[z] += iaCur[z];
				}

				d.put(path, iaVal);
			}
		}
	}
	else if ( dta instanceof float[] )
	{
		float[] faVal = ov.getFloatArrayData();
		float[] faCur = d.getFloatArray(path);
		if ( (faCur == null) || (faCur.length == 0) )
		{
			d.put(path, faVal);
		}
		else
		{
			if ( faVal.length == faCur.length )
			{
				for ( int z = 0; z < faVal.length; z++ )
				{
					faVal[z] += faCur[z];
				}

				d.put(path, faVal);
			}
		}
	}

	return d;
}

dictionary addObjVarToDictionary(obj_var ov, dictionary d)
{
	return addObjVarToDictionary(ov, d, null);
}

dictionary addObjVarListToDictionary(obj_var_list ovl, dictionary d, string basePath)
{
	if ( ovl == null || d == null )
	{
		return d;
	}

	if ( basePath == null )
	{
		basePath = "";
	}

	string name = ovl.getName();
	string path = basePath + name;

	boolean litmus = true;

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		obj_var ov = ovl.getObjVar(i);
		if ( ov != null )
		{
			if ( ov instanceof obj_var_list )
			{
				d = addObjVarListToDictionary((obj_var_list)(ov), d, path + ".");
			}
			else
			{
				d = addObjVarToDictionary(ov, d, path + ".");
			}
		}
	}

	return d;
}

dictionary addObjVarListToDictionary(obj_var_list ovl, dictionary d)
{
	return addObjVarListToDictionary(ovl, d, null);
}

obj_id cloneObject(obj_id template, obj_id container)
{
	string templateName = getTemplateName(template);
	obj_id clone = createObject(templateName, container, "");
	if(!isIdValid(clone))
	{
		return null;
	}

	copyObjectData(template, clone);
	return clone;
}

obj_id cloneObject(obj_id template, location loc)
{
	string templateName = getTemplateName(template);
	obj_id clone = createObject(templateName, loc);
	if(!isIdValid(clone))
	{
		return null;
	}

	copyObjectData(template, clone);
	return clone;
}

void copyObjectData(obj_id template, obj_id clone)
{
	/* this block of code seems to cause an exception
	string[] scripts = getScriptList(template);
	for(int i = 0; i < scripts.length; i++)
	{
		if(!hasScript(clone, scripts[i]))
		{
			attachScript(clone, scripts[i]);
		}
	}
	*/

	obj_var_list ovl = getObjVarList(clone, "");

	if(ovl == null)
	{
		return;
	}

	int numItems = ovl.getNumItems();
	for(int x = 0; x < numItems; x++)
	{
		obj_var ov = ovl.getObjVar(x);
		if(ov != null)
		{
			copyObjVar(template, clone, ov.getName());
		}
	}
}



boolean copyObjVar(obj_id target, string basePath, obj_var ov)
{
	if ( !isIdValid(target) )
	{
		return false;
	}

	if ( basePath == null )
	{
		basePath = "";
	}

	if ( ov == null )
	{
		return false;
	}

	string name = ov.getName();
	string path = basePath + name;

	Object dta = ov.getData();
	if ( dta instanceof int )
	{
		int val = ov.getIntData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof int[] )
	{
		int[] val = ov.getIntArrayData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof float )
	{
		float val = ov.getFloatData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof float[] )
	{
		float[] val = ov.getFloatArrayData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof Boolean )
	{
		boolean val = ov.getBooleanData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof Boolean[] )
	{
		boolean[] val = ov.getBooleanArrayData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof string )
	{
		string val = ov.getStringData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof string[] )
	{
		string[] val = ov.getStringArrayData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof obj_id )
	{
		obj_id val = ov.getObjIdData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof obj_id[] )
	{
		obj_id[] val = ov.getObjIdArrayData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof location )
	{
		location val = ov.getLocationData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof location[] )
	{
		location[] val = ov.getLocationArrayData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof string_id )
	{
		string_id val = ov.getStringIdData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof string_id[] )
	{
		string_id[] val = ov.getStringIdArrayData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof attrib_mod )
	{
		attrib_mod val = ov.getAttribModData();
		return setObjVar(target, path, val);
	}
	else if ( dta instanceof attrib_mod[] )
	{
		attrib_mod[] val = ov.getAttribModArrayData();
		return setObjVar(target, path, val);
	}

	return false;
}

boolean[] removeObjVarList(obj_id object, string[] objVarList)
{
	boolean[] result = new boolean[objVarList.length];

	for (int i=0;i<objVarList.length;i++)
	{
		if (!hasObjVar(object, objVarList[i]))
		{
			result[i] = false;
		}
		else
		{
			removeObjVar(object, objVarList[i]);
			result[i] = true;
		}
	}

	if (result == null || result.length == 0)
		result[0] = false;

	return result;
}

/**
 * Saves the data in a dictionary as objvars on an object.
 * !!! ONLY SUPPORTS INT, FLOAT, AND SUB-DICTIONARY DATA !!!
 *
 * @param object		the object to write the objvars to
 * @param rootName		the objvar root name for the dictionary; null or empty string will place the dictionary data at the root level
 * @param dict			the dictionary data to write
 *
 * @return true on success, false if there was an error
 */
boolean saveDictionaryAsObjVar(obj_id object, string rootName, dictionary dict)
{
	if ( !isIdValid(object) || dict == null )
		return false;

	// make sure the root name is valid
	if ( rootName == null )
		rootName = "";
	else if ( rootName != null && rootName.length() > 0 )
	{
		if ( !Character.isLetterOrDigit(rootName.charAt(0)) )
			return false;
		if ( rootName.charAt(rootName.length() - 1) != '.' )
			rootName = rootName + ".";
	}

	Enumeration keys = dict.keys();
	while ( keys.hasMoreElements() )
	{
		string key = null;
		try
		{
			key = (string)keys.nextElement();
		}
		catch ( ClassCastException err )
		{
			return false;
		}
		Object data = dict.get(key);
		if ( data instanceof Integer )
		{
			//debugServerConsoleMsg(null, "\tsaveDictionaryAsObjVar -> "+rootName+key+" (Integer) = "+ data.toString());
			setObjVar(object, rootName + key, ((Integer)data).intValue());
		}
		else if ( data instanceof Float )
		{
			//debugServerConsoleMsg(null, "\tsaveDictionaryAsObjVar -> "+rootName+key+" (Float) = "+ data.toString());
			setObjVar(object, rootName + key, ((Float)data).floatValue());
		}
		else if ( data instanceof string )
		{
			//debugServerConsoleMsg(null, "\tsaveDictionaryAsObjVar -> "+rootName+key+" (string) = "+ data.toString());
			setObjVar(object, rootName + key, (string)data);
		}
		else if ( data instanceof int[] )
		{
			//debugServerConsoleMsg(null, "\tsaveDictionaryAsObjVar -> "+rootName+key+" (int[]) = "+ data.toString());
			setObjVar(object, rootName + key, (int[])data);
		}
		else if ( data instanceof float[] )
		{
			//debugServerConsoleMsg(null, "\tsaveDictionaryAsObjVar -> "+rootName+key+" (float[]) = "+ data.toString());
			setObjVar(object, rootName + key, (float[])data);
		}
		else if ( data instanceof dictionary )
		{
			//debugServerConsoleMsg(null, "\tsaveDictionaryAsObjVar -> "+rootName+key+" (dictionary) = "+ data.toString());
			saveDictionaryAsObjVar(object, rootName + key, (dictionary)data);
		}
		else
		{
			//debugServerConsoleMsg(null, "\tsaveDictionaryAsObjVar -> "+rootName+key+" (unknown) = "+ data.getClass().getName());
			//return false;
		}
	}
	return true;
}

string getFactionSubString(string strSearchString) // THIS FINDS THE SUBSTRING IN A BASE STRING AND RETURNS THE CORRECT FACTION
{
	if(strSearchString==null)
	{
		return null;
	}
	string strTestString = toLower(strSearchString);
	const string[] FACTION_SEARCH_STRINGS = {factions.FACTION_IMPERIAL, factions.FACTION_REBEL};
	for(int intI = 0; intI<FACTION_SEARCH_STRINGS.length; intI++)
	{

		int intIndex = strTestString.indexOf(toLower(FACTION_SEARCH_STRINGS[intI]));
		if(intIndex>-1)
		{
			return FACTION_SEARCH_STRINGS[intI];
		}


	}
	return null;
}

boolean setBatchObjVar(obj_id target, string base_path, Object[] array)
{
	if ( !isIdValid(target) )
	{
		return false;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return false;
	}

	if ( (array == null) || (array.length == 0) )
	{
		return false;
	}

	if ( hasObjVar(target, base_path) )
		removeObjVar(target, base_path);

	int BatchSize = 10;

	boolean litmus = true;
	int n = 0;
	Vector toSet = new Vector();
	for ( int i = 0; i < array.length; i++ )
	{
		toSet.add(array[i]);
		if ( toSet.size() >= BatchSize )
		{
			litmus &= setObjectArrayObjVar(target, base_path + "." + n, toSet);
			toSet.clear();
			n++;
		}
	}

	litmus &= setObjectArrayObjVar(target, base_path + "." + n, toSet);

	return litmus;
}

void removeBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return;
	}

	if (hasObjVar(target, base_path))
		removeObjVar(target, base_path);

	obj_var_list list = getObjVarList(target, null);

	if (list == null)
		return;

	int listLength = list.getNumItems();
	int intQ = 0;

	for (int i=0;i<listLength;i++)
	{
		if (hasObjVar(target, base_path+"."+intQ))
		{
			removeObjVar(target, base_path+"."+intQ);
			intQ++;
		}

	}

}

boolean setBatchObjVar(obj_id target, string base_path, int[] array)
{
	if ( !isIdValid(target) )
	{
		return false;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return false;
	}

	if ( (array == null) || (array.length == 0) )
	{
		return false;
	}

	if ( hasObjVar(target, base_path) )
		removeObjVar(target, base_path);

	int BatchSize = 10;

	boolean litmus = true;
	int n = 0;
	Vector toSet = new Vector();
	for ( int i = 0; i < array.length; i++ )
	{
		toSet.add(new Integer(array[i]));
		if ( toSet.size() >= BatchSize )
		{
			litmus &= setObjectArrayObjVar(target, base_path + "." + n, toSet);
			toSet.clear();
			n++;
		}
	}

	litmus &= setObjectArrayObjVar(target, base_path + "." + n, toSet);

	return litmus;
}

boolean setResizeableBatchObjVar(obj_id target, string base_path, Vector vector)
{
	if ( !isIdValid(target) )
	{
		return false;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		//debugSpeakMsg(target, "setResizeableBatchObjVar: invalid base path!");
		return false;
	}

	if ( (vector == null) || (vector.size() == 0) )
	{
		//debugSpeakMsg(target, "setResizeableBatchObjVar: invalid vector!");
		return false;
	}

	if ( hasObjVar(target, base_path) )
		removeObjVar(target, base_path);

	int BatchSize = 10;

	boolean litmus = true;
	int n = 0;
	Vector toSet = new Vector();
	for ( int i = 0; i < vector.size(); i++ )
	{
		toSet.add(vector.get(i));
		if ( toSet.size() >= BatchSize )
		{
			litmus &= setObjectArrayObjVar(target, base_path + "." + n, toSet);
			toSet.clear();
			n++;
		}
	}

	//debugSpeakMsg(target, "attempting to set final objvar: n = " + n + " toSet.size = " + toSet.size());
	litmus &= setObjectArrayObjVar(target, base_path + "." + n, toSet);

	return litmus;
}

boolean setObjectArrayObjVar(obj_id target, string path, Vector vec)
{
	if ( !isIdValid(target) )
	{
		return false;
	}

	if ( (path == null) || (path.equals("")) )
	{
		return false;
	}

	if ( (vec == null) || (vec.size() == 0) )
	{
		return false;
	}

	int size = vec.size();

	Object test = vec.elementAt(0);

	if ( test instanceof string )
	{
		string[] tmp = new string[size];
		vec.toArray(tmp);
		return setObjVar(target, path, tmp);
	}
	else if ( test instanceof string_id )
	{
		string_id[] tmp = new string_id[size];
		vec.toArray(tmp);
		return setObjVar(target, path, tmp);
	}
	else if ( test instanceof obj_id )
	{
		obj_id[] tmp = new obj_id[size];
		vec.toArray(tmp);
		return setObjVar(target, path, tmp);
	}
	else if ( test instanceof attrib_mod )
	{
		attrib_mod[] tmp = new attrib_mod[size];
		vec.toArray(tmp);
		return setObjVar(target, path, tmp);
	}
	else if ( test instanceof location )
	{
		location[] tmp = new location[size];
		vec.toArray(tmp);
		return setObjVar(target, path, tmp);
	}
	else if ( test instanceof int )
	{
		int[] tmp = new int[size];
		for ( int i = 0; i < vec.size(); i ++ )
			tmp[i] = ((Integer)(vec.get(i))).intValue();
		return setObjVar(target, path, tmp);
	}

	return false;
}

string[] getStringBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return null;
	}

	resizeable string[] ret = new string[0];
	obj_var_list ovl = getObjVarList(target, base_path);
	if ( (ovl == null) || (ovl.getNumItems() == 0) )
	{
		return null;
	}

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		string[] tmp = getStringArrayObjVar(target, base_path + "." + i);
		if ( (tmp != null) && (tmp.length > 0) )
		{
			ret = concatArrays(ret, tmp);
		}
	}

	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

Vector getResizeableStringBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return null;
	}

	resizeable string[] ret = new string[0];
	obj_var_list ovl = getObjVarList(target, base_path);
	if ( (ovl == null) || (ovl.getNumItems() == 0) )
	{
		return null;
	}

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		string[] tmp = getStringArrayObjVar(target, base_path + "." + i);
		if ( (tmp != null) && (tmp.length > 0) )
		{
			ret = concatArrays(ret, tmp);
		}
	}

	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

string_id[] getStringIdBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return null;
	}

	resizeable string_id[] ret = new string_id[0];
	obj_var_list ovl = getObjVarList(target, base_path);
	if ( (ovl == null) || (ovl.getNumItems() == 0) )
	{
		return null;
	}

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		string_id[] tmp = getStringIdArrayObjVar(target, base_path + "." + i);
		if ( (tmp != null) && (tmp.length > 0) )
		{
			ret = concatArrays(ret, tmp);
		}
	}

	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

obj_id[] getObjIdBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return null;
	}

	resizeable obj_id[] ret = new obj_id[0];
	obj_var_list ovl = getObjVarList(target, base_path);
	if ( (ovl == null) || (ovl.getNumItems() == 0) )
	{
		return null;
	}

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		obj_id[] tmp = getObjIdArrayObjVar(target, base_path + "." + i);
		if ( (tmp != null) && (tmp.length > 0) )
		{
			ret = concatArrays(ret, tmp);
		}
	}

	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

Vector getResizeableObjIdBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return null;
	}

	resizeable obj_id[] ret = new obj_id[0];
	obj_var_list ovl = getObjVarList(target, base_path);
	if ( (ovl == null) || (ovl.getNumItems() == 0) )
	{
		return null;
	}

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		obj_id[] tmp = getObjIdArrayObjVar(target, base_path + "." + i);
		if ( (tmp != null) && (tmp.length > 0) )
		{
			ret = concatArrays(ret, tmp);
		}
	}

	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

int[] getIntBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return null;
	}

	resizeable int[] ret = new int[0];
	obj_var_list ovl = getObjVarList(target, base_path);
	if ( (ovl == null) || (ovl.getNumItems() == 0) )
	{
		return null;
	}

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		int[] tmp = getIntArrayObjVar(target, base_path + "." + i);
		if ( (tmp != null) && (tmp.length > 0) )
		{
			ret = concatArrays(ret, tmp);
		}
	}

	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

Vector getResizeableIntBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return null;
	}

	resizeable int[] ret = new int[0];
	obj_var_list ovl = getObjVarList(target, base_path);
	if ( (ovl == null) || (ovl.getNumItems() == 0) )
	{
		return null;
	}

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		int[] tmp = getIntArrayObjVar(target, base_path + "." + i);
		if ( (tmp != null) && (tmp.length > 0) )
		{
			ret = concatArrays(ret, tmp);
		}
	}

	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

attrib_mod[] getAttribModBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return null;
	}

	obj_var_list ovl = getObjVarList(target, base_path);
	if ( (ovl == null) || (ovl.getNumItems() == 0) )
	{
		return null;
	}

	resizeable attrib_mod[] ret = new attrib_mod[0];
	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		attrib_mod[] tmp = getAttribModArrayObjVar(target, base_path + "." + i);
		if ( (tmp != null) && (tmp.length > 0) )
		{
			ret = concatArrays(ret, tmp);
		}
	}

	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

location[] getLocationBatchObjVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasObjVar(target, base_path) )
	{
		return null;
	}

	resizeable location[] ret = new location[0];
	obj_var_list ovl = getObjVarList(target, base_path);
	if ( (ovl == null) || (ovl.getNumItems() == 0) )
	{
		return null;
	}

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		location[] tmp = getLocationArrayObjVar(target, base_path + "." + i);
		if ( (tmp != null) && (tmp.length > 0) )
		{
			ret = concatArrays(ret, tmp);
		}
	}

	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

boolean hasStringBatchObjVar(obj_id target, string base_path)
{
	return getStringBatchObjVar(target, base_path) != null;
}

boolean hasResizeableStringBatchObjVar(obj_id target, string base_path)
{
	return getResizeableStringBatchObjVar(target, base_path) != null;
}

boolean hasStringIdBatchObjVar(obj_id target, string base_path)
{
	return getStringIdBatchObjVar(target, base_path) != null;
}

boolean hasObjIdBatchObjVar(obj_id target, string base_path)
{
	return getObjIdBatchObjVar(target, base_path) != null;
}

boolean hasResizeableObjIdBatchObjVar(obj_id target, string base_path)
{
	return getResizeableObjIdBatchObjVar(target, base_path) != null;
}

boolean hasIntBatchObjVar(obj_id target, string base_path)
{
	return getIntBatchObjVar(target, base_path) != null;
}

boolean hasResizeableIntBatchObjVar(obj_id target, string base_path)
{
	return getResizeableIntBatchObjVar(target, base_path) != null;
}

boolean hasAttribModBatchObjVar(obj_id target, string base_path)
{
	return getAttribModBatchObjVar(target, base_path) != null;
}

boolean hasLocationBatchObjVar(obj_id target, string base_path)
{
	return getLocationBatchObjVar(target, base_path) != null;
}


boolean setBatchScriptVar(obj_id target, string base_path, Vector array)
{
	if ( !isIdValid(target) )
	{
		return false;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return false;
	}

	if ( (array == null) || (array.size() == 0) )
	{
		return false;
	}

	deltadictionary dd = target.getScriptVars();

	int BatchSize = 10;

	int n = 0;
	Vector toSet = new Vector();
	for ( int i = 0; i < array.size(); i++ )
	{
		toSet.add(array.elementAt(i));
		if ( toSet.size() >= BatchSize )
		{
			dd.put(base_path + "." + n, toSet);
			toSet.clear();
			n++;
		}
	}

	if ( toSet.size() > 0 )
	{
		dd.put(base_path + "." + n, toSet);
		n++;
	}

	dd.put(base_path, n);
	return true;
}

boolean setBatchScriptVar(obj_id target, string base_path, obj_id[] array)
{
	if ( (array == null) || (array.length == 0) )
		return false;

	Vector vArray = new Vector(Arrays.asList(array));
	return setBatchScriptVar(target, base_path, vArray);
}

boolean setBatchScriptVar(obj_id target, string base_path, string[] array)
{
	if ( (array == null) || (array.length == 0) )
		return false;

	Vector vArray = new Vector(Arrays.asList(array));
	return setBatchScriptVar(target, base_path, vArray);
}

boolean setBatchScriptVar(obj_id target, string base_path, string_id[] array)
{
	if ( (array == null) || (array.length == 0) )
		return false;

	Vector vArray = new Vector(Arrays.asList(array));
	return setBatchScriptVar(target, base_path, vArray);
}

boolean setBatchScriptVar(obj_id target, string base_path, location[] array)
{
	if ( (array == null) || (array.length == 0) )
		return false;

	Vector vArray = new Vector(Arrays.asList(array));
	return setBatchScriptVar(target, base_path, vArray);
}

Vector getResizeableObjIdBatchScriptVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasScriptVar(target, base_path) )
	{
		return null;
	}

	int cnt = getIntScriptVar(target, base_path);
	deltadictionary dd = target.getScriptVars();

	Vector ret = new Vector();
	for ( int i = 0; i < cnt; i++ )
	{
		Vector tmp = dd.getResizeableObjIdArray(base_path + "." + i);
		if ( (tmp != null) && (tmp.size() > 0) )
		{
			ret.addAll(tmp);
		}
	}

	if ( (ret != null) && (ret.size() > 0) )
	{
		return ret;
	}

	return null;
}

obj_id[] getObjIdBatchScriptVar(obj_id target, string base_path)
{
	Vector ret = getResizeableObjIdBatchScriptVar(target, base_path);
	if ( (ret != null) && (ret.size() > 0) )
	{
		return toStaticObjIdArray(ret);
	}

	return null;
}

Vector getResizeableStringBatchScriptVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasScriptVar(target, base_path) )
	{
		return null;
	}

	int cnt = getIntScriptVar(target, base_path);
	deltadictionary dd = target.getScriptVars();

	Vector ret = new Vector();
	for ( int i = 0; i < cnt; i++ )
	{
		Vector tmp = dd.getResizeableStringArray(base_path + "." + i);
		if ( (tmp != null) && (tmp.size() > 0) )
		{
			ret.addAll(tmp);
		}
	}

	if ( (ret != null) && (ret.size() > 0) )
	{
		return ret;
	}

	return null;
}

string[] getStringBatchScriptVar(obj_id target, string base_path)
{
	Vector ret = getResizeableStringBatchScriptVar(target, base_path);
	if ( (ret != null) && (ret.size() > 0) )
	{
		return toStaticStringArray(ret);
	}

	return null;
}

Vector getResizeableLocationBatchScriptVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasScriptVar(target, base_path) )
	{
		return null;
	}

	int cnt = getIntScriptVar(target, base_path);
	deltadictionary dd = target.getScriptVars();

	Vector ret = new Vector();
	for ( int i = 0; i < cnt; i++ )
	{
		Vector tmp = dd.getResizeableLocationArray(base_path + "." + i);
		if ( (tmp != null) && (tmp.size() > 0) )
		{
			ret.addAll(tmp);
		}
	}

	if ( (ret != null) && (ret.size() > 0) )
	{
		return ret;
	}

	return null;
}

Vector getResizeableIntBatchScriptVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return null;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return null;
	}

	if ( !hasScriptVar(target, base_path) )
	{
		return null;
	}

	int cnt = getIntScriptVar(target, base_path);
	deltadictionary dd = target.getScriptVars();

	Vector ret = new Vector();
	for ( int i = 0; i < cnt; i++ )
	{
		Vector tmp = dd.getResizeableIntArray(base_path + "." + i);
		if ( (tmp != null) && (tmp.size() > 0) )
		{
			ret.addAll(tmp);
		}
	}

	if ( (ret != null) && (ret.size() > 0) )
	{
		return ret;
	}

	return null;
}

location[] getLocationBatchScriptVar(obj_id target, string base_path)
{
	Vector ret = getResizeableLocationBatchScriptVar(target, base_path);
	if ( (ret != null) && (ret.size() > 0) )
	{
		return toStaticLocationArray(ret);
	}

	return null;
}

int[] getIntBatchScriptVar(obj_id target, string base_path)
{
	resizeable int[] ret = getResizeableIntBatchScriptVar(target, base_path);
	if ( (ret != null) && (ret.length > 0) )
	{
		return ret;
	}

	return null;
}

void removeBatchScriptVar(obj_id target, string base_path)
{
	if ( !isIdValid(target) )
	{
		return;
	}

	if ( (base_path == null) || (base_path.equals("")) )
	{
		return;
	}

	if ( !hasScriptVar(target, base_path) )
	{
		return;
	}

	int cnt = getIntScriptVar(target, base_path);
	deltadictionary dd = target.getScriptVars();
	dd.remove(base_path);

	for ( int i = 0; i < cnt; i++ )
	{
		dd.remove(base_path + "." + i);
	}
}

boolean hasResizeableObjIdBatchScriptVar(obj_id target, string base_path)
{
	return getResizeableObjIdBatchScriptVar(target, base_path) != null;
}

boolean hasObjIdBatchScriptVar(obj_id target, string base_path)
{
	return getObjIdBatchScriptVar(target, base_path) != null;
}

boolean hasResizeableStringBatchScriptVar(obj_id target, string base_path)
{
	return getResizeableStringBatchScriptVar(target, base_path) != null;
}

boolean hasStringBatchScriptVar(obj_id target, string base_path)
{
	return getStringBatchScriptVar(target, base_path) != null;
}

boolean hasResizeableLocationBatchScriptVar(obj_id target, string base_path)
{
	return getResizeableLocationBatchScriptVar(target, base_path) != null;
}

boolean hasResizeableIntBatchScriptVar(obj_id target, string base_path)
{
	return getResizeableIntBatchScriptVar(target, base_path) != null;
}

boolean hasLocationBatchScriptVar(obj_id target, string base_path)
{
	return getLocationBatchScriptVar(target, base_path) != null;
}

boolean hasIntBatchScriptVar(obj_id target, string base_path)
{
	return getIntBatchScriptVar(target, base_path) != null;
}

int getIntConfigSetting(String section, String key)
{
	String setting = getConfigSetting(section, key);
	if ( setting == null || setting.length() == 0 )
		return 0;

	try
	{
		return Integer.parseInt(setting);
	}
	catch ( NumberFormatException err)
	{
	}
	return 0;
}

float getFloatConfigSetting(String section, String key)
{
	String setting = getConfigSetting(section, key);
	if ( setting == null || setting.length() == 0 )
		return 0;

	try
	{
		return Float.parseFloat(setting);
	}
	catch ( NumberFormatException err)
	{
	}
	return 0;
}

boolean checkConfigFlag(string strSection, string strConfigSetting)
{
	// looks for true/false
	string strTest = getConfigSetting(strSection, strConfigSetting);
	if(strTest!=null)
	{
		strTest = toLower(strTest);
		if(strTest=="true")
		{
			return true;

		}
		if(strTest=="1")
		{
			return true;

		}
		return false;

	}
	else
	{
		return false;
	}

}
boolean checkServerSpawnLimits()
{
	const int intServerSpawnLimit = getServerSpawnLimit();
	const int intNumCreatures = utils.getNumCreaturesForSpawnLimit();
	const int intNumPlayers = getNumPlayers();
	if(intNumPlayers>0)
	{

		if(intServerSpawnLimit>0)
		{

			if(intNumCreatures>intServerSpawnLimit)
			{
				return false;

			}
		}
		else
		{
			if(intNumPlayers<200000) // JUSTIN CAHNGE THIS TO <20, AND THE NUMCREATURES TO WHAT YOU WANT.
			{
				//////LOG("spawning", "no ratio");
				if(intNumCreatures>5000)
				{
					return false;

				}

			}
			else
			{
				float fltRatio = (float)(intNumCreatures/intNumPlayers);

				//////LOG("spawning", "fltRatio is "+fltRatio);
				if(fltRatio>10) // RAIO
				{
					return false;

				}
			}
		}
	}
	return true;
}

string formatTimeVerbose(int seconds)
{
	if ( seconds < 1 )
	{
		return "";
	}

	int[] convert_time = player_structure.convertSecondsTime(seconds);

	int idx = 0;
	for ( int i = 0; i < convert_time.length; i++ )
	{
		if ( convert_time[i] > 0 )
		{
			idx = i;
			break;
		}
	}

	if ( idx == convert_time.length - 1)
	{
		idx--;
	}

	string time_str = "";
	string[] verboseIndex =
			{
				" days ",
				" hours ",
				" minutes ",
				" seconds "
			};

	for ( int n = idx; n < convert_time.length; n++ )
	{

		time_str += convert_time[n]+verboseIndex[n];

		if ( n < convert_time.length - 1 )
		{
			time_str += ", ";
		}
	}

	if ( time_str != null && !time_str.equals("") )
	{
		return time_str;
	}

	return "";
}

string formatTimeVerboseNoSpaces(int seconds)
{
	if ( seconds < 1 )
	{
		return "";
	}

	int[] convert_time = player_structure.convertSecondsTime(seconds);

	int idx = 0;
	for ( int i = 0; i < convert_time.length; i++ )
	{
		if ( convert_time[i] > 0 )
		{
			idx = i;
			break;
		}
	}

	if ( idx == convert_time.length - 1)
	{
		idx--;
	}

	string time_str = "";
	string[] verboseIndex =
			{
				" days",
				" hours",
				" minutes",
				" seconds"
			};

	for ( int n = idx; n < convert_time.length; n++ )
	{

		time_str += convert_time[n]+verboseIndex[n];

		if ( n < convert_time.length - 1 )
		{
			time_str += ", ";
		}
	}

	if ( time_str != null && !time_str.equals("") )
	{
		return time_str;
	}

	return "";
}

string formatTime(int seconds)
{
	if ( seconds < 1 )
	{
		return "";
	}

	int[] convert_time = player_structure.convertSecondsTime(seconds);
	//string time_str = player_structure.assembleTimeRemaining(convert_time);

	//find first non-zero index
	int idx = 0;
	for ( int i = 0; i < convert_time.length; i++ )
	{
		if ( convert_time[i] > 0 )
		{
			idx = i;
			break;
		}
	}

	if ( idx == convert_time.length - 1)
	{
		idx--;
	}

	string time_str = "";
	for ( int n = idx; n < convert_time.length; n++ )
	{

		time_str += convert_time[n];

		if ( n < convert_time.length - 1 )
		{
			time_str += ":";
		}
	}

	if ( time_str != null && !time_str.equals("") )
	{
		return time_str;
	}

	return "";
}

string formatTime(float fTime)
{
	int iTime = (int)fTime;

	float diff = fTime - iTime;
	int decimals = (int)(diff*100);

	if ( iTime > 0 )
	{
		string sTime = formatTime(iTime);
		sTime += "." + decimals;
		return sTime;
	}
	else
	{
		return "0." + decimals;
	}
}

string padTimeDHMS(int seconds)
{
	if(seconds < 0)
	{
		return null;
	}

	int days = seconds / (3600 * 24);

	string daysText = "" + days;

	if(daysText.length() <= 4)
	{
		daysText = "0000".substring(0, 4 - daysText.length()) + daysText;
	}

	seconds = seconds % (3600 * 24);

	int hours = seconds / 3600;

	string hoursText = "" + hours;

	if(hoursText.length() <= 2)
	{
		hoursText = "00".substring(0,2 - hoursText.length()) + hoursText;
	}

	seconds = seconds % 3600;

	int minutes = seconds / 60;

	string minutesText = "" + minutes;

	if(minutesText.length() <= 2)
	{
		minutesText = "00".substring(0,2 - minutesText.length()) + minutesText;
	}

	seconds = seconds % 60;

	string secondsText = "" + seconds;

	if(secondsText.length() <= 2)
	{
		secondsText = "00".substring(0,2 - secondsText.length()) + secondsText;
	}

	return daysText + "d:" + hoursText + "h:" + minutesText + "m:" + secondsText + "s";
}

string padTimeHM(int seconds)
{
	seconds = seconds % (3600 * 24);

	int hours = seconds / 3600;

	string hoursText = "" + hours;

	if(hoursText.length() <= 2)
	{
		hoursText = "00".substring(0,2 - hoursText.length()) + hoursText;
	}

	seconds = seconds % 3600;

	int minutes = seconds / 60;

	string minutesText = "" + minutes;

	if(minutesText.length() <= 2)
	{
		minutesText = "00".substring(0,2 - minutesText.length()) + minutesText;
	}
	
	return hoursText + "h:" + minutesText + "m";
}

void sendDelayedSystemMessage(obj_id target, string_id sid, float delay)
{
	if ( !isIdValid(target) || (sid == null) || (delay < 0f) )
		return;

	dictionary msg = new dictionary();
	msg.put("sidMsg", sid);

	messageTo(target, "handleDelayedSystemMessage", msg, delay, false);
}

void sendDelayedSystemMessage(obj_id target, string sid, float delay)
{
	if ( !isIdValid(target) || (sid == null) || sid.equals("") || (delay < 0f) )
		return;

	dictionary msg = new dictionary();
	msg.put("stringMsg", sid);

	messageTo(target, "handleDelayedSystemMessage", msg, delay, false);
}

void sendDelayedProseMessage(obj_id msgTarget, string_id sid,
						obj_id actor,  string actorString,  string_id actorStringId,
						obj_id target, string targetString, string_id targetStringId,
						obj_id other,  string otherString,  string_id otherStringId,
						int di, float df,
						float delay)
{
	if ( !isIdValid(msgTarget) || (sid == null) || (delay < 0f) )
		return;

	dictionary msg = new dictionary();
	msg.put("sid", sid);

	msg.put("actor", actor);
	msg.put("actorString", actorString);
	msg.put("actorStringId", actorStringId);

	msg.put("target", target);
	msg.put("targetString", targetString);
	msg.put("targetStringId", targetStringId);

	msg.put("other", other);
	msg.put("otherString", otherString);
	msg.put("otherStringId", otherStringId);

	msg.put("di", di);
	msg.put("df", df);

	messageTo(msgTarget, "handleDelayedProseMessage", msg, delay, false);
}

Vector alphabetizeStringArray(string[] array)
{
	if ( (array == null) || (array.length == 0) )
		return null;

	Vector tmp = new Vector();
	java.text.Collator myCol = java.text.Collator.getInstance();
	for ( int i = 0; i < array.length; i++ )
	{
		boolean inserted = false;
		for ( int n = 0; n < tmp.size(); n++ )
		{
			if ( myCol.compare(array[i], tmp.elementAt(n)) < 0 )	//insert element at n
			{
				tmp.add(n, array[i]);
				inserted = true;
				break;
			}
		}

		if ( !inserted )
		{
			tmp.add(array[i]);
		}
	}

	if ( (tmp == null) || (tmp.size() == 0) )
		return null;

	return tmp;
}

Vector alphabetizeStringArray(Vector array)
{
	if ( (array == null) || (array.size() == 0) )
		return null;

	string[] toPass = toStaticStringArray(array);
	if ( (toPass == null) || (toPass.length == 0) )
		return null;

	return alphabetizeStringArray(toPass);
}

string getPlayerSpeciesName(int species)
{
	switch (species)
	{
		case SPECIES_HUMAN:
			return "human";

		case SPECIES_BOTHAN:
			return "bothan";

		case SPECIES_RODIAN:
			return "rodian";

		case SPECIES_TWILEK:
			return "twilek";

		case SPECIES_TRANDOSHAN:
			return "trandoshan";

		case SPECIES_MON_CALAMARI:
			return "moncalamari";

		case SPECIES_WOOKIEE:
			return "wookiee";

		case SPECIES_ZABRAK:
			return "zabrak";
		case SPECIES_ITHORIAN:
			return "ithorian";
		case SPECIES_SULLUSTAN:
			return "sullustan";
		default:
			return "unknown";
	}
}





void addListener(string strObjVar, obj_id objListener, obj_id objTarget)
{

	if(strObjVar==null)
	{
		LOG("DESIGNER_FATAL", "Null objVar paseed into addListener");
		return;

	}
	if(!isIdValid(objTarget))
	{
		LOG("DESIGNER_FATAL", "Null owner paseed into addListener");
		return;
	}
	if(!isIdValid(objListener))
	{

		LOG("DESIGNER_FATAL", "Null listener paseed into addListener");
	}


	dictionary dctParams = new dictionary();
	dctParams.put("objListener", objListener);
	dctParams.put("strObjVar", strObjVar);
	messageTo(objTarget, "addListener", dctParams, 0, true);
	return;


}


void removeListener(string strObjVar, obj_id objListener, obj_id objTarget)
{
	if(strObjVar==null)
	{
		LOG("DESIGNER_FATAL", "Null objVar paseed into removeListener");
		return;

	}
	if(!isIdValid(objTarget))
	{
		LOG("DESIGNER_FATAL", "Null target paseed into removeListener");
		return;
	}
	if(!isIdValid(objListener))
	{

		LOG("DESIGNER_FATAL", "Null listener paseed into removeListeer");
	}


	dictionary dctParams = new dictionary();
	dctParams.put("objListener", objListener);
	dctParams.put("strObjVar", strObjVar);
	messageTo(objTarget, "removeListener", dctParams, 0, true);
	return;

}


void messageListeners(string strObjVar, obj_id objOwner, string strMessageName, dictionary dctParams)
{

// this messages all of the listeners with the specified message
	if(strObjVar==null)
	{
		LOG("DESIGNER_FATAL", "Null objVar paseed into messageListeners");
		return;

	}
	if(!isIdValid(objOwner))
	{
		LOG("DESIGNER_FATAL", "Null owner paseed into messageListeners");
		return;
	}
	if(strMessageName==null)
	{
		LOG("DESIGNER_FATAL", "Null messageName paseed into messageListeners");

	}


	if(hasObjVar(objOwner, strObjVar))
	{

		int intI = 0;
		obj_id objListeners[] = getObjIdArrayObjVar(objOwner, "mission.objListeners");
		while(intI<objListeners.length)
		{
			//debugServerConsoleMsg(objListeners[intI], "messaging "+objListeners[intI].toString()+ "with "+strMessageName+" and params of "+dctParams.toString());
			//debugServerConsoleMsg(objOwner, "intI is "+intI);
			//debugServerConsoleMsg(objOwner, "length is "+objListeners.length);
			messageTo(objListeners[intI], strMessageName, dctParams, 0, true);
			intI = intI+1;
		}
	}

	return;



}

int getTheaterSize(string strLairType)
{
	if(isTheater(strLairType))
	{
		int intIndex = strLairType.indexOf("medium");
		if(intIndex>0)
		{
			return 40;

		}
		intIndex = strLairType.indexOf("small");
		if(intIndex>0)
		{
			return 24;

		}
		intIndex = strLairType.indexOf("large");
		if(intIndex>0)
		{
			return 72;

		}

		return 24;
	}
	return -1;


}

boolean isTheater(string strLairType)
{


	if(strLairType==null)
	{
		return false;
	}
	int intIndex = strLairType.indexOf("theater");
	if(intIndex>0)
	{
		return true;
	}
	return false;
}

boolean isAppropriateName(string name)
{
	if ( name == null || name.equals("") )
		return false;

	java.util.StringTokenizer st = new java.util.StringTokenizer(name);
	while ( st.hasMoreTokens() )
	{
		string tkn = st.nextToken();
		if ( stringToFloat(tkn) == Float.NEGATIVE_INFINITY )
		{
			if ( isObscene(tkn) || !isAppropriateText(tkn) )
				return false;
		}
	}

	return true;
}

boolean setNonProfaneName(obj_id target, string name)
{
	if ( !isIdValid(target) || name == null || name.equals("") )
		return false;

	if ( !isAppropriateName(name) )
		return false;

	return setName(target, name);
}

boolean setNonReservedName(obj_id target, string name)
{
	if ( !isIdValid(target) || name == null || name.equals("") )
		return false;

	if ( !isNameReserved(name) )
		return setName(target, name);

	return false;
}


boolean setFilteredName(obj_id target, string name)
{
	if ( !isIdValid(target) || name == null || name.equals("") )
		return false;

	if ( !isNameReserved(name) )
		return setNonProfaneName(target, name);

	return false;
}

void destroyObjects(obj_id[] objects)
{
	if ( objects == null || objects.length == 0 )
		return;

	for ( int i = 0; i < objects.length; i++ )
	{
		if ( isIdValid(objects[i]) )
			destroyObject(objects[i]);
	}
}

string getTemplateFilenameNoPath(obj_id target)
{
	if ( !isIdValid(target) )
		return null;

	string filename = null;
	string fullPath = getTemplateName(target);
	if ( fullPath != null && !fullPath.equals("") )
	{
		string[] tmp = split(fullPath, '/');
		if ( tmp != null && tmp.length > 0 )
		{
			filename = tmp[tmp.length - 1];
		}
	}

	return filename;
}

int getFirstNonValidIdIndex(obj_id[] ids)
{
	if ( ids == null || ids.length == 0 )
		return -1;

	for ( int i = 0; i < ids.length; i++ )
	{
		if ( !isIdValid(ids[i]) )
			return i;
	}

	return -1;
}

int getFirstValidIdIndex(obj_id[] ids)
{
	if ( ids == null || ids.length == 0 )
		return -1;

	for (int i = 0; i < ids.length; i++ )
	{
		if ( isIdValid(ids[i]) )
			return i;
	}

	return -1;
}

void moneyInMetric (obj_id objTransferer, string strAccount, int intAmount)
{
	// receiver, acct, amt
	int intTime = getGameTime();
	string strSpam = "moneyIn;"+intTime+";"+objTransferer+";"+strAccount+";"+intAmount;
	logBalance(strSpam);
	return;
}

void moneyOutMetric(obj_id objTransferer, string strAccount, int intAmount)
{
	int intTime = getGameTime();
	string strSpam = "moneyOut;"+intTime+";"+objTransferer+";"+strAccount+";"+intAmount;
	logBalance(strSpam);
	return;
}

int getValidAttributeIndex(string[] array)
{
	for (int i = 0; i < array.length; i++)
	{
		if (array[i] == null || array[i].equals(""))
			return i;
	}
	return -1;
}

string getStringName(obj_id target)
{
	if ( !isIdValid(target) )
		return null;

	string name = getEncodedName(target);
	string_id sid_name = unpackString(name);
	if ( sid_name != null )
		name = getString(sid_name);

	return name;
}

void warpPlayer( obj_id player, location dest )
{
	if (isIdValid(dest.cell))
		warpPlayer (player, dest.area, 0.0f, 0.0f, 0.0f, dest.cell, dest.x, dest.y, dest.z);
	else
		warpPlayer (player, dest.area, dest.x, dest.y, dest.z, null, 0.0f, 0.0f, 0.0f);
}

void warpPlayer( obj_id player, string planet, location dest )
{
		warpPlayer (player, planet, dest.x, dest.y, dest.z, null, 0.0f, 0.0f, 0.0f);
}

boolean copyObjVarList(obj_id from, obj_id to, string listpath)
{
	if ( !isIdValid(from) || !isIdValid(to) || listpath == null || listpath.equals("") )
		return false;

	obj_var_list ovl = getObjVarList(from, listpath);
	if ( ovl == null )
		return false;

	boolean litmus = true;

	int numItems = ovl.getNumItems();
	for ( int i = 0; i < numItems; i++ )
	{
		obj_var ov = ovl.getObjVar(i);
		if ( ov != null )
			litmus &= copyObjVar(from, to, listpath + "." + ov.getName());
	}

	return litmus;
}


string_id getCardinalDirectionForPoints(location locTest1, location locTest2)
{
	string cardinalString = getStringCardinalDirection(locTest1, locTest2);
	if ( cardinalString == null || cardinalString.equals("") )
		return null;

	return new string_id("mission/mission_generic", cardinalString);
}

string getStringCardinalDirection(location locTest1, location locTest2, boolean abbreviated)
{
	if ( locTest1 == null || locTest2 == null )
		return null;

	float fltAngle =getHeadingToLocation(locTest1, locTest2);

	// north is 0
	// west is 90
	// south is -180
	// east is -90
	// we use 1/2 of each of those..
	// so we end up with 45 degree arcs for each of these

	if((fltAngle>=-22.5)&&(fltAngle<=22.5))
	{
		if ( !abbreviated )
			return "north";
		else
			return "N";
	}
	else if((fltAngle>=-67.5)&&(fltAngle<=-22.5))
	{
		if ( !abbreviated )
			return "northeast";
		else
			return "NE";
	}
	else if ((fltAngle>=-112.5)&&(fltAngle<=-67.5))
	{
		if ( !abbreviated )
			return "east";
		else
			return "E";
	}
	else if((fltAngle>=-157.5)&&(fltAngle<=-112.5))
	{
		if ( !abbreviated )
			return "southeast";
		else
			return "SE";
	}
	// south is the fallback, so it's below (its -180/180 so the math is yucky
	else if((fltAngle>=22.5)&&(fltAngle<=67.5))
	{
		if ( !abbreviated )
			return "northwest";
		else
			return "NW";
	}
	else if((fltAngle>=67.5)&&(fltAngle<=112.5))
	{
		if ( !abbreviated )
			return "west";
		else
			return "W";
	}
	else if((fltAngle>=112.5)&&(fltAngle<=157.5))
	{
		if ( !abbreviated )
			return "southwest";
		else
			return "SW";
	}
	else
	{
		if ( !abbreviated )
			return "south";
		else
			return "S";
	}
}

string getStringCardinalDirection(location locTest1, location locTest2)
{
	return getStringCardinalDirection(locTest1, locTest2, false);
}

boolean isContainer(obj_id target)
{
	if ( isIdValid(target) )
		return (getContainerType(target)!=0);

	return false;
}

boolean noIncapDrainAttributes(obj_id target, int actionCost, int mindCost)
{
	if ( !isIdValid(target) || actionCost < 0)
		return false;

	if ( getAttrib(target, ACTION) < actionCost )
	{
		//sendSystemMessageTestingOnly(target, "You lack the necessary ACTION to perform that action");
		return false;
	}

	return drainAttributes(target, actionCost, 0);
}

int getUnbuffedWoundedMaxAttrib(obj_id target, int attrib)
{
	if ( !isIdValid(target) || attrib < HEALTH || attrib > WILLPOWER )
		return -1;

	int unmodmax = getUnmodifiedMaxAttrib(target, attrib);
	return unmodmax;
}

boolean validatePlayerHairStyle(obj_id player)
{
	if (!isIdValid(player))
		return false;

	string hair_table = "datatables/customization/hair_assets_skill_mods.iff";
	//LOG("LOG_CHANNEL", "num_rows ->" + dataTableGetNumRows(hair_table));
	obj_id hair = getObjectInSlot(player, "hair");
	//LOG("LOG_CHANNEL", "hair ->" + hair);
	if (!isIdValid(hair))
		return false;

	string hair_template = getTemplateName(hair);
	//LOG("LOG_CHANNEL", "hair_template ->" + hair_template);
	int idx = dataTableSearchColumnForString(hair_template, "SERVER_TEMPLATE", hair_table);
	//LOG("LOG_CHANNEL", "idx ->" + idx);

	if (idx < 0)
		return false;

	string required_template = dataTableGetString(hair_table, idx, "SERVER_PLAYER_TEMPLATE");
	//LOG("LOG_CHANNEL", "required_template ->" + required_template);
	if (required_template == null)
		return false;

	string player_template = getTemplateName(player);
	//LOG("LOG_CHANNEL", "player_template ->" + player_template);

	if (player_template != required_template)
	{
		// If the player is not of the required template, he has an illegal hair style.
		// We use the first one that we can find in the datatable.
		int new_hair_idx = dataTableSearchColumnForString(player_template, "SERVER_PLAYER_TEMPLATE", hair_table);
		//LOG("LOG_CHANNEL", "new_hair_idx ->" + new_hair_idx);
		string new_hair_template = dataTableGetString(hair_table, new_hair_idx, "SERVER_TEMPLATE");
		//LOG("LOG_CHANNEL", "new_hair_template ->" + new_hair_template);
		if (new_hair_template == null)
		{
			CustomerServiceLog("imageDesigner", getFirstName(player) + "(" + player + ") has an invalid hairstyle, but a replacement cannot be found!");
			return false;
		}

		destroyObject(hair);
		createObject(new_hair_template, player, "hair");
		CustomerServiceLog("imageDesigner", getFirstName(player) + "(" + player + ") has an invalid hairstyle. It has been replaced with a default style.");
		sendSystemMessageTestingOnly(player, "An illegal hairstyle has been detected on your character. This has been corrected.");
	}

	return true;
}

string getPackedScripts(obj_id objObject)
{
	string strTest = "";
	string[] strScripts = getScriptList(objObject);
	if(strScripts.length>0)
	{
		for(int intI = 0; intI<strScripts.length; intI++)
		{
			strTest = strTest + strScripts[intI];
			if(intI<strScripts.length-1)
			{
				strTest = strTest + ",";
			}
		}
	}
	return strTest;
}
string[] getUsableScriptList(obj_id objObject)
{
	string strTest = "";
	string[] strScripts = getScriptList(objObject);
	debugSpeakMsg(objObject, "script list is "+strScripts.length);
	if(strScripts.length>0)
	{
		debugSpeakMsg(objObject, "list length is "+strScripts.length);
		string[] strCorrectArray = new string[strScripts.length];
		for(int intI = 0; intI<strScripts.length; intI++)
		{
			string script = strScripts[intI];
			if ( script.indexOf( "script." ) > -1 )
			{
				script = script.substring( 7 );
				debugSpeakMsg(objObject, "setting array to  "+script);
				strCorrectArray[intI] = script;
			}
		}
		return strCorrectArray;
	}
	return null;


}

string[] unpackScriptString(string strScripts)
{
	string[] strTest = split(strScripts, ',');
	return strTest;
}

boolean isEquipped(obj_id item)
{
	if ( !isIdValid(item) )
		return false;

	obj_id containedBy = getContainedBy(item);
	return ( isIdValid(containedBy) && getContainerType(containedBy) == 1 ); //container type 1 = CT_slotted
}

obj_id unequipWeaponHand(obj_id player)
{
	return unequipSlot(player, "hold_r");
}

obj_id unequipOffHand(obj_id player)
{
	return unequipSlot(player, "hold_l");
}

obj_id unequipSlot(obj_id player, string slot)
{
	obj_id equipment = getObjectInSlot(player, slot);
	if ( isIdValid(equipment) )
	{
		obj_id playerInv = utils.getInventoryContainer(player);
		if ( isIdValid(playerInv) )
		{
			putInOverloaded(equipment, playerInv);
			return equipment;
		}
	}
	return obj_id.NULL_ID;
}



obj_id[] getAttackableTargetsInRadius(obj_id attacker, int radius, boolean player_targets)
{
	// Returns all mobs within a specified radius that are pvpCanAttack-true and are in the light of sight.
	location loc = getLocation(attacker);
	if (loc == null)
		return null;

	obj_id[] objects = getObjectsInRange(loc, radius);
	resizeable obj_id[] attackable_targets = new obj_id[0];
	for (int i = 0; i < objects.length; i++)
	{
		if (isMob(objects[i]))
		{
			if (pvpCanAttack(attacker, objects[i]))
			{
				if (!isIncapacitated(objects[i]) && !isDead(objects[i]))
				{
					if (isPlayer(objects[i]))
					{
						if (!player_targets)
							continue;
					}

					if (canSee(attacker, objects[i]))
					{
						attackable_targets = utils.addElement(attackable_targets, objects[i]);
					}
				}
			}
		}
		else if ( ai_lib.isTurret(objects[i]))
		{
			if (pvpCanAttack(attacker, objects[i]))
			{

				if (canSee(attacker, objects[i]))
					attackable_targets = utils.addElement(attackable_targets, objects[i]);
			}
		}
	}

	if (attackable_targets.length < 1)
		return null;
	else
		return attackable_targets;
}


obj_id getTrapDroidId(obj_id player)
{
	obj_id dataPad = getPlayerDatapad(player);
	resizeable obj_id[] data = getResizeableContents(dataPad);

	for(int i = 0; i < data.length; i++)
	{
		if(callable.hasCDCallable(data[i]) && hasObjVar(data[i], "module_data.trap_bonus"))
		{
			return data[i];
		}
	}

	return null;

}//end getTrapDroidId

int getTimeLeft(obj_id player, string toCheckFor, int timePenalty)
{

	int currentTime = getGameTime();
	int timeCalled = utils.getIntScriptVar(player, toCheckFor);
	if (timeCalled < 1)
		return -1;

	int timeDone = timeCalled + timePenalty;
	int timeLeft = timeDone - currentTime;

	return timeLeft;

}

int getTimeLeft(obj_id player, string toCheckFor, string modifiedTime)
{

	int currentTime = getGameTime();
	int timeCalled = utils.getIntScriptVar(player, toCheckFor);
	if (timeCalled < 1)
		return -1;

	int timePenalty = utils.getIntScriptVar(player, modifiedTime);
	int timeDone = timeCalled + timePenalty;
	int timeLeft = timeDone - currentTime;

	return timeLeft;

}

boolean isFreeTrial(obj_id player)
{
	return isFreeTrialAccount(player);
}

boolean isFreeTrial(obj_id player, obj_id target)
{
	return isFreeTrialAccount(player);

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////   STOLEN FROM SPACE_UTILS.SCRIPTLIB:  THESE ARE NOT SAFE FOR MULTI-SERVER
////   We're going to have to remove and fix references when space is integrated to Current
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void notifyObject(obj_id objTarget, string strNotificationName, dictionary dctParams)
{
	if(!isIdValid(objTarget))
	{
		debugServerConsoleMsg(null, "Null object id passed into notifyObject, exceptioning");
		Thread.dumpStack();
		throw new InterruptedException();
	}
	if(strNotificationName==null)
	{
		debugServerConsoleMsg(null, "null notification name passed into notifyObject, exceptioning");
		Thread.dumpStack();
		throw new InterruptedException();
	}
	if(strNotificationName=="")
	{
		debugServerConsoleMsg(null, "Empty Notification name passed into notifyObject, exceptioning");
		Thread.dumpStack();
		throw new InterruptedException();
	}

	try
	{
		int intReturn = script_entry.callMessageHandlers(strNotificationName, objTarget, dctParams);
		return;
	}
	catch (Throwable err)
	{
		debugServerConsoleMsg(null, "Unable to call into callMessageHandlers ");
		Thread.dumpStack();
		throw new InterruptedException();
	}
}

void callTrigger(string strTrigger, Object[] params)
{
	try
	{
		script_entry.runScripts(strTrigger, params);
		return;
	}
	catch (Throwable err)
	{
		debugServerConsoleMsg(null, "Unable to call into callMessageHandlers ");
		Thread.dumpStack();
		throw new InterruptedException();
	}
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

string getCellName(obj_id building, obj_id cell) {

	string[] cellNames = getCellNames(building);

	for(int i = 0; i < cellNames.length; i++) {

		string cellName = cellNames[i];
		obj_id thisCell = getCellId(building, cellName);

		if (thisCell == cell) {

			return cellName;
		}
	}

	return "";
}

string getRealPlayerFirstName(obj_id player)
{
	string firstName = getPlayerName(player);

	if(firstName == null)
	{
		return null;
	}

	int idx = firstName.toLowerCase().indexOf("corpse of");
	if(idx >= 0)
	{
		firstName = firstName.substring(idx+1);
	}

	// upper case the first letter in the name
	if(firstName.length() > 0)
	{
		char first = firstName.charAt(0);
		first = Character.toUpperCase(first);
		firstName = first + firstName.substring(1);
	}

	return firstName;
}

void dismountRiderJetpackCheck (obj_id rider)
{
	if(!isIdValid(rider))
	{
		return;
	}

	obj_id mount = getMountId (rider);

	if(!exists(mount))
	{
		return;
	}

	if(isIdValid(mount))
	{
		pet_lib.doDismountNow(rider, false);
		string name = getTemplateName (mount);

		if(vehicle.isJetPackVehicle(mount))
		{
			string_id jetDismount = new string_id ("pet/pet_menu", "jetpack_dismount");
			sendSystemMessage(rider, jetDismount);

			obj_id petControlDevice = callable.getCallableCD(mount);
			vehicle.storeVehicle(petControlDevice, rider);
		}
	}

	return;
}

location getLocationFromTransform(transform trTest)
{
	location locTest = new location();
	vector vctTest = trTest.getPosition_p();
	locTest.x = vctTest.x;
	locTest.y = vctTest.y;
	locTest.z = vctTest.z;
	return locTest;
}

int addClassRequirementAttributes(obj_id player, obj_id item, string[] names, string[] attribs, int firstFree, string prefix)
{
	//sendSystemMessageTestingOnly(obj_id.getObjId(10012897), "1");
	if(hasObjVar(item, prefix + "classRequired"))
	{
		//sendSystemMessageTestingOnly(player, "Class Requirements");
		string requiredClasses = getStringObjVar(item, prefix + "classRequired");
		java.util.StringTokenizer st = new java.util.StringTokenizer(requiredClasses, ",");
		string requiredText = "";
		boolean qualifies = false;

		while(st.hasMoreTokens())
		{
			string classId = st.nextToken();
			string tmp = "@skl_n:class_" + classId + "\0";
			if(st.hasMoreTokens())
			{
				 tmp += "\n\\>117\0";
			}

			requiredText += tmp;
			//sendSystemMessageTestingOnly(player, "Req: " + requiredText);
			if(isProfession(player, stringToInt(classId)))
			{
				qualifies = true;
				break;
			}
		}

		if(!qualifies)
		{
			names[firstFree] = "class_required";
			attribs[firstFree++] = requiredText;
		}
	}

	if(hasObjVar(item, prefix + "levelRequired"))
	{
		int minLevel = getIntObjVar(item, prefix + "levelRequired");
		if(minLevel > getLevel(player))
		{
			names[firstFree] = "levelrequired";
			attribs[firstFree++] = "" + minLevel;
		}
	}

	return firstFree;
}

boolean testItemClassRequirements(obj_id player, string requiredClasses, boolean silent)
{
	java.util.StringTokenizer st = new java.util.StringTokenizer(requiredClasses, ",");
	string requiredText = "";

	while(st.hasMoreTokens())
	{
		string classId = st.nextToken();
		if(isProfession(player, stringToInt(classId)))
		{
			return true;
		}
	}

	if(!silent)
	{
		sendSystemMessage(player, new string_id("spam", "classrequired"));
	}

	return false;
}

boolean testItemClassRequirements(obj_id player, obj_id thing, boolean silent, string prefix)
{
	if(!hasObjVar(thing, prefix + "classRequired"))
	{
		return true;
	}

	string requiredClasses = getStringObjVar(thing, prefix + "classRequired");
	return testItemClassRequirements(player, requiredClasses, silent);
}

boolean testItemLevelRequirements(obj_id player, obj_id thing, boolean silent, string prefix)
{
	if(!hasObjVar(thing, prefix + "levelRequired"))
	{
		return true;
	}

	int minLevel = getIntObjVar(thing, prefix + "levelRequired");
	if(minLevel > getLevel(player))
	{
		if(!silent)
		{
			prose_package pp = prose.getPackage(new string_id("spam", "levelrequired"), "" + minLevel);
			sendSystemMessageProse(player, pp);
		}
		return false;
	}

	return true;
}

boolean testItemAbilityRequirements(obj_id player, obj_id thing, boolean silent, string prefix)
{
	if(!hasObjVar(thing, prefix + "abilityRequired"))
	{
		return true;
	}

	string commandRequired = getStringObjVar(thing, prefix + "abilityRequired");
	if(!hasCommand(player, commandRequired))
	{
		if(!silent)
		{
			prose_package pp = prose.getPackage(new string_id("spam", "abilityrequired"), "@cmd_n:" + toLower(commandRequired));
			sendSystemMessageProse(player, pp);
		}
		return false;
	}

	return true;
}

boolean testItemSkillRequirements(obj_id player, obj_id thing, boolean silent, string prefix)
{
	if(!hasObjVar(thing, prefix + "skillRequired"))
	{
		return true;
	}

	string skillRequired = getStringObjVar(thing, prefix + "skillRequired");
	if(!hasSkill(player, skillRequired))
	{
		if(!silent)
		{
			prose_package pp = prose.getPackage(new string_id("spam", "skill_required"), "@skl_n:" + toLower(skillRequired));
			sendSystemMessageProse(player, pp);
		}
		return false;
	}

	return true;
}

void makeItemNoDrop(obj_id item)
{
	attachScript(item, "item.special.nomove");
	setObjVar(item, "noTrade", 1);
}

boolean isItemNoDrop(obj_id item)
{
	return hasScript(item, "item.special.nomove") || hasObjVar(item, "noTrade");
}

void clearNoDropFromItem(obj_id item)
{
	detachScript(item, "item.special.nomove");
	removeObjVar(item, "noTrade");
}

/**
 * Checks a list of objects to see if one is a notrade item. Will recusively check the contents of containers.
 *
 * @param items			the list of items to check
 * @param testPlayers   flag to check the equipment/inventory of any players in the list
 *
 * @return the id of the 1st notrade item found, or null if there are none
 */
obj_id findNoTradeItem(obj_id[] items, boolean testPlayers)
{
	return findNoTradeItem( items, testPlayers, false );
}

obj_id findNoTradeItem(obj_id[] items, boolean testPlayers, boolean novendor)
{
	if ( items != null )
	{
		for ( int i = 0; i < items.length; ++i )
		{
			if ( isIdValid(items[i]) && (testPlayers || !isPlayer(items[i])) )
			{
				if ( novendor && hasScript( items[i], "terminal.vendor" ) )
					continue;
				if ( !canTrade(items[i]) )
					return items[i];
				else if (utils.isContainer(items[i]))
				{
					obj_id result = findNoTradeItem(getContents(items[i]), testPlayers);
					if ( isIdValid(result) )
						return result;
				}
			}
		}
	}
	return null;
}

obj_id findNoTradeItemNotVendor(obj_id[] items, boolean testPlayers)
{
	return findNoTradeItem( items, testPlayers, true );
}

/**
 * Tests to see if a player has a waypoint with a given name.
 *
 * @param player		the player to test
 * @param name			the waypoint name to look for
 *
 * @return the wapoint with the name, or null if the player has no waypoint
 */
obj_id hasWaypoint(obj_id player, string name)
{
	if ( !isIdValid(player) || name == null )
		return null;

	obj_id[] waypoints = getWaypointsInDatapad(player);
	if ( waypoints == null )
		return null;

	for ( int i = 0; i < waypoints.length; ++i )
	{
		if ( isIdValid(waypoints[i]) )
		{
			string waypointName = getWaypointName(waypoints[i]);
			if ( waypointName != null && waypointName == name)
			{
				return waypoints[i];
			}
		}
	}
	return null;
}

/**
 * Tests to see if a player has a waypoint of the given id.
 *
 * @param player		the player to test
 * @param waypoint		the waypoint id to look for
 *
 * @return true if the waypoint is found, or false if not
 */

boolean waypointExists(obj_id player, obj_id waypoint)
{
	if ( !isIdValid(player) || !isIdValid(waypoint) )
		return false;

	obj_id[] waypoints = getWaypointsInDatapad(player);
	if ( waypoints == null || waypoints.length <= 0 )
		return false;

	for ( int i = 0; i < waypoints.length; ++i )
	{
		if ( isIdValid(waypoints[i]) )
		{
			if ( waypoints[i] == waypoint )
			{
				return true;
			}
		}
	}
	return false;
}

/**
 * Checks a string to see if there are any extended ascii characters in it.
 *
 * @param inString		the incoming string to test
 *
 * @return true or false depending on extended ascii being found.
 */

boolean isExtendedASCII(string inString)
{

	if (inString == null)
	{
		return false;
	}

	for ( int i = 0; i < inString.length(); i++ )
	{
		int ASCIIValue = inString.charAt(i);
		if (ASCIIValue < 0 || ASCIIValue > 255)
		{
			return true;
		}
	}
	return false;
}

// checks to see if the item is antidecay.
// Items that are antidecay will not take damage due to player death or on use (if they are armor or weapons)
boolean isAntiDecay(obj_id item)
{
	if( isIdValid(item) && hasObjVar(item, "antidecay") )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// make an item anti-decay which causes it not to take damage when player dies or it is used (such as armor, weapons and tools)
boolean makeAntiDecay(obj_id item)
{
	if( isIdValid(item) )
	{
		setObjVar(item, "antidecay", 1);
		attachScript(item, "systems.veteran_reward.antidecay_examine");
		// item has been successfully set to be antidecay
		return true;
	}
	// add override code here to prevent specific items to not be anti decay
	else
	{
		// item was not set to be antidecay
		return false;
	}
}

// remove anti-decay from item
boolean removeAntiDecay(obj_id item)
{
	if( isIdValid(item) )
	{
		if ( hasObjVar(item, "antidecay") )
		{
			removeObjVar(item, "antidecay");
		}
		// means item is no longer anti decay (even if it wasn't previously)
		return true;
	}
	// add override code here to not remove anti decay
	else
	{
		return false;
	}
}

// validates if the item can have anti decay applied to it
boolean validItemForAntiDecay(obj_id item)
{
	if( isIdValid(item) )
	{
		// Sorry, Dave
		if (jedi.isLightsaber(item))
			return true;

		// Don't allow PSGs to be flagged anti-decay
		if (isGameObjectTypeOf(item, GOT_armor_psg))
			return false;

		// allow anything that is normally insured as well as weapons to be anti-decay even though weapons don't need insured
		if( cloninglib.isDamagedOnCloneGOT(getGameObjectType(item)) || isGameObjectTypeOf(item, GOT_weapon) )
		{
			return true;
		}
	}
	return false;
}

obj_id[] getLocalGroupMemberIds( obj_id group )
{
	if ( !isIdValid(group) )
		return null;

	obj_id[] groupMemberIds = getGroupMemberIds(group);
	if ( groupMemberIds == null || groupMemberIds.length == 0 )
		return null;

	Vector localMemberIdsVector = new Vector();
	for ( int i =0; i < groupMemberIds.length; ++i )
	{
		if ( isIdValid(groupMemberIds[i]) && exists(groupMemberIds[i]) && isPlayer(groupMemberIds[i]) )
		{
			localMemberIdsVector.addElement(groupMemberIds[i]);
		}
	}

	if ( localMemberIdsVector == null || localMemberIdsVector.size() < 1 )
		return null;

	return ( utils.toStaticObjIdArray(localMemberIdsVector));
}

boolean canSpeakWookiee(obj_id player, obj_id npc)
{
	if(hasSkill(player, "class_smuggler_phase1_novice"))
		return false;

	if(hasSkill(player, "social_language_wookiee_comprehend"))
		return false;

	else
		return true;
}

void emoteWookieeConfusion (obj_id player, obj_id npc)
{
	playClientEffectObj(npc, "clienteffect/voc_wookiee_med_4sec.cef", player, "");
	chat.thinkTo(player, player, new string_id("ep3/sidequests", "wke_convo_failure"));
}


void setObjVarsList(obj_id object, string objVarList)
{
	if ( objVarList == null || objVarList == "" )
		return;

	//get array of strings in the format int:name=value
	string[] pairs = split(objVarList, ',');
	for ( int i = 0; i < pairs.length; i++ )
	{
		//split each pair to get int:name and value
		string[] objVarToSet = split(pairs[i], '=' );
		string objVarValue = objVarToSet[1];
		//split int:name into type (int) and name ("name")
		string[] objVarNameAndType = split(objVarToSet[0], ':');
		string objVarType = objVarNameAndType[0];
		string objVarName = objVarNameAndType[1];

		//Now we have:
		// objVarType	=	string, int, float, boolean
		// objVarName	=	the name of the objvar to set
		// objVarValue	=	the value of the objvar

		if ( objVarType == "string" )
			setObjVar( object, objVarName, objVarValue );
		else if ( objVarType == "int" )
			setObjVar( object, objVarName, utils.stringToInt( objVarValue ) );
		else if ( objVarType == "float" )
			setObjVar( object, objVarName, utils.stringToFloat( objVarValue ) );
		else if ( objVarType == "boolean" || objVarType == "bool" )
			setObjVar( object, objVarName, utils.stringToInt( objVarValue ) );//booleans are stored as int's.
		else
			setObjVar( object, objVarName, objVarValue );//fuck it, must have been a string after all.

	}
}

void setObjVarsListUsingSemiColon(obj_id object, string objVarList)
{
	if ( objVarList == null || objVarList == "" )
		return;

	//get array of strings in the format int:name=value
	string[] pairs = split(objVarList, ',');
	for ( int i = 0; i < pairs.length; i++ )
	{
		//split each pair to get int:name and value
		string[] objVarToSet = split(pairs[i], '=' );
		string objVarValue = objVarToSet[1];
		//split int:name into type (int) and name ("name")
		string[] objVarNameAndType = split(objVarToSet[0], ';');
		string objVarType = objVarNameAndType[0];
		string objVarName = objVarNameAndType[1];

		//Now we have:
		// objVarType	=	string, int, float, boolean
		// objVarName	=	the name of the objvar to set
		// objVarValue	=	the value of the objvar

		if ( objVarType == "string" )
			setObjVar( object, objVarName, objVarValue );
		else if ( objVarType == "int" )
			setObjVar( object, objVarName, utils.stringToInt( objVarValue ) );
		else if ( objVarType == "float" )
			setObjVar( object, objVarName, utils.stringToFloat( objVarValue ) );
		else if ( objVarType == "boolean" || objVarType == "bool" )
			setObjVar( object, objVarName, utils.stringToInt( objVarValue ) );//booleans are stored as int's.
		else
			setObjVar( object, objVarName, objVarValue );//fuck it, must have been a string after all.

	}
}

boolean verifyLocationBasedDestructionAnchor(obj_id subject, float distance)
{
	if (!hasObjVar(subject, "recordLoc"))
	{
		location recordLoc = getLocation(subject);
		setObjVar(subject, "recordLoc", recordLoc);
		return true;
	}

	location verifyLoc = getLocationObjVar(subject, "recordLoc");
	location here = getLocation(getTopMostContainer(subject));
	float distanceDifference = getDistance(verifyLoc, here);
	if (distanceDifference > distance || distanceDifference == -1f)
	{
		destroyObject(subject);
		return false;
	}

	return true;
}

boolean verifyLocationBasedDestructionAnchor(obj_id subject, location recordLoc, float distance)
{
	if (!hasObjVar(subject, "recordLoc"))
	{
		setObjVar(subject, "recordLoc", recordLoc);
		return true;
	}

	location verifyLoc = getLocationObjVar(subject, "recordLoc");
	location here = getLocation(getTopMostContainer(subject));
	float distanceDifference = getDistance(verifyLoc, here);
	if (distanceDifference > distance || distanceDifference == -1f)
	{
		destroyObject(subject);
		return false;
	}

	return true;
}

/***********************************************************************
 * @brief	Converts time from seconds into localized seconds or minutes/seconds or hours/minutes or days/hours  2 significant digits is all anyone really needs
 *			This was setup to use prose packages in the examine window however prose packages couldnt be properly unpacked after using base class packOutOfBandProsePackage
 * @param	int time
 *
 *
 ***********************************************************************/
string assembleTimeRemainToUse(int time)
{
	return assembleTimeRemainToUse(time, true);
}

string assembleTimeRemainToUse(int time, boolean localized)
{
	//check to see if we display seconds
	if(time <= 60)
	{
		string attrib = "";
		if(localized)
			attrib = time + (time != 1 ? " $@spam:seconds$" : " $@spam:second$");
		else
			attrib = time + (time != 1 ? " seconds" : " second");

		return attrib;
	}

	if(time > 60 && time <= 3600 )
	{
		//get minutes
		int minutes = (int)Math.floor(time / 60);
		//get remainder seconds
		int remainder_time = time % 60;

		string attrib = "";
		if(localized)
			attrib = minutes + (minutes != 1 ? " $@spam:minutes$, " : " $@spam:minute$, ") + remainder_time + (remainder_time != 1 ? " $@spam:seconds$" : " $@spam:second$");
		else
			attrib = minutes + (minutes != 1 ? " minutes, " : " minute, ") + remainder_time + (remainder_time != 1 ? " seconds" : " second");
		return attrib;
	}

	if(time  > 3600 && time <= 86400)
	{
		//get hours
		int hours = (int)Math.floor(time / 3600);
		//get remainder minutes
		int remainder_time = (time % 3600) / 60;

		string attrib = "";
		if(localized)
			attrib = hours + (hours != 1 ? " $@spam:hours$, " : " $@spam:hour$, ") + remainder_time + (remainder_time != 1 ? " $@spam:minutes$" : " $@spam:minute$");
		else
			attrib = hours + (hours != 1 ? " hours, " : " hour, ") + remainder_time + (remainder_time != 1 ? " minutes" : " minute");
		return attrib;
	}

	if(time > 86400 && time < Integer.MAX_VALUE)
	{
		//get days
		int days = (int)Math.floor(time / 86400);
		//get remainder hours
		int remainder_hours = (time % 86400) / 3600;
		int remainder_minutes = (time % 3600) / 60;

		string attrib = "";
		if(localized)
		{
			attrib = days + (days != 1 ? " $@spam:days$, " : " $@spam:day$, ") + remainder_hours + (remainder_hours != 1 ? " $@spam:hours$, " : " $@spam:hour$, ") +
			+ remainder_minutes + (remainder_minutes != 1 ? " $@spam:minutes$" : " $@spam:minute$");
		}
		else
		{
			attrib = days + (days != 1 ? " days, " : " day, ") + remainder_hours + (remainder_hours != 1 ? " hours, " : " hour, ") +
			+ remainder_minutes + (remainder_minutes != 1 ? " minutes" : " minute");
		}

		return attrib;
	}

	return null;
}

//helper function to determine if someone is a specific profession
boolean isProfession(obj_id player, int profession)
{
	if (!isIdValid(player))
		return false;

	if (!isPlayer(player))
		return false;

	string classTemplate = getSkillTemplate(player);
	string professionName = "";

	switch(profession)
	{
		case COMMANDO:
			professionName = "commando";
			break;
		case SMUGGLER:
			professionName = "smuggler";
			break;
		case MEDIC:
			professionName = "medic";
			break;
		case OFFICER:
			professionName = "officer";
			break;
		case SPY:
			professionName = "spy";
			break;
		case BOUNTY_HUNTER:
			professionName = "bounty";
			break;
		case FORCE_SENSITIVE:
			professionName = "force";
			break;
		case TRADER:
			professionName = "trader";
			break;
		case ENTERTAINER:
			professionName = "entertainer";
			break;
		default:
			break;
	}

	if ( classTemplate != null && classTemplate.startsWith(professionName))
	{
		return true;
	}
	return false;
}

int getPlayerProfession(obj_id player)
{
	string[] noviceSkillList =
				{
					"class_forcesensitive_phase1_novice",
					"class_bountyhunter_phase1_novice",
					"class_smuggler_phase1_novice",
					"class_commando_phase1_novice",
					"class_officer_phase1_novice",
					"class_spy_phase1_novice",
					"class_medic_phase1_novice",
					"class_entertainer_phase1_novice"
				};

	int[] 	professionList =
				{
					FORCE_SENSITIVE,
					BOUNTY_HUNTER,
					SMUGGLER,
					COMMANDO,
					OFFICER,
					SPY,
					MEDIC,
					ENTERTAINER
				};

	for (int i=0;i<noviceSkillList.length;i++)
	{
		if (hasSkill(player, noviceSkillList[i]))
			return professionList[i];
	}

	return TRADER;
}

//------------------------------------------------------------------------------
// Networking code used to pack objects on Java side. Don't use unless you know
// what you're doing with these
//------------------------------------------------------------------------------

byte[] packObject(Object o)
{
	byte[] ret = null;

	try
	{
		ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
		ObjectOutputStream objectOutput = new ObjectOutputStream(byteOutput);

		try
		{
			objectOutput.writeObject(o);
			ret = byteOutput.toByteArray();
		}
		catch ( IOException err )
		{
			LOG("utils", "ERROR in Java utils.packObject(): " + err.getMessage());
		}
	}
	catch (java.io.IOException e)
	{
		LOG("utils", "ERROR in initialization of utils.packObject: " + e.getMessage());
	}

	return ret;
}

Object unpackObject(byte[] source)
{
	try
	{
		ByteArrayInputStream byteInput = new ByteArrayInputStream(source);
		ObjectInputStream ois = new ObjectInputStream(byteInput);
		Object result = ois.readObject();

		return result;
	}
	catch (ClassNotFoundException x)
	{
		LOG("utils", "ClassNotFoundException:  "+x.toString());
	}
	catch (IOException x)
	{
		LOG("utils", "IOException:  "+x.toString());
	}

	return null;
}

//Deletes an old snowflake item and replaces with updated snowflake item, handles player equipped
//on floor in houses and containers in houses, in containers in players inventory

boolean replaceSnowflakeItem(obj_id oldItem, string newTemplateName)
{
	obj_id ownerContainer = getContainedBy(oldItem);
	//LOG("replaceSnowflakeItem", "ownerContainer = "+ownerContainer);
	if(!isIdValid(ownerContainer))
		return false;

	//check to see if oldItem is in a bazaar or vendor
	//this is to fix issue with items being converted during the split second it is in the bazzars or vendors inventory
	boolean inVendor = isInVendor(oldItem);
	boolean inBazaar = isInBazaar(oldItem);
	if(inVendor || inBazaar)
	{
		//you are inside a vendor and you will need to delay the change till in players inventory
		//NOTE TO DESIGNERS: if you are going to use this function, you must make the messageHandler on the script on the
		//object. Otherwise nothing will happen. The item wont convert till the player re-loads.
		messageTo(oldItem, "handlerReInitialize", null, 5.0f, false);
		return false;
	}

	obj_id newItem = null;

	//check to see if we are a player
	if (isPlayer(ownerContainer))
	{
		obj_id inventory = utils.getInventoryContainer(ownerContainer);
		//check to see if we are equipped, if so unequip
		if(utils.isEquipped(oldItem))
			putInOverloaded(oldItem, inventory);

		newItem = createObjectOverloaded(newTemplateName, inventory);
		CustomerServiceLog("replaceSnowflakeItem: ", "Old Item (" + oldItem + ")"+ " is contained in player's " + getFirstName(getContainingPlayer(oldItem)) + "(" + getContainingPlayer(oldItem) + ") inventory.");
		CustomerServiceLog("replaceSnowflakeItem: ", "New Item (" + newItem + ")"+ " was created in " + getFirstName(getContainingPlayer(newItem)) + "(" + getContainingPlayer(newItem) + ") inventory.");
	}
	//check to see if we are floating in a house
	else if(getCellName(ownerContainer) != null)
	{
		if(player_structure.isBuilding(getTopMostContainer(ownerContainer)))
		{
			location loc = getLocation(oldItem);
			newItem = createObject(newTemplateName, loc);

			//so for some reason the server creating objects on the floor of a house causes them not to persist
			//so lets we manually do it
			if(isIdValid(newItem))
			{
				if( isObjectPersisted(oldItem) && !isObjectPersisted(newItem) )
					persistObject(newItem);
			}

			CustomerServiceLog("replaceSnowflakeItem: ", "Old Item (" + oldItem + ") is contained in a building (" + getTopMostContainer(ownerContainer) + ")");
			CustomerServiceLog("replaceSnowflakeItem: ", "New Item (" + newItem + ") was created in building (" + getTopMostContainer(ownerContainer) + ")");
			CustomerServiceLog("replaceSnowflakeItem: ", "New Item (" + newItem + ")s location is in a building (" + getTopMostContainer(ownerContainer) + ") is x = " + loc.x + " y = " + loc.y + " z = " + loc.z + "and cell = " + getCellName(getTopMostContainer(ownerContainer), loc.cell));
		}
	}
	else
	{
		newItem = createObjectOverloaded(newTemplateName, ownerContainer);
		CustomerServiceLog("replaceSnowflakeItem: ", "New Item (" + newItem + ")"+ " was created in container (" + ownerContainer + ")");
	}

	//make sure new item is good before destroying old
	if(isIdValid(newItem))
	{
		CustomerServiceLog("replaceSnowflakeItem: ", "New Item (" + newItem + ")"+ " has a valid ID. So Old Item (" + oldItem + ") is to be destroyed");
		destroyObject(oldItem);
	}

	return true;
}

void checkInventoryForSnowflakeItemSwaps(obj_id self)
{
	string[] oldTemplates = dataTableGetStringColumn("datatables/item/snowflake_item_swaps.iff", "OLD_TEMPLATE");
	obj_id objInventory = getInventoryContainer(self);

	if(isIdValid(objInventory) )
	{
		obj_id[] objContents = getContents(objInventory, true);

		if(objContents != null)
		{
			for(int i = 0; i < objContents.length; i++)
			{
				for(int j = 0; j < oldTemplates.length; j++)
				{
					string strItemTemplate = getTemplateName(objContents[i]);
					if(strItemTemplate == oldTemplates[j])
					{
						string newTemplate = dataTableGetString("datatables/item/snowflake_item_swaps.iff", j, "NEW_TEMPLATE");

						if(newTemplate != null || !newTemplate.equals("") )
						{
							replaceSnowflakeItem(objContents[i], newTemplate);
						}
					}
				}
			}
		}
	}


	return;
}

//checks to see if the object is a player vendor
boolean isVendorObject(obj_id object)
{
	if(hasScript(object, VENDOR_SCRIPT))
		return true;
	return false;
}

//checks to see if the object is a bazaar
boolean isBazaarObject(obj_id object)
{
	if(hasScript(object, BAZAAR_SCRIPT))
		return true;
	return false;
}

//Checks to see if an item is in a vendors inventory
// Items will only be in the inventory during the split second it takes to
// move item from wharehouse to players inventory. This function is used in the replaceSnowflakeItem function
boolean isInVendor(obj_id item)
{
	obj_id ownerContainer = getContainedBy(item);
	if(!isIdValid(ownerContainer))
		return false;

	//get the parent ID
	obj_id parentContainer = getContainedBy(ownerContainer);
	//LOG("replaceSnowflakeItem", "parentContainer = "+parentContainer);
	if(hasObjVar(parentContainer, "vendor"))
		return true;
	else
		return false;
}

//Checks to see if an item is in a bazaars inventory
// Items will only be in the inventory during the split second it takes to
// move item from wharehouse to players inventory. This function is used in the replaceSnowflakeItem function
boolean isInBazaar(obj_id item)
{
	obj_id ownerContainer = getContainedBy(item);
	if(!isIdValid(ownerContainer))
		return false;

	if(hasScript(ownerContainer, "terminal.bazaar"))
		return true;
	else
		return false;
}

//checks to see if 2 objects are out of the specified distance of each other
boolean outOfRange(obj_id self, obj_id player, float distance, boolean message)
{
	//gods override range checks
	if(isGod(player))
		return false;

	location a = getLocation(self);
	location b = getLocation(player);
	if (a.cell == b.cell && a.distance(b) < distance)
		return false;

	if (message)
		sendSystemMessage(player, SID_OUT_OF_RANGE);

	return true;
}
//pass in a very long float, round it to the Hundredths place and pass it back
float roundFloatByDecimal(float number)
{
	float tempNumber = number *100;
	int result = (int)Math.round(tempNumber);
	float finalResult = (float)result/100;
	return finalResult;
}

// House packing code
void housePackingDecreaseIncrease (obj_id objPlayer, int change)
{
	// player is earning a point by blowing up a house
	if (change > 0)
	{
		//current points[0]
		//max ever points[1]
		int [] housePacking = new int [utils.HOUSE_MAX];
		//if this is the first house blown up
		if (!hasObjVar (objPlayer, "housePackup"))
			setObjVar (objPlayer, "housePackup", housePacking);

		housePacking = getIntArrayObjVar (objPlayer, "housePackup");
		//validate
		if (housePacking.length != utils.HOUSE_MAX)
			return;
		//increase both counters by 1
		housePacking[0]++;
		housePacking[1]++;
		setObjVar (objPlayer, "housePackup", housePacking);
		//set objvar to make sure that a player can only pack up 10 houses a day
		if (!hasObjVar (objPlayer, "dailyHousePackup"))
		{
			setObjVar (objPlayer, "dailyHousePackup", 1);
			int resetTime = getGameTime() + player_structure.TIME_TO_NEXT_PACKUP; // 24 hours
			setObjVar (objPlayer, "maxHousePackupTimer", resetTime);
		}
		else
		{
			int dailyHousePacking = getIntObjVar (objPlayer, "dailyHousePackup");
			dailyHousePacking++;
			setObjVar (objPlayer, "dailyHousePackup", dailyHousePacking);
		}
		//grant badge after 10 blown up houses
		if (!badge.hasBadge (objPlayer, "house_packup_badge"))
		{
			int[] packupObjVar = getIntArrayObjVar (objPlayer, "housePackup");

			if (packupObjVar != null && packupObjVar.length > 0)
			{
				if (packupObjVar[1] >= player_structure.NUM_NEEDED_PACKUP_FIRST_BADGE)
				{
					badge.grantBadge (objPlayer, "house_packup_badge");
				}
			}
		}
		if (badge.hasBadge (objPlayer, "house_packup_badge"))
		{
			if (!badge.hasBadge (objPlayer, "house_packup_badge_master"))
			{
				int[] packupObjVar = getIntArrayObjVar (objPlayer, "housePackup");

				if (packupObjVar != null && packupObjVar.length > 0)
				{
					if (packupObjVar[1] >= player_structure.NUM_NEEDED_PACKUP_SECOND_BADGE)
					{
						badge.grantBadge (objPlayer, "house_packup_badge_master");
					}
				}
			}
		}
	}
	//decreasing current points because the player is buying something
	else
	{
		//current points[0]
		int [] housePacking = new int [utils.HOUSE_MAX];

		housePacking = getIntArrayObjVar (objPlayer, "housePackup");
		//validate
		if (housePacking.length != utils.HOUSE_MAX)
			return;
		//decrease current points counter by 1
		housePacking[0]--;
		setObjVar (objPlayer, "housePackup", housePacking);
	}
}

//checks to see if we are on the floor of a building and not in a container,player, or other weird place
boolean isInHouseCellSpace(obj_id object)
{
	if(isIdValid(object))
	{
		//are we in a player
		if(isNestedWithinAPlayer(object))
			return false;

		//top object is a building
		obj_id house = getTopMostContainer(object);
		if(isIdValid(house) && !player_structure.isBuilding(house))
			return false;

		obj_id container = getContainedBy(object);
		if(isIdValid(container) && (getContainedBy(container) != house))
			return false;

		//I am not in a cave or public structure
		if(!hasObjVar(house, "player_structure.admin.adminList"))
			return false;

		return true;
	}

	return false;
}

//quick check to see if player has any of the named resource type in inventory
//returns true the first time it finds any of the passed in resource in inventory
boolean hasResourceInInventory(obj_id player, string resource)
{
	if(!isIdValid(player))
		return false;

	if(resource == null || resource == "")
		return false;

	obj_id[] contents = getFilteredPlayerContents(player);
	if ( (contents == null) || (contents.length == 0))
		return false;

	for ( int n = 0; n < contents.length; n++ )
	{
		int got = getGameObjectType(contents[n]);
		if ( isGameObjectTypeOf(got, GOT_resource_container) )
		{
			obj_id resourceCrate = contents[n];
			if ( isIdValid(resourceCrate) )
			{
				obj_id resourceId = getResourceContainerResourceType(resourceCrate);
				if ( isIdValid(resourceId) )
				{
					if ( isResourceDerivedFrom(resourceId, resource) )
						return true;

				}
			}
		}
	}
	return false;
}

obj_id[] validateObjIdArray(obj_id[] source)
{
	resizeable obj_id[] target = new obj_id[0];

	for(int i = 0; i < source.length; i++)
	{
		if(isIdValid(source[i]) && exists(source[i]))
		{
			addElement(target, source[i]);
		}
	}

	source = target;

	return source;
}

obj_id[] getPlayersInBuildoutRow(obj_id player)
{
	location loc = getLocation(player);
	return getPlayersInBuildoutRow(loc.area, locations.getBuildoutAreaRow(player));
}

obj_id[] getPlayersInBuildoutDimensions(string scene, float x1, float x2, float z1, float z2)
{
	float centX = Math.abs((x2 - x1) / 2.0f) + x1;
	float centZ = Math.abs((z2 - z1) / 2.0f) + z1;

	location centerLoc = new location(centX, 0.0f, centZ, scene);
	location lowerLeft = new location(x1, 0.0f, z1, scene);

	float hypotenuse = getDistance(centerLoc, lowerLeft);

	obj_id[] allPlayers = getAllPlayers(centerLoc, hypotenuse * 3.0f);

	resizeable obj_id[] playersInArea = new obj_id[0];

	if(allPlayers == null || allPlayers.length == 0)
	{
		return null;
	}

	for(int i = 0; i < allPlayers.length; i++)
	{
		location loc = getLocation(trial.getTop(allPlayers[i]));

		if(loc.x < x1 || loc.x > x2 || loc.z < z1 || loc.z > z2)
		{
			LOG("doLogging", ""+loc.x+" vs: "+x1+", "+x2+" and "+loc.z+" vs: "+z1+", "+z2);
			continue;
		}

		utils.addElement(playersInArea, allPlayers[i]);
	}

	if(playersInArea == null || playersInArea.length == 0)
		return null;

	return playersInArea;
}

dictionary getCoordinatesInBuildoutRow(string scene, int buildout_row)
{
	string datatable = "datatables/buildout/areas_"+scene+".iff";
	dictionary data = dataTableGetRow(datatable, buildout_row);

	return data;
}

obj_id[] getPlayersInBuildoutRow(string scene, int buildout_row)
{
	string datatable = "datatables/buildout/areas_"+scene+".iff";
	dictionary data = dataTableGetRow(datatable, buildout_row);

	return getPlayersInBuildoutDimensions(scene, data.getFloat("x1"), data.getFloat("x2"), data.getFloat("z1"), data.getFloat("z2"));
}

obj_id[] getPlayersInBuildoutArea(string scene, string buildout_area)
{
	string datatable = "datatables/buildout/areas_"+scene+".iff";
	int rowNum = dataTableSearchColumnForString(buildout_area, 0, datatable);

	if(rowNum == -1)
		return null;

	return getPlayersInBuildoutRow(scene, rowNum);
}

obj_id[] getAllNpcInBuildoutArea(obj_id baseObject)
{
	location loc = getLocation(baseObject);
	int buildout_area = locations.getBuildoutAreaRow(baseObject);

	obj_id[] allObjects =  getAllObjectsInBuildoutArea(loc.area, buildout_area);

	if (allObjects == null || allObjects.length == 0)
		return null;

	resizeable obj_id[] allNpc = new obj_id[0];


	for (int i=0;i<allObjects.length;i++)
	{
		if (!isMob(allObjects[i]))
			continue;

		allNpc.add(allObjects[i]);
	}

	if (allNpc == null || allNpc.length == 0)
		return null;

	allObjects = allNpc;
	return allObjects;
}

obj_id[] getAllObjectsInBuildoutArea(obj_id baseObject)
{
	location loc = getLocation(baseObject);
	int buildout_row = locations.getBuildoutAreaRow(baseObject);

	return getAllObjectsInBuildoutArea(loc.area, buildout_row);
}

obj_id[] getAllObjectsInBuildoutArea(string scene, int buildout_row)
{
	string datatable = "datatables/buildout/areas_"+scene+".iff";
	dictionary data = dataTableGetRow(datatable, buildout_row);

	float x1 = data.getFloat("x1");
	float x2 = data.getFloat("x2");
	float z1 = data.getFloat("z1");
	float z2 = data.getFloat("z2");

	float centX = Math.abs((data.getFloat("x2") - data.getFloat("x1")) / 2.0f) + data.getFloat("x1");
	float centZ = Math.abs((data.getFloat("z2") - data.getFloat("z1")) / 2.0f) + data.getFloat("z1");

	location centerLoc = new location(centX, 0.0f, centZ, scene);
	location lowerLeft = new location(data.getFloat("x1"), 0.0f, data.getFloat("z1"), scene);

	float hypotenuse = getDistance(centerLoc, lowerLeft);

	obj_id[] allObjects = getObjectsInRange(centerLoc, hypotenuse * 3.0f);

	resizeable obj_id[] objectsInArea = new obj_id[0];

	if (allObjects == null || allObjects.length == 0)
		return null;

	for (int i=0;i<allObjects.length;i++)
	{
		location testLoc = getLocation(trial.getTop(allObjects[i]));
		if (testLoc.x < x1 || testLoc.x > x2 || testLoc.z < z1 || testLoc.z > z2)
			continue;

		objectsInArea.add(allObjects[i]);

	}

	if (objectsInArea == null || objectsInArea.length == 0)
		return null;

	return objectsInArea;

}


Vector shuffleArray(Vector list)
{
	Vector newList = new Vector();

	for(int size = list.size();size > 0;size--)
	{

		int i = rand(0, (size - 1));

		newList = utils.addElement(newList, list.get(i));
		list = utils.removeElementAt(list, i);
	}

	if(newList == null || newList.size() == 0)
		return null;

	return newList;

}

//used for granting xmas gifts in past via dropping in players inventories on login
//each year increment the constants if you want to use this, last used 2006
boolean grantGift(obj_id player)
{
	//check character age if they are less than 10 days no joy
	if( (getCurrentBirthDate() - getPlayerBirthDate(player))  < 10 )
		return false;

	// Check to see if the player has already gotten presents
	if ( hasObjVar(player, XMAS_RECEIVED_VI1))
		return false;

	if (!isIdValid(player))
		return false;

	string config = getConfigSetting("GameServer", "grantGift");
	if (config != null)
	{
		if (config.equals("false"))
			return false;
	}

	if	(isInTutorialArea(player))
	{
		setObjVar(player, XMAS_NOT_RECEIVED_TUTORIAL, 1);
		CustomerServiceLog("grantGift", getFirstName(player) + "(" + player + ") did not receive Christmas '06 gift because they logged in on the tutorial planet.");
		return false;
	}

	//you are no longer in tutorial give them presents when they leave
	removeObjVar(player, XMAS_NOT_RECEIVED_TUTORIAL);

	obj_id inv = utils.getInventoryContainer(player);
	if (!isIdValid(inv))
	{
		CustomerServiceLog("grantGift", getFirstName(player) + "(" + player + ") did not have an inventory container. Didn't receive Christmas '06 gift, but not blocked from future attempt.");
		return false;
	}

	obj_id giftSelf= static_item.createNewItemFunction( "item_lifeday_gift_self_01_02", inv);

	obj_id giftOther= static_item.createNewItemFunction( "item_lifeday_gift_other_01_02", inv);
	setObjVar(giftOther, LIFEDAY_OWNER, player);

	// Mark the player has having gotten the item
	utils.sendMail(GIFT_GRANTED_SUB, GIFT_GRANTED, player, "System");
	setObjVar(player, XMAS_RECEIVED_VI1, 1);
	CustomerServiceLog("grantGift", getFirstName(player) + "(" + player + ") has received his Christmas '06 gift.");

	return true;
}

void fullExpertiseReset(obj_id player, boolean storeBeast)
{
	//need to store beasts
	if(storeBeast)
	{
		if(beast_lib.isBeastMaster(player))
			beast_lib.storeBeasts(player);
	}
	//drop the stance/focus buff if we are a jedi
	if(utils.isProfession(player, utils.FORCE_SENSITIVE))
	{
		if(buff.isInStance(player))
			buff.removeBuff(player, jedi.JEDI_STANCE);

		if(buff.isInFocus(player))
			buff.removeBuff(player, jedi.JEDI_FOCUS);
	}
	//set the version number
	respec.setRespecVersion(player);

	//clear buffs
	buff.removeAllBuffs(player, false, true);

	//reset the expertise
	resetExpertises(player);
}

//Used to get all the passengers in all the slots of vehicles
//this will not get the riderId, it only checks for passengers
obj_id[] getAllRidersInVehicle(obj_id player, obj_id vehicle)
{
	//validate our data
	if(!isIdValid(player) || !isIdValid(vehicle))
		return null;
	if(!exists(player) || !exists(vehicle))
		return null;

	//create our temporary array for holding data
	 resizeable obj_id[] resizeList = new obj_id[0];

	//we are going to assume that we dont have more than 25 passengers
	for(int i = 1; i <= 25; ++i)
	{
		//lets attempt to get the obj_id of rider in this slot
		obj_id tempRider = getObjectInSlot(vehicle, "rider"+i);

		//if it is an invalid Id we need to keep going
		if(!isIdValid(tempRider) || !exists(tempRider))
			continue;

		//if the id is valid, lets add it to the list.
		resizeList = addElement(resizeList, tempRider);
	}

	//lets return our list of passengers. This list could be zero length, if we had no passengers
	//so be sure to check for null or 0 length where you are calling this function
	return resizeList;
}

/*
retroactively fix up CTS stuff
*/
void updateCTSObjVars(obj_id player)
{
	if (!isIdValid(player) || !exists(player))
		return;

	boolean retrievedCtsOjbvars = false;
	dictionary[] ctsOjbvars = null;

	//check to see if they have already done this update
	string updateObjvar = utils.CTS_OBJVAR_HISTORY + ".1";
	if (!hasObjVar(player, updateObjvar))
	{
		if ((ctsOjbvars == null) && !retrievedCtsOjbvars)
		{
			ctsOjbvars = getCharacterRetroactiveCtsObjvars(player);
			retrievedCtsOjbvars = true;
		}

		if ((ctsOjbvars != null) && (ctsOjbvars.length > 0))
		{
			utils.updateRespecCTSObjvars(player, ctsOjbvars);
			utils.updateBeastMasterCTSObjvars(player, ctsOjbvars);
		}

		setObjVar(player, updateObjvar, 1);
	}

	//check to see if they have already done this update
	updateObjvar = utils.CTS_OBJVAR_HISTORY + ".2";
	if (!hasObjVar(player, updateObjvar))
	{
		if ((ctsOjbvars == null) && !retrievedCtsOjbvars)
		{
			ctsOjbvars = getCharacterRetroactiveCtsObjvars(player);
			retrievedCtsOjbvars = true;
		}

		if ((ctsOjbvars != null) && (ctsOjbvars.length > 0))
		{
			utils.updateHousePackupCTSObjvars(player, ctsOjbvars);
		}

		setObjVar(player, updateObjvar, 1);
	}

/* template for for future CTS objvar migrations
	//check to see if they have already done this update
	updateObjvar = utils.CTS_OBJVAR_HISTORY + ".3";
	if (!hasObjVar(player, updateObjvar))
	{
		if ((ctsOjbvars == null) && !retrievedCtsOjbvars)
		{
			ctsOjbvars = getCharacterRetroactiveCtsObjvars(player);
			retrievedCtsOjbvars = true;
		}

		if ((ctsOjbvars != null) && (ctsOjbvars.length > 0))
		{
			utils.updateXXXXXCTSObjvars(player, ctsOjbvars);
			utils.updateYYYYYCTSObjvars(player, ctsOjbvars);
			utils.updateZZZZZCTSObjvars(player, ctsOjbvars);
		}

		setObjVar(player, updateObjvar, 1);
	}
*/
}

/*
retroactively fix up CTS stuff relating to the respec objvars
*/
void updateRespecCTSObjvars(obj_id player, dictionary[] ctsOjbvars)
{
	if (!isIdValid(player) || !exists(player))
		return;

	if ((ctsOjbvars == null) || (ctsOjbvars.length <= 0))
		return;

	// use the higher of respecsBought objvar from the most recent
	// tranfer or the current respecsBought objvar on the character
	const int indexMostRecentTransfer = ctsOjbvars.length - 1;
	if ((ctsOjbvars[indexMostRecentTransfer] != null) && ctsOjbvars[indexMostRecentTransfer].containsKey("respecsBought") && ctsOjbvars[indexMostRecentTransfer].isInt("respecsBought"))
	{
		const int respecsBoughtFromTransfer = ctsOjbvars[indexMostRecentTransfer].getInt("respecsBought");
		int respecsBoughtCurrentValue = 0;
		if (hasObjVar(player, "respecsBought"))
			respecsBoughtCurrentValue = getIntObjVar(player, "respecsBought");

		if (respecsBoughtFromTransfer > respecsBoughtCurrentValue)
		{
			CustomerServiceLog("CharacterTransferRetroactiveHistory", "changing respecsBought objvar for " + player + " from " + respecsBoughtCurrentValue + " to " + respecsBoughtFromTransfer);
			setObjVar(player, "respecsBought", respecsBoughtFromTransfer);
		}
	}

	// for each of the value of the playerRespec.levelArrayComEntCra objvar,
	// use the higher value from the highest value from all the transfers
	// or the current value on the character
	int[] recpecLevelsFromTransfer = {-1, -1, -1};
	for (int i = 0; i < ctsOjbvars.length; ++i)
	{
		if ((ctsOjbvars[i] != null) && ctsOjbvars[i].containsKey(respec.PROF_LEVEL_ARRAY) && ctsOjbvars[i].isIntArray(respec.PROF_LEVEL_ARRAY))
		{
			int[] levelArray = ctsOjbvars[i].getIntArray(respec.PROF_LEVEL_ARRAY);
			if ((levelArray != null) && (levelArray.length == 3))
			{
				if (levelArray[0] > recpecLevelsFromTransfer[0])
					recpecLevelsFromTransfer[0] = levelArray[0];

				if (levelArray[1] > recpecLevelsFromTransfer[1])
					recpecLevelsFromTransfer[1] = levelArray[1];

				if (levelArray[2] > recpecLevelsFromTransfer[2])
					recpecLevelsFromTransfer[2] = levelArray[2];
			}
		}
	}

	if ((recpecLevelsFromTransfer[0] > -1) || (recpecLevelsFromTransfer[1] > -1) || (recpecLevelsFromTransfer[2] > -1))
	{
		int[] recpecLevelsCurrentValue = {-1, -1, -1};
		if (hasObjVar(player, respec.PROF_LEVEL_ARRAY))
			recpecLevelsCurrentValue = getIntArrayObjVar(player, respec.PROF_LEVEL_ARRAY);

		if ((recpecLevelsCurrentValue != null) && (recpecLevelsCurrentValue.length == 3))
		{
			int[] recpecLevelsNewValue = {-1, -1, -1};
			recpecLevelsNewValue[0] = Math.max(recpecLevelsCurrentValue[0], recpecLevelsFromTransfer[0]);
			recpecLevelsNewValue[1] = Math.max(recpecLevelsCurrentValue[1], recpecLevelsFromTransfer[1]);
			recpecLevelsNewValue[2] = Math.max(recpecLevelsCurrentValue[2], recpecLevelsFromTransfer[2]);

			if ((recpecLevelsNewValue[0] != recpecLevelsCurrentValue[0]) || (recpecLevelsNewValue[1] != recpecLevelsCurrentValue[1]) || (recpecLevelsNewValue[2] != recpecLevelsCurrentValue[2]))
			{
				CustomerServiceLog("CharacterTransferRetroactiveHistory", "changing " + respec.PROF_LEVEL_ARRAY + " objvar for " + player + " from (" + recpecLevelsCurrentValue[0] + "," + recpecLevelsCurrentValue[1] + "," + recpecLevelsCurrentValue[2] + ") to (" + recpecLevelsNewValue[0] + "," + recpecLevelsNewValue[1] + "," + recpecLevelsNewValue[2] + ")");
				setObjVar(player, respec.PROF_LEVEL_ARRAY, recpecLevelsNewValue);
			}
		}
	}

	//lets make sure that our current template is the right level
	if (hasObjVar(player, respec.PROF_LEVEL_ARRAY))
	{
		//get the current tempalte of the player
		string skillTemplate = getSkillTemplate(player);
		//get the respec history values
		int[] recpecLevelsValue = getIntArrayObjVar(player, respec.PROF_LEVEL_ARRAY);

		if ((skillTemplate != null) && (skillTemplate.length() > 0) && (recpecLevelsValue != null) && (recpecLevelsValue.length == 3))
		{
			//get the current level
			int currentLevel = getLevel(player);

			//if you are not an entertainer or trader, you are a combat toon
			if (!skillTemplate.startsWith("entertainer") && !skillTemplate.startsWith("trader"))
			{
				//get respec history combat level
				int combatLevel = recpecLevelsValue[respec.PROF_LEVEL_COMBAT];
				//if current level is lower than respec history combat level
				//we need to level the player up to the historical level
				if(currentLevel < combatLevel)
					respec.autoLevelPlayer(player, combatLevel, true);
			}
			//are you an entertainer?
			else if (skillTemplate.startsWith("entertainer"))
			{
				//get respec history entertainer level
				int entLevel = recpecLevelsValue[respec.PROF_LEVEL_ENT];

				//if current level is lower than respec history entertainer level
				//we need to level the player up to the historical level
				if(currentLevel < entLevel)
					respec.autoLevelPlayer(player, entLevel, true);
			}
			//are you an trader?
			else if (skillTemplate.startsWith("trader"))
			{
				//get respec history trader level
				int traderLevel = recpecLevelsValue[respec.PROF_LEVEL_TRADER];

				//if current level is lower than respec history trader level
				//we need to level the player up to the historical level
				if(currentLevel < traderLevel)
					respec.autoLevelPlayer(player, traderLevel, true);
			}
		}
	}
}

/*
retroactively fix up CTS stuff relating to the beast master ability objvar
*/
void updateBeastMasterCTSObjvars(obj_id player, dictionary[] ctsOjbvars)
{
	if (!isIdValid(player) || !exists(player))
		return;

	if ((ctsOjbvars == null) || (ctsOjbvars.length <= 0))
		return;

	// merge the values of the beast_master.known_skills objvars
	// from all the previous transfers with the current values
	HashSet abilities = new HashSet();

	// compile the list of abilities frm all previous transfers
	for (int i = 0; i < ctsOjbvars.length; ++i)
	{
		if (ctsOjbvars[i] != null)
		{
			int j = 0;
			while (true)
			{
				const String objVarName = beast_lib.PLAYER_KNOWN_SKILLS_LIST + "." + j;
				if (ctsOjbvars[i].containsKey(objVarName) && ctsOjbvars[i].isIntArray(objVarName))
				{
					const int[] objVarValue = ctsOjbvars[i].getIntArray(objVarName);
					if ((objVarValue != null) && (objVarValue.length > 0))
					{
						for (int k = 0; k < objVarValue.length; ++k)
						{
							abilities.add(new Integer(objVarValue[k]));
						}
					}

					++j;
				}
				else
				{
					break;
				}
			}
		}
	}

	if (!abilities.isEmpty())
	{
		// get current abilities
		resizeable int[] abilitiesCurrent = utils.getResizeableIntBatchObjVar(player, beast_lib.PLAYER_KNOWN_SKILLS_LIST);

		boolean updateRequired = false;
		if ((abilitiesCurrent == null) || (abilitiesCurrent.length <= 0))
		{
			updateRequired = true;
		}
		else
		{
			// make sure there are no dupes in the current abilities
			HashSet abilitiesCurrentNoDupes = new HashSet();
			for (int i = 0; i < abilitiesCurrent.length; ++i)
			{
				abilitiesCurrentNoDupes.add(new Integer(abilitiesCurrent[i]));
			}

			// merge current abilities with those from previous transfers
			Iterator abilitiesIterator = abilitiesCurrentNoDupes.iterator();
			while (abilitiesIterator.hasNext())
			{
				Integer ability = (Integer)abilitiesIterator.next();
				abilities.add(ability);
			}

			// if there is at least one ability from all the previous transfers
			// that the player currently doesn't have, we need to update the
			// player's current abilities to include the missing abilities
			if (abilities.size() != abilitiesCurrentNoDupes.size())
			{
				updateRequired = true;
			}
		}

		if (updateRequired)
		{
			int[] abilitiesNew = new int[abilities.size()];
			Iterator abilitiesIterator = abilities.iterator();
			string strAbilitiesNew = new string();
			int i = 0;
			while (abilitiesIterator.hasNext() && (i < abilitiesNew.length))
			{
				Integer ability = (Integer)abilitiesIterator.next();
				abilitiesNew[i] = ability.intValue();
				strAbilitiesNew += "" + abilitiesNew[i] + ", ";

				++i;
			}

			string strAbilitiesCurrent = new string();
			if ((abilitiesCurrent != null) && (abilitiesCurrent.length > 0))
			{
				for (int j = 0; j < abilitiesCurrent.length; ++j)
				{
					strAbilitiesCurrent += "" + abilitiesCurrent[j] + ", ";
				}
			}

			CustomerServiceLog("CharacterTransferRetroactiveHistory", "changing " + beast_lib.PLAYER_KNOWN_SKILLS_LIST + " objvar for " + player + " from (" + strAbilitiesCurrent + ") to (" + strAbilitiesNew + ")");

			utils.setBatchObjVar(player, beast_lib.PLAYER_KNOWN_SKILLS_LIST, abilitiesNew);
		}
	}
}

/*
retroactively fix up CTS stuff relating to the house packup objvars
*/
void updateHousePackupCTSObjvars(obj_id player, dictionary[] ctsOjbvars)
{
	if (!isIdValid(player) || !exists(player))
		return;

	if ((ctsOjbvars == null) || (ctsOjbvars.length <= 0))
		return;

	// add all the values of the housePackup objvars from all the
	// previous transfers to the current values on the character
	int[] housePackupNewValues = {0, 0};
	for (int i = 0; i < ctsOjbvars.length; ++i)
	{
		if ((ctsOjbvars[i] != null) && ctsOjbvars[i].containsKey(player_structure.HOUSE_PACKUP_ARRAY_OBJVAR) && ctsOjbvars[i].isIntArray(player_structure.HOUSE_PACKUP_ARRAY_OBJVAR))
		{
			int[] housePackupCTSValues = ctsOjbvars[i].getIntArray(player_structure.HOUSE_PACKUP_ARRAY_OBJVAR);
			if ((housePackupCTSValues != null) && (housePackupCTSValues.length == 2))
			{
				if (housePackupCTSValues[0] > 0)
					housePackupNewValues[0] += housePackupCTSValues[0];

				if (housePackupCTSValues[1] > 0)
					housePackupNewValues[1] += housePackupCTSValues[1];
			}
		}
	}

	if ((housePackupNewValues[0] > 0) || (housePackupNewValues[1] > 0))
	{
		int[] housePackupCurrentValues = {0, 0};
		if (hasObjVar(player, player_structure.HOUSE_PACKUP_ARRAY_OBJVAR))
			housePackupCurrentValues = getIntArrayObjVar(player, player_structure.HOUSE_PACKUP_ARRAY_OBJVAR);

		if ((housePackupCurrentValues != null) && (housePackupCurrentValues.length == 2))
		{
			housePackupNewValues[0] += housePackupCurrentValues[0];
			housePackupNewValues[1] += housePackupCurrentValues[1];

			CustomerServiceLog("CharacterTransferRetroactiveHistory", "changing " + player_structure.HOUSE_PACKUP_ARRAY_OBJVAR + " objvar for " + player + " from (" + housePackupCurrentValues[0] + ", " + housePackupCurrentValues[1] + ") to (" + housePackupNewValues[0] + ", " + housePackupNewValues[1] + ")");
			setObjVar(player, player_structure.HOUSE_PACKUP_ARRAY_OBJVAR, housePackupNewValues);
		}
	}
}
//Will return the status of a player in the following formats:
//If the player is online it will display: "Online <PlanetName>: <RegionName>, <CityName>
//If the player is offline it will display: "Offline <days>:<hours>:<minutes>:<seconds>
//If the obj_id is not a player it will return "Deleted"
string getOnlineOfflineStatus(obj_id player)
{
	string returnData = "";

	if(!isPlayer(player))
	{
		    returnData = "Deleted";
	}
	else if(!isPlayerConnected(player))
	{
		int lastLoginTime = getPlayerLastLoginTime(player);

		if(lastLoginTime > 0)
		{
			int timeDifference = getCalendarTime() - lastLoginTime;

			if(timeDifference > 0)
			{
				returnData = "Offline " + utils.padTimeDHMS(timeDifference);
			}
			else
			{
				returnData = "Offline ????d:??h:??m:??s";
			}
		}
		else
		{
			returnData = "Unknown";
		}
	}
	else
	{
		string locText = "Unknown";
		dictionary playerLoc = getConnectedPlayerLocation(player);

		//failed base call - bail
		if(playerLoc == null)
		{
			return locText;
		}

		string planet = playerLoc.getString("planet");

		if(planet != null && planet.length() > 0)
		{
			locText = localize(new string_id("planet_n", planet));
		}

		string region = playerLoc.getString("region");

		if(region != null && region.length() > 0)
		{
			locText += ": " + localize(new string_id(region.substring(1, region.indexOf(":")), region.substring(region.indexOf(":") + 1, region.length())));
		}

		string city = playerLoc.getString("playerCity");

		if(city != null && city.length() > 0)
		{
			locText += ", " + city;
		}

		returnData = "Online " + locText;
	}
	return returnData;
}

string localizeSIDString(string text)
{
	if(text == null || text.length() < 1)
	{
		return null;
	}

	int left = 0;

	if(text.startsWith("@"))
	{
		left = 1;
	}

	if(text.indexOf(":") < 0)
	{
		return text;
	}

	return localize(new string_id(text.substring(left, text.indexOf(":")), text.substring(text.indexOf(":") + 1, text.length())));
}

//function to set the color on an object. Usually called from trigger OnCustomizeFinished
//the trigger fires on the player who uses the UI generated from openCustomizationWindow
boolean colorizeItemFromWidget(obj_id player, obj_id item, string params)
{

	if(!isValidId(player) || !exists(player))
	{
		return false;
	}
	if(!isValidId(item) || !exists(item))
	{
		utils.removeScriptVar(player, "veteranRewardItemColor.color_setting");
		return false;
	}

	if(params == null || params.equals(""))
	{
		utils.removeScriptVar(player, "veteranRewardItemColor.color_setting");
		return false;
	}

	string[] colorArray = split(params, ' ');
	if(colorArray == null || colorArray.length <= 0)
	{
		utils.removeScriptVar(player, "veteranRewardItemColor.color_setting");
		return false;
	}

	for(int i = 0; i < colorArray.length; i+=2)
	{
		if(colorArray[i] == null || colorArray[i].equals(""))
			break;//if a blank entry is found bail out.
		hue.setColor(item, colorArray[i], utils.stringToInt(colorArray[i+1]));
	}
	utils.removeScriptVar(player, "veteranRewardItemColor.color_setting");
	return true;
}

/*
* Validates number of skills on an item
* Validates the stat ranges on an item
*
*
*
*
*/
boolean validateSkillModsAttached(obj_id item)
{
	return true;
}

int getNumCreaturesForSpawnLimit()
{
	// the following formula is also duplicated in GameServerMetricsData.cpp::updateData()
	const int intNumCreatures = getNumAI() - (getNumHibernatingAI() / 2);
	if (intNumCreatures <= 0)
		return 0;

	return intNumCreatures;
}

