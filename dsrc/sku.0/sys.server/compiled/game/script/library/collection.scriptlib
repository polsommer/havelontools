/**
 * Copyright (c)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        collection.scriptlib
 * Description:  required script for player collections
 * @author       $Author:$
 * @version      $Revision:$
 */

/***** INCLUDES ********************************************************/
include java.util.HashSet;
include library.badge;
include library.buff;
include library.gcw;
include library.groundquests;
include library.prose;
include library.skill;
include library.static_item;
include library.stealth;
include library.sui;
include library.utils;
include library.xp;
/***** CONSTANTS *******************************************************/
//strings
const string COLLECTION_REWARD_TABLE			= "datatables/collection/rewards.iff";
const string COLLECTION_TABLE				= "datatables/collection/collection.iff";
const string COLLECTION_NPC_TABLE 			= "datatables/collection/collection_npc.iff";
const string QUEST__COMPLETED_COLLECTIONS		= "datatables/collection/quest_completion_collections.iff";
const string COL_NPC_PID				= "collection_npc";
const string CONSUME_PID_NAME				= "collectionConsume";
const string REWARD_ON_UPDATE_CATEGORY			= "rewardOnUpdate";
const string REWARD_ON_COMPLETE_CATEGORY		= "rewardOnComplete";
const string CLEAR_ON_COMPLETE				= "clearOnComplete";
const string CATEGORY_PREREQ_MET			= "grantIfPreReqMet";
const string CATEGORY_UPDATE_ON_COUNT			= "updateOnCount";
const string NO_MESSAGE_CATEGORY			= "noMessage";
const string CRAFTING_TEMPLATE				= "crafting_template";
const string OBJVAR_SLOT_NAME				= "collection.slotName";
const string OBJVAR_PAGE_NAME				= "collection.pageName";
const string ENT_BUFF_COLLECTION_01			= "col_entertainer_01";
const string COL_BUFF_TRACKER				= "collection.buffTracker";
const string COL_HEROIC_SD_TAXI_SERVICE			= "heroic_sd_taxi_service_01";
const string COL_HEROIC_SD_SMUGGLE_OBJVAR		= "collection.heroic_sd_smuggle_timer";
const string COL_SLOT_SMUGGLE_GROUPS			= "smuggled_groups";
const string COL_BUFF_ARRAY				= "collection.buffTracker";
const string AUTO_STACK_SCRIPT				= "object.autostack";
const string CATEGORY_NUM_ALT_TITLES			= "numAltTitles";


//bools
const boolean LOGGING_ENABLED				= true;

//floats
const float MAX_HATE_RADIUS_ON_CLICK_COL		= 15.0f;

//ints
const int MAXLOOP 					= 7;
const int REQUIRED_TIME_LAPSE				= 21600;
//Collections
const int CONST_ROLL_CHANCE				= 50;

//Collection - Resources
const int CONST_RESOURCE_ROLL				= 4;
const string PRISTINE_MEAT				= "col_pristine_meat_02_01";
const string PRISTINE_HIDE				= "col_pristine_hide_02_01";
const string PRISTINE_BONE				= "col_pristine_bone_02_01";
const string PRISTINE_EGG				= "col_pristine_egg_02_01";
const string PRISTINE_MILK				= "col_pristine_milk_02_01";


//string Ids
const string_id SID_REWARD_XP				= new string_id("collection","reward_xp_amount");
const string_id SID_REWARD_ITEM				= new string_id("collection","reward_item");
const string_id SID_REWARD_SKILL_MOD			= new string_id("collection","reward_skill_mod");
const string_id SID_SLOT_INCREMENT			= new string_id("collection","player_slot_increment");
const string_id SID_SYS_NO_COMBAT			= new string_id("collection","click_not_combat");
const string_id SID_SYS_NO_MOUNT			= new string_id("collection","click_not_mounted");
const string_id SID_SYS_NO_DEAD_INCAP			= new string_id("collection","click_not_dead_incap");
const string_id SID_NEED_TO_ACTIVATE_COLLECTION		= new string_id("collection", "need_to_activate_collection");
const string_id SID_MAX_ACTIVE				= new string_id("collection", "max_active_collections");
const string_id COMPLETE_COLLECTION_CAN_NOT_CLEAR 	= new string_id("collection", "collection_complete_can_not_clear");
const string_id COLLECTION_CLEARED		 	= new string_id("collection", "collection_cleared");
const string_id SID_SYS_QUEST_INCORRECT			= new string_id("collection", "collection_quest_wrong");
const string SUI_DELETE_TITLE			 	= "@collection:collection_sui_delete_title";
const string SUI_DELETE_PROMPT			 	= "@collection:collection_sui_delete_prompt";
const string COL_NPC_PROMPT 				= "@collection:col_npc_prompt";//The Nexus Collector has the following collections available at this time.\nYou can activate 2 collections at a time.
const string COL_NPC_TITLE 				= "@collection:col_npc_title";//Nexus Collector
const string_id SID_COLLECTION_RESET			= new string_id("collection","player_collection_reset");
const string_id UPDATED_ENTERTAINER_COLLECTION 		= new string_id("collection", "update_entertainer");
const string_id SUCCESSFUL_SMUGGLE_ATTEMPT		= new string_id("collection", "successful_smuggle_attempt");
const string_id SMUGGLE_ATTEMPT_TIME_ISSUE		= new string_id("collection", "smuggle_attempt_time_issue");
const string_id DRIVING_SOROSUUB			= new string_id("collection", "driving_sorosuub");
const string_id STILL_HAS_TAXI_BUFF			= new string_id("collection", "still_has_taxi_buff");
const string_id SID_ALREADY_FINISHED_COLLECTION		= new string_id("collection", "already_finished_collection");
const string_id SID_NOT_CLOSE_ENOUGH			= new string_id("collection", "not_close_enough");
const string_id SID_ALREADY_HAVE_SLOT			= new string_id("collection", "already_have_slot");
const string_id SID_REPORT_CONSUME_ITEM_FAIL		= new string_id("collection", "report_consume_item_fail");

//Ice Cream Fryer data
const string[] ICE_CREAM_BUFF_ARRAY 			=
							{
								"item_ice_cream_buff_debuff_01_01",
								"item_ice_cream_buff_forage_buff_01_01",
								"item_ice_cream_buff_health_01_01",
								"item_ice_cream_buff_action_01_01",
								"item_ice_cream_buff_xp_bonus_01_01",
								"item_ice_cream_buff_remove_weakened_01_01",
								"item_ice_cream_buff_remove_debuff_01_01",
								"item_ice_cream_buff_action_reduction_01_01"
							};

const string FRYER_BUFF_TYPE 				= "ice_cream_category";
const int ICE_CREAM_ALL_PLAYERS				= 0;
const int ICE_CREAM_DOMESTICS_ONLY			= 1;
const int MAX_RANGE_TO_COLLECT				= 5;

//used for logging.
void blog (string identifier, string text)
{
	if(LOGGING_ENABLED)
	{
		LOG(identifier, text);
	}
}

boolean grantCollectionReward(obj_id player, string collectionName, boolean canResetCollection)
{
	if(!isIdValid(player) || !exists(player))
		return false;
	if(collectionName == null || collectionName.equals(""))
		return false;

	int row = dataTableSearchColumnForString(collectionName, "collection_name", COLLECTION_REWARD_TABLE);

	if(row < 0)
	{
		//This means we have a collection with no row in the rewards table
		blog("COLLECTIONS", "collection with no entry in rewards table. Collection name is " + collectionName);

		return false;
	}

	dictionary dict = dataTableGetRow(COLLECTION_REWARD_TABLE, row);

	if(dict == null || dict.isEmpty())
		return false;

	string slotName = dict.getString("slot_name");
	string quest = dict.getString("quest");
	string item = dict.getString("item");
	string command = dict.getString("command");
	string skillMod = dict.getString("skill_mod");
	string questSignal = dict.getString("quest_signal");
	int grantRandom = dict.getInt("grantRandomItem");
	int grantWeightedRandom = dict.getInt("grantWeightedRandom");
	int itemIncrement = dict.getInt("stackAmount");

	prose_package pp = new prose_package();

	if(slotName != null && !slotName.equals(""))
	{
		//grant them the badges
		string[] badges = split(slotName, ',');
		blog("COLLECTIONS", "badges.length: " + badges.length + " badges[0]: " + badges[0]);
		for(int i = 0; i < badges.length; ++i)
		{
			string[] info = getCollectionSlotInfo(badges[i]);
			if ((info != null) || (info.length == COLLECTION_INFO_ARRAY_SIZE) || (info[COLLECTION_INFO_INDEX_BOOK] != null))
			{
				if(info[COLLECTION_INFO_INDEX_BOOK].equals("badge_book"))
				{
					badge.grantBadge(player, badges[i]);
				}
				else
				{
					modifyCollectionSlotValue(player, badges[i], 1);
				}
			}
			else
			{
				//blog("COLLECTIONS", "INFO NOT WORKING");
			}
		}
		CustomerServiceLog("CollectionComplete: ", "Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " and was granted Slot" + slotName + ".");
	}

	int xpAmount = 0;
	boolean spaceType = false;

	int isSpaceXP = dataTableGetInt(collection.COLLECTION_REWARD_TABLE, collectionName, "is_space_xp");

	if(isSpaceXP == 1)
	{
		spaceType = true;
		xpAmount = xp.grantCollectionSpaceXP(player, collectionName);
	}
	else
	{
		//collection XP calculation and XP grant to the player; if there is XP to grant.
		xpAmount = xp.grantCollectionXP(player, collectionName);
	}

	if(xpAmount > 0)
	{
		//grant them the xp
		prose.setStringId(pp, SID_REWARD_XP);
		prose.setDI(pp, xpAmount);
		sendSystemMessageProse(player, pp);
		//LOG("collectionXp", "ProsePackage Grant: " + (int)xpToGrant);
		if(spaceType)
		{
			xp.grant(player, xp.SPACE_COMBAT_GENERAL, xpAmount, true);
		}
		else
		{
			xp.grantXpByTemplate(player, xpAmount);
		}
		CustomerServiceLog("CollectionComplete: ", "Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " and was granted XP: " + xpAmount + ".");
	}

	if(quest != null && !quest.equals(""))
	{
		//grant them the quests
		string[] quests = split(quest, ',');
		for(int i = 0; i < quests.length; ++i)
		{
			int result = groundquests.grantQuestNoAcceptUI(player, quests[i], false);
			if(result > 0)
				logQuestError(player, quest, result);
		}
	}

	if(item != null && !item.equals(""))
	{
		//look for more than one reward and split if needed
		resizeable obj_id[] allNewObjectsResizable = new obj_id[0];
		obj_id itemId = null;
		string[] items = split(item, ',');

		if(grantRandom == 1)
		{
			itemId = getRandomItem(player, items, collectionName, pp);
			if(!isValidId(itemId))
				return false;
			utils.addElement(allNewObjectsResizable, itemId);
			if(itemIncrement > 1 && hasScript(itemId, AUTO_STACK_SCRIPT))
				setCount(itemId, itemIncrement);
		}
		else if(grantWeightedRandom == 1)
		{
			itemId = getWeightedRandomItem(player, items, collectionName, pp);
			if(!isValidId(itemId))
				return false;

			utils.addElement(allNewObjectsResizable, itemId);
			if(itemIncrement > 1 && hasScript(itemId, AUTO_STACK_SCRIPT))
				setCount(itemId, itemIncrement);
		}
		else
		{
			//give them the item rewards
			for(int i = 0; i < items.length; ++i)
			{
				if(static_item.isStaticItem(items[i]))
				{
					itemId = createStaticItemWithMessage(player, items[i], collectionName, pp);
					if(!isValidId(itemId))
						return false;

					utils.addElement(allNewObjectsResizable, itemId);
				}
				else
				{
					itemId = createTemplateItemWithMessage(player, items[i], collectionName, pp);
					if(!isValidId(itemId))
						return false;

					utils.addElement(allNewObjectsResizable, itemId);
				}
				if(itemIncrement > 1 && hasScript(itemId, AUTO_STACK_SCRIPT))
					setCount(itemId, itemIncrement);
			}
		}
		obj_id[] finalLootList = new obj_id[allNewObjectsResizable.size()];
		allNewObjectsResizable.toArray(finalLootList);
		showLootBox(player, finalLootList);
	}

	if(command != null && !command.equals(""))
	{
		string[] commands = split(command, ',');
		for(int i = 0; i < commands.length; ++i)
		{
			grantCommand(player, commands[i]);
			CustomerServiceLog("CollectionComplete: ", "Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " and was granted Command: " + command + ".");
		}
	}

	if(skillMod != null && !skillMod.equals(""))
	{
		int skillModAmount = dict.getInt("skill_mod_amount");
		int skillModMax = dict.getInt("skill_mod_max");

		string[] skillMods = split(skillMod, ',');
		for(int i = 0; i < skillMods.length; ++i)
		{
			int currentSkillModAmount = getSkillStatMod(player, skillMods[i]);

			if(currentSkillModAmount < skillModMax || skillModMax == -1)
			{
				prose.setStringId(pp, SID_REWARD_SKILL_MOD);
				prose.setDI(pp, skillModAmount);
				prose.setTT(pp, new string_id("stat_n", skillMods[i]));
				applySkillStatisticModifier(player, skillMods[i], skillModAmount);
				sendSystemMessageProse(player, pp);
				CustomerServiceLog("CollectionComplete: ", "Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " and was granted SkillMod: " + skillMods[i] + ".");
			}
		}
	}

	if(questSignal != null && !questSignal.equals(""))
	{
		groundquests.sendSignal(player, questSignal);
		CustomerServiceLog("CollectionComplete: ", "Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " and was granted QuestSignal " + questSignal + ".");
	}

	if(canResetCollection == true)
	{
		removeCompletedCollection(player, collectionName);
	}

	return true;
}

boolean updateCraftingSlot(obj_id player, string template)
{
	if(!isIdValid(player) || !exists(player))
		return false;
	if(template == null || template.equals(""))
		return false;

	string[] collectionTemplateCol = dataTableGetStringColumn(COLLECTION_REWARD_TABLE, CRAFTING_TEMPLATE );

	if (collectionTemplateCol == null || collectionTemplateCol.equals(""))
		return false;

	int row = dataTableSearchColumnForString(template, CRAFTING_TEMPLATE, COLLECTION_REWARD_TABLE);

	if(row < 0)
	{
		blog("COLLECTIONS", "Collection Reward Table did not have template data to increment slot for crafting collection for " + template + ".");
		return false;
	}

	//dataTableGetString(String table, int row, String column);
	string category = dataTableGetString(COLLECTION_REWARD_TABLE, row, "category");
	if(category == null || category.equals(""))
	{
		blog("COLLECTIONS", "Collection Reward Table had a template but no category for " + template + ".");
		return false;
	}

	string[] slotNames = getAllCollectionSlotsInCategory(category);

	if(slotNames == null || slotNames.length <= 0)
		return false;

	for(int i = 0; i < slotNames.length; ++i)
	{
		if(hasCompletedCollectionSlot(player, slotNames[i]))
			continue;

		string[] collectionInfo = getCollectionSlotInfo(slotNames[i]);
		string collectionName = collectionInfo[COLLECTION_INFO_INDEX_COLLECTION];

		modifyCollectionSlotValue(player, slotNames[i], 1);

		blog("COLLECTIONS", "Updating allslotName " + slotNames[i]);

		//check again so the player isn't spammed the last slot update
		if(hasCompletedCollectionSlot(player, slotNames[i]))
			continue;

		prose_package pp = new prose_package();
		prose.setStringId(pp, SID_SLOT_INCREMENT);
		prose.setTU(pp, new string_id("collection_n", slotNames[i]));
		prose.setTO(pp, new string_id("collection_n", collectionName));
		sendSystemMessageProse(player, pp);
	}
	return true;
}

boolean checkState(obj_id player)
{
	if(getState(player, STATE_COMBAT) == 1)
	{
		sendSystemMessage(player, SID_SYS_NO_COMBAT);
		return false;
	}
	if(getState(player, STATE_RIDING_MOUNT) == 1)
	{
		sendSystemMessage(player, SID_SYS_NO_MOUNT);
		return false;
	}
	if(isDead(player) || isIncapacitated(player))
	{
		sendSystemMessage(player, SID_SYS_NO_DEAD_INCAP);
		return false;
	}
	return true;
}

boolean checkDistance(obj_id clickObj, obj_id player, int maxDist)
{
	if(!isIdValid(player) || !exists(player))
		return false;

	location objLoc = getLocation(clickObj);
	if(objLoc == null || objLoc.equals(""))
		return false;

	location playerLoc = getLocation(player);
	if(playerLoc == null || playerLoc.equals(""))
		return false;

	float dist = utils.getDistance2D(objLoc, playerLoc);
	if (dist > maxDist || dist < 0)
	{
		return false;
	}

	return true;
}

boolean giveAreaMobsHate(obj_id collectible, obj_id player)
{
	if(hasObjVar(collectible, "collection.aggro"))
	{
		boolean hasAggro = getBooleanObjVar(collectible, "collection.aggro");
		if(!hasAggro)
			return false;
	}

	if(!isIdValid(collectible) || !exists(collectible))
		return false;
	if(!isIdValid(player) || !exists(player))
		return false;

	location collectibleLoc = getLocation(collectible);
	if(collectibleLoc == null)
		return false;

	obj_id[] allMobsCombat = getAllNpcs(collectibleLoc, MAX_HATE_RADIUS_ON_CLICK_COL);
	if(allMobsCombat == null || allMobsCombat.length < 1)
		return false;

	blog("collection","length of mobs: "+allMobsCombat.length);

	for(int i = 0; i < allMobsCombat.length; i++)
	{
		//LOG("collection","mob hate added to: "+allMobsCombat[i]);
		if(allMobsCombat[i] == player)
			continue;
		if(hasObjVar(allMobsCombat[i], "ignoreCollector"))
			continue;			
		if(isInvulnerable(allMobsCombat[i]))
			continue;
		if(pvpCanAttack(allMobsCombat[i], player))
			startCombat(allMobsCombat[i], player);
			//addHate(allMobsCombat[i], player, 1.0f);
	}
	return true;
}

void showNpcCollections(obj_id player, obj_id npc, string columnName)
{
	if(sui.hasPid(player, COL_NPC_PID))
	{
		int pid = sui.getPid(player, COL_NPC_PID);
		forceCloseSUIPage(pid);
	}

	HashSet availableCollections = new HashSet();
	HashSet active_collection = new HashSet();

	string[] allCollections = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, columnName);  // collections offered by this npc
	int columnNumber = dataTableFindColumnNumber(COLLECTION_NPC_TABLE, columnName);  //get int of column
	string[] prereqColumn = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, (columnNumber + 1));  // collection prereq slots

	for(int i = 0; i < allCollections.length; i++)
	{
		if(!hasCompletedCollectionSlot(player, prereqColumn[i]))
		{
			availableCollections.add(allCollections[i]);
		}
		else if(hasCompletedCollectionSlot(player, prereqColumn[i]) && !hasCompletedCollection(player, allCollections[i]))
		{
			active_collection.add(allCollections[i]);  // you are active!
		}
	}

	//now convert Vector to arrays.
	string[] strArrayAvailableCollections = new string[availableCollections.size()];
	availableCollections.toArray(strArrayAvailableCollections);

	string[] activeCollections = new string[active_collection.size()];
	active_collection.toArray(activeCollections);

	if(activeCollections.length >= 2)
	{
		sendSystemMessage(player, SID_MAX_ACTIVE);
		return;
	}
	//Localizing the available collections for the SUI
	string[] SUIcollectionNames = new string[strArrayAvailableCollections.length];

	for(int q = 0; q < strArrayAvailableCollections.length; q++)
	{
		SUIcollectionNames[q] = "@collection_n:" + strArrayAvailableCollections[q];
	}

	utils.setScriptVar(player, "collection.allCollections", strArrayAvailableCollections);
	int pid = sui.listbox( npc, player, COL_NPC_PROMPT, sui.OK_CANCEL, COL_NPC_TITLE, SUIcollectionNames, "handleCollectionNpc", true );
	sui.setPid(player, pid, COL_NPC_PID);
}

//Collection NPC function - locates and grants the selected collection activation bit.
void findAndGrantSlot(obj_id player, obj_id npc, string selectedCollection)
{
	string collectionColumn = "";
	string slotToGrant = "";

	if(utils.hasObjVar(npc, "collection.columnName"))
	{
		collectionColumn = getStringObjVar(npc, "collection.columnName");  //get collectionColumn from the NPC
	}
	else
	{
		return;
	}

	int columnNumber = dataTableFindColumnNumber(COLLECTION_NPC_TABLE, collectionColumn);  //get int of column
	//get both collection and grant columns for comparison
	string[] allCollections = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, collectionColumn);
	string[] grantColumn = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, (columnNumber + 1));

	for(int r = 0; r < allCollections.length; r++)
	{
		if(allCollections[r].equals(selectedCollection))
		{
			modifyCollectionSlotValue(player, grantColumn[r], 1);
		}
	}
}

boolean checkMaxActive(obj_id player, obj_id npc, string columnName)
{
	HashSet active_collection = new HashSet();

	if(!hasObjVar(npc, "collection.columnName"))
	{
		return true;
	}
	string[] allCollections = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, columnName);  // collections offered by this npc
	int columnNumber = dataTableFindColumnNumber(COLLECTION_NPC_TABLE, columnName);  //get int of column
	string[] prereqColumn = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, (columnNumber + 1));  // collection prereq slots

	if(allCollections == null || allCollections.length <= 0)
	{
		return false;
	}
	if(prereqColumn == null || prereqColumn.length <= 0)
	{
		return false;
	}

	for(int i = 0; i < allCollections.length; i++)
	{
		if(hasCompletedCollectionSlot(player, prereqColumn[i]) && !hasCompletedCollection(player, allCollections[i]))
		{
			active_collection.add(allCollections[i]);  // you are active!
		}
	}

	//now convert Vector to arrays.
	string[] activeCollections = new string[active_collection.size()];
	active_collection.toArray(activeCollections);

	if(activeCollections.length >= 2)
	{
		return true;
	}
	return false;
}

boolean npcHasMoreCollections(obj_id player, obj_id npc, string columnName)
{
	if(!isIdValid(player) || !exists(player))
		return false;
	if(!isIdValid(npc) || !exists(npc))
		return false;
	if(columnName == null || columnName.equals(""))
		return false;

	HashSet playerCollections = new HashSet();

	if(!hasObjVar(npc, "collection.columnName"))
	{
		return false;
	}

	string[] allCollections = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, columnName);  // collections offered by this npc
	int columnNumber = dataTableFindColumnNumber(COLLECTION_NPC_TABLE, columnName);  //get int of column
	string[] prereqColumn = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, (columnNumber + 1));  // collection prereq slots

	if(allCollections == null || allCollections.length <= 0)
	{
		return false;
	}

	if(prereqColumn == null || prereqColumn.length <= 0)
	{
	 	return false;
	}

	for(int i = 0; i < allCollections.length; i++)
	{
		if(hasCompletedCollectionSlot(player, prereqColumn[i]))
		{
			playerCollections.add(allCollections[i]);  // you are active!
			//allCollections.remove(allCollectoins[i]);
		}
	}

	//now convert Vector to arrays.
	string[] activeOrComplete = new string[playerCollections.size()];
	playerCollections.toArray(activeOrComplete);

	if(activeOrComplete.length == allCollections.length)
	{
		return false;
	}
	return true;
}

string[] getAllCollectionsForItem(obj_id collectible)
{
	if(!isIdValid(collectible) || !exists(collectible))
		return null;

	//format for objvars:
	//<collectionName>:<slotName> Seperated by a colon
	//if more than one collection for an item:
	//<collectionName>:<slotName>|<collectionName>:<slotName> seperated by a bar |

	string[] baseSlotNames = split(getStringObjVar(collectible, OBJVAR_SLOT_NAME), '|');

	Vector collectionNames = new Vector();

	//loop thru base string array, spliting the collection name from the slotName
	for(int i = 0; i < baseSlotNames.length; ++i)
	{
		//split the entry by : to seperate the collection name from the slot name
		string[] splitSlotNames = split(baseSlotNames[i], ':');
		collection.blog("COLLECTIONS", "splitSlotNames.length " + splitSlotNames.length);

		//loop thru the seperated collection names to find out if we have finished
		//the collect or have already unlocked this slot
		for(int j = 0; j < splitSlotNames.length; j += 2)
		{
			collectionNames.add(splitSlotNames[j]);
		}

	}

	string[] availableCollections = new string[collectionNames.size()];
	collectionNames.toArray(availableCollections);
	return availableCollections;
}

string[] getAllSlotsForItem(obj_id collectible)
{
	if(!isIdValid(collectible) || !exists(collectible))
		return null;

	//format for objvars:
	//<collectionName>:<slotName> Seperated by a colon
	//if more than one collection for an item:
	//<collectionName>:<slotName>|<collectionName>:<slotName> seperated by a bar |

	string[] baseSlotNames = split(getStringObjVar(collectible, OBJVAR_SLOT_NAME), '|');

	Vector slotNames = new Vector();

	//loop thru base string array, spliting the collection name from the slotName
	for(int i = 0; i < baseSlotNames.length; ++i)
	{
		//split the entry by : to seperate the collection name from the slot name
		string[] splitSlotNames = split(baseSlotNames[i], ':');

		collection.blog("COLLECTIONS", "splitSlotNames.length " + splitSlotNames.length);

		//loop thru the seperated collection names to find out if we have finished
		//the collect or have already unlocked this slot
		for(int j = 0; j < splitSlotNames.length; j += 2)
		{
			slotNames.add(splitSlotNames[j + 1]);
		}

	}

	string[] availableSlots	= new string[slotNames.size()];
	slotNames.toArray(availableSlots);
	return availableSlots;
}


string[] getAllAvailableCollectionsForItem(obj_id player, obj_id collectible)
{
	if(!isIdValid(collectible) || !exists(collectible))
		return null;

	//format for objvars:
	//<collectionName>:<slotName> Seperated by a colon
	//if more than one collection for an item:
	//<collectionName>:<slotName>|<collectionName>:<slotName> seperated by a bar |

	string[] baseSlotNames = split(getStringObjVar(collectible, OBJVAR_SLOT_NAME), '|');

	Vector collectionNames = new Vector();

	//loop thru base string array, spliting the collection name from the slotName
	for(int i = 0; i < baseSlotNames.length; ++i)
	{
		//split the entry by : to seperate the collection name from the slot name
		string[] splitSlotNames = split(baseSlotNames[i], ':');
		collection.blog("COLLECTIONS", "splitSlotNames.length " + splitSlotNames.length);
		//loop thru the seperated collection names to find out if we have finished
		//the collect or have already unlocked this slot
		for(int j = 0; j < splitSlotNames.length; j += 2)
		{
			collection.blog("COLLECTIONS", "splitSlotNames[" + j + "] " + splitSlotNames[j]);
			//check to see if we have finished this collection
			if(!hasCompletedCollection(player, splitSlotNames[j]))
			{
				//check to see if they already have this slot completed
				if(!hasCompletedCollectionSlot(player, splitSlotNames[j + 1]))
				{
					//check to see if they have completed the prereqs for the collection
					if(hasCompletedCollectionSlotPrereq(player,  splitSlotNames[j + 1]))
					{
						//add the collection
						collectionNames.add(splitSlotNames[j]);
					}
				}
			}
		}

	}

	string[] availableCollections = new string[collectionNames.size()];
	collectionNames.toArray(availableCollections);
	return availableCollections;
}

string[] getAllAvailableSlotsForItem(obj_id player, obj_id collectible)
{
	if(!isIdValid(collectible) || !exists(collectible))
		return null;

	//format for objvars:
	//<collectionName>:<slotName> Seperated by a colon
	//if more than one collection for an item:
	//<collectionName>:<slotName>|<collectionName>:<slotName> seperated by a bar |

	string[] baseSlotNames = split(getStringObjVar(collectible, OBJVAR_SLOT_NAME), '|');

	Vector slotNames = new Vector();

	//loop thru base string array, spliting the collection name from the slotName
	for(int i = 0; i < baseSlotNames.length; ++i)
	{
		//split the entry by : to seperate the collection name from the slot name
		string[] splitSlotNames = split(baseSlotNames[i], ':');
		collection.blog("COLLECTIONS", "splitSlotNames.length " + splitSlotNames.length);
		//loop thru the seperated collection names to find out if we have finished
		//the collect or have already unlocked this slot
		for(int j = 0; j < splitSlotNames.length; j += 2)
		{
			collection.blog("COLLECTIONS", "splitSlotNames[" + j + "] " + splitSlotNames[j]);
			//check to see if we have finished this collection
			if(!hasCompletedCollection(player, splitSlotNames[j]))
			{
				//check to see if they already have this slot completed
				if(!hasCompletedCollectionSlot(player, splitSlotNames[j + 1]))
				{
					//check to see if they have completed the prereqs for the collection
					if(hasCompletedCollectionSlotPrereq(player,  splitSlotNames[j + 1]))
					{
						//add the collection
						slotNames.add(splitSlotNames[j + 1]);
					}
				}
			}
		}

	}

	string[] availableSlots	= new string[slotNames.size()];
	slotNames.toArray(availableSlots);
	return availableSlots;
}

boolean removeCollectionForRealsies(obj_id player, string collectionName)
{
	if(!isIdValid(player) || !exists(player))
		return false;
	if(collectionName == null || collectionName.equals(""))
		return false;

	// get all the slots in the chosen collection
	string[] slotsInCollection = getAllCollectionSlotsInCollection(collectionName);
	// loop through and clear each slot
	for(int i = 0; i < slotsInCollection.length; i++)
	{
		// get the collectionSlotValue and multiply by -1
		long collectionSlotValue = getCollectionSlotValue(player, slotsInCollection[i]) * -1;
		// apply the collectionSlotValue to each slot - this should clear the slot.
		modifyCollectionSlotValue(player, slotsInCollection[i], collectionSlotValue);
	}
	sendSystemMessage(player, COLLECTION_CLEARED);
	return true;
}

boolean revokeThenGrantCollection(obj_id player, string collectionName)
{
	if(!isIdValid(player) || !exists(player))
		return false;
	if(collectionName == null || collectionName.equals(""))
		return false;

	// get all the slots in the chosen collection
	string[] slotsInCollection = getAllCollectionSlotsInCollection(collectionName);
	// loop through and clear each slot
	for(int i = 0; i < slotsInCollection.length; i++)
	{
		// get the collectionSlotValue and multiply by -1
		long collectionSlotNegativeValue = getCollectionSlotValue(player, slotsInCollection[i]) * -1;
		long collectionSlotPostiveValue = getCollectionSlotValue(player, slotsInCollection[i]);

		// apply the collectionSlotValue to each slot - this should clear the slot.
		modifyCollectionSlotValue(player, slotsInCollection[i], collectionSlotNegativeValue);
		modifyCollectionSlotValue(player, slotsInCollection[i], collectionSlotPostiveValue);
	}
	sendSystemMessageTestingOnly(player, "Collection Revoked and Regranted.");
	return true;
}

boolean removeCollection(obj_id player, string collectionName)
{
	if(!isIdValid(player) || !exists(player))
		return false;
	if(collectionName == null || collectionName.equals(""))
		return false;

	// if the collection is complete - the player can not reset it!
	if(hasCompletedCollection(player, collectionName))
	{
		sendSystemMessage(player, COMPLETE_COLLECTION_CAN_NOT_CLEAR);
		return false;
	}
	// get all the slots in the chosen collection
	string[] slotsInCollection = getAllCollectionSlotsInCollection(collectionName);
	// loop through and clear each slot
	for(int i = 0; i < slotsInCollection.length; i++)
	{
		// get the collectionSlotValue and multiply by -1
		long collectionSlotValue = getCollectionSlotValue(player, slotsInCollection[i]) * -1;
		// apply the collectionSlotValue to each slot - this should clear the slot.
		modifyCollectionSlotValue(player, slotsInCollection[i], collectionSlotValue);
	}
	sendSystemMessage(player, COLLECTION_CLEARED);
	CustomerServiceLog("Collection: ", "Player " + getFirstName(player) + "(" + player + ") has voluntarily reset their collection: " + collectionName);
	return true;
}

//This is only to be used when you want a player to repeat a collection.
boolean removeCompletedCollection(obj_id player, string collectionName)
{
	if(!isIdValid(player) || !exists(player))
		return false;
	if(collectionName == null || collectionName.equals(""))
		return false;
	//the collection must be complete in order to remove
	if(!hasCompletedCollection(player, collectionName))
		return false;

	// get all the slots in the chosen collection
	string[] slotsInCollection = getAllCollectionSlotsInCollection(collectionName);
	// loop through and clear each slot
	for(int i = 0; i < slotsInCollection.length; i++)
	{
		// get the collectionSlotValue and multiply by -1
		long collectionSlotValue = getCollectionSlotValue(player, slotsInCollection[i]) * -1;
		// apply the collectionSlotValue to each slot - this should clear the slot.
		modifyCollectionSlotValue(player, slotsInCollection[i], collectionSlotValue);
	}

	//we need to give them a message stating the collection was reset -
	prose_package pp = new prose_package();
	prose.setTO(pp, new string_id("collection_n", collectionName));
	prose.setStringId(pp, SID_COLLECTION_RESET);
	sendSystemMessageProse(player, pp);
	CustomerServiceLog("Collection: ", "Player " + getFirstName(player) + "(" + player + ") has voluntarily reset their collection: " + collectionName);
	return true;
}

void showNpcCollectionsRemoval(obj_id player, obj_id npc, string columnName)
{
	if(sui.hasPid(player, COL_NPC_PID))
	{
		int pid = sui.getPid(player, COL_NPC_PID);
		forceCloseSUIPage(pid);
	}

	//HashSet availableCollections = new HashSet();
	HashSet active_collection = new HashSet();

	string[] allCollections = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, columnName);  // collections offered by this npc
	int columnNumber = dataTableFindColumnNumber(COLLECTION_NPC_TABLE, columnName);  //get int of column
	string[] prereqColumn = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, (columnNumber + 1));  // collection prereq slots

	for(int i = 0; i < allCollections.length; i++)
	{
		if(hasCompletedCollectionSlot(player, prereqColumn[i]) && !hasCompletedCollection(player, allCollections[i]))
		{
			active_collection.add(allCollections[i]);  // you are active!
		}
	}

	string[] activeCollections = new string[active_collection.size()];
	active_collection.toArray(activeCollections);

	//Localizing the available collections for the SUI
	string[] SUIcollectionNames = new string[activeCollections.length];

	for(int q = 0; q < activeCollections.length; q++)
	{
		SUIcollectionNames[q] = "@collection_n:" + activeCollections[q] + "_finished";
	}

	utils.setScriptVar(player, "collection.allCollections", activeCollections);
	int pid = sui.listbox( npc, player, SUI_DELETE_PROMPT, sui.OK_CANCEL, SUI_DELETE_TITLE, SUIcollectionNames, "handleCollectionRemoval", true );
	sui.setPid(player, pid, COL_NPC_PID);
}

boolean npcHasCollectionsToRemove(obj_id player, obj_id npc, string columnName)
{
	if(!isIdValid(player) || !exists(player))
		return false;
	if(!isIdValid(npc) || !exists(npc))
		return false;
	if(columnName == null || columnName.equals(""))
		return false;

	//HashSet availableCollections = new HashSet();
	HashSet active_collection = new HashSet();

	string[] allCollections = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, columnName);  // collections offered by this npc
	int columnNumber = dataTableFindColumnNumber(COLLECTION_NPC_TABLE, columnName);  //get int of column
	string[] prereqColumn = dataTableGetStringColumnNoDefaults(COLLECTION_NPC_TABLE, (columnNumber + 1));  // collection prereq slots

	if(allCollections == null || allCollections.length <= 0)
	{
	 	return false;
	}
	if(prereqColumn == null || prereqColumn.length <= 0)
	{
	 	return false;
	}

	for(int i = 0; i < allCollections.length; i++)
	{
		if(hasCompletedCollectionSlot(player, prereqColumn[i]) && !hasCompletedCollection(player, allCollections[i]))
		{
			active_collection.add(allCollections[i]);  // you are active!
		}
	}

	string[] activeCollections = new string[active_collection.size()];
	active_collection.toArray(activeCollections);

	if(activeCollections.length > 0)
	{
		return true;
	}
	return false;
}

boolean spaceGetCreditForKills(obj_id player, string[] slotNames)
{
	if(slotNames == null || slotNames.length <= 0)
		return false;

	for(int i = 0; i < slotNames.length; ++i)
	{
		if(!hasCompletedCollectionSlot(player, slotNames[i]))
		{
			modifyCollectionSlotValue(player, slotNames[i], 1);
		}
	}
	return true;
}

boolean logQuestError(obj_id player, string quest, int result)
{
	if(!isIdValid(player) || !exists(player))
		return false;

	string s = "";

	if(result == 1)
	{
		s = "Error: Quest already active.";
	}
	else if(result == 2)
	{
		s = "Error: No such quest.";
	}
	else if(result == 3)
	{
		s = "Error: No such task.";
	}
	else if(result == 4)
	{
		s = "Error: Quest already completed, and not repeatable.";
	}
	else if(result == 5)
	{
		s = "Error: Failed prerequisites.";
	}
	else if(result == 6)
	{
		s = "Error: Failed exclusions.";
	}
	else if(result == 7)
	{
		s = "Error: Quest Not active.";
	}
	else if(result == 8)
	{
		s = "Error: Task not active.";
	}
	else if(result == 9)
	{
		s = "Error: No such player.";
	}

	if(s == "" || s.equals(""))
		return false;

	//debugSpeakMsg(player, s);
	CustomerServiceLog("CollectionComplete: ", "Player " + getFirstName(player) + "(" + player + ") has failed to receive quest: " + quest + " becasue of the errror: " + s);
	blog("collection","Quest Error: " + s);

	return true;
}

boolean entertainerBuffCollection(obj_id buffedPlayerId, obj_id bufferId, float duration)
{
	//validation - must have valid player ids
	if(!isIdValid(buffedPlayerId) || !isIdValid(bufferId))
	{
		return false;
	}

	//if player has completed the collection: Bail
	if(hasCompletedCollection(bufferId, ENT_BUFF_COLLECTION_01))
	{
		return false;
	}

	//get the SkillTemplate of the player being buffed
	string buffedPlayerTemplate = getSkillTemplate(buffedPlayerId);
	//all traders go under this category
	if(buffedPlayerTemplate.startsWith("trader"))
	{
		buffedPlayerTemplate = "prof_trader";
	}
	//We don't want Entertainers! *They do not have a spot in the collection*
	if(buffedPlayerTemplate.startsWith("entertainer"))
	{
		return false;
	}
	//If entertainer has completed the slot for this template: Bail
	if(hasCompletedCollectionSlot(bufferId, buffedPlayerTemplate))
	{
		//slot has already been completed.
		return false;
	}

	//roll to see if you qualify for a Collection Buff
	int collectionRollChance = rand(1, 100);
	if(collectionRollChance > CONST_ROLL_CHANCE)
	{
		//Did not get a qualifying roll - apply timer buff to buffedPlayer and exit
		buff.applyBuff(buffedPlayerId, "col_ent_invis_buff_tracker");
		return false;
	}

	if(duration >= 7200.00)
	{
	        //apply the tracking buff to the Buffed Player
	        buff.applyBuff(buffedPlayerId, "col_ent_invis_buff_tracker");
		//Modify Collection Slot
		modifyCollectionSlotValue(bufferId, buffedPlayerTemplate, 1);
		//Inform the Entertainer
		sendSystemMessage(bufferId, new string_id("collection", "update_entertainer"));

		return true;
	}
	else //This should never get called
	{
		sendSystemMessage(bufferId, new string_id("collection", "time_too_short"));
		return false;
	}
}

boolean pilotSmuggleTimeCheck(obj_id pilot, obj_id groupMember, obj_id ship, string strChassisType)
{
	//Check to see if they have an existing "smuggle buff" - this needs to be removed
	//So that we can revert to the old system.
	if(buff.hasBuff(groupMember, "col_sd_invis_buff_tracker"))
	{
		buff.removeBuff(groupMember, "col_sd_invis_buff_tracker");
		CustomerServiceLog("Collection: ", "DePalma: Buff was removed from player: (" + groupMember + ") we are now tracking by objvar");
	}

	//obj_id validation
	if(!isIdValid(pilot) || !isIdValid(groupMember) || !isIdValid(ship))
	{
		CustomerServiceLog("Collection: ", "DePalma: validation of pilot/groupMember/ship null value: Pilot: " + pilot + "groupMember: " + groupMember + "Ship: " + ship);
		return false;
	}
	//if player has completed the collection: Bail
	if(hasCompletedCollection(groupMember, COL_HEROIC_SD_TAXI_SERVICE))
	{
		if(hasObjVar(groupMember, COL_HEROIC_SD_SMUGGLE_OBJVAR))
		{
			//remove the Objvar from the pilot - he has completed the collection
			removeObjVar(groupMember, COL_HEROIC_SD_SMUGGLE_OBJVAR);
			CustomerServiceLog("Collection: ", "DePalma: Player completed collection - objvar removed: " + groupMember + ".");
		}
		return false;
	}
	if(strChassisType == null || strChassisType.equals(""))
	{
		CustomerServiceLog("Collection: ", "DePalma: invalid Chassis(checks everyone): blank or null: ShipId: " + ship + "(" + strChassisType + ")");
		//Chassis is bad
		return false;
	}
	if(strChassisType.equals("player_sorosuub_space_yacht") && groupMember == pilot && utils.isOwner(ship, groupMember))
	{
		CustomerServiceLog("Collection: ", "DePalma: Sorosuub Chassis (Pilot check): Chassis " + strChassisType + "Pilot Id (" + pilot + ")" + "groupMember(should be same as pilot)" + groupMember);
		//Sorosuub is invulnerable - this is not smuggling - it's cheating
		sendSystemMessage(pilot, DRIVING_SOROSUUB);
		return false;
	}

	int currentTime = getCalendarTime(); 		//current time for comparison
	int nextTimeEligible = 0;			//initialize

	//All Validation passed - let's see about giving credit.
	if(hasObjVar(groupMember, COL_HEROIC_SD_SMUGGLE_OBJVAR))
	{
		//he has been here before - get his timeStamp
		int timeStampCheck = getIntObjVar(groupMember, COL_HEROIC_SD_SMUGGLE_OBJVAR);
		//check to see if the timer is still active.
		if(currentTime < timeStampCheck)	//existing timer is still active -
		{
			if(groupMember.equals(pilot) && utils.isOwner(ship, groupMember))
			{
				CustomerServiceLog("Collection: ", "DePalma: Timer not expired - currentTime: " + currentTime + ". from Player: " + groupMember + ".");
				//if pilot and ship owner - tell him why
				sendSystemMessage(pilot, SMUGGLE_ATTEMPT_TIME_ISSUE);
			}
			return false;
		}
		else
		{
			//give me a new objvar for the next time.
			nextTimeEligible = currentTime + REQUIRED_TIME_LAPSE;
			//set the objvar - this determines when he is eligible for the next attempt
			setObjVar(groupMember, COL_HEROIC_SD_SMUGGLE_OBJVAR, nextTimeEligible);
			//if you are the pilot and you're flying YOUR ship - we want to increment your collection count.
			if(groupMember.equals(pilot) && utils.isOwner(ship, groupMember))
			{
				CustomerServiceLog("Collection: ", "DePalma: Successful Run: Pilot (" + groupMember + ") received update. This was his first run - did not have objvar...Must wait until " + nextTimeEligible + " for an update.");
				//give him credit!
				modifyCollectionSlotValue(groupMember, COL_SLOT_SMUGGLE_GROUPS, 1);
				//send a message informing them of a successful "smuggle" attempt
				sendSystemMessage(pilot, SUCCESSFUL_SMUGGLE_ATTEMPT);
				return true;
			}
		}
	}
	//This is his first time - let's mark the beast.
	else
	{
		nextTimeEligible = currentTime + REQUIRED_TIME_LAPSE;
		//set the objvar - this determines when he is eligible for the next attempt
		setObjVar(groupMember, COL_HEROIC_SD_SMUGGLE_OBJVAR, nextTimeEligible);
		//if you are the pilot and you're flying YOUR ship - we want to increment your collection count.
		if(groupMember.equals(pilot) && utils.isOwner(ship, groupMember))
		{
			CustomerServiceLog("Collection: ", "DePalma: Successful Run: Pilot (" + groupMember + ") received update. Must wait until " + nextTimeEligible + " for an update.");
			//give him credit!
			modifyCollectionSlotValue(groupMember, COL_SLOT_SMUGGLE_GROUPS, 1);
			//send a message informing them of a successful "smuggle" attempt
			sendSystemMessage(pilot, SUCCESSFUL_SMUGGLE_ATTEMPT);
			return true;
		}
	}
	return false;
}
/****************SAVE THIS FOR LATER - ENGINEERING WILL BE ADDING 'REAL TIME' TO BUFFS.**************************
*****************THIS WILL BE REVERTED BACK TO TRACK DEPALMAS RUN ONCE IT IS IMPLEMENTED*************************
****************************THIS IS FULLY FUNCTIONAL AT THE TIME OF REMOVAL**************************************
/*boolean pilotSmuggleTimeCheck(obj_id pilot, obj_id groupMember, obj_id ship, string strChassisType)
{
	//obj_id validation
	if(!isIdValid(pilot) || !isIdValid(groupMember) || !isIdValid(ship))
	{
		CustomerServiceLog("Collection: ", "DePalma: validation of pilot/groupMember/ship null value: Pilot: " + pilot + "groupMember: " + groupMember + "Ship: " + ship);
		return false;
	}
	//if player has completed the collection: Bail
	if(hasCompletedCollection(groupMember, COL_HEROIC_SD_TAXI_SERVICE))
	{
		CustomerServiceLog("Collection: ", "DePalma: completedCollection: groupMember: " + groupMember);
		return false;
	}
	//Make sure the ship chassis is valid.
	if(strChassisType.equals("") || strChassisType == null)
	{
		CustomerServiceLog("Collection: ", "DePalma: invalid Chassis(checks everyone): blank or null: ShipId: " + ship + "(" + strChassisType + ")");
		return false;
	}
	//This will inform the Pilot he is using an invalid ship for this collection.
	if(strChassisType.equals("player_sorosuub_space_yacht") && groupMember.equals(pilot) && utils.isOwner(ship, groupMember))
	{
		CustomerServiceLog("Collection: ", "DePalma: Sorosuub Chassis (Pilot check): Chassis " + strChassisType + "Pilot Id (" + pilot + ")" + "groupMember(should be same as pilot)" + groupMember);
		//Sorosuub is invulnerable - this is not smuggling - it's cheating
		sendSystemMessage(pilot, DRIVING_SOROSUUB);
		return false;
	}
	//This catches everyone else (other than the pilot who was already caught.
	if(strChassisType.equals("player_sorosuub_space_yacht"))
	{
		CustomerServiceLog("Collection: ", "DePalma: Sorosuub Chassis:(non-Pilot Check): " + strChassisType);
		return false;
	}

	// ********Passed all validation - Let's see if you get credit now.**********

	//Check to see if the player has an active timer.
	if(buff.hasBuff(groupMember, "col_sd_invis_buff_tracker"))
	{
		float groupMemberDuration = buff.getDuration("col_sd_invis_buff_tracker");

		if(groupMember.equals(pilot))
		{
			CustomerServiceLog("Collection: ", "DePalma: Player had Tracking buff: (Pilot): (" + pilot + ") (" + groupMember + ") has " + groupMemberDuration + "seconds remaining on buff");
			sendSystemMessage(pilot, STILL_HAS_TAXI_BUFF);
		}
		else
		{
			CustomerServiceLog("Collection: ", "DePalma: Player had Tracking buff: (non-Pilot): " + groupMember + "has " + groupMemberDuration + "seconds remaining on buff");
		}
		return false;
	}
	else
	{
		//There is no active invisible buff on this player - see if he is the pilot && owner of ship.
		if(groupMember.equals(pilot) && utils.isOwner(ship, groupMember))
		{
			//give the pilot credit!
			modifyCollectionSlotValue(groupMember, COL_SLOT_SMUGGLE_GROUPS, 1);
			//apply the invisible time tracker buff
			buff.applyBuff(groupMember, "col_sd_invis_buff_tracker");
			//send a message informing them of a successful "smuggle" attempt
			sendSystemMessage(groupMember, SUCCESSFUL_SMUGGLE_ATTEMPT);

			CustomerServiceLog("Collection: ", "DePalma: Pilot received update: --pilotId (" + pilot + ")" + "should equal(" + groupMember + ").  See other collection logs for update verification");
			return true;
		}
		else
		{
			CustomerServiceLog("Collection: ", "DePalma: Player is not Pilot - did not have buff - entered correct function: (non-Pilot): " + groupMember + "buff being applied");
			//apply the invisible time tracker buff
			buff.applyBuff(groupMember, "col_sd_invis_buff_tracker");
		}
	}
	return false;
}*/

boolean collectionResource(obj_id player, string restype)
{
	return collectionResource(player, restype, 0);
}

boolean collectionResource(obj_id player, string restype, int modifier)
{
	if(!isValidId(player) || !exists(player))
		return false;
	if(restype == null || restype.equals(""))
		return false;
	if(modifier < 0)
	{
		CustomerServiceLog("Collection: ", "DESIGNER BUG "+modifier+" is invalid. Int should be higher than zero.");
		modifier = 0;
	}

	CustomerServiceLog("Collection: ", "Player " + getFirstName(player) + "(" + player + ") is rolling for resource: "+restype+" with a modifier of "+modifier+".");
	int randomChoice = rand(1, 100);
	CustomerServiceLog("Collection: ", "Player " + getFirstName(player) + "(" + player + ") is rolling for resource: "+restype+" and has received a roll of "+randomChoice+".");

	if(modifier > 0)
	{
		CustomerServiceLog("Collection: ", "Player " + getFirstName(player) + "(" + player + ") is rolling for resource: "+restype+" has a modifier of "+modifier+" so this will be SUBTRACTED FROM: "+randomChoice+".");
		randomChoice -= modifier;
		if(randomChoice < 0)
			randomChoice = 0;

		CustomerServiceLog("Collection: ", "Player " + getFirstName(player) + "(" + player + ") is rolling for resource: "+restype+" the roll has been modified to be: "+randomChoice+".");
	}

	//Put in for QA Testing
	if(utils.hasScriptVar(player, "qa.resource_roll_bypass"))
	{
		randomChoice = 1;
		sendSystemMessageTestingOnly(player, "Collection Harvest Percentage bypassed for testing(100% success).");
	}

	if(randomChoice > CONST_RESOURCE_ROLL)
	{
		CustomerServiceLog("Collection: ", "Player " + getFirstName(player) + "(" + player + ") was rolling for resource: "+restype+" but rolled "+randomChoice+" which was higher than the cap of "+CONST_RESOURCE_ROLL+".");
		return false;
	}


	string staticItem = "";
	string resourceMessage = "";
	if(restype.startsWith("meat"))
	{
		staticItem = PRISTINE_MEAT;
		resourceMessage = "resource_meat";
	}
	else if(restype.startsWith("hide"))
	{
		staticItem = PRISTINE_HIDE;
		resourceMessage = "resource_hide";
	}
	else if(restype.startsWith("bone"))
	{
		staticItem = PRISTINE_BONE;
		resourceMessage = "resource_bone";
	}
	else if(restype.startsWith("egg"))
	{
		staticItem = PRISTINE_EGG;
		resourceMessage = "resource_egg";
	}
	else if(restype.startsWith("milk"))
	{
		staticItem = PRISTINE_MILK;
		resourceMessage = "resource_milk";
	}
	if(staticItem == null || staticItem.equals(""))
	{
		CustomerServiceLog("Collection: ", "DESIGNER BUG - static item reward came back invalid for Player " + getFirstName(player) + "(" + player + ").");
		return false;
	}
	if(resourceMessage == null || resourceMessage.equals(""))
	{
		CustomerServiceLog("Collection: ", "DESIGNER BUG - reward message came back invalid for Player " + getFirstName(player) + "(" + player + ").");
		return false;
	}

	obj_id newResourceItem = static_item.createNewItemFunction(staticItem, player);
	if(!isValidId(newResourceItem) || !exists(newResourceItem))
	{
		//Customer Service Log for failure to create item
		CustomerServiceLog("CollectionLootChannel: ", "collectionResource - BrokenLoot: inValid resource failed to be rewarded to Player: " + player + " Name: " +getName(player));
		return false;
	}
	CustomerServiceLog("CollectionLootChannel", "collectionResource - Player: "+player+" Name: " +getName(player)+ " Has triggered the creation of a static item object within the collection system. The object: "+newResourceItem+" Name: "+getName(newResourceItem));

	sendSystemMessage(player, new string_id("collection", resourceMessage));
	return true;
}


///This function has a list of ALL loot drop collection items as of 02/01/2008
///This will grant a player a random item from that list.
///Container = the container to place the object in (originally developed for Magseals)
boolean getRandomCollectionItemShowLootBox(obj_id player, obj_id container, string loot_table, string loot_column)
{
	//Validation
	if(!isIdValid(container) || !isIdValid(player))
	{
		return false;
	}
	//Get the collection loot column from the magseal loot table.
	string[] collectionLootArray = dataTableGetStringColumnNoDefaults(loot_table, loot_column);
	//ensure there is data in the collection column
	if(collectionLootArray == null || collectionLootArray.length <= 0)
	{
		return false;
	}
	int random = rand(0, collectionLootArray.length-1);

	obj_id collectionItem = static_item.createNewItemFunction(collectionLootArray[random], container);

	if(!isValidId(collectionItem) || !exists(collectionItem))
	{
		//Customer Service Log for failure to create item
		CustomerServiceLog("CollectionLootChannel: ", "getRandomCollectionItem - BrokenLoot: inValid object was created for player " + player + " Name: " +getName(player)+" for container: " + container);
		return false;
	}
	CustomerServiceLog("CollectionLootChannel", "getRandomCollectionItem - Player: "+player+" Name: " +getName(player)+ " Has triggered the creation of a collection object from the collection system. The object: "+collectionItem+" Name: "+getName(collectionItem)+" has been placed in the container: "+container);
	obj_id objArrray[] = new obj_id[1];
	objArrray[0] = collectionItem;
	showLootBox(player, objArrray);
	return true;
}

///This function has a list of ALL loot drop collection items as of 02/01/2008
///This will grant a player a random item from that list.
///Container = the container to place the object in (originally developed for Magseals)
boolean getRandomCollectionItem(obj_id player, obj_id container, string loot_table, string loot_column)
{
	//Validation
	if(!isIdValid(container) || !isIdValid(player))
	{
		return false;
	}
	//Get the collection loot column from the magseal loot table.
	string[] collectionLootArray = dataTableGetStringColumnNoDefaults(loot_table, loot_column);
	//ensure there is data in the collection column
	if(collectionLootArray == null || collectionLootArray.length <= 0)
	{
		return false;
	}
	int random = rand(0, collectionLootArray.length-1);

	obj_id collectionItem = static_item.createNewItemFunction(collectionLootArray[random], container);

	if(!isValidId(collectionItem) || !exists(collectionItem))
	{
		//Customer Service Log for failure to create item
		CustomerServiceLog("CollectionLootChannel: ", "getRandomCollectionItem - BrokenLoot: inValid object was created for player " + player + " Name: " +getName(player)+" for container: " + container);
		return false;
	}
	CustomerServiceLog("CollectionLootChannel", "getRandomCollectionItem - Player: "+player+" Name: " +getName(player)+ " Has triggered the creation of a collection object from the collection system. The object: "+collectionItem+" Name: "+getName(collectionItem)+" has been placed in the container: "+container);

	return true;
}

obj_id grantRandomCollectionItem(obj_id player, string loot_table, string loot_column)
{
	if( !isIdValid(player) || !isPlayer(player) )
	{
		return obj_id.NULL_ID;
	}
	obj_id playerInv = getObjectInSlot(player, "inventory");
	if( !isIdValid(playerInv) )
	{
		return obj_id.NULL_ID;
	}

	string[] collectionLootArray = dataTableGetStringColumnNoDefaults(loot_table, loot_column);
	if(collectionLootArray == null || collectionLootArray.length <= 0)
	{
		return obj_id.NULL_ID;
	}

	int random = rand(0, collectionLootArray.length-1);
	obj_id collectionItem = static_item.createNewItemFunction(collectionLootArray[random], playerInv);
	if(!isValidId(collectionItem) || !exists(collectionItem))
	{
		//Customer Service Log for failure to create item
		CustomerServiceLog("CollectionLootChannel: ", "grantRandomCollectionItem - BrokenLoot: inValid object was created for player " + player + " Name: " +getName(player));
		return obj_id.NULL_ID;
	}
	else
	{
		CustomerServiceLog("CollectionLootChannel", "grantRandomCollectionItem - Player: "+player+" Name: " +getName(player)+ " Has received a random collection object from the collection system. The object: "+collectionItem+" Name: "+getName(collectionItem)+" has been placed in the player inventory: "+playerInv);
		prose_package pp = new prose_package();
		prose.setStringId(pp, new string_id("collection","reward_item"));
		prose.setTT(pp, new string_id("static_item_n", getStaticItemName(collectionItem)));
		sendSystemMessageProse(player, pp);
	}

	return collectionItem;
}

boolean gcwBaseControlCheck(obj_id factionObject, obj_id player)
{
	//Get the player's faction.
	string playerFaction = factions.getFaction(player);

	//Get what faction controls the base.
	obj_id subject = gcw.getPub30StaticBaseControllerId(factionObject);
	int baseFaction = gcw.getPub30StaticBaseControllingFaction(subject);

	/********Faction Constants from GCW ScriptLib*********
	const int NO_CONTROL				= 0;
	const int IMPERIAL_CONTROL			= 1;
	const int REBEL_CONTROL				= 2;
	*****************************************************/

	//The Faction Base is Neutral - BAIL
	if(baseFaction == gcw.NO_CONTROL)
	{
		return false;
	}
	//get planet scene -- this will be added to _rebel/_imperial to find the slot.
	string planet = getCurrentSceneName();
	//Faction Base is Rebel - must be an Imperial collecting
	if(baseFaction == gcw.REBEL_CONTROL)
	{

		if(toLower(playerFaction).equals("imperial"))
		{
			//Grant them the collection slot.
			utils.setScriptVar(factionObject, "collection.gcwSlotName", "col_gcw_insurgency_" + planet + "_imperial");
			return true;
		}
		else
		{
			return false;
		}
	}
	//Faction Base is Imperial - must be an Rebel collecting
	else if(baseFaction == gcw.IMPERIAL_CONTROL)
	{
		if(toLower(playerFaction).equals("rebel"))
		{
			//Grant them the collection slot.
			utils.setScriptVar(factionObject, "collection.gcwSlotName", "col_gcw_insurgency_" + planet + "_rebel");
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

//validates that both the player can indeed collect the collectible
//and that the collectible has all necessary varaibles on itself
boolean canCollectCollectible(obj_id player, obj_id collectible)
{
	if(!isValidId(collectible) || !isValidId(player))
		return false;
	else if(!exists(collectible) || !exists(player))
		return false;

	//check state of the player
	if(!checkState(player))
		return false;

	//Check to make sure the player has not already completed the collection slot
	string baseSlotName = getStringObjVar(collectible, OBJVAR_SLOT_NAME);
	if(baseSlotName == null || baseSlotName.equals(""))
		return false;

	//split the entry by : to seperate the collection name from the slot name
	string[] splitSlotNames = split(baseSlotName, ':');
	if(splitSlotNames == null || splitSlotNames.length < 0)
		return false;

	string slotName = splitSlotNames[1];
	string collectionName = splitSlotNames[0];

	if(collectionName == null || collectionName.equals(""))
		return false;

	boolean isCloseEnough = checkDistance(collectible, player, MAX_RANGE_TO_COLLECT);
	if(!isCloseEnough)
	{
		sendSystemMessage(player, SID_NOT_CLOSE_ENOUGH);
		return false;
	}

	//check to see if they have completed the prereqs for the collection
	else if(!hasCompletedCollectionSlotPrereq(player, slotName))
	{
		//you need to activate this collection
		sendSystemMessage(player, SID_NEED_TO_ACTIVATE_COLLECTION);
		return false;
	}
	//Check to make sure they havent completed the collection yet.
	else if(hasCompletedCollection(player, collectionName))
	{
		//tell the player They have already finished the collection
		sendSystemMessage(player, SID_ALREADY_FINISHED_COLLECTION);
		return false;
	}

	//check to see if they already have this slot completed
	else if((slotName == null || slotName.equals("")) || hasCompletedCollectionSlot(player, slotName))
	{
		//tell the player They have already finished all collections for this item
		sendSystemMessage(player, SID_ALREADY_HAVE_SLOT);
		return false;
	}

	return true;
}

boolean rewardPlayerCollectionSlot(obj_id player, obj_id collectible)
{
	if(!isValidId(collectible) || !isValidId(player))
		return false;
	else if(!exists(collectible) || !exists(player))
		return false;

	//the player has completed a puzzle or other requirement
	string baseSlotName = getStringObjVar(collectible, OBJVAR_SLOT_NAME);
	if(baseSlotName == null || baseSlotName.equals(""))
		return false;

	//split the entry by : to seperate the collection name from the slot name
	string[] splitSlotNames = split(baseSlotName, ':');
	if(splitSlotNames == null || splitSlotNames.length < 0)
		return false;

	string slotName = splitSlotNames[1];
	string collectionName = splitSlotNames[0];
	if(collectionName == null || collectionName.equals(""))
		return false;

	//check to see if they have completed the prereqs for the collection
	if(!hasCompletedCollectionSlotPrereq(player, slotName))
	{
		//you need to activate this collection
		sendSystemMessage(player, SID_NEED_TO_ACTIVATE_COLLECTION);
		return false;
	}
	//Check to make sure they havent completed the collection yet.
	else if(hasCompletedCollection(player, collectionName))
	{
		//tell the player They have already finished the collection
		sendSystemMessage(player, SID_ALREADY_FINISHED_COLLECTION);
		return false;
	}

	//check to see if they already have this slot completed
	else if((slotName == null || slotName.equals("")) || hasCompletedCollectionSlot(player, slotName))
	{
		//tell the player They have already finished all collections for this item
		sendSystemMessage(player, SID_ALREADY_HAVE_SLOT);
		return false;
	}

	if(!checkState(player))
		return false;

	boolean isCloseEnough = collection.checkDistance(collectible, player, MAX_RANGE_TO_COLLECT);
	if(!isCloseEnough)
	{
		sendSystemMessage(player, SID_NOT_CLOSE_ENOUGH);
		return false;
	}
	//removes stealth
	stealth.testInvisNonCombatAction(player, collectible);
	//gives mobs hate
	giveAreaMobsHate(collectible, player);

	//Update the player with the slot
	if(modifyCollectionSlotValue(player, slotName, 1))
	{
		CustomerServiceLog("CollectionConsume: ", "collectionItem (" + collectible + ")"+ " was consumed into a collection, for player " + getFirstName(player) + "(" + player + ").");
	}
	else
	{
		//tell cs we failed
		CustomerServiceLog("CollectionConsume: ", "collectionItem (" + collectible + ")"+ " was NOT consumed into a collection, for player " + getFirstName(player) + "(" + player + ").");
		//tell the player we failed
		sendSystemMessage(player, SID_REPORT_CONSUME_ITEM_FAIL);
		return false;
	}

	return true;
}

obj_id getRandomItem(obj_id player, string[] items, string collectionName, prose_package pp)
{
	int randomChoice = rand(0, items.length -1);
	string itemToGrant = items[randomChoice];

	if(static_item.isStaticItem(itemToGrant))
	{
		return createStaticItemWithMessage(player, itemToGrant, collectionName, pp);
	}

	return createTemplateItemWithMessage(player, itemToGrant, collectionName, pp);
}

obj_id getWeightedRandomItem(obj_id player, string[] items, string collectionName, prose_package pp)
{
	//making random reward objects less aggravating to players//
	int randomChoice = 0;

	for(int k = 0; k < MAXLOOP; k++)
	{
		//select a random item from the list
		randomChoice = rand(0, items.length -1);

		//get the dictionary row of the item to grant -
		dictionary itemDict = dataTableGetRow(static_item.ITEM_STAT_BALANCE_TABLE, items[randomChoice]);
		//get the slot of the item to grant
		string slotObjvar = itemDict.getString("objvars");
		string[] objvarArray = split(slotObjvar, ':');
		slotObjvar = objvarArray[objvarArray.length -1]; //this is the slot

		//check to see if the player completed the slot
		if(hasCompletedCollectionSlot(player, slotObjvar))
		{
			//slot has been completed - continue
			continue;
		}
		else
		{
			//break out and create item!
			break;
		}
	}
	if(static_item.isStaticItem(items[randomChoice]))
	{
		return createStaticItemWithMessage(player, items[randomChoice], collectionName, pp);
	}

	return createTemplateItemWithMessage(player, items[randomChoice], collectionName, pp);
}

obj_id createStaticItemWithMessage(obj_id player, string staticItem, string collectionName, prose_package pp)
{
	if(!isValidId(player) || !exists(player) || staticItem == null || staticItem.equals(""))
		return null;

	obj_id itemId = static_item.createNewItemFunction(staticItem, player);
	if(!isValidId(itemId) || !exists(itemId))
	{
		CustomerServiceLog("CollectionComplete: ", "createStaticItemWithMessage - Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " Item:  " + staticItem + " was not created due to invalid itemID. Attempted to create as static item.");
		return null;
	}
	CustomerServiceLog("CollectionComplete: ", "createStaticItemWithMessage - Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " Item:  " + staticItem + " OID: "+itemId+" was rewarded.");

	prose.setStringId(pp, SID_REWARD_ITEM);
	prose.setTT(pp, new string_id("static_item_n", getStaticItemName(itemId)));
	sendSystemMessageProse(player, pp);
	CustomerServiceLog("CollectionComplete: ", "Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " and was granted Item: " + staticItem + "(" + itemId + ")" + ".");
	return itemId;
}

obj_id createTemplateItemWithMessage(obj_id player, string templateItem, string collectionName, prose_package pp)
{
	if(!isValidId(player) || !exists(player) || templateItem == null || templateItem.equals(""))
		return null;

	obj_id pInv = utils.getInventoryContainer(player);
	if(!isValidId(pInv) || !exists(pInv))
	{
		CustomerServiceLog("CollectionComplete: ", "Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " Item:  " + templateItem + "was not created due to invalid Player Inventory.");
		return null;
	}
	obj_id itemId = createObjectOverloaded(templateItem, pInv);
	if(!isValidId(itemId) || !exists(itemId))
	{
		CustomerServiceLog("CollectionComplete: ", "Player " + getFirstName(player) + "(" + player + ") has completed " + collectionName + " Item:  " + templateItem + "was not created due to invalid itemID. Attempted to create as object template.");
		return null;
	}
	prose.setStringId(pp, SID_REWARD_ITEM);
	prose.setTT(pp, "@" + getName(itemId));
	sendSystemMessageProse(player, pp);
	return itemId;
}

//This give a player a comm message while on Tansarii Station.  this comm gives them information about collections.
void giveNewbieCommWindow(obj_id player, obj_id object)
{
	if(!isIdValid(player) || !isIdValid(object))
		return;

	if(getLevel(player) >= 10)
	{
		return;
	}

	if(utils.hasScriptVar(player, "newbie_comm_series"))
	{
		int number = utils.getIntScriptVar(player, "newbie_comm_series");
		if(number > 3)
			//player has seen all the comms -
			return;
		prose_package pp = new prose_package();

		switch(number)
		{
			case 1:
				prose.setStringId(pp, new string_id("collection", "newbie_comm_message_2"));
				commPlayers(object, "object/mobile/r2.iff", "sound/dro_r2_3_danger.snd", 10f, player, pp);
				number++;
				utils.setScriptVar(player, "newbie_comm_series", number);
				break;
			case 2:
				prose.setStringId(pp, new string_id("collection", "newbie_comm_message_3"));
				commPlayers(object, "object/mobile/r2.iff", "sound/dro_r2_3_danger.snd", 15f, player, pp);
				number++;
				utils.setScriptVar(player, "newbie_comm_series", number);
				break;
			case 3:
				prose.setStringId(pp, new string_id("collection", "newbie_comm_message_4"));
				commPlayers(object, "object/mobile/r2.iff", "sound/dro_r2_3_danger.snd", 12f, player, pp);
				number++;
				utils.setScriptVar(player, "newbie_comm_series", number);
				break;
			default:
				break;
		}
	}
	else
	{
		prose_package pp = new prose_package();
		prose.setStringId(pp, new string_id("collection", "newbie_comm_message"));
		commPlayers(object, "object/mobile/r2.iff", "sound/dro_r2_3_danger.snd", 10f, player, pp);
		utils.setScriptVar(player, "newbie_comm_series", 1);
	}
	return;
}

void grantQuestBasedCollections(string questString, obj_id player)
{
	if(!isIdValid(player) || !exists(player) || !isPlayer(player))
	{
		return;
	}
	
	string collectionFaction = null;
	string collectionName = null;
	
	if(factions.isRebelorRebelHelper(player))
	{
		collectionFaction = "rebelCollection";
	}
	
	else if(factions.isImperialorImperialHelper(player))
	{
		collectionFaction = "imperialCollection";
	}
	
	else
	{
		collectionFaction = "neutralCollection";
	}
	
	int tableRow = dataTableSearchColumnForString(questString, "questName", QUEST__COMPLETED_COLLECTIONS);
	
	if(tableRow > -1)
	{
		collectionName = dataTableGetString(QUEST__COMPLETED_COLLECTIONS, tableRow, collectionFaction);
	}

	if(collectionName == null)
	{
		return;
	}
	
	if ( !hasCompletedCollectionSlot(player, collectionName) )
	{
		modifyCollectionSlotValue(player, collectionName, 1);
	}
	
	return;
}