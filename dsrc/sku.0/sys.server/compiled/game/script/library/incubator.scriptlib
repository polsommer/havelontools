/**
 * Copyright (c) ©2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        library.incubator.scriptlib
 * Description:
 * @author       jbenjamin
 * @version      $Revision: 1$
 */



//Includes
include library.beast_lib;
include library.city;
include library.create;
include library.hue;
include library.loot;
include library.npe;
include library.pet_lib;
include library.resource;
include library.utils;

//constants
const int MAX_ADJUSTED_POINTS_PER_SESSION_DPS_ARMOR				= 8;
const int MAX_ADJUSTED_POINTS_PER_SESSION_ATTRIBUTES				= 16;
const int MAX_SESSION_SKILL_INCREMENT						= 10;
const int MAX_TOTAL_POINTS_ATTRIBUTES						= 50;
const int MAX_TOTAL_POINTS_DPS_ARMOR						= 23;
const int MAX_TOTAL_SKILL_INCREMENT						= 10;
const int MAX_SESSION_TIME 							= 60*60*40;
const int MAX_POINTS_PER_SESSION_DPS_ARMOR					= 5;
const int MAX_POINTS_PER_SESSION_ATTRIBUTES					= 14;
const int MAX_GUI_POWER								= 1000;
const int MAX_BONUS_FOR_POWER_QUALITY						= 11;
const int MAX_POWER_QUALITY							= 1000;
const int CHANCE_FOR_ONE_KNOWN_SKILL 						= 70;
const int NUMBER_OF_COLORS 							= 8;
const int SESSIONS_TO_HATCH 							= 4;
const int NEXT_SESSION_TIME 							= 60*60*24;
const int TEMP_SCALE_MAX_RANGE							= 10;
const int RESOURCE_POWER_AMOUNT_CAP						= 50000;
const int POWER_PER_SESSION							= 2500;

const int MAX_MUTAGEN_POINTS							= 20;
const int MUTATION_MAX_INCREASE							= 18;
const int MAX_MUTATIONS								= 3;

const int MUTATION_SKILL_BONUS_AMT						= 2;

const float MUTATION_BONUS_DNA							= 3.5f;
const float MUTATION_BONUS_ENZYME						= 3.5f;
const float MUTATION_BONUS_INCUBATOR						= 3.5f;
const float MUTATION_BONUS_MUTAGEN						= 4.5f;
const float BASE_MUTATION_CHANCE						= 2.0f;

const int MUTATION_PALETTE_LENGTH						= 20;

const int GUI_TIME_TO_REFRESH							= 10800; //3 hours


const float TEMP_SCALE_CONVERSION_TO_PERCENT					= 0.1f;
const float MIN_QUALITY_RANGE 							= 10.0f;
const float MAX_QUALITY_RANGE 							= 90.0f;
const float STATION_QUALITY_MIN							= -12.0f;
const float STATION_QUALITY_MAX							= 4.0f;
const float STATION_FUNCTIONALITY_MIN						= -12.0f;
const float STATION_FUNCTIONALITY_MAX						= 4.0f;

const int MAX_RE_EXOTIC_DPS_ARMOR_SKILLMOD				= 10;
const int MAX_RE_EXOTIC_MUTATION_SKILLMOD				= 10;

const string DATATABLE_INCUBATOR_TEMPLATES					= "datatables/beast/incubator_templates.iff";
const string DATATABLE_TEMPLATE_MUTATION_COLORS					= "datatables/beast/beast_master_color_chances.iff";

const string BASE_ENZYME_OBJVAR 						= "beast.enzyme";
const string BASE_DNA_OBJVAR 							= "beast.dna";
const string ENZYME_LEVEL_OBJVAR 						= BASE_ENZYME_OBJVAR+".level";
const string ENZYME_TYPE_OBJVAR 						= BASE_ENZYME_OBJVAR+".type";
const string ENZYME_QUALITY_OBJVAR 						= BASE_ENZYME_OBJVAR+".quality";
const string ENZYME_RANDOM_STATS_OBJVAR 					= BASE_ENZYME_OBJVAR+".randomStats";
const string ENZYME_FREE_STAT_OBJVAR 						= BASE_ENZYME_OBJVAR+".freeStatName";
const string ENZYME_PURITY_OBJVAR 						= "enzyme.enzyme_purity";
const string ENZYME_MUTAGEN_OBJVAR 						= "enzyme.enzyme_mutagen";
const string ENZYME_TRAIT_OBJVAR 						= "trait";
const string ENZYME_COLOR_OBJVAR 						= BASE_ENZYME_OBJVAR+".color";
const string DNA_TEMPLATE_OBJVAR						= BASE_DNA_OBJVAR+".creature_template";
const string DNA_PARENT_TEMPLATE						= BASE_DNA_OBJVAR+".parent_creature_template";
const string DNA_PARENT_TEMPLATE_NAME						= BASE_DNA_OBJVAR+".parent_creature_name";
const string DNA_QUALITY_OBJVAR 						= BASE_DNA_OBJVAR+".quality";
const string DNA_BEEN_SAMPLED_SCRIPTVAR						= BASE_DNA_OBJVAR+".sampled";
const string DNA_HUE_OLD_PET							= BASE_DNA_OBJVAR+".hue";
const string DNA_SCALE_OLD_PET							= BASE_DNA_OBJVAR+".scale";
const string DNA_OLD_PET_IDENTIFIER						= BASE_DNA_OBJVAR+".converted_pet";
const string DNA_PARENT_NAME							= BASE_DNA_OBJVAR+".name";
const string DNA_CS								= BASE_DNA_OBJVAR+".cs_item";

const string BASE_INCUBATOR_OBJVAR						= "incubator";
const string BASE_INCUBATOR_POWER_OBJVAR					= "power";
const string ACTIVE_INCUBATOR							= BASE_INCUBATOR_OBJVAR+".active";
const string SESSION_NUMBER							= BASE_INCUBATOR_OBJVAR+".session";
const string LAST_MUTATION							= BASE_INCUBATOR_OBJVAR+".last_mutation";
const string ACTIVE_SESSION							= SESSION_NUMBER+".active";
const string NEXT_SESSION							= BASE_INCUBATOR_OBJVAR+".next_session";
const string POINTS_ALLOCATED							= BASE_INCUBATOR_OBJVAR+".points_allocated";
const string OBJVAR_EGG_CREATED							= BASE_INCUBATOR_OBJVAR+".egg_created";

const string ALLOCATED_DPS							= POINTS_ALLOCATED+".dps";
const string ALLOCATED_ARMOR							= POINTS_ALLOCATED+".armor";
const string ALLOCATED_HEALTH							= POINTS_ALLOCATED+".health";

const string ALLOCATED_HIT_CHANCE						= POINTS_ALLOCATED+".hit_chance";
const string ALLOCATED_DODGE							= POINTS_ALLOCATED+".dodge";
const string ALLOCATED_PARRY_CHANCE						= POINTS_ALLOCATED+".parry_chance";
const string ALLOCATED_GLANCING_BLOW						= POINTS_ALLOCATED+".glancing_blow";
const string ALLOCATED_BLOCK_CHANCE						= POINTS_ALLOCATED+".block_chance";
const string ALLOCATED_BLOCK_VALUE						= POINTS_ALLOCATED+".block_value";
const string ALLOCATED_EVASION							= POINTS_ALLOCATED+".evasion";
const string ALLOCATED_EVASION_RATING						= POINTS_ALLOCATED+".evasion_rating";
const string ALLOCATED_STRIKETHROUGH						= POINTS_ALLOCATED+".strikethrough";
const string ALLOCATED_STRIKETHROUGH_RATING					= POINTS_ALLOCATED+".strikethrough_rating";
const string ALLOCATED_CRITICAL_HIT						= POINTS_ALLOCATED+".critical_hit";

const string ALLOCATED_AGGRESSION						= POINTS_ALLOCATED+".aggression";
const string ALLOCATED_BEASTIAL_RESILIENCE					= POINTS_ALLOCATED+".beastialResilience";
const string ALLOCATED_HUNTERS_INSTINCT						= POINTS_ALLOCATED+".huntersInstinct";
const string ALLOCATED_INTELLIGENCE						= POINTS_ALLOCATED+".intelligence";
const string ALLOCATED_SURVIVAL							= POINTS_ALLOCATED+".survival";
const string ALLOCATED_CUNNING							= POINTS_ALLOCATED+".cunning";

const string ALLOCATED_CREATURE_HUE_INDEX					= "incubator.hueIndex";

const string TEMPLATE_STORED							= ".creature_template";
const string STATION_QUALITY_OBJVAR						= "crafting.stationMod_1";
const string STATION_FUNCTIONALITY_OBJVAR					= "crafting.stationMod";

const string POINTS_SPENT_OBJVAR						= ".points_spent";
const string POINTS_SPENT_SLOT_1_QUALITY					= POINTS_SPENT_OBJVAR+".slotOneQuality";
const string POINTS_SPENT_SLOT_3_QUALITY					= POINTS_SPENT_OBJVAR+".slotThreeQuality";
const string POINTS_SPENT_SLOT_2_STAT						= POINTS_SPENT_OBJVAR+".slotTwoStat";
const string POINTS_SPENT_RANDOM_STAT_COUNT					= POINTS_SPENT_OBJVAR+".slotTwoRandomStatCount";
const string POINTS_SPENT_SLOT_4_MUTAGEN					= POINTS_SPENT_OBJVAR+".slotFourMutagenAmt";
const string POINTS_SPENT_SLOT_4_PURITY						= POINTS_SPENT_OBJVAR+".slotFourPurity";
const string POINTS_SPENT_SLOT_4_TRAIT						= POINTS_SPENT_OBJVAR+".slotFourTrait";

const string POINTS_SPENT_INCREMENT_SURVIVAL					= POINTS_SPENT_OBJVAR+".survivalSkillIncrement";
const string POINTS_SPENT_INCREMENT_BEASTIAL					= POINTS_SPENT_OBJVAR+".beastialSkillIncrement";
const string POINTS_SPENT_INCREMENT_CUNNING					= POINTS_SPENT_OBJVAR+".cunningSkillIncrement";
const string POINTS_SPENT_INCREMENT_INTELLIGENCE				= POINTS_SPENT_OBJVAR+".intelligenceSkillIncrement";
const string POINTS_SPENT_INCREMENT_AGGRESSION					= POINTS_SPENT_OBJVAR+".aggressionSkillIncrement";
const string POINTS_SPENT_INCREMENT_HUNTERS					= POINTS_SPENT_OBJVAR+".huntersSkillIncrement";

const string POINTS_SPENT_POS_TEMP_SLIDER					= POINTS_SPENT_OBJVAR+".tempGaugeSliderPos";
const string POINTS_SPENT_POS_NUTRIENT_SLIDER					= POINTS_SPENT_OBJVAR+".nutGaugeSliderPos";

const string POINTS_SPENT_DPS							= POINTS_SPENT_OBJVAR+".dps";
const string POINTS_SPENT_ARMOR							= POINTS_SPENT_OBJVAR+".armor";
const string POINTS_SPENT_HEALTH						= POINTS_SPENT_OBJVAR+".health";

const string POINTS_SPENT_HIT_CHANCE						= POINTS_SPENT_OBJVAR+".hit_chance";
const string POINTS_SPENT_DODGE							= POINTS_SPENT_OBJVAR+".dodge";
const string POINTS_SPENT_PARRY_CHANCE						= POINTS_SPENT_OBJVAR+".parry_chance";
const string POINTS_SPENT_GLANCING_BLOW						= POINTS_SPENT_OBJVAR+".glancing_blow";
const string POINTS_SPENT_BLOCK_CHANCE						= POINTS_SPENT_OBJVAR+".block_chance";
const string POINTS_SPENT_BLOCK_VALUE						= POINTS_SPENT_OBJVAR+".block_value";
const string POINTS_SPENT_CRITICAL_HIT						= POINTS_SPENT_OBJVAR+".critical_hit";
const string POINTS_SPENT_EVASION						= POINTS_SPENT_OBJVAR+".evasion";
const string POINTS_SPENT_EVASION_RATING					= POINTS_SPENT_OBJVAR+".evasion_rating";
const string POINTS_SPENT_STRIKETHROUGH						= POINTS_SPENT_OBJVAR+".strikethrough";
const string POINTS_SPENT_STRIKETHROUGH_RATING					= POINTS_SPENT_OBJVAR+".strikethrough_rating";

const string COLORS_USED_OBJVAR							= ".colors_used";
const string COLORS_USED_SLOT_1							= COLORS_USED_OBJVAR+".slotOneColor";
const string COLORS_USED_SLOT_2							= COLORS_USED_OBJVAR+".slotTwoColor";
const string COLORS_USED_SLOT_3							= COLORS_USED_OBJVAR+".slotThreeColor";
const string STATION_DNA							= BASE_INCUBATOR_OBJVAR+".dna";
const string STATION_DNA_ID							= STATION_DNA+".id";
const string STATION_DNA_CREATURE						= STATION_DNA+".parent_creature_template";
const string STATION_DNA_QUALITY						= STATION_DNA+".quality";
const string STATION_DNA_CREATURE_TEMPLATE					= STATION_DNA+".creature_template";
const string STATION_DNA_OLD_PET_IDENTIFIER					= STATION_DNA+".converted_pet";
const string STATION_DNA_HUE_OLD_PET						= STATION_DNA+".hue";
const string STATION_DNA_PARENT_NAME						= STATION_DNA+".name";
const string STATION_STORED_CREATURE_TEMPLATE					= BASE_INCUBATOR_OBJVAR+TEMPLATE_STORED;
const string RESOURCE_POWER_NAME						= BASE_INCUBATOR_POWER_OBJVAR+".name";
const string RESOURCE_POWER_QUALITY						= BASE_INCUBATOR_POWER_OBJVAR+".quality";
const string RESOURCE_POWER_AMOUNT						= BASE_INCUBATOR_POWER_OBJVAR+".amount";

const string PARTICLE_LABEL_DEFAULT						= "default_bubbles";
const string PARTICLE_LABEL_PHASE_ONE						= "phase_1";
const string PARTICLE_LABEL_PHASE_TWO						= "phase_2";
const string PARTICLE_LABEL_PHASE_THREE						= "phase_3";
const string PARTICLE_LABEL_PHASE_FOUR						= "phase_4";
const string PARTICLE_DEFAULT							= "appearance/pt_incubator_bubbles_mid.prt";
const string PARTICLE_PHASE_ONE							= "appearance/pt_incubator_swirl_s01.prt";
const string PARTICLE_PHASE_TWO							= "appearance/pt_incubator_swirl_s02.prt";
const string PARTICLE_PHASE_THREE						= "appearance/pt_incubator_swirl_s03.prt";
const string PARTICLE_PHASE_FOUR						= "appearance/pt_incubator_egg.prt";
const string PARTICLE_LABEL_SCRIPT_VAR						= "particleLabel";
const string PARTICLE_HARDPOINT_ONE						= "hardpoint_1";
const string PARTICLE_HARDPOINT_TWO						= "hardpoint_2";
const string PARTICLE_HARDPOINT_THREE						= "hardpoint_3";

const string COMM_APPEARANCE_ACTIVATE						= "object/mobile/incubator_activation_comm_01.iff";
const string COMM_APPEARANCE_VADER						= "object/mobile/darth_vader.iff";
const string COMM_SFX_ACTIVATE							= "sound/voc_huttese_blurt_m_09.snd";
const string COMM_SFX_MUTATE_TEMPLATE						= "sound/voc_huttese_blurt_rnd_03_thru_05.snd";
const string COMM_SFX_MUTATE_ATTRIB						= "sound/voc_huttese_blurt_rnd_06_thru_08.snd";
const string COMM_SFX_MUTATION_3_VADER						= "sound/darth_1.snd";

const string GUI_SCRIPT_VAR							= "incubator.lastSessionTime";

const string[] ENZYME_TYPES =
{
	"",// we only have types 1  thru 3, so 0 is blank.
	"Quality",
	"Stat",
	"Skill"
};
const string[] STAT_LIST = 
{
	"Hit Chance",
	"Dodge",
	"Parry Chance",
	"Glancing Blow",
	"Block Chance",
	"Block Value",
	"Critical Hit",
	"Evasion",
	"Evasion Rating",
	"Strikethrough",
	"Strikethrough Rating",
	"Health Bonus"
};

const string[] COMM_MUTATION_APP =
{
	"object/mobile/incubator_mutation_comm_01.iff",
	"object/mobile/incubator_mutation_comm_02.iff",
	"object/mobile/incubator_mutation_comm_03.iff"
};

const string[] ARRAY_SKILLS =
{
	ALLOCATED_AGGRESSION,
	ALLOCATED_BEASTIAL_RESILIENCE,
	ALLOCATED_HUNTERS_INSTINCT,
	ALLOCATED_INTELLIGENCE,
	ALLOCATED_SURVIVAL,
	ALLOCATED_CUNNING
};

const string[]	SKILL_DISPLAY_NAMES =
{
	"aggression_skill",
	"beastial_resilience_skill",
	"hunters_instinct_skill",
	"intelligence_skill",
	"survival_skill",
	"cunning_skill"
};

const string[] ARRAY_ATTRIBUTES = 
{
	ALLOCATED_DPS,
	ALLOCATED_ARMOR,
	ALLOCATED_HEALTH,
	ALLOCATED_HIT_CHANCE,
	ALLOCATED_DODGE,
	ALLOCATED_PARRY_CHANCE,
	ALLOCATED_GLANCING_BLOW,
	ALLOCATED_BLOCK_CHANCE,
	ALLOCATED_BLOCK_VALUE,
	ALLOCATED_CRITICAL_HIT,
	ALLOCATED_EVASION,
	ALLOCATED_EVASION_RATING,
	ALLOCATED_STRIKETHROUGH,
	ALLOCATED_STRIKETHROUGH_RATING

};

const string[]	ATTRIBUTE_DISPLAY_NAMES =
{
	"dps_bonus",
	"armor_bonus",
	"health_bonus",
	"hit_chance_bonus",
	"dodge_bonus",
	"parry_bonus",
	"glancing_blow_bonus",
	"block_chance_bonus",
	"block_value_bonus",
	"critical_hit_bonus",
	"evasion_bonus",
	"evasion_rating_bonus",
	"strikethrough_bonus",
	"strikethrough_rating_bonus"

};

const string[] ENZYME_COLORS =
{
	"Yellow",
	"Orange",
	"Red",
	"Violet",
	"Purple",
	"Dark Blue",
	"Light Blue",
	"Teal",
	"Green",
	"Lime"
};

const string[] ENZYME_COLLECTION_NAMES =
{
	"col_yellow_enzyme",
	"col_orange_enzyme",
	"col_red_enzyme",
	"col_violet_enzyme",
	"col_purple_enzyme",
	"col_dark_blue_enzyme",
	"col_light_blue_enzyme",
	"col_teal_enzyme",
	"col_green_enzyme",
	"none"
};

const float[]	ATTRIBUTE_DISPLAY_CONVERSION_RATES =
{
	0.1f, //dps
	0.1f, //armor
	0.2f, //health
	0.1f, //hit chance
	0.1f, //dodge
	0.1f, //parry
	0.1f, //glancing blow
	0.1f, //block chance
	1.0f, //block value
	0.1f, //critical hit
	0.1f, //evasion
	1.0f, //evasion rating
	0.1f, //strikethrough chance
	1.0f  //strikethrough rating
};


//string_ids
const string_id SID_NOT_YOUR_INCUBATOR						= new string_id( "beast", "incubator_not_yours");
const string_id SID_DNA_ALREADY_BEEN_SAMPLED					= new string_id("incubator", "dna_already_sampled");
const string_id SID_DNA_CREATURE_NOT_ON_LIST					= new string_id("incubator", "dna_creature_not_on_list"); 
const string_id SID_DNA_SAMPLED							= new string_id("incubator", "dna_sampled"); 
const string_id SID_DNA_FAILED_SAMPLE						= new string_id("incubator", "dna_failed_get");
const string_id SID_DNA_FAILED_SAMPLE_FULL_INVENTORY				= new string_id("incubator", "dna_failed_full_inventory");
const string_id SID_DNA_NO_ALLOW_COLLECT					= new string_id("incubator", "dna_cannot_vehicle");
const string_id SID_DNA_CANT_COLLECT_MOUNTED					= new string_id("incubator", "dna_cannot_mounted");
const string_id SID_DNA_CANT_COLLECT						= new string_id("incubator", "dna_is_pet");
const string_id SID_DNA_CANT_IN_COMBAT						= new string_id("incubator", "dna_is_in_combat");
const string_id SID_DNA_INVALID_TARGET						= new string_id("incubator", "dna_invalid_target");
const string_id RESOURCE_POWER_AMOUNT_FULL					= new string_id("incubator", "full_station");
const string_id RESOURCE_POWER_AMOUNT_MUST_EMPTY				= new string_id("incubator", "must_empty");
const string_id RESOURCE_TYPE_MISMATCH						= new string_id("incubator", "type_mismatch");
const string_id RESOURCE_POWER_INV_FULL						= new string_id("incubator", "inventory_full");
const string_id RESOURCE_POWER_NOT_ENOUGH					= new string_id("incubator", "need_power");
const string_id	SID_REPORT_PET_NOT_CONVERTING					= new string_id("incubator", "report_pet_conversion_fail");
const string_id SID_COMM_ACTIVATION						= new string_id("incubator", "comm_activate");
const string_id SID_COMM_RDM_MUTATION_1						= new string_id("incubator", "comm_rdm_mutation_1");
const string_id SID_COMM_RDM_MUTATION_2						= new string_id("incubator", "comm_rdm_mutation_2");
const string_id SID_COMM_RDM_MUTATION_3						= new string_id("incubator", "comm_rdm_mutation_3");
const string_id SID_COMM_VADER_MUTATION_3					= new string_id("incubator", "comm_vader_mutation_3");
const string_id SID_COMM_ATTRIB_MUTATION_1					= new string_id("incubator", "comm_attrib_mutation_1");
const string_id SID_COMM_ATTRIB_MUTATION_2					= new string_id("incubator", "comm_attrib_mutation_2");
const string_id SID_COMM_ATTRIB_MUTATION_3					= new string_id("incubator", "comm_attrib_mutation_3");
const string_id SID_COMM_MUTATION_COLOR_CORRECT					= new string_id("incubator", "comm_mutation_color_correct");
const string_id SID_ATTRIBUTE_MUTATION						= new string_id("incubator", "sys_message_attribute_mutated");
const string_id SID_CHEATER_DNA_CHANGED						= new string_id("incubator", "cheater_dna_changed");

const string_id[] COMM_MUTATED_TEMPLATE_TEXT =
{
	SID_COMM_RDM_MUTATION_1,
	SID_COMM_RDM_MUTATION_2,
	SID_COMM_RDM_MUTATION_3
};

const string_id[] COMM_MUTATED_ATTRIB_TEXT =
{
	SID_COMM_ATTRIB_MUTATION_1,
	SID_COMM_ATTRIB_MUTATION_2,
	SID_COMM_ATTRIB_MUTATION_3
};

const boolean LOGGING_ENABLED							= true;
//helper functions

//Gets the Enzyme type as integer
//This is the best way to get the Enzyme type
//
int getIntEnzymeType(obj_id enzyme)
{
	if(!hasObjVar(enzyme, ENZYME_TYPE_OBJVAR))
	{
		//doesnt have the objvar, something is wrong.
		//may not be an enzyme
		return 0;
	}
	return getIntObjVar(enzyme, ENZYME_TYPE_OBJVAR);
}

//Gets the Enzyme type as string
//This is just to help debug. It puts it in human
//readable form
String getStringEnzymeType(obj_id enzyme)
{
	if(!hasObjVar(enzyme, ENZYME_TYPE_OBJVAR))
	{
		//doesnt have the objvar, something is wrong.
		//may not be an enzyme
		return "";
	}
	int enzymeType = getIntObjVar(enzyme, ENZYME_TYPE_OBJVAR);
	return ENZYME_TYPES[enzymeType];
}

//determines if given enzyme is quality type
boolean isQualityEnzyme(obj_id enzyme)
{
	if(hasObjVar(enzyme, ENZYME_QUALITY_OBJVAR) && exists(enzyme))
	{
		return true;
	}
	return false;
}

//determines if given enzyme is stat modifying type
boolean isStatEnzyme(obj_id enzyme)
{
	if(exists(enzyme))
	{
		if(hasObjVar(enzyme, ENZYME_RANDOM_STATS_OBJVAR) || hasObjVar(enzyme, ENZYME_FREE_STAT_OBJVAR))
			return true;
	}
	return false;	
}

//determines if given enzyme is skill point type
boolean isSkillEnzyme(obj_id enzyme)
{
	if(hasObjVar(enzyme, ENZYME_PURITY_OBJVAR) && exists(enzyme))
	{
		return true;
	}
	return false;
}

//returns number of random stats on given enzyme
int getEnzymeRandomStats(obj_id enzyme)
{
	if(hasObjVar(enzyme, ENZYME_RANDOM_STATS_OBJVAR) && exists(enzyme))
		return getIntObjVar(enzyme, ENZYME_RANDOM_STATS_OBJVAR);
	else
		return 0;
}

//returns freen stat name for given enzyme
string getEnzymeFreeStat(obj_id enzyme)
{
	if(hasObjVar(enzyme, ENZYME_FREE_STAT_OBJVAR) && exists(enzyme))
		return getStringObjVar(enzyme, ENZYME_FREE_STAT_OBJVAR);
	else
		return "";
}

//returns number of skill points granted for given enzyme
float getEnzymeSkillPoints(obj_id enzyme)
{
	return getFloatObjVar(enzyme, ENZYME_PURITY_OBJVAR);
}

//returns float quality of given enzyme
float getEnzymeQuality(obj_id enzyme)
{
	float baseQuality = 0.0f;
	if(hasObjVar(enzyme, ENZYME_QUALITY_OBJVAR))
	{
		baseQuality = getFloatObjVar(enzyme, ENZYME_QUALITY_OBJVAR);
	}		
	return baseQuality;
		
}

//returns the enzymes color integer
int getEnzyemColor(obj_id enzyme)
{
	return getIntObjVar(enzyme, ENZYME_COLOR_OBJVAR);
}

float getEnzyemMutagen(obj_id enzyme)
{
	float mutagen = 0.0f;
	if(hasObjVar(enzyme, ENZYME_MUTAGEN_OBJVAR))
		mutagen = getFloatObjVar(enzyme, ENZYME_MUTAGEN_OBJVAR);
		
	return mutagen;	
}

string getEnzyemTrait(obj_id enzyme)
{
	string trait = "";
	if(hasObjVar(enzyme, ENZYME_TRAIT_OBJVAR))
		trait = getStringObjVar(enzyme, ENZYME_TRAIT_OBJVAR);
		
	return trait;
}

//returns wheter the enzyme has a color assigned to it.
boolean hasEnzymeColor(obj_id enzyme)
{
	if(hasObjVar(enzyme, ENZYME_COLOR_OBJVAR) && exists(enzyme))
	{
		return true;
	}
	return false;
}

//returns whether the DnaContainer has the quality Objvar
boolean hasDnaQuality(obj_id dnaContainer)
{
	if(hasObjVar(dnaContainer, DNA_QUALITY_OBJVAR) && exists(dnaContainer))
	{
		return true;
	}
	return false;
}

//returns whether the DnaContainer has the template objvar
boolean hasDnaTemplate(obj_id dnaContainer)
{
	if(hasObjVar(dnaContainer, DNA_TEMPLATE_OBJVAR) && exists(dnaContainer))
	{
		return true;
	}
	return false;
}

//returns whether the dna container has the parent creature objvar
boolean hasDnaParentCreature(obj_id dnaContainer)
{
	if(hasObjVar(dnaContainer, DNA_PARENT_TEMPLATE)&& exists(dnaContainer))
	{
		return true;
	}
	return false;
}


//returns float DNA qualty of given DNA container
float getDnaQuality(obj_id dnaContainer)
{
	return getFloatObjVar(dnaContainer, DNA_QUALITY_OBJVAR);
}

//Returns template stored
int getDnaCreatureTemplate(obj_id dnaContainer)
{
	return getIntObjVar(dnaContainer, DNA_TEMPLATE_OBJVAR);
}

//returns the parent creature objvar
string getDnaParentCreature(obj_id dnaContainer)
{
	return getStringObjVar(dnaContainer, DNA_PARENT_TEMPLATE);
}

void setUpEnzymeWithDummyData(obj_id enzyme)
{
	if(hasObjVar(enzyme, ENZYME_TYPE_OBJVAR))
	{
		int enzymeType = getIntEnzymeType(enzyme);
		int enzymeColor = 0;
		switch(enzymeType)
		{
			case 1://Quality Enzymes
				setObjVar(enzyme, ENZYME_QUALITY_OBJVAR, 90.0f);
				//set the color
				enzymeColor = rand(0,NUMBER_OF_COLORS);
				setObjVar(enzyme, ENZYME_COLOR_OBJVAR, enzymeColor);
				hue.setColor(enzyme, "/private/index_color_1", enzymeColor);	
				break;
			case 2://Stat Enzymes
				initializeEnzymes(enzyme);	
				break;
			case 3://Special Skill Point enzymes
				blog("BEAST_ENZYME", "Skill Point Enzyme, we no longer do anything with these. They are setup elsewhere");
				break;
			default:
				blog("BEAST_ENZYME", "default case in switch statement. This shouldnt happen.");
				break;
		}
	}
}
//function to initialize values on enzymes
void initializeEnzymes(obj_id enzyme)
{
	//we need to determine the quality, stats modified, and color.
	int creatureLevel = getIntObjVar(enzyme, ENZYME_LEVEL_OBJVAR);
	blog("BEAST_ENZYME", "creatureLevel = " + creatureLevel);
	if(hasObjVar(enzyme, ENZYME_TYPE_OBJVAR))
	{
		int enzymeType = getIntEnzymeType(enzyme);
		switch(enzymeType)
		{
			case 1://Quality Enzymes
				float minRange = 0.0f;
				float maxRange = MIN_QUALITY_RANGE;
				boolean foundRange = false;

				//Loop thru levels until we reach level 75
				for(int i = 10; i <= 75; i+=5)
				{
					if(creatureLevel <= i)
					{
						minRange = creatureLevel; //qaulity will not be lower than level
						maxRange = creatureLevel + 5;// quality can be 5 higher than level
						foundRange = true;
						break;
					}

				}

				if(!foundRange)
				{
					//deliberately set the max to be only 90
					//this will encourage incubator players to use the expertise
					minRange = 80.0f;
					maxRange = MAX_QUALITY_RANGE;
					foundRange = true;
				}

				//get random quality
				float quality = rand(minRange,maxRange);
				blog("BEAST_ENZYME", "quality = " + quality);
				setObjVar(enzyme, ENZYME_QUALITY_OBJVAR, quality);
				break;
			case 2://Stat Enzymes
				int randomChance = rand(1,100);
				int statListMinusOne = STAT_LIST.length - 1;
				int maxRandomWithKnown = STAT_LIST.length - 3;
				if( randomChance <= CHANCE_FOR_ONE_KNOWN_SKILL)
				{
					// you get one garunteed skill
					int statIndex = rand(0, statListMinusOne);
					string freeStatName = STAT_LIST[statIndex];
					int numRandomStats = rand(0, maxRandomWithKnown);
					blog("BEAST_ENZYME", "numRandomStats = " + numRandomStats);
					blog("BEAST_ENZYME", "freeStatName = " + freeStatName);
					setObjVar(enzyme, ENZYME_RANDOM_STATS_OBJVAR, numRandomStats);
					setObjVar(enzyme, ENZYME_FREE_STAT_OBJVAR, freeStatName);
				}
				else
				{
					//since you didnt get the one gauranteed, you can have up to 7
					//random skills affected
					if(hasObjVar(enzyme, ENZYME_FREE_STAT_OBJVAR))
					{
						// need to remove it
						removeObjVar(enzyme, ENZYME_FREE_STAT_OBJVAR);
					}
					int numRandomStats = rand(1, statListMinusOne);
					blog("BEAST_ENZYME", "numRandomStats = " + numRandomStats);
					setObjVar(enzyme, ENZYME_RANDOM_STATS_OBJVAR, numRandomStats);
				}
				break;
			case 3://Special Skill Point enzymes
				blog("BEAST_ENZYME", "Skill Point Enzyme, we no longer do anything with these. They are setup elsewhere");
			default:
				blog("BEAST_ENZYME", "default case in switch statement. This shouldnt happen.");
				break;
		}
	}
	int enzymeColor = rand(0,NUMBER_OF_COLORS);
	setObjVar(enzyme, ENZYME_COLOR_OBJVAR, enzymeColor);
	hue.setColor(enzyme, "/private/index_color_1", enzymeColor);
}



//lets see if our station has an acitve user
boolean hasActiveUser(obj_id station)
{
	if(!hasObjVar(station, ACTIVE_INCUBATOR))
		return false;
	
	return true;
}

//get the active user of the station, returns nullid if no station is found
obj_id getIncubatorActiveUser(obj_id station)
{
	return( utils.getObjIdObjVar(station, ACTIVE_INCUBATOR , obj_id.NULL_ID) );
}


//used on player to see if they are attached to an incubator
boolean hasActiveIncubator(obj_id player)
{
	if(!hasObjVar(player, ACTIVE_INCUBATOR))
		return false;
	
	return true;
}

//get the station the player is linked to, returns nullid if no station is found
obj_id getActiveIncubator(obj_id player)
{
	return( utils.getObjIdObjVar(player, ACTIVE_INCUBATOR , obj_id.NULL_ID) );
}

//set the player and incubator as active to each other
boolean setActiveUser(obj_id station, obj_id player)
{
	if( isIdValid(player) && isIdValid(station) )
	{
		//make sure station doesnt have a user, if player does we just overwrite it
		if( !hasActiveUser(station) )
		{
		//TODO:: Add session hash for verification
			setObjVar(station, ACTIVE_INCUBATOR, player);
			setObjVar(player, ACTIVE_INCUBATOR, station);
			return true;	
		}
	}
	
	return false;
}

//set next time the minigame can be played as a variable on the player
boolean setNextSessionTime(obj_id station, obj_id player)
{
	if(isIdValid(player) && isIdValid(station))
	{
		int currentTime = getGameTime();
		
		int expertiseModifier = (int)getSkillStatisticModifier(player, "expertise_bm_incubation_time"); // Expertise skill modifier (hours)
		float stationFunctionality = getFloatObjVar(station, STATION_FUNCTIONALITY_OBJVAR);
		int modifiedTime = currentTime + NEXT_SESSION_TIME;
		if(expertiseModifier > 0)
		{
			modifiedTime -= expertiseModifier * 3600;
		}

		int skillModifier = (int)getSkillStatisticModifier(player, "incubation_time_reduction"); // Reverse engineering modifier (minutes)

		if(skillModifier > 0)
		{
			modifiedTime -= skillModifier * 60;
		}
		
		//City Modifier - City Specialization: reduces incubation session times by 3 hours per session.
		int city_id = city.checkCity(player, false);

		if(city.cityHasSpec(city_id, city.SF_SPEC_INCUBATOR))
		{
			modifiedTime -= (3 * 60 * 60); //10800 seconds
		}
		
		if(stationFunctionality != 0)
		{
			modifiedTime -= Math.round(stationFunctionality * 3600); //Functionality effects incubation time by hour segments.
		}
		
		//lets make sure we didnt make a number greater than 40 hours
		if(modifiedTime >  currentTime + MAX_SESSION_TIME)
			modifiedTime = currentTime + MAX_SESSION_TIME;
		
		if(modifiedTime <= 0)
		{
			modifiedTime = 3600; // Minimum one hour
		}
		
		//last check to make sure our number isnt garbage
		if(modifiedTime > 0)
		{
			setObjVar(player, NEXT_SESSION, modifiedTime);
			CustomerServiceLog("INCUBATOR: ", "Incubator Session Completed, next session can be performed in  " +((modifiedTime - currentTime) /3600)+ " hours" );
			return true;
		}
	}

	return false;
}

//check to see if enough time has elapsed to play the next minigame session
//we store this on the player so they dont drop more stations to avoid the timer
boolean isSessionEligible(obj_id player)
{
	if(isIdValid(player))
	{
		int currentTime = getGameTime();
		int nextSessionTime = getIntObjVar(player, NEXT_SESSION);
		
		//lets make sure number isn't munged
		if(nextSessionTime >= 0)
		{
			if(currentTime >= nextSessionTime)
				return true;
		}
	}
	return false;
}


//check to see if we are ready to turn into an egg
boolean isIncubationComplete(obj_id station, obj_id player)
{
	if(isIdValid(station))
	{
		int sessionNumber = getIntObjVar(station, ACTIVE_SESSION);
		if( sessionNumber >= SESSIONS_TO_HATCH && isSessionEligible(player))
			return true;
	}
	return false;
}

//Function for extracting DNA
obj_id extractDna(obj_id player, obj_id target)
{
	if(!isIdValid(player) || !isIdValid(target))
	{
		blog("BEAST_DNA", "invalid Ids");
		return obj_id.NULL_ID;
	}
	
	if(!beast_lib.isBeastMaster(player))
	{
		sendSystemMessage(player, beast_lib.SID_NOT_BEAST_MASTER);
		return obj_id.NULL_ID;
	}
	
	//get the creatures appearance, this will help determine if the creature can be sampled
	string targetAppearance = getAppearance(target);
	string finalTargetAppearance = targetAppearance;
	//some templates have _hue, we need to remove that portion, in order to get the base sat
	
	finalTargetAppearance = cleanAppearanceOfHueTag(targetAppearance);
	
	int row = dataTableSearchColumnForString(finalTargetAppearance, "start_appearance", DATATABLE_INCUBATOR_TEMPLATES);
	doAnimationAction(player, "heal_other");
	if(row < 0)
	{
		//this means that the appearance template doesnt exist in our beast list.
		blog("BEAST_DNA", "invalid appearance");
		
		sendSystemMessage(player, SID_DNA_CREATURE_NOT_ON_LIST);
		//sendSystemMessageTestingOnly(player, "This creature has no viable DNA for you.");
		return obj_id.NULL_ID;
	}
	/*inserting a way to prevent harvesting of DNA from certain creatures when 
	the .sat file is already in the datatables*/
	if(hasObjVar(target, "no_dna_harvest")) 
	{
		sendSystemMessage(player, SID_DNA_CREATURE_NOT_ON_LIST);
		blog("BEAST_DNA", "invalid creature - stopped by objvar 'no_dna_harvest");
		return obj_id.NULL_ID;
	}
	
	dictionary dict = dataTableGetRow(DATATABLE_INCUBATOR_TEMPLATES, row);
	int harvestChance = dict.getInt("harvestChance");
	if(harvestChance == 0)
	{
		//this means that the creature is not allowed to be sampled.
		blog("BEAST_DNA", "harvestChance = 0");
		
		sendSystemMessage(player, SID_DNA_CREATURE_NOT_ON_LIST);
		//sendSystemMessageTestingOnly(player, "This creature has no viable DNA for you.");
		return obj_id.NULL_ID;
	}
	if(hasObjVar(target, "qa.dnaChance"))
	{
		harvestChance = getIntObjVar(target, "qa.dnaChance");		
	}
	//Time to see if we tick the critter off
	int chance = rand(1,100);	
	if(chance <= 50)
	{
		if(!isDead(target) || !isIncapacitated(target))
		{
			addHate(target, player, 50.0f);
		}
	}
	
	
	//since it can be sampled, we need to mark this critter as having a sampling attempted tried
	utils.setScriptVar(target, DNA_BEEN_SAMPLED_SCRIPTVAR, 1);
	//determine if they get any DNA
	chance = rand(1,100);
	
	if(chance <= harvestChance)
	{
		//they got something
		obj_id pInv = utils.getInventoryContainer(player);
		if(getVolumeFree(pInv) <= 0)
		{
			utils.removeScriptVar(target, DNA_BEEN_SAMPLED_SCRIPTVAR);
			sendSystemMessage(player, SID_DNA_FAILED_SAMPLE_FULL_INVENTORY);
			return obj_id.NULL_ID;
		}
		//create it
		obj_id dnaContainer = createObject("object/tangible/loot/beast/dna_container.iff", pInv, "");
		//make sure it created correctly
		if(!isIdValid(dnaContainer) || !exists(dnaContainer))
		{
			//inventory is probably full. removing scriptvar so players can try again.
			blog("BEAST_DNA", "invalid dnaContainer");
			utils.removeScriptVar(target, DNA_BEEN_SAMPLED_SCRIPTVAR);
			return obj_id.NULL_ID;
		}
		
		//set the creature template of its parent doner
		int template = dataTableGetInt(DATATABLE_INCUBATOR_TEMPLATES, row, "hash_initial_template");
		setObjVar(dnaContainer, DNA_TEMPLATE_OBJVAR, template);
		sendSystemMessage(player, SID_DNA_SAMPLED);
		return dnaContainer;
	}
	else
	{
		sendSystemMessage(player, SID_DNA_FAILED_SAMPLE);
		return obj_id.NULL_ID;
	}	
	
}
//GODMODE Stamps good Quality on DNA
void setUpDnaWithDummyData (obj_id dnaContainer, obj_id player)
{
	initializeDna(dnaContainer, player);
	setObjVar(dnaContainer, DNA_PARENT_TEMPLATE, "bull_rancor");
	
	string dummyTemplate = "object/mobile/beast_master/bm_rancor.iff";
	int row = dataTableSearchColumnForString(dummyTemplate, "initial_template", DATATABLE_INCUBATOR_TEMPLATES);
	int hashTemplate = dataTableGetInt(DATATABLE_INCUBATOR_TEMPLATES, row, "hash_initial_template");
	setObjVar(dnaContainer, DNA_TEMPLATE_OBJVAR, hashTemplate);
	
}

//function to initialize values on dna
void initializeDna(obj_id dna, obj_id player)
{
	
	//make sure they dont already have the objvar
	//if they do, it is most likely due to CTS
	if(hasObjVar(dna, DNA_QUALITY_OBJVAR))
	{
		float quality = getFloatObjVar(dna, DNA_QUALITY_OBJVAR);

		if(quality != 0)
			return;
	}
	
	if(!hasObjVar(dna, DNA_OLD_PET_IDENTIFIER) && !hasObjVar(dna, DNA_CS))
	{
	//set quality on dna strand
		int expertiseQualityBonus = getEnhancedSkillStatisticModifierUncapped(player, "expertise_bm_dna_harvesting_1");
			blog("BEAST_DNA", "expertiseQualityBonus " + expertiseQualityBonus);
			
		//we dont want min range to be more than 50% so we use that as our modifier for the expertise
		//we take the expertise percent and multiply it by 50, to get our actual percentage.
		float modifiedExpertiseBonus = (expertiseQualityBonus * .01f) * 50;
			blog("BEAST_DNA", "modifiedExpertiseBonus " + modifiedExpertiseBonus);
		float min_range = MIN_QUALITY_RANGE + modifiedExpertiseBonus;
			blog("BEAST_DNA", "min_range " + min_range);
		float quality = rand(min_range, MAX_QUALITY_RANGE);
			blog("BEAST_DNA", "quality " + quality);

		setObjVar(dna, DNA_QUALITY_OBJVAR, quality);
	}
	else
	{
		//this is a pet from pre-nge. We are giving them a base max quality.
		setObjVar(dna, DNA_QUALITY_OBJVAR, MAX_QUALITY_RANGE);
	}
	
}

//god level players can clear their cooldowns
void clearMiniGameCooldown(obj_id player)
{
	if(isIdValid(player) && isGod(player))
	{
		utils.removeScriptVar(player, GUI_SCRIPT_VAR);
		setObjVar(player, NEXT_SESSION, getGameTime());
	}
}

//remove the active user of the station
boolean removeActiveUser(obj_id station, obj_id player)
{
	if( isIdValid(player) && isIdValid(station) )
	{
		obj_id stationOwner = getIncubatorActiveUser(station);
		if(validateActiveUser(station, player))
		{
			//remove objvars from player and station
			removeObjVar(player, ACTIVE_INCUBATOR);
			removeObjVar(station, ACTIVE_INCUBATOR);
			return true;
		}
	}
	return false;
}

//only used when station is destroyed to clear objvar off of player
void forceRemoveIncubatorFromUser(obj_id station, obj_id player)
{
	//remove active objvar from player if it matches
	 if(station == getActiveIncubator(player))
		removeObjVar(player, ACTIVE_INCUBATOR);
}

//verifies the player passed in is the active user to the station
boolean validateActiveUser(obj_id station, obj_id player)
{
	if( isIdValid(player) && isIdValid(station) )
	{
		obj_id stationOwner = getIncubatorActiveUser(station);
		obj_id currentStation = getActiveIncubator(player);
		if(!isIdNull(stationOwner) && !isIdNull(currentStation))
		{
			if((stationOwner == player) && (currentStation == station))
				return true;
		}
	}
	return false;
}

//does the station think it is linked to the player but the player is linked to a different incubator
void checkIncubatorForMismatch(obj_id station, obj_id player)
{
	if( isIdValid(player) && isIdValid(station) )
	{
		obj_id stationOwner = getIncubatorActiveUser(station);
		obj_id currentStation = getActiveIncubator(player);
		if(!isIdNull(stationOwner) && !isIdNull(currentStation))
		{
			if((stationOwner == player) && (currentStation != station))
			{
				incubatorTotalCleanse(station);
			}
		}
	}
}
//Total cleanse of all incubator data by removing base of the objvar tree
boolean incubatorTotalCleanse(obj_id station)
{
	if( isIdValid(station) )
	{
		removeObjVar(station, BASE_INCUBATOR_OBJVAR);
		obj_id[] stationContents = utils.getContents(station, false);
		if(stationContents != null && stationContents.length > 0)
			destroyObject(stationContents[0]);
			
		if(utils.isInHouseCellSpace(station))
			messageTo(station, "refreshCurrentParticle", null, 0, false);
		
		return true;
	}
	return false;
}


//Tells us if an incubator has an active experiement in it
 boolean isSessionActive(obj_id station)
{
 	if(isIdValid(station) )
 	{
 		int sessionNumber = getIntObjVar(station, SESSION_NUMBER);
 		if( sessionNumber > 0)
 			return true;
 	}
 	return false;	
}

//Tells us the session number the incubator is on with validation
 int getCurrentSessionNumber(obj_id station)
{
 	if(isIdValid(station) )
 	{
 		int sessionNumber =getIntObjVar(station, ACTIVE_SESSION);
 		//lets just put in some caps in case we get out of band data
 		if( sessionNumber > 0 && sessionNumber < 10)
 			return sessionNumber;
 	}
 	return 1;	
}


	
//gets the bonus from previous session, you pass in the stations objId
// the session number, and the item that was bonuses
int getIntBonusLastSession(obj_id station, int sessionNumber, string bonusItem)
{
	//build our variable we are looking for. made up of constants
	// and our session number
	string objVarNeeded = POINTS_ALLOCATED+"."+bonusItem;
	blog("INCUBATOR", "objVarNeededs = " + objVarNeeded);
	if(hasObjVar(station, objVarNeeded))
	{
		return getIntObjVar(station, objVarNeeded);
	}
	else
		return 0;
}

//gets the bonus from previous session, you pass in the stations objId
// the session number, and the item that was bonuses
float getFloatBonusLastSession(obj_id station, int sessionNumber, string bonusItem)
{
	//build our variable we are looking for. made up of constants
	// and our session number
	string objVarNeeded = POINTS_ALLOCATED+"."+bonusItem;
	blog("INCUBATOR", "objVarNeededs = " + objVarNeeded);
	if(hasObjVar(station, objVarNeeded))
	{
		return getFloatObjVar(station, objVarNeeded);
	}
	else
		return 0.0f;
}

//gets the appearance stored on the incubator
string getTemplateLastSession(obj_id station, int sessionNumber)
{
	//build our variable we are looking for. made up of constants
	// and our session number
	string objVarNeeded = SESSION_NUMBER+sessionNumber+TEMPLATE_STORED;
	if(hasObjVar(station, objVarNeeded))
	{
		return getStringObjVar(station, objVarNeeded);
	}
	else
		return "";
}

//returns stored Creature template
int getIncubatorCreatureTemplate(obj_id station)
{
	if(hasObjVar(station, STATION_STORED_CREATURE_TEMPLATE))
	{
		return getIntObjVar(station, STATION_STORED_CREATURE_TEMPLATE);
	}
	return 0;
}


//checks to see if player gets a chance at mutation
boolean getMutationChance( string template, int slotOneColor, int slotTwoColor, int slotThreeColor, obj_id station, obj_id player)
{
	if(isConvertedPet(station))
	{
		//converted pets cannot mutate
		return false;
	}

	//.5% chance to mutate regardless of colors
	int randChance = rand(1,200);
	
	if(randChance == 1)
	{
		return true;
	}
	
	int row = dataTableSearchColumnForString(template, "base_template", DATATABLE_TEMPLATE_MUTATION_COLORS);
	if(row < 0)
	{
		//something is wrong, your creature isnt on this list.
		//Shouldnt happen, as this is the list of creatures that can
		//be sampled in world.
		blog("INCUBATOR", "There is no mutation chance for template "+template);
		blog("INCUBATOR", "This is because it is either the last mutation for its base or it is missing from the table");
		return false;
	}
	
	dictionary dict = dataTableGetRow(DATATABLE_TEMPLATE_MUTATION_COLORS, row);
	int numRight = 3;
	if(slotOneColor != dict.getInt("color_1"))
	{
		if(isGod(player))
		{
			sendSystemMessageTestingOnly(player, "slotOneColor is wrong.");
			sendSystemMessageTestingOnly(player, "slotOneColor needed to be " + ENZYME_COLORS[dict.getInt("color_1")]);
			sendSystemMessageTestingOnly(player, "slotOneColor used was " + ENZYME_COLORS[slotOneColor]);
		}
		--numRight;
	}
	if(slotTwoColor != dict.getInt("color_2"))
	{
		if(isGod(player))
		{
			sendSystemMessageTestingOnly(player, "slotTwoColor is wrong.");
			sendSystemMessageTestingOnly(player, "slotTwoColor needed to be " + ENZYME_COLORS[dict.getInt("color_2")]);
			sendSystemMessageTestingOnly(player, "slotTwoColor used was " + ENZYME_COLORS[slotTwoColor]);
		}
		--numRight;
	}
	else
	{
		int index = rand(0,2);
		npe.commTutorialPlayer(station, player, 12.0f, SID_COMM_MUTATION_COLOR_CORRECT, "", COMM_MUTATION_APP[index]);
	}
	
	if(slotThreeColor != dict.getInt("color_3"))
	{
		if(isGod(player))
		{
			sendSystemMessageTestingOnly(player, "slotThreeColor is wrong.");
			sendSystemMessageTestingOnly(player, "slotThreeColor needed to be " + ENZYME_COLORS[dict.getInt("color_3")]);
			sendSystemMessageTestingOnly(player, "slotThreeColor used was " + ENZYME_COLORS[slotThreeColor]);
		}
		--numRight;
	}
	
	if(numRight == 3)
	{
		return true;
	}
	else
	{
		return false;
	}
}

//get the quality of the incubator station
float getIncubatorQuality(obj_id station)
{
	//check for the objvar
	if(hasObjVar(station, STATION_QUALITY_OBJVAR))
	{
		float stationQuality = getFloatObjVar(station, STATION_QUALITY_OBJVAR);
		//verify that it isnt over the max
		if(stationQuality > STATION_QUALITY_MAX)
		{
			setObjVar(station, STATION_QUALITY_OBJVAR, STATION_QUALITY_MAX);
			stationQuality = STATION_QUALITY_MAX;
		}
		//verify that it isnt under the min
		if(stationQuality < STATION_QUALITY_MIN)
		{
			setObjVar(station, STATION_QUALITY_OBJVAR, STATION_QUALITY_MIN);
			stationQuality = STATION_QUALITY_MIN;
		}
		//return quality
		return stationQuality;
	}
	else
	{
		//for some reason the objvar is missing
		//should never happen. In case it does
		//we will set it to the min and return that
		setObjVar(station, STATION_QUALITY_OBJVAR, STATION_QUALITY_MIN);
		return STATION_QUALITY_MIN;
	}
}

//get the functionality of the incubator station
float getIncubatorFunctionality(obj_id station)
{
	//check for the objvar
	if(hasObjVar(station, STATION_FUNCTIONALITY_OBJVAR))
	{
		float stationFunctionality = getFloatObjVar(station, STATION_FUNCTIONALITY_OBJVAR);
		//verify that it isnt over the max
		if(stationFunctionality > STATION_FUNCTIONALITY_MAX)
		{
			setObjVar(station, STATION_FUNCTIONALITY_OBJVAR, STATION_FUNCTIONALITY_MAX);
			stationFunctionality = STATION_FUNCTIONALITY_MAX;
		}
		//verify that it isnt under the min
		if(stationFunctionality < STATION_FUNCTIONALITY_MIN)
		{
			setObjVar(station, STATION_FUNCTIONALITY_OBJVAR, STATION_FUNCTIONALITY_MIN);
			stationFunctionality = STATION_FUNCTIONALITY_MIN;
		}
		//return quality
		return stationFunctionality;
	}
	else
	{
		//for some reason the objvar is missing
		//should never happen. In case it does
		//we will set it to the min and return that
		setObjVar(station, STATION_FUNCTIONALITY_OBJVAR, STATION_FUNCTIONALITY_MIN);
		return STATION_FUNCTIONALITY_MIN;
	}
}
int getLastSessionMutated(obj_id station)
{
	if(hasObjVar(station, LAST_MUTATION))
	{
		return getIntObjVar(station, LAST_MUTATION);
	}
	else
		return 0;
}

//get the mutated template for the supplied appearance template
string getMutatedTemplate(string template, int session, obj_id station, obj_id player)
{
	blog("INCUBATOR", "session("+session+") getMutatedTemplate::template " + template);
	int row = -1;
	
	int lastMutationSession = getLastSessionMutated(station);
	if( lastMutationSession > MAX_MUTATIONS)
	{
		//there are no more mutations you can have.
		return template;
	}
	blog("INCUBATOR", "session("+session+") lastMutationSession "+lastMutationSession);
	if(lastMutationSession == 0)
	{
		//this is the first time
		row = dataTableSearchColumnForString(template, "initial_template", DATATABLE_INCUBATOR_TEMPLATES);
		blog("INCUBATOR", "session("+session+") initial_template: row " + row);
	}
	else
	{
		row = dataTableSearchColumnForString(template, "mutated_template_"+lastMutationSession, DATATABLE_INCUBATOR_TEMPLATES);
		blog("INCUBATOR", "session("+session+") mutated_template_"+lastMutationSession+ ": row " + row);
	}
		
		
	if(row < 0)
	{
		//something is wrong, your creature isnt on this list.
		//Shouldnt happen, as this is the list of creatures that can
		//be sampled in world.
		blog("INCUBATOR", "someone tried to mutate "+template+", and it wasnt in the table");
		return template;
	}
	
	dictionary dict = dataTableGetRow(DATATABLE_INCUBATOR_TEMPLATES, row);
	string newTemplate = dict.getString("mutated_template_"+(lastMutationSession + 1));
	blog("INCUBATOR", "mutated_template_+(lastMutationSession + 1) mutated_template_" + (lastMutationSession + 1));
	//check to see if there was no mutated appearance for this creature. If not, then send back
	//start appearance
	if(newTemplate == null || newTemplate.equals(""))
	{
		//No mutation for you.
		blog("INCUBATOR", "No Mutated Appearance for this Creature");
		//send comm telling player attributes have been updated
		int index = rand(0,2);
		npe.commTutorialPlayer(station, player, 12.0f, COMM_MUTATED_ATTRIB_TEXT[index], COMM_SFX_MUTATE_ATTRIB, COMM_MUTATION_APP[index]);
		playClientEffectObj(station, "clienteffect/incubator_mutation.cef", station, PARTICLE_HARDPOINT_THREE,null, "");
		return template;
	}
	else
	{
		//found a mutated appearance, send it.
		blog("INCUBATOR", "This creature has a mutation");
		setObjVar(station, LAST_MUTATION, (lastMutationSession + 1));
		//send template mutation comms
		if( (lastMutationSession + 1) >= 3)
		{
			//third strait mutations deserve the attention of Lord Vader.
			npe.commTutorialPlayer(station, player, 12.0f, SID_COMM_VADER_MUTATION_3, COMM_SFX_MUTATION_3_VADER, COMM_APPEARANCE_VADER);
		}
		else
		{
			//Huttese speaking Mutation Comms
			int index = rand(0,2);
			if(template.equals(newTemplate))
			{
				npe.commTutorialPlayer(station, player, 12.0f, COMM_MUTATED_ATTRIB_TEXT[index], COMM_SFX_MUTATE_ATTRIB, COMM_MUTATION_APP[index]);
			}
			else
				npe.commTutorialPlayer(station, player, 12.0f, COMM_MUTATED_TEMPLATE_TEXT[index], COMM_SFX_MUTATE_TEMPLATE, COMM_MUTATION_APP[index]);
		}
		playClientEffectObj(station, "clienteffect/incubator_mutation.cef", station, PARTICLE_HARDPOINT_THREE,null, "");
		return dict.getString("mutated_template_"+(lastMutationSession + 1));
	}	
}

//update all of our variables at the end of the session
boolean updateSessionVariables(obj_id station, dictionary values)
{
	if(values == null || values.isEmpty())
	{
		//we sent an empty dictionary
		blog("INCUBATOR", "Empty dictionary sent in function updateSessionVariables");
		return false;
	}
	
	//pull all the data from the dictionary
	float dpsBonus 			= values.getFloat("dpsBonus");
	float armorBonus 		= values.getFloat("armorBonus");
	float healthBonus 		= values.getFloat("healthBonus");
	float hitChanceBonus 		= values.getFloat("hitChanceBonus");
	float dodgeBonus 		= values.getFloat("dodgeBonus");
	float glancingBlowBonus 	= values.getFloat("glancingBlowBonus");
	float parryBonus 		= values.getFloat("parryBonus");
	float blockChanceBonus		= values.getFloat("blockChanceBonus");
	float blockValueBonus		= values.getFloat("blockValueBonus");
	float criticalHitBonus		= values.getFloat("criticalHitBonus");
	float evasionBonus		= values.getFloat("evasionBonus");
	float evasionRatingBonus	= values.getFloat("evasionRatingBonus");
	float strikethroughBonus	= values.getFloat("strikethroughBonus");
	float strikethroughRatingBonus	= values.getFloat("strikethroughRatingBonus");

	int survivalUpdate 		= values.getInt("survivalUpdate");
	int beastialResilienceUpdate 	= values.getInt("beastialResilienceUpdate");
	int cunningUpdate  		= values.getInt("cunningUpdate");
	int intelligenceUpdate		= values.getInt("intelligenceUpdate");
	int aggressionUpdate		= values.getInt("aggressionUpdate");
	int huntersInstinctUpdate	= values.getInt("huntersInstinctUpdate");
	int newTemplate			= values.getInt("newTemplate");
	int session 			= values.getInt("sessionNumber");
	int creatureHueIndex            = values.getInt("creatureHueIndex");
	

	//start adding points spent objvars
	string baseObjVarString = SESSION_NUMBER+"."+session;
	string builtObjVarString = baseObjVarString+POINTS_SPENT_SLOT_1_QUALITY;
	setObjVar(station, builtObjVarString, values.getFloat("slotOneQuality"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_SLOT_3_QUALITY;
	setObjVar(station, builtObjVarString, values.getFloat("slotThreeQuality"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_SLOT_4_MUTAGEN;
	setObjVar(station, builtObjVarString, values.getFloat("slotFourMutagen"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_SLOT_4_PURITY;
	setObjVar(station, builtObjVarString, values.getFloat("slotFourPurity"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_SLOT_4_TRAIT;
	setObjVar(station, builtObjVarString, values.getString("slotFourTrait"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_RANDOM_STAT_COUNT;
	setObjVar(station, builtObjVarString, values.getInt("slotTwoRandomStatCount"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_INCREMENT_SURVIVAL;
	setObjVar(station, builtObjVarString, values.getInt("survivalSkillIncrement"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_INCREMENT_BEASTIAL;
	setObjVar(station, builtObjVarString, values.getInt("beastialSkillIncrement"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_INCREMENT_CUNNING;
	setObjVar(station, builtObjVarString, values.getInt("cunningSkillIncrement"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_INCREMENT_INTELLIGENCE;
	setObjVar(station, builtObjVarString, values.getInt("intelligenceSkillIncrement"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_INCREMENT_AGGRESSION;
	setObjVar(station, builtObjVarString, values.getInt("aggressionSkillIncrement"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_INCREMENT_HUNTERS;
	setObjVar(station, builtObjVarString, values.getInt("huntersSkillIncrement"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_POS_TEMP_SLIDER;
	setObjVar(station, builtObjVarString, values.getInt("tempGaugeSliderPos"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_POS_NUTRIENT_SLIDER;
	setObjVar(station, builtObjVarString, values.getInt("nutGaugeSliderPos"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_SLOT_2_STAT;
	setObjVar(station, builtObjVarString, values.getString("slotTwoStat"));
		
	builtObjVarString = baseObjVarString+COLORS_USED_SLOT_1;
	setObjVar(station, builtObjVarString, values.getInt("slotOneColor"));
	
	builtObjVarString = baseObjVarString+COLORS_USED_SLOT_2;
	setObjVar(station, builtObjVarString, values.getInt("slotTwoColor"));
	
	builtObjVarString = baseObjVarString+COLORS_USED_SLOT_3;
	setObjVar(station, builtObjVarString, values.getInt("slotThreeColor"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_DPS;
	setObjVar(station, builtObjVarString, values.getFloat("pointsTowardDps"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_ARMOR;
	setObjVar(station, builtObjVarString, values.getFloat("pointsTowardArmor"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_HIT_CHANCE;
	setObjVar(station, builtObjVarString, values.getFloat("hitChanceUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_DODGE;
	setObjVar(station, builtObjVarString, values.getFloat("dodgeUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_PARRY_CHANCE;
	setObjVar(station, builtObjVarString, values.getFloat("parryChanceUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_GLANCING_BLOW;
	setObjVar(station, builtObjVarString, values.getFloat("glancingBlowUpdate"));
	
	builtObjVarString = baseObjVarString+POINTS_SPENT_BLOCK_CHANCE;
	setObjVar(station, builtObjVarString, values.getFloat("blockChanceUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_BLOCK_VALUE;
	setObjVar(station, builtObjVarString, values.getFloat("blockValueUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_CRITICAL_HIT;
	setObjVar(station, builtObjVarString, values.getFloat("criticalHitUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_EVASION;
	setObjVar(station, builtObjVarString, values.getFloat("evasionUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_EVASION_RATING;
	setObjVar(station, builtObjVarString, values.getFloat("evasionRatingUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_STRIKETHROUGH;
	setObjVar(station, builtObjVarString, values.getFloat("strikethroughUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_STRIKETHROUGH_RATING;
	setObjVar(station, builtObjVarString, values.getFloat("strikethroughRatingUpdate"));

	builtObjVarString = baseObjVarString+POINTS_SPENT_HEALTH;
	setObjVar(station, builtObjVarString, values.getFloat("healthUpdate"));

	//start verifying and storing the data
	if(dpsBonus > MAX_TOTAL_POINTS_DPS_ARMOR)
	{
		dpsBonus = MAX_TOTAL_POINTS_DPS_ARMOR;
	}
	setObjVar(station, ALLOCATED_DPS, dpsBonus);
	
	if(armorBonus > MAX_TOTAL_POINTS_DPS_ARMOR)
	{
		armorBonus = MAX_TOTAL_POINTS_DPS_ARMOR;
	}
	setObjVar(station, ALLOCATED_ARMOR, armorBonus);
		
	if(hitChanceBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		hitChanceBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_HIT_CHANCE, hitChanceBonus);
	
	if(dodgeBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		dodgeBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_DODGE, dodgeBonus);
	
	if(glancingBlowBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		glancingBlowBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_GLANCING_BLOW, glancingBlowBonus);
	
	if(parryBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		parryBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_PARRY_CHANCE, parryBonus);
	
	if(blockChanceBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		blockChanceBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_BLOCK_CHANCE, blockChanceBonus);
	
	if(blockValueBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		blockValueBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_BLOCK_VALUE, blockValueBonus);

	if(criticalHitBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		criticalHitBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_CRITICAL_HIT, criticalHitBonus);

	if(evasionBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		evasionBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_EVASION, evasionBonus);

	if(evasionRatingBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		evasionRatingBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_EVASION_RATING, evasionRatingBonus);

	if(strikethroughBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		strikethroughBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_STRIKETHROUGH, strikethroughBonus);

	if(strikethroughRatingBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		strikethroughRatingBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_STRIKETHROUGH_RATING, strikethroughRatingBonus);

	if(healthBonus > MAX_TOTAL_POINTS_ATTRIBUTES)
	{
		healthBonus = MAX_TOTAL_POINTS_ATTRIBUTES;
	}
	setObjVar(station, ALLOCATED_HEALTH, healthBonus);

	if(survivalUpdate > MAX_TOTAL_SKILL_INCREMENT)
	{
		survivalUpdate = MAX_TOTAL_SKILL_INCREMENT;
	}
	setObjVar(station, ALLOCATED_SURVIVAL, survivalUpdate);
	
	if(beastialResilienceUpdate > MAX_TOTAL_SKILL_INCREMENT)
	{
		beastialResilienceUpdate = MAX_TOTAL_SKILL_INCREMENT;
	}
	setObjVar(station, ALLOCATED_BEASTIAL_RESILIENCE, beastialResilienceUpdate);
	
	if(cunningUpdate > MAX_TOTAL_SKILL_INCREMENT)
	{
		cunningUpdate = MAX_TOTAL_SKILL_INCREMENT;
	}
	setObjVar(station, ALLOCATED_CUNNING, cunningUpdate);
	
	if(intelligenceUpdate > MAX_TOTAL_SKILL_INCREMENT)
	{
		intelligenceUpdate = MAX_TOTAL_SKILL_INCREMENT;
	}
	setObjVar(station, ALLOCATED_INTELLIGENCE, intelligenceUpdate);
	
	if(aggressionUpdate > MAX_TOTAL_SKILL_INCREMENT)
	{
		aggressionUpdate = MAX_TOTAL_SKILL_INCREMENT;
	}
	setObjVar(station, ALLOCATED_AGGRESSION, aggressionUpdate);
	
	if(huntersInstinctUpdate > MAX_TOTAL_SKILL_INCREMENT)
	{
		huntersInstinctUpdate = MAX_TOTAL_SKILL_INCREMENT;
	}
	setObjVar(station, ALLOCATED_HUNTERS_INSTINCT, huntersInstinctUpdate);
	
	builtObjVarString = baseObjVarString+TEMPLATE_STORED;
	setObjVar(station, builtObjVarString, newTemplate);

	setObjVar(station, ALLOCATED_CREATURE_HUE_INDEX, creatureHueIndex);
	
	
	setObjVar(station, ACTIVE_SESSION, (session + 1));
	setObjVar(station, STATION_STORED_CREATURE_TEMPLATE, newTemplate);
	
	return true;
}

//gets ObjId of DNA
obj_id getStationDnaInInventory(obj_id station)
{
	obj_id[] stationContents = utils.getContents(station, false);
	if(stationContents.length > 1 || stationContents.length < 1)
	{
		//something wrong
		return obj_id.NULL_ID;
	}
	return stationContents[0];
}

boolean stationHasDnaInInventory(obj_id station)
{
	obj_id dna = getStationDnaInInventory(station);
	
	if(isIdNull(dna))
	{
		return false;
	}
	return true;
}

//Check to see if incubator is ready to begin incubation cycles
boolean canOpenInventory(obj_id station)
{
	boolean ready = false;
	if(hasObjVar(station, ACTIVE_SESSION))
	{
		int sessionNumber = getIntObjVar(station, ACTIVE_SESSION);
		if(sessionNumber < 1 || isReadyToRetrieveEgg(station))
		{
			ready = true;
		}
	}
	else
	{
		if(hasActiveUser(station))
		{
			ready = true;
		}
	}
		
	return ready;
}

//check to see if the egg is made.
boolean isReadyToRetrieveEgg(obj_id station)
{
	if(getCurrentSessionNumber(station) == 5 )
	{
		return true;
	}
	return false;
}

//function to see if the station already has DNA assigned to it.
boolean stationHasDnaStored(obj_id station)
{
	if(hasObjVar(station, STATION_DNA))
		return true;
	else
		return false;
}

//start session function
boolean startSession(obj_id station, obj_id player)
{

	if(!validateActiveUser(station, player))
	{
		sendSystemMessage(player, SID_NOT_YOUR_INCUBATOR);
		return false;
	}
	
	if(!beast_lib.isBeastMaster(player))
	{
		sendSystemMessage(player, beast_lib.SID_NOT_BEAST_MASTER);
		return false;
	}
	
	if(!hasPowerForSession(station))
	{
		sendSystemMessage(player, RESOURCE_POWER_NOT_ENOUGH);
		return false;
	}
	
	
	
	int session = getCurrentSessionNumber(station);
	if(isIncubationComplete(station, player))
	{
		//You shouldnt have gotten here, there is abug
		//sendSystemMessageTestingOnly(player, "Incubation is complete, bailing out");
		return false;
	}
	
	//get DNA info from Core, and store it
	obj_id dnaCore = getStationDnaInInventory(station);
	
	if(isIdNull(dnaCore))
	{
		//sendSystemMessageTestingOnly(player, "null DNA, bailing out");
		return false;
	}
	
	//is this the first session?
	if(session <= 1)
	{
		string dnaParentTemplate = getStringObjVar(dnaCore, DNA_PARENT_TEMPLATE);
		int dnaCreatureTemplate = getDnaCreatureTemplate(dnaCore);
		float dnaQuality = getDnaQuality(dnaCore);
		//get converted pets data
		if(isConvertedPet(dnaCore))
		{
			int oldHue = getIntObjVar(dnaCore, DNA_HUE_OLD_PET);
			string oldName = getStringObjVar(dnaCore, DNA_PARENT_NAME);
			setObjVar(station, STATION_DNA_HUE_OLD_PET, oldHue);
			setObjVar(station, STATION_DNA_OLD_PET_IDENTIFIER, 1);
			setObjVar(station, STATION_DNA_PARENT_NAME, oldName);			
		}

		//store the dna stats on incubator

		setObjVar(station, STATION_DNA_CREATURE, dnaParentTemplate);
		setObjVar(station, STATION_DNA_QUALITY, dnaQuality);
		setObjVar(station, STATION_DNA_CREATURE_TEMPLATE, dnaCreatureTemplate);
		setObjVar(station, STATION_DNA_ID, dnaCore);
		
	}
	
	//get the DNA objId we stamped on station first session
	obj_id stationsDna = getObjIdObjVar(station, STATION_DNA_ID);
	
	
	
	//make sure what we have is correct
	if(exists(stationsDna) && isIdValid(stationsDna))
	{
		if(stationsDna != dnaCore)
		{
			//we have mismatched DNA
			prose_package pp = new prose_package();
			string playerName = getPlayerName(player);
			pp = prose.setTT(pp, playerName);
			pp = prose.setStringId(pp, SID_CHEATER_DNA_CHANGED);
			CustomerServiceLog("SuspectedCheaterChannel: ", "Player '" + playerName + "'(" + player + ") has DNA in their incubator that doesnt match the DNA stamped on incubator from first session. Exiting session.");
			sendSystemMessageProse(player, pp);
			return false;
		}
	}
	else
	{
		//DNA Stamped on first session doesnt exist anymore. Somehow it was destroyed
		prose_package pp = new prose_package();
		string playerName = getPlayerName(player);
		pp = prose.setTT(pp, playerName);
		pp = prose.setStringId(pp, SID_CHEATER_DNA_CHANGED);
		CustomerServiceLog("SuspectedCheaterChannel: ", "Player '" + playerName + "'(" + player + ") has DNA in their incubator that doesnt match the DNA stamped on incubator from first session. Exiting session.");
		sendSystemMessageProse(player, pp);		
		return false;
	}
	
	int initialPointsSurvival		= getSurvivalPointsAllocated(station);
	int initialPointsBeastialResilience	= getBeastialResiliencePointsAllocated(station);
	int initialPointsCunning		= getCunningPointsAllocated(station);
	int initialPointsIntelligence		= getIntelligencePointsAllocated(station);
	int initialPointsAggression		= getAggressionPointsAllocated(station);
	int initialPointsHuntersInstinct	= getHuntersInstinctPointsAllocated(station);
	int stationPowerAmount			= getStationPowerAmount(station);
	int tempGaugeSliderPos			= getTemperatureGaugePosition(station, session);
	int nutGaugeSliderPos			= getNutrientGaugePosition(station, session);
	int initialCreatureColorIndex		= getCreatureHueIndex(station, session);
	
	
	String template				= "";
	int hashTemplate			= 0;
	
	if(hasObjVar(station, STATION_DNA_CREATURE_TEMPLATE) && session <= 1)
	{
		blog("INCUBATOR", "startSession hasObjVar(station, STATION_DNA_CREATURE_TEMPLATE) && session <= 1");
		hashTemplate = getIntObjVar(station, STATION_DNA_CREATURE_TEMPLATE);
		blog("INCUBATOR", "startSession hashTemplate " + hashTemplate);
	}
	else
	{
		if(session > 1)
		{
			blog("INCUBATOR", "startSession session > 1");
			hashTemplate = getIncubatorCreatureTemplate(station);
			blog("INCUBATOR", "startSession hashTemplate " + hashTemplate);
		}
	}
	
	//convert template from hash to string for sending.
	
	template = convertHashTemplateToString(hashTemplate, station);
	blog("INCUBATOR", "template " + template);
	
	
	//convert power to percentage
	int powerPercentage = Math.round(((float)stationPowerAmount / (float)RESOURCE_POWER_AMOUNT_CAP) * MAX_GUI_POWER);
	blog("INCUBATOR", "powerPercentage = ("+stationPowerAmount+" / "+RESOURCE_POWER_AMOUNT_CAP+") * " + MAX_GUI_POWER);
	blog("INCUBATOR", "powerPercentage " + powerPercentage);
	//call up GUI	
	incubatorStart(
		session,			// sessionNumber
		player,				// playerId
		station,			// terminalId
		powerPercentage,		// powerGauge
		initialPointsSurvival,		// initialPointsSurvival
		initialPointsBeastialResilience,// initialPointsBeastialResilience
		initialPointsCunning,		// initialPointsCunning
		initialPointsIntelligence,	// initialPointsIntelligence
		initialPointsAggression,	// initialPointsAggression
		initialPointsHuntersInstinct,	// initialPointsHuntersInstinct
		tempGaugeSliderPos,		// temperatureGauge
		nutGaugeSliderPos,		// nutrientGuage
		initialCreatureColorIndex,      // index into palette
		template			// creatureTemplate
	);

	

	
	
	return true;
}

//returns temperature gauges last position
int getTemperatureGaugePosition(obj_id station, int session)
{
	
	string builtObjVarString = SESSION_NUMBER + "." + session + POINTS_SPENT_POS_TEMP_SLIDER;
	if(hasObjVar(station, builtObjVarString))
	{
		return getIntObjVar(station, builtObjVarString);
	}
	return 5; //middle
}

//returns nutrient gauges last position
int getNutrientGaugePosition(obj_id station, int session)
{
	
	string builtObjVarString = SESSION_NUMBER + "." + session + POINTS_SPENT_POS_NUTRIENT_SLIDER;
	if(hasObjVar(station, builtObjVarString))
	{
		return getIntObjVar(station, builtObjVarString);
	}
	return 5; //middle
}

// returns index into palette
int getCreatureHueIndex(obj_id station, int session)
{
	if(hasObjVar(station, ALLOCATED_CREATURE_HUE_INDEX))
	{
			return getIntObjVar(station, ALLOCATED_CREATURE_HUE_INDEX);
	}
	return 0;
}

	
//returns aggression points allocated to skill
int getAggressionPointsAllocated(obj_id station)
{
	if(hasObjVar(station, ALLOCATED_AGGRESSION))
	{
		return getIntObjVar(station, ALLOCATED_AGGRESSION);
	}
	
	return 0;
}
//returns beastialResilience points allocated
int getBeastialResiliencePointsAllocated(obj_id station)
{
	if(hasObjVar(station, ALLOCATED_BEASTIAL_RESILIENCE))
	{
		return getIntObjVar(station, ALLOCATED_BEASTIAL_RESILIENCE);
	}
	
	return 0;
}
//returns huntersInstinct points allocated
int getHuntersInstinctPointsAllocated(obj_id station)
{
	if(hasObjVar(station, ALLOCATED_HUNTERS_INSTINCT))
	{
		return getIntObjVar(station, ALLOCATED_HUNTERS_INSTINCT);
	}
	
	return 0;
}
//returns intelligence points allocated
int getIntelligencePointsAllocated(obj_id station)
{
	if(hasObjVar(station, ALLOCATED_INTELLIGENCE))
	{
		return getIntObjVar(station, ALLOCATED_INTELLIGENCE);
	}
	
	return 0;
}
//returns survival points allocated
int getSurvivalPointsAllocated(obj_id station)
{
	if(hasObjVar(station, ALLOCATED_SURVIVAL))
	{
		return getIntObjVar(station, ALLOCATED_SURVIVAL);
	}
	
	return 0;
}

//returns cunning points allocated
int getCunningPointsAllocated(obj_id station)
{
	if(hasObjVar(station, ALLOCATED_CUNNING))
	{
		return getIntObjVar(station, ALLOCATED_CUNNING);
	}
	
	return 0;
}

//final step, converts all the data compiled during incubation
//removes DNA, and creates an egg
obj_id convertDnaToEgg(obj_id station, obj_id player)
{
	if(!validateActiveUser(station, player))
	{
		sendSystemMessage(player, SID_NOT_YOUR_INCUBATOR);
		return obj_id.NULL_ID;
	}

	if(!beast_lib.isBeastMaster(player))
	{
		sendSystemMessage(player, beast_lib.SID_NOT_BEAST_MASTER);
		return obj_id.NULL_ID;
	}
	
	obj_id[] stationContents = utils.getContents(station, false);
	if(stationContents.length > 1)
	{
		//something wrong
		return obj_id.NULL_ID;
	}
	obj_id dnaCore = stationContents[0];
	
	//verify it is still the same DNA
	//get the DNA objId we stamped on station first session
	obj_id stationsDna = getObjIdObjVar(station, STATION_DNA_ID);
	
	//make sure what we have is correct
	if(exists(stationsDna) && isIdValid(stationsDna))
	{
		if(stationsDna != dnaCore)
		{
			//we have mismatched DNA
			prose_package pp = new prose_package();
			string playerName = getPlayerName(player);
			pp = prose.setTT(pp, playerName);
			pp = prose.setStringId(pp, SID_CHEATER_DNA_CHANGED);
			CustomerServiceLog("SuspectedCheaterChannel: ", "Player '" + playerName + "'(" + player + ") has DNA in their incubator that doesnt match the DNA stamped on incubator from first session. Exiting session.");
			sendSystemMessageProse(player, pp);
			return obj_id.NULL_ID;
		}
	}
	else
	{
		//DNA Stamped on first session doesnt exist anymore. Somehow it was destroyed
		prose_package pp = new prose_package();
		string playerName = getPlayerName(player);
		pp = prose.setTT(pp, playerName);
		pp = prose.setStringId(pp, SID_CHEATER_DNA_CHANGED);
		CustomerServiceLog("SuspectedCheaterChannel: ", "Player '" + playerName + "'(" + player + ") has DNA in their incubator that doesnt match the DNA stamped on incubator from first session. Exiting session.");
		sendSystemMessageProse(player, pp);		
		return obj_id.NULL_ID;
	}

	//need to remove the old DNA core
	boolean dnaDestroyed = destroyObject(dnaCore);
	if(dnaDestroyed)
	{
		//time to create Egg.
		obj_id egg = createObject( "object/tangible/item/beast/bm_egg.iff", station, "");
		//sendSystemMessageTestingOnly(player, "egg "+egg);
		if(!isIdValid(egg) || isIdNull(egg))
		{
			//sendSystemMessageTestingOnly(player, " Failed isIdValid(egg) || isIdNull(egg)");
			return obj_id.NULL_ID;
		}
		
		setObjVar(station, ACTIVE_SESSION, 5);
		messageTo(station, "refreshCurrentParticle", null, 1, false);
		CustomerServiceLog("BeastEggCreated: ", "Player " + getPlayerName(player) + "(" + player + ") has finished incubation and created an egg (" + egg + ").");
		return egg;
	}
	else
		return obj_id.NULL_ID;
}

//function only called with God Mode, for testing
void setUpEggWithDummyData(obj_id player, obj_id egg, int beastType)
{
	setObjVar(egg, beast_lib.OBJVAR_BEAST_TYPE, beastType);
	setObjVar(egg, beast_lib.OBJVAR_SKILL_AGGRESSION, rand(0, MAX_TOTAL_SKILL_INCREMENT));
	setObjVar(egg, beast_lib.OBJVAR_SKILL_BEASTIAL_RESILIENCE, rand(0, MAX_TOTAL_SKILL_INCREMENT));
	setObjVar(egg, beast_lib.OBJVAR_SKILL_CUNNING, rand(0, MAX_TOTAL_SKILL_INCREMENT));
	setObjVar(egg, beast_lib.OBJVAR_SKILL_HUNTERS_INSTINCT, rand(0, MAX_TOTAL_SKILL_INCREMENT));
	setObjVar(egg, beast_lib.OBJVAR_SKILL_INTELLIGENCE, rand(0, MAX_TOTAL_SKILL_INCREMENT));
	setObjVar(egg, beast_lib.OBJVAR_SKILL_SURVIVAL, rand(0, MAX_TOTAL_SKILL_INCREMENT));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_ARMOR, rand(0, MAX_TOTAL_POINTS_DPS_ARMOR));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_DPS, rand(0, MAX_TOTAL_POINTS_DPS_ARMOR));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_HEALTH, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_HIT_CHANCE, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_DODGE, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_PARRY, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_GLANCING_BLOW, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_BLOCK_CHANCE, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_BLOCK_VALUE, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));	
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_CRITICAL_HIT, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_EVASION, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));	
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_EVASION_RATING, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_STRIKETHROUGH, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));	
	setObjVar(egg, beast_lib.OBJVAR_INCREASE_STRIKETHROUGH_RATING, rand(0, MAX_TOTAL_POINTS_ATTRIBUTES));
}

void initializeEgg(obj_id egg)
{
	//obj_id player = utils.getContainingPlayer(egg);  // Egg is in your Inventory which is in a Player
	obj_id station = getContainedBy(egg);
	
	if(isIdNull(station))
	{
		//We didnt create inside a container
		return;
	}
		
	string template = getTemplateName(station);
	blog("INCUBATOR", "template = "+template);
	
	if(template.equals("object/tangible/crafting/station/incubator_station.iff"))
	{
		//stamp data on egg
		
		string creatureName = getCreatureTypeFromHashTemplate(station);
		blog("INCUBATOR", "creatureName = " + creatureName);
		
		int hashCreatureType = getHashType(creatureName);
		
		//get the values off of the incubator
		int dpsIncrease			= Math.round(getFloatObjVar(station, ALLOCATED_DPS));
		int armorIncrease		= Math.round(getFloatObjVar(station, ALLOCATED_ARMOR));
		int healthIncrease		= Math.round(getFloatObjVar(station, ALLOCATED_HEALTH));
		int hitChanceIncrease		= Math.round(getFloatObjVar(station, ALLOCATED_HIT_CHANCE));
		int dodgeIncrease		= Math.round(getFloatObjVar(station, ALLOCATED_DODGE));
		int parryChanceIncrease		= Math.round(getFloatObjVar(station, ALLOCATED_PARRY_CHANCE));
		int glancingBlowIncrease	= Math.round(getFloatObjVar(station, ALLOCATED_GLANCING_BLOW));
		int blockChanceIncrease		= Math.round(getFloatObjVar(station, ALLOCATED_BLOCK_CHANCE));
		int blockValueIncrease		= Math.round(getFloatObjVar(station, ALLOCATED_BLOCK_VALUE));
		int criticalHitIncrease		= Math.round(getFloatObjVar(station, ALLOCATED_CRITICAL_HIT));
		int evasionIncrease		= Math.round(getFloatObjVar(station, ALLOCATED_EVASION));
		int evasionRatingIncrease	= Math.round(getFloatObjVar(station, ALLOCATED_EVASION_RATING));
		int strikethroughIncrease	= Math.round(getFloatObjVar(station, ALLOCATED_STRIKETHROUGH));
		int strikethroughRatingIncrease	= Math.round(getFloatObjVar(station, ALLOCATED_STRIKETHROUGH_RATING));
		
		
		
		int aggression	 		= getIntObjVar(station, ALLOCATED_AGGRESSION);
		int beastialResilience		= getIntObjVar(station, ALLOCATED_BEASTIAL_RESILIENCE);
		int huntersInstinct		= getIntObjVar(station, ALLOCATED_HUNTERS_INSTINCT);
		int intelligence		= getIntObjVar(station, ALLOCATED_INTELLIGENCE);
		int survival			= getIntObjVar(station, ALLOCATED_SURVIVAL);
		int cunning			= getIntObjVar(station, ALLOCATED_CUNNING);
		string parentCreatureTemplate	= getStringObjVar(station, STATION_DNA_CREATURE);
		int eggHue			= getIntObjVar(station, ALLOCATED_CREATURE_HUE_INDEX);
		
		obj_id creatorId		= getIncubatorActiveUser(station);
		string creatorName		= "";
		if(isIdValid(creatorId))
		{
			creatorName = getPlayerName(creatorId);
		}

		//store the values on the egg
		setObjVar(egg, beast_lib.OBJVAR_BEAST_TYPE, hashCreatureType);
		setObjVar(egg, beast_lib.OBJVAR_BEAST_PARENT, parentCreatureTemplate);
		
		setObjVar(egg, beast_lib.OBJVAR_SKILL_AGGRESSION, aggression);
		setObjVar(egg, beast_lib.OBJVAR_SKILL_BEASTIAL_RESILIENCE, beastialResilience);
		setObjVar(egg, beast_lib.OBJVAR_SKILL_CUNNING, cunning);
		setObjVar(egg, beast_lib.OBJVAR_SKILL_HUNTERS_INSTINCT, huntersInstinct);
		setObjVar(egg, beast_lib.OBJVAR_SKILL_INTELLIGENCE, intelligence);
		setObjVar(egg, beast_lib.OBJVAR_SKILL_SURVIVAL, survival);
		
		
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_ARMOR, armorIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_DPS, dpsIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_HEALTH, healthIncrease);
		
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_HIT_CHANCE, hitChanceIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_DODGE, dodgeIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_PARRY, parryChanceIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_GLANCING_BLOW, glancingBlowIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_BLOCK_CHANCE, blockChanceIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_BLOCK_VALUE, blockValueIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_CRITICAL_HIT, criticalHitIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_EVASION, evasionIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_EVASION_RATING, evasionRatingIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_STRIKETHROUGH, strikethroughIncrease);
		setObjVar(egg, beast_lib.OBJVAR_INCREASE_STRIKETHROUGH_RATING, strikethroughRatingIncrease);
		
		//add the beast egg creator
		if(!creatorName.equals("") && creatorName != null)
		{
			setObjVar(egg, beast_lib.OBJVAR_BEAST_ENGINEER, creatorName);
		}
		
		//assign all old data from converted pets
		if(hasObjVar(station, STATION_DNA_OLD_PET_IDENTIFIER))
		{
			string name = getStringObjVar(station, STATION_DNA_PARENT_NAME);
			setObjVar(egg, beast_lib.OBJVAR_OLD_PET_REHUED, 1);
			setObjVar(egg, beast_lib.OBJVAR_OLD_PET_IDENTIFIER, 1);
			setName(egg, name);
		}
		
		setObjVar(egg, beast_lib.OBJVAR_BEAST_HUE, eggHue);
		setObjVar(station, OBJVAR_EGG_CREATED, 1);
		setEggHue(egg);
	}
	else
	{
		blog("beast", "Beast egg not not in incubator, we are in: ("+station+")" + template);
	}
}
string cleanAppearanceOfHueTag(string appearance)
{
	blog("BEAST_DNA_CLEAN_HUE", "appearance = "+appearance);
	if(appearance.indexOf("_hue") > -1)
	{
		String[] splitAppearance = split(appearance, '_');
		blog("BEAST_DNA_CLEAN_HUE", "splitAppearance.length = "+splitAppearance.length);
		if(splitAppearance.length >= 2)
		{
			appearance = splitAppearance[0];
			blog("BEAST_DNA_CLEAN_HUE", "appearance = "+appearance);
			for(int i = 1; i < splitAppearance.length -1; ++i)
			{
				appearance += "_"+splitAppearance[i];
				blog("BEAST_DNA_CLEAN_HUE", "appearance = "+appearance);
			}
		}
		
		appearance += ".sat";
		blog("BEAST_DNA_CLEAN_HUE", "FinalAappearance = "+appearance);
		return appearance;
	}
	else if(appearance.indexOf(".iff") > -1)
	{
		String[] splitAppearance = split(appearance, '.');
		blog("BEAST_DNA_CLEAN_HUE", "splitAppearance.length = "+splitAppearance.length);
		if(splitAppearance.length >= 2)
		{
			appearance = splitAppearance[0];
			blog("BEAST_DNA_CLEAN_HUE", "appearance = "+appearance);
		}
		
		appearance += ".sat";
		blog("BEAST_DNA_CLEAN_HUE", "FinalAappearance = "+appearance);
		return appearance;
	}
	else
		return appearance;
}

boolean hasPower(obj_id station)
{	
	int amount = getStationPowerAmount(station);
	if(amount > 0)
		return true;
		
	return false;
}

string getStationPowerName(obj_id station)
{
	return(getStringObjVar(station, RESOURCE_POWER_NAME));
}

int getStationPowerAmount(obj_id station)
{
	return(getIntObjVar(station, RESOURCE_POWER_AMOUNT));
}

int getStationPowerQuality(obj_id station)
{
	return(getIntObjVar(station, RESOURCE_POWER_QUALITY));
}

//adds a specified amount of power to the incubator
boolean addPowerIncubator(obj_id station, obj_id player, int amount, int quality, string resourceName)
{
	//make sure we passed in valid numbers
	if(isIdValid(station) && isIdValid(player))
	{
		if(amount > 0 && quality > 0 )
		{
			//cap the amount in station
			int amountInStation = getStationPowerAmount(station);
			int finalAmount = amountInStation + amount;
			if(finalAmount > RESOURCE_POWER_AMOUNT_CAP)
				finalAmount = RESOURCE_POWER_AMOUNT_CAP;
				
			//set out the objvars
			// RESOURCE_POWER_NAME objvar will be set in C++, because we need to do
			// special handling if the resource is an imported resource from another galaxy
			setIncubatorPowerResourceName(station, resourceName);
			setObjVar(station, RESOURCE_POWER_AMOUNT, finalAmount);
			setObjVar(station, RESOURCE_POWER_QUALITY, quality);
			return true;
		}
	}
	return false;
}

//Removes all the Power from the incubator and refundds it to the player
boolean removeAllPowerIncubator(obj_id station, obj_id player)
{
	//make sure we passed in valid numbers
	if(isIdValid(station) && isIdValid(player))
	{
		string resourceName = getStationPowerName(station);
		int amount = getStationPowerAmount(station);
		
		if(amount > 0)
		{
			obj_id resourceType = getResourceTypeByName(resourceName);
			if(isIdValid(resourceType))
			{
				obj_id inventoryId = utils.getInventoryContainer(player);
				if ( isIdValid(inventoryId) )
				{
					//make sure inventory isnt full
					if (getVolumeFree(inventoryId) <= 0)
					{
						sendSystemMessage(player, RESOURCE_POWER_INV_FULL);
						return false;
					}
					resource.create(resourceType, amount, inventoryId, player);
					//remove objvars from station
					removeObjVar(station, BASE_INCUBATOR_POWER_OBJVAR);
					return true;
				}
			}
		}
	}
	return false;
}

//Returns true if we have enough power on the station for 1 session
boolean hasPowerForSession(obj_id station)
{
	if(isIdValid(station))
	{
		int powerInStation = getStationPowerAmount(station);
		if (powerInStation >= POWER_PER_SESSION)
			return true;
	}
	return false;
}

//returns true if we remove 1 sessions worth of power
boolean decrementPowerForSession(obj_id station)
{
	if(isIdValid(station))
	{

		if(!hasPowerForSession(station))
			return false;

		int powerAmount = getStationPowerAmount(station);
		powerAmount -= POWER_PER_SESSION;

		//we ran out of power!
		if(powerAmount == 0 )
		{
			removeObjVar(station, BASE_INCUBATOR_POWER_OBJVAR);
			return true;
		}
		else
		{	
			setObjVar(station, RESOURCE_POWER_AMOUNT, powerAmount);
			return true;
		}
	}
	return false;
}

//check to see if station already has power in it and we dont go over the cap
boolean addPowerPreCheck(obj_id station, obj_id player, int amount, string resourceName)
{
	
	if( isIdValid(station) && isIdValid(player))
	{
		if(resourceName == null || resourceName == "")
			return false;
		
		//we passed in a 0, station must be full
		if(amount == 0)
		{
			sendSystemMessage(player, RESOURCE_POWER_AMOUNT_FULL);
			return false;
		}
	
		// get the name of the power already in the station	
		string resourceInStation = getStationPowerName(station);
		
		//nothing in station
		if(resourceInStation == null || resourceInStation == "")
			return true;
			
		//make sure they are putting in the same resource in station
		if ( resourceName ==  resourceInStation )
		{
			//check to make sure we aren't over cap
			int amountInStation = getStationPowerAmount(station);
			if ( (amount + amountInStation) > RESOURCE_POWER_AMOUNT_CAP )
			{
				sendSystemMessage(player, RESOURCE_POWER_AMOUNT_FULL);
				return false;
			}
			else
			{	
				//we arent over cap and the resource types match
				return true;
			}
		}
		else
		{
			//resource names didnt match, tell them to clear out the old crap before putting new in
			sendSystemMessage(player, RESOURCE_TYPE_MISMATCH);
			return false;
		}	
	}
	return false;
}

//returns the quality of DNA stored on Incubator
float getIncubatorDnaQuality(obj_id station)
{
	if(hasObjVar(station, STATION_DNA_QUALITY))
		return getFloatObjVar(station, STATION_DNA_QUALITY);
	
	return MIN_QUALITY_RANGE;//something is wrong and the DNA didnt have the quality, so we return the min
}


boolean convertPcdIntoPetItem(obj_id player, obj_id pcd)
{
	obj_id pInv = utils.getInventoryContainer(player);
	
	string pcdAppearance = getAppearance(pcd);
	string finalPcdAppearance = pcdAppearance;
	//some templates have _hue, we need to remove that portion, in order to get the base sat

	finalPcdAppearance = cleanAppearanceOfHueTag(finalPcdAppearance);

	int row = dataTableSearchColumnForString(finalPcdAppearance, "start_appearance", DATATABLE_INCUBATOR_TEMPLATES);
	if(row < 0)
	{	
		//lets try getting the appearance off the parent template
		string parentTemplate = getStringObjVar(pcd, "pet.creatureName");
		row = dataTableSearchColumnForString(parentTemplate, "creatureName", create.CREATURE_TABLE);
		if(row < 0)
		{	
			//This means that we dont have that appearance for some reason. We must have missed one.
			//time to log the heck out of this to find out why. We also need to tell the player
			CustomerServiceLog("BeastPetConversion: ", "Old Pcd (" + pcd + ")"+ " is contained in player's " + getFirstName(player) + "(" + player + ") Datapad.");
			CustomerServiceLog("BeastPetConversion: ", "Initial appearance on Old Pcd (" + pcd + ")"+ " is " + pcdAppearance);
			CustomerServiceLog("BeastPetConversion: ", "Appearance searched for in datatable for pcd (" + pcd + ")"+ " was " + finalPcdAppearance + " and this appearance was not found. We are now bailing out and not deleting or creating anything. This needs to be reported to development");
			sendSystemMessage(player, SID_REPORT_PET_NOT_CONVERTING);
			return false;
		}
		else
		{
			dictionary dict = dataTableGetRow(create.CREATURE_TABLE, row);
			pcdAppearance = dict.getString("template");
			finalPcdAppearance = pcdAppearance;
			finalPcdAppearance = cleanAppearanceOfHueTag(finalPcdAppearance);
			finalPcdAppearance = "appearance/" + finalPcdAppearance;
			row = dataTableSearchColumnForString(finalPcdAppearance, "start_appearance", DATATABLE_INCUBATOR_TEMPLATES);
			if(row < 0)
			{	
				//lets check our table of exceptions. If it is still not there, we are missing something
				row = dataTableSearchColumnForString(finalPcdAppearance, "pcd_template_appearance", DATATABLE_INCUBATOR_TEMPLATES);
				if(row < 0)
				{
					//This means that we dont have that appearance for some reason. We must have missed one.
					//time to log the heck out of this to find out why. We also need to tell the player
					CustomerServiceLog("BeastPetConversion: ", "Old Pcd (" + pcd + ")"+ " is contained in player's " + getFirstName(player) + "(" + player + ") Datapad.");
					CustomerServiceLog("BeastPetConversion: ", "Initial appearance on Old Pcd (" + pcd + ")"+ " is " + pcdAppearance);
					CustomerServiceLog("BeastPetConversion: ", "Appearance searched for in datatable for pcd (" + pcd + ")"+ " was " + finalPcdAppearance + " and this appearance was not found. We are now bailing out and not deleting or creating anything. This needs to be reported to development");
					sendSystemMessage(player, SID_REPORT_PET_NOT_CONVERTING);
					return false;
				}
				string overrideAppearance = dataTableGetString(DATATABLE_INCUBATOR_TEMPLATES, row, "incubator_template_appearance");
				row = dataTableSearchColumnForString(overrideAppearance, "start_appearance", DATATABLE_INCUBATOR_TEMPLATES);
				if(row < 0)
				{
					//This means that we dont have that appearance for some reason. We must have missed one.
					//time to log the heck out of this to find out why. We also need to tell the player
					CustomerServiceLog("BeastPetConversion: ", "Old Pcd (" + pcd + ")"+ " is contained in player's " + getFirstName(player) + "(" + player + ") Datapad.");
					CustomerServiceLog("BeastPetConversion: ", "Initial appearance on Old Pcd (" + pcd + ")"+ " is " + pcdAppearance);
					CustomerServiceLog("BeastPetConversion: ", "Appearance searched for in datatable for pcd (" + pcd + ")"+ " was " + overrideAppearance + " and this appearance was not found. This appearance was an override taken because we failed on first attempts. We are now bailing out and not deleting or creating anything. This needs to be reported to development");
					sendSystemMessage(player, SID_REPORT_PET_NOT_CONVERTING);
					return false;
				}
			}
		}
	}		
		
	dictionary dict = dataTableGetRow(DATATABLE_INCUBATOR_TEMPLATES, row);
	
	if(dict == null)
	{
		blog("BeastPetConversion", "dataTableGetRow(DATATABLE_INCUBATOR_TEMPLATES, row) was null");
		//this shouldnt happen, but just in case.
		return false;
	}
	
	string templateOfConvertedItem = dict.getString("convert_item_template");
	string creatureTemplate = dict.getString("initial_template");
	string parentTemplate = getStringObjVar(pcd, "pet.creatureName");
	

	obj_id convertedPetItem = createObjectOverloaded(templateOfConvertedItem, pInv);
	
	if(!isIdValid(convertedPetItem) || isIdNull(convertedPetItem) || !exists(convertedPetItem))
	{
		//it didnt create properly
		//sendSystemMessageTestingOnly(player, "!isIdValid(convertedPetItem) || isIdNull(convertedPetItem) || !exists(convertedPetItem)");
		return false;
	}
	
	if(copyObjVar(pcd, convertedPetItem, "ai"))
	{
		//sendSystemMessageTestingOnly(player, "ai objvarlist transfered");
	}
	else
	{
		CustomerServiceLog("BeastPetConversion: ", "pcd (" + pcd + ")"+ " was NOT converted into a stuffed pet, for player " + getFirstName(player) + "(" + player + "). This is because we had an invalid objvar (ai) transfer.");
		return false;
	}
	
	if(copyObjVar(pcd, convertedPetItem, "pet"))
	{
		//sendSystemMessageTestingOnly(player, "pet objvarlist transfered");
	}
	else
	{
		CustomerServiceLog("BeastPetConversion: ", "pcd (" + pcd + ")"+ " was NOT converted into a stuffed pet, for player " + getFirstName(player) + "(" + player + "). This is because we had an invalid objvar (pet) transfer.");
		return false;
	}
	
	//set the colors on item to match the colors on creature
		
	if(hasObjVar(pcd, "creature_attribs.hue"))
	{
		int hueColor = getIntObjVar(pcd, "creature_attribs.hue");
		hue.setColor(convertedPetItem, hue.INDEX_1, hueColor);
		setObjVar(convertedPetItem, DNA_HUE_OLD_PET, hueColor);
	}
	else if(hasObjVar(pcd, "ai.pet.palvar.vars./private/index_color_1"))
	{
		int hueColor = getIntObjVar(pcd, "ai.pet.palvar.vars./private/index_color_1");
		hue.setColor(convertedPetItem, hue.INDEX_1, hueColor);
		setObjVar(convertedPetItem, DNA_HUE_OLD_PET, hueColor);
	}
	else
	{
		row = dataTableSearchColumnForString(parentTemplate, "creatureName", create.CREATURE_TABLE);
		if(row >= 0)
		{
			dict = dataTableGetRow(create.CREATURE_TABLE, row);
			if(dict != null && !dict.isEmpty())
			{
				int hueColor = dict.getInt("hue");
				if ( hueColor != 0 )
				{
					int highhuevar = (hueColor*8)-1;
					int lowhuevar = highhuevar-7;
					hueColor = rand(lowhuevar, highhuevar);
				}
				hue.setColor(convertedPetItem, hue.INDEX_1, hueColor);
				setObjVar(convertedPetItem, DNA_HUE_OLD_PET, hueColor);
			}
		}
	}
	
	//set scale
	row = dataTableSearchColumnForString(parentTemplate, "creatureName", create.CREATURE_TABLE);
	if(row >= 0)
	{
		dict = dataTableGetRow(create.CREATURE_TABLE, row);
		if(dict != null && !dict.isEmpty())
		{
			float minScale = dict.getFloat("minScale");
			float maxScale = dict.getFloat("maxScale");
			float myScale = rand(minScale, maxScale);
			setObjVar(convertedPetItem, DNA_SCALE_OLD_PET, myScale);
			//setScale(convertedPetItem, myScale);
		}
	}
	
	
	row = dataTableSearchColumnForString(creatureTemplate, "initial_template",DATATABLE_INCUBATOR_TEMPLATES);
	int hashTemplate = dataTableGetInt(DATATABLE_INCUBATOR_TEMPLATES, row, "hash_initial_template");
	
	setObjVar(convertedPetItem, DNA_TEMPLATE_OBJVAR, hashTemplate);
	setObjVar(convertedPetItem, DNA_PARENT_TEMPLATE, parentTemplate);
	
	string name = getAssignedName(pcd);
	if(!name.equals("") && name != null)
	{
		setName(convertedPetItem, name);
		setObjVar(convertedPetItem, DNA_PARENT_NAME, name);
	}
	
	CustomerServiceLog("BeastPetConversion: ", "Old Pcd (" + pcd + ")"+ " is about to be destroyed. New Pet Decoration item (" + convertedPetItem + ") has been placed in thier inventory, complete with all the necessary data.");
	
	return true;
}

boolean convertDeedIntoPetItem(obj_id player, obj_id deed)
{
	obj_id pInv = utils.getInventoryContainer(player);
	
	string deedAppearance = getAppearance(deed);
	string finalDeedAppearance = deedAppearance;
	//some templates have _hue, we need to remove that portion, in order to get the base sat

	finalDeedAppearance = cleanAppearanceOfHueTag(finalDeedAppearance);

	int row = dataTableSearchColumnForString(finalDeedAppearance, "start_appearance", DATATABLE_INCUBATOR_TEMPLATES);
	if(row < 0)
	{
		//This means that we dont have that appearance for some reason. We must have missed one.
		//time to log the heck out of this to find out why. We also need to tell the player
		CustomerServiceLog("BeastPetConversion: ", "Old deed (" + deed + ")"+ " is contained in player's " + getFirstName(player) + "(" + player + ") inventory.");
		CustomerServiceLog("BeastPetConversion: ", "Initial appearance on Old deed (" + deed + ")"+ " is " + deedAppearance);
		CustomerServiceLog("BeastPetConversion: ", "Appearance searched for in datatable for deed (" + deed + ")"+ " was " + finalDeedAppearance + " and this appearance was not found. We are now bailing out and not deleting or creating anything. This needs to be reported to development");
		sendSystemMessage(player, SID_REPORT_PET_NOT_CONVERTING);
		return false;
	}		
		
	dictionary dict = dataTableGetRow(DATATABLE_INCUBATOR_TEMPLATES, row);
	
	if(dict == null)
	{
		blog("BeastPetConversion", "dataTableGetRow(DATATABLE_INCUBATOR_TEMPLATES, row) was null");
		//this shouldnt happen, but just in case.
		return false;
	}
	
	string creatureTemplate = dict.getString("initial_template");
	string parentTemplate = getStringObjVar(deed, "creature_attribs.type");
	
	row = dataTableSearchColumnForString(creatureTemplate, "initial_template",DATATABLE_INCUBATOR_TEMPLATES);
	int hashTemplate = dataTableGetInt(DATATABLE_INCUBATOR_TEMPLATES, row, "hash_initial_template");
	
	setObjVar(deed, DNA_TEMPLATE_OBJVAR, hashTemplate);
	setObjVar(deed, DNA_PARENT_TEMPLATE, parentTemplate);
	
	string name = getAssignedName(deed);
	if(!name.equals("") && name != null)
	{
		setObjVar(deed, DNA_PARENT_NAME, name);
	}
	
	return true;
}



boolean convertPetItemToDna(obj_id player, obj_id petItem)
{
	//verify that the player objId is correct
	if(!isValidId(player) || !exists(player))
	{
		return false;
	}
	
	//verify that the petItem is
	if(!isValidId(petItem) || !exists(petItem))
	{
		return false;
	}
	
	//make sure the player is a beast master
	if(!beast_lib.isBeastMaster(player))
	{
		CustomerServiceLog("BeastPetConversion: ", "petItem (" + petItem + ")"+ " was not converted into a dna object, because player " + getFirstName(player) + "(" + player + ") is not a beast master.");
		return false;
	}
	
	//get the players inventory id
	obj_id pInv = utils.getInventoryContainer(player);
	
	//create our bease DNA object
	obj_id dnaContainer = createObjectOverloaded("object/tangible/loot/beast/dna_container.iff", pInv);
	
	if(!isValidId(dnaContainer) || !exists(dnaContainer))
	{
		CustomerServiceLog("BeastPetConversion: ", "petItem (" + petItem + ")"+ " was NOT converted into a dna object, for player " + getFirstName(player) + "(" + player + "). This is because creation of the new item failed.");
		return false;
	}
	
	//set the identifier objvar for pre-nge pets being converted.
	setObjVar(dnaContainer, DNA_OLD_PET_IDENTIFIER, 1);
	
	//copy all of our Ai objvars. We prolly dont need these, but we will transfer just in case.
	if(copyObjVar(petItem, dnaContainer, "ai"))
	{
		//sendSystemMessageTestingOnly(player, "ai objvarlist transfered");
	}
	else
	{
		CustomerServiceLog("BeastPetConversion: ", "petItem (" + petItem + ")"+ " was not converted into a dna object, for player " + getFirstName(player) + "(" + player + "). This is because we had an invalid objvar (ai) transfer.");
		destroyObject(dnaContainer);
		return false;
	}
	
	//copy all of our Pet objvars. We prolly dont need these, but we will transfer just in case.
	if(copyObjVar(petItem, dnaContainer, "pet"))
	{
		//sendSystemMessageTestingOnly(player, "pet objvarlist transfered");
	}
	else
	{
		CustomerServiceLog("BeastPetConversion: ", "petItem (" + petItem + ")"+ " was NOT converted into a dna object, for player " + getFirstName(player) + "(" + player + "). This is because we had an invalid objvar (pet) transfer.");
		destroyObject(dnaContainer);
		return false;
	}
	
	//copy our important DNA objvars. The are used in incubation
	if(copyObjVar(petItem, dnaContainer, "beast"))
	{
		string name = getName(petItem);
		if(name != null && !name.equals(""))
			setObjVar(dnaContainer, DNA_PARENT_TEMPLATE_NAME, name);
		//sendSystemMessageTestingOnly(player, "beast objvarlist transfered");
	}
	else
	{
		CustomerServiceLog("BeastPetConversion: ", "petItem (" + petItem + ")"+ " was NOT converted into a dna object, for player " + getFirstName(player) + "(" + player + "). This is because we had an invalid objvar (beast) transfer.");
		destroyObject(dnaContainer);
		return false;
	}
	
	if(hasObjVar(dnaContainer, DNA_PARENT_NAME))
	{
		setName(dnaContainer, getStringObjVar(dnaContainer, DNA_PARENT_NAME));
	}

	
	CustomerServiceLog("BeastPetConversion: ", "petItem (" + petItem + ")"+ " was converted into a dna object" + dnaContainer + "), for player " + getFirstName(player) + "(" + player + "). All data has been transfered, and we will now destroy the PetItem(" + petItem + ")");	
	return true;
}

//function to convert a creature template in hash form to a string form
string convertHashTemplateToString(int hashTemplate, obj_id station)
{
	//validation
	if(hashTemplate == 0)
	{
		blog("INCUBATOR", "convertHashTemplateToString hashTemplate == 0");
		return "";
	}
	
	if(!isValidId(station) || !exists(station))
	{
		blog("INCUBATOR", "convertHashTemplateToString !isValidId(station) || !exists(station)");
		return "";
	}
	
	blog("INCUBATOR", "convertHashTemplateToString start");
	blog("INCUBATOR", "convertHashTemplateToString hashTemplate " + hashTemplate);
	
	//intialize variables
	int row = -1;
	string template = "";
	
	//get last mutation we had a mutation
	int lastMutatedSession = getLastSessionMutated(station);
	blog("INCUBATOR", "convertHashTemplateToString lastMutatedSession " + lastMutatedSession);
	
	//if lastMutatedSession is >= 1 then we need to look for the mutated template in the datatable
	boolean movedSessionVariable = false;
	if(lastMutatedSession >= 1)
	{

		row = dataTableSearchColumnForInt(hashTemplate, "hash_mutated_template_" + lastMutatedSession, DATATABLE_INCUBATOR_TEMPLATES);
		if(row < 0)
		{
			row = dataTableSearchColumnForInt(hashTemplate, "hash_mutated_template_" + (lastMutatedSession + 1), DATATABLE_INCUBATOR_TEMPLATES);
			blog("INCUBATOR", "convertHashTemplateToString column is hash_mutated_template_" + (lastMutatedSession + 1));
			if(row < 0)
			{
				blog("INCUBATOR", "convertHashTemplateToString row " + row + " bailing out.");
				return "";
			}
			movedSessionVariable = true;
			setObjVar(station, LAST_MUTATION, (lastMutatedSession + 1));
		}
		
		blog("INCUBATOR", "convertHashTemplateToString row " + row);
		if(!movedSessionVariable)
		{
			template = dataTableGetString(DATATABLE_INCUBATOR_TEMPLATES, row, "mutated_template_" + lastMutatedSession);
		}
		else
		{
			template = dataTableGetString(DATATABLE_INCUBATOR_TEMPLATES, row, "mutated_template_" + (lastMutatedSession + 1));
		}
	}
	else
	{
		//no mutation yet, so we look at the initial template
		blog("INCUBATOR", "convertHashTemplateToString no mutation yet");
		row = dataTableSearchColumnForInt(hashTemplate, "hash_initial_template", DATATABLE_INCUBATOR_TEMPLATES);
		if(row < 0)
		{
			blog("INCUBATOR", "convertHashTemplateToString row " + row + " bailing out.");
			return "";
		}

		blog("INCUBATOR", "convertHashTemplateToString row " + row);
		template = dataTableGetString(DATATABLE_INCUBATOR_TEMPLATES, row, "initial_template");
	}
	//lets return our template
	blog("INCUBATOR", "convertHashTemplateToString returning " + template);
	return template;
}

//function to convert string to hash CrC
int convertStringTemplateToCrC(string strTemplate)
{
	//validation
	if(strTemplate == null || strTemplate.equals(""))
	{
		blog("INCUBATOR", "convertStringTemplateToCrC hashTemplate null");
		return 0;
	}
	
	blog("INCUBATOR", "convertStringTemplateToCrC start");
	blog("INCUBATOR", "convertStringTemplateToCrC strTemplate " + strTemplate);
	
	//intialize variables
	int row = -1;
	int crcTemplate = 0;
	
	row = dataTableSearchColumnForString(strTemplate, "initial_template", DATATABLE_INCUBATOR_TEMPLATES);
	if(row < 0)
	{
		blog("INCUBATOR", "convertStringTemplateToCrC row " + row + " bailing out.");
		return 0;
	}

	blog("INCUBATOR", "convertStringTemplateToCrC row " + row);
	crcTemplate = dataTableGetInt(DATATABLE_INCUBATOR_TEMPLATES, row, "hash_initial_template");
	
	//lets return our template
	blog("INCUBATOR", "convertStringTemplateToCrC returning " + crcTemplate);
	return crcTemplate;
}

//function to get the hash type of a string creature tyep
int getHashType(string beastType)
{
	int hashType = 0;
	//validation
	if(beastType == null || beastType.equals(""))
	{
		blog("INCUBATOR", "getHashType beastType == null");
		return 0;
	}
	
	blog("INCUBATOR", "getHashType start");
	blog("INCUBATOR", "getHashType beastType " + beastType);
	
	//look in the datatable for the beastType
	int row = dataTableSearchColumnForString(beastType, "beastType", beast_lib.BEASTS_TABLE);
	
	if(row < 0)
	{
		blog("INCUBATOR", "getHashType row < 0");
		return 0;
	}
	blog("INCUBATOR", "getHashType row " + row);
	
	hashType = dataTableGetInt(beast_lib.BEASTS_TABLE, row, "hashBeastType");
	blog("INCUBATOR", "getHashType returning " + hashType);
	return hashType;
}


//function for converting Hash to string for beast type
string convertHashTypeToString(int hashType)
{
	//validation
	if(hashType == 0)
	{
		blog("INCUBATOR", "convertHashTypeToString hashType == 0");
		return "";
	}
	
	string beastType = "";
	
	blog("INCUBATOR", "convertHashTypeToString start");
	blog("INCUBATOR", "convertHashTypeToString hashType " + hashType);
	
	//search the datatable for the hashtype
	int row = dataTableSearchColumnForInt(hashType, "hashBeastType", beast_lib.BEASTS_TABLE);
	if(row < 0)
	{
		blog("INCUBATOR", "convertHashTypeToString row < 0");
		return "";
	}
	blog("INCUBATOR", "convertHashTypeToString row " + row);		
	beastType = dataTableGetString(beast_lib.BEASTS_TABLE, row, "beastType");
	
	blog("INCUBATOR", "convertHashTypeToString returning " + beastType);
	return beastType;
}

//used for logging.

void blog (string identifier, string text)
{
	if(LOGGING_ENABLED)
	{
		LOG(identifier, text);
	}
}


boolean isEggMountType(obj_id egg)
{
	int hashBeastType = 0;
	if(hasObjVar(egg, beast_lib.OBJVAR_BEAST_TYPE))
	{
		hashBeastType = getIntObjVar(egg,  beast_lib.OBJVAR_BEAST_TYPE);
	}
	else
	{
		return false;
	}
		
	int row = dataTableSearchColumnForInt(hashBeastType, "hashBeastType", beast_lib.BEASTS_TABLE);
	
	string mountTemplate = dataTableGetString(beast_lib.BEASTS_TABLE, row, "mountTemplate");
	
	if(mountTemplate == null || mountTemplate.equals(""))
	{
		return false;
	}
	
	return true;
}

//used to dermine mount template
string getMountTemplate (obj_id egg, obj_id player)
{
	int hashBeastType = 0;

	if(hasObjVar(egg, beast_lib.OBJVAR_BEAST_TYPE))
	{
		hashBeastType = getIntObjVar(egg,  beast_lib.OBJVAR_BEAST_TYPE);
	}
	else
	{
		return "";
	}
		
	int row = dataTableSearchColumnForInt(hashBeastType, "hashBeastType", beast_lib.BEASTS_TABLE);
	
	string mountTemplate = dataTableGetString(beast_lib.BEASTS_TABLE, row, "mountTemplate");
	
	return mountTemplate;
}

boolean stampEggAsMount(obj_id egg, obj_id player)
{
	
	if(!isIdValid(egg) || !exists(egg))
	{
		return false;
	}
	
	if(!isIdValid(player) || !exists(player))
	{
		return false;
	}
	
	if(isEggMountFlagged(egg))
	{
		return false;
	}
	
	setObjVar(egg, beast_lib.OBJVAR_BEAST_MOUNT_FLAG, 1);
	return true;
}
	


//converts incubated eggs to a mount
obj_id convertEggToMount(obj_id egg, obj_id player)
{
	//get the mount type
	string mountType = getMountTemplate(egg, player);
	
	//need to validate mountType
	if(mountType == null && mountType.equals(""))
	{
		return obj_id.NULL_ID;
	}
	
	//make sure the player has the master script
	if (!hasScript(player, "ai.pet_master"))
		attachScript(player, "ai.pet_master");
	
	//verify that the player does not have too many mounts
	if ( !pet_lib.hasMaxStoredPetsOfType( player, pet_lib.PET_TYPE_MOUNT ) )
	{
		//get the datapad
		obj_id datapad = utils.getPlayerDatapad(player);
		
		//verify it
		if ( !isIdValid( datapad ) )
		{
			CustomerServiceLog("BeastEggToMountConversion: ", "Player (" + player + ") tried to convert thier beast egg(" + egg + ") into a mount and FAILED. This was due to them returning an invalid Datapad objId. Egg (" + egg + ") was not destroyed.");	
			return obj_id.NULL_ID;
		}
		
		//setup the template for the PCD
		string controlTemplate = "object/intangible/pet/" + utils.dataTableGetString(create.CREATURE_TABLE, mountType, "template" );

		//verify that we ahve a valid template
		if (!controlTemplate.endsWith(".iff") )
			controlTemplate = pet_lib.PET_CTRL_DEVICE_TEMPLATE;
		
		//create the PCD
		obj_id petControlDevice = createObject( controlTemplate, datapad, "");
		
		//validate it
		if ( !isIdValid( petControlDevice ) )
		{
			//try making another with the base template
			petControlDevice = createObject( pet_lib.PET_CTRL_DEVICE_TEMPLATE, datapad, "");
			if ( !isIdValid( petControlDevice ) )
			{
				//still not working, most likely too much in datapad
				sendSystemMessage( player, pet_lib.SID_SYS_TOO_MANY_STORED_PETS );
				CustomerServiceLog("BeastEggToMountConversion: ", "Player (" + player + ") tried to convert thier beast egg(" + egg + ") into a mount and FAILED. This was due being unable to create a PCD in thier datatpad. Most likely they have too many objects in it. Egg (" + egg + ") was not destroyed.");	
				return obj_id.NULL_ID;
			}
		}
		
		//set all or info on the PCD
		int mountHue = getIntObjVar(egg, beast_lib.OBJVAR_BEAST_HUE);
		setUpPetControlDevice( petControlDevice, mountType, egg);
		setObjVar( petControlDevice, "ai.pet.trainedMount", 1 );
		setObjVar( petControlDevice, "ai.pet.type", pet_lib.PET_TYPE_MOUNT);
		setObjVar( petControlDevice, beast_lib.OBJVAR_BEAST_HUE, mountHue);
		setObjVar( petControlDevice, beast_lib.OBJVAR_OLD_PET_REHUED, 1);
		hue.setColor(petControlDevice, hue.INDEX_1, mountHue);
		//tell cs we succeeded
		CustomerServiceLog("BeastEggToMountConversion: ", "Player (" + player + ") converted thier beast egg(" + egg + ") into a mount and SUCEEDED. PCD(" +petControlDevice + ") was created. We will now destroy the egg(" + egg + ").");	
		return petControlDevice;
	}
	sendSystemMessage( player, pet_lib.SID_SYS_TOO_MANY_STORED_PETS );
	return obj_id.NULL_ID;
}


//sets up PCD from converted Egg
void setUpPetControlDevice( obj_id petControlDevice, string petType, obj_id egg )
{
	//set the creature type to spawn
	setObjVar( petControlDevice, "pet.creatureName", petType );
	//put the pcd script on it.
	attachScript( petControlDevice, "ai.pet_control_device" );
	
	//see if this egg has a name. This will only happen if we have an old converted pet, or if we handed one out
	string myName = getAssignedName( egg );
	
	//validate name
	if ( myName != null && myName != "" )
	{
		//check if name we recieved is the default name for eggs
		if(myName.startsWith("an incubated"))
		{
			//lets set the name to the beast type
			if(setBeastTypeToName(egg, petControlDevice))
			{
				setObjVar(petControlDevice, beast_lib.OBJVAR_OLD_PET_IDENTIFIER, 1);
				return;
			}
		}
		//set name to myName
		setName( petControlDevice, myName );
		setObjVar(petControlDevice, beast_lib.OBJVAR_OLD_PET_IDENTIFIER, 1);
	}
	//try to set it to the beasts type
	setBeastTypeToName(egg, petControlDevice);
	setObjVar(petControlDevice, beast_lib.OBJVAR_OLD_PET_IDENTIFIER, 1);
	return;

}

boolean setBeastTypeToName(obj_id egg, obj_id pcd)
{
	if(hasObjVar(egg, beast_lib.OBJVAR_BEAST_TYPE))
	{
		//get the hash objvar for beast type
		int hashType = getIntObjVar(egg, beast_lib.OBJVAR_BEAST_TYPE);
		//convert hash to string
		string beastType = incubator.convertHashTypeToString(hashType);
		//remove the bm_
		string beastDisplayType = beast_lib.stripBmFromType(beastType);
		//get the string id for this creature
		string_id beastTypeSid = new string_id("monster_name", beastDisplayType);
		//set the localized name
		setName(pcd, localize(beastTypeSid));
		return true;
	}
	return false;
}


boolean giveMutationAttributeBonus(obj_id station, obj_id player, float[] attributesUpdateAmount, string[] attributes)
{
	
	if(!isValidId(station) || !exists(station))
	{
		return false;
	}
	
	if(!isValidId(player) || !exists(player))
	{
		return false;
	}
	
	if(attributesUpdateAmount.length <= 0)
	{
		return false;
	}
	
	if(attributes.length <= 0)
	{
		return false;
	}
	
	int index = rand(0, (attributes.length -1));
	
	//every ten points is worth 1% so they can get up to a 1% increase.
	int bonusAmt = rand(1,10);
	
	incubator.blog("INCUBATOR", attributes[index] + " Before " + attributesUpdateAmount[index]);
	attributesUpdateAmount[index] += (float)bonusAmt;
	
	//convert the attribute amount to actual percentage
	float attrib = 0.0f;
	if(attributes[index] == "Health Bonus")
	{
		attrib = attributesUpdateAmount[index] * 0.2f;
	}
	else
	{
		attrib = attributesUpdateAmount[index] * .1f;
	}
	
	attrib = utils.roundFloatByDecimal(attrib);
	
	incubator.blog("INCUBATOR", attributes[index] + " After " + attributesUpdateAmount[index]);
	incubator.blog("INCUBATOR", "attrib " + attrib);
	
	prose_package pp = new prose_package();
	pp = prose.setDF(pp, attrib);
	pp = prose.setDI(pp, bonusAmt);
	pp = prose.setTT(pp, attributes[index]);
	pp = prose.setStringId(pp, SID_ATTRIBUTE_MUTATION);
	sendSystemMessageProse(player, pp);
	CustomerServiceLog("incubatorMutationLog: ", "Player '" + getPlayerName(player) + "' (" + player + ") received a Type 1 mutation. This type of mutation gives a bonuse to stats. They received " + bonusAmt + " points to " + attributes[index] + ".");
	return true;
}

//determines creatureType from the hashTemplate stored on the Incubator
string getCreatureTypeFromHashTemplate(obj_id station)
{
	if(!isValidId(station) || !exists(station))
	{
		return "";
	}
	
	//get the HashTemplate off the incubator
	int hashTemplate = getIncubatorCreatureTemplate(station);
	//convert the hash to a workable string
	string creatureTemplate = convertHashTemplateToString(hashTemplate, station);
		blog("INCUBATOR", "creatureTemplate = " + creatureTemplate);
	//remove the .iff
	string[] splitCreatureTemplate = split(creatureTemplate, '.');
		blog("INCUBATOR", "splitCreatureTemplate[0] = "+splitCreatureTemplate[0]+" splitCreatureTemplate[1] = "+splitCreatureTemplate[1]);
	//remove all the previous folder locations, so you end up with
	string[] finalCreatureTemplate = split(splitCreatureTemplate[0], '/');
	
	//get the last index of that split
	int finalIndex = finalCreatureTemplate.length - 1;
		blog("INCUBATOR", "finalCreatureTemplate[finalIndex] = "+finalCreatureTemplate[finalIndex]);
	//set creature name to that final index value
	string creatureName = finalCreatureTemplate[finalIndex];
		blog("INCUBATOR", "creatureName = " + creatureName);
	
	return creatureName;
}

//used to determin if the given items is from a converted pet
boolean isConvertedPet(obj_id item)
{
	if(hasObjVar(item, DNA_OLD_PET_IDENTIFIER) || hasObjVar(item, STATION_DNA_OLD_PET_IDENTIFIER))
		return true;
		
	return false;
}

//used in god hack to convert old converted pet's template from strings to hash
boolean fixDnaData(obj_id dna, obj_id player)
{
	if(hasObjVar(dna, DNA_TEMPLATE_OBJVAR))
	{
		string templateString = getStringObjVar(dna, DNA_TEMPLATE_OBJVAR);
		int row = dataTableSearchColumnForString(templateString, "initial_template",DATATABLE_INCUBATOR_TEMPLATES);
		int hashTemplate = dataTableGetInt(DATATABLE_INCUBATOR_TEMPLATES, row, "hash_initial_template");

		setObjVar(dna, DNA_TEMPLATE_OBJVAR, hashTemplate);
		return true;
	}
	return false;
}

//Find out what the label of our Particle should be
string getCurrentSessionParticleLabelName(obj_id station)
{
	int currentSession = getCurrentSessionNumber(station);
	string sessionLabel = PARTICLE_LABEL_DEFAULT;
	
	switch(currentSession)
	{
		case 1:
			sessionLabel = PARTICLE_LABEL_DEFAULT;
			break;
		case 2:
			sessionLabel = PARTICLE_LABEL_PHASE_ONE;
			break;
		case 3:
			sessionLabel = PARTICLE_LABEL_PHASE_TWO;
			break;
		case 4:
			sessionLabel = PARTICLE_LABEL_PHASE_THREE;
			break;
		case 5:
			sessionLabel = PARTICLE_LABEL_PHASE_FOUR;
			break;		
		default:
			sessionLabel = PARTICLE_LABEL_DEFAULT;
			break;
	}
	//LOG("INCUBATOR","INCUBATOR.getCurrentSessionParticleLabelName is " +sessionLabel);
	return sessionLabel;
}

//Find out what the label of our Particle should be
string advanceParticleLabelName(string labelName)
{
	string sessionLabel = null;
	if(labelName != null && labelName != "")
	{	
		if(labelName.equals(PARTICLE_LABEL_DEFAULT))
			sessionLabel = PARTICLE_LABEL_PHASE_ONE;
		
		if(labelName.equals(PARTICLE_LABEL_PHASE_ONE))
			sessionLabel = PARTICLE_LABEL_PHASE_TWO;
			
		if(labelName.equals(PARTICLE_LABEL_PHASE_TWO))
			sessionLabel = PARTICLE_LABEL_PHASE_THREE;
		
		if(labelName.equals(PARTICLE_LABEL_PHASE_THREE))
			sessionLabel = PARTICLE_LABEL_PHASE_FOUR;		
			
		if(labelName.equals(PARTICLE_LABEL_PHASE_FOUR))
			sessionLabel = PARTICLE_LABEL_DEFAULT;
	}
	
	return sessionLabel;
}

//Find out what Particle we should be playing
string getCurrentSessionParticle(obj_id station)
{
	int currentSession = getCurrentSessionNumber(station);
	string sessionParticle = PARTICLE_DEFAULT;
	
	switch(currentSession)
	{
		case 1:
			sessionParticle = PARTICLE_DEFAULT;
			break;
		case 2:
			sessionParticle = PARTICLE_PHASE_ONE;
			break;
		case 3:
			sessionParticle = PARTICLE_PHASE_TWO;
			break;
		case 4:
			sessionParticle = PARTICLE_PHASE_THREE;
			break;
		case 5:
			sessionParticle = PARTICLE_PHASE_FOUR;
			break;
		default:
			sessionParticle = PARTICLE_DEFAULT;
			break;
	}
	//LOG("INCUBATOR","INCUBATOR.getCurrentSessionParticle is " +sessionParticle);
	return sessionParticle;
}

//Find out what Particle we should be playing
string getCurrentSessionParticle(string labelName)
{
	string sessionParticle = null;
	if(labelName != null && labelName != "")
	{	
		if(labelName.equals(PARTICLE_LABEL_DEFAULT))
			sessionParticle = PARTICLE_DEFAULT;
		
		if(labelName.equals(PARTICLE_LABEL_PHASE_ONE))
			sessionParticle = PARTICLE_PHASE_ONE;
			
		if(labelName.equals(PARTICLE_LABEL_PHASE_TWO))
			sessionParticle = PARTICLE_PHASE_TWO;
			
		if(labelName.equals(PARTICLE_LABEL_PHASE_THREE))
			sessionParticle = PARTICLE_PHASE_THREE;
		
		if(labelName.equals(PARTICLE_LABEL_PHASE_FOUR))
			sessionParticle = PARTICLE_PHASE_FOUR;
	}
	
	return sessionParticle;
}

//Find what Hardpoint matches the particle
string getCurrentParticleHardpoint(string sessionParticle)
{
	string hardPoint = null;
	if(sessionParticle != null && sessionParticle != "")
	{	
		if(sessionParticle.equals(PARTICLE_DEFAULT))
			hardPoint = PARTICLE_HARDPOINT_TWO;

		if(sessionParticle.equals(PARTICLE_PHASE_ONE))
			hardPoint = PARTICLE_HARDPOINT_THREE;

		if(sessionParticle.equals(PARTICLE_PHASE_TWO))
			hardPoint = PARTICLE_HARDPOINT_THREE;

		if(sessionParticle.equals(PARTICLE_PHASE_THREE))
			hardPoint = PARTICLE_HARDPOINT_THREE;
		
		if(sessionParticle.equals(PARTICLE_PHASE_FOUR))
			hardPoint = PARTICLE_HARDPOINT_THREE;
	}
		
	return hardPoint;
}

//Advance to the next Particle in the chain
void advanceSessionParticle(obj_id station)
{
	if(!isValidId(station))
		return;
		
	string currentLabel = utils.getStringScriptVar(station, PARTICLE_LABEL_SCRIPT_VAR);
	if(currentLabel != null && currentLabel != "")
	{
	
		string newLabel = advanceParticleLabelName(currentLabel);
		string sessionParticle = getCurrentSessionParticle(newLabel);
		string hardPoint = incubator.getCurrentParticleHardpoint(sessionParticle);

		if((newLabel != null && newLabel != "") && 
		(sessionParticle != null && sessionParticle != "") &&
		(hardPoint != "" && hardPoint != null))
		{
			stopClientEffectObjByLabel(station, currentLabel);
			utils.setScriptVar(station, incubator.PARTICLE_LABEL_SCRIPT_VAR, newLabel);
			playClientEffectObj(station, sessionParticle, station, hardPoint,null, newLabel);
		}
	}
	
	return;
}

//Emergency function to stop all client effects going on the station
void stopAllSessionParticles(obj_id station)
{	
	stopClientEffectObjByLabel(station, PARTICLE_LABEL_DEFAULT);
	stopClientEffectObjByLabel(station, PARTICLE_LABEL_PHASE_ONE);
	stopClientEffectObjByLabel(station, PARTICLE_LABEL_PHASE_TWO);
	stopClientEffectObjByLabel(station, PARTICLE_LABEL_PHASE_THREE);
	stopClientEffectObjByLabel(station, PARTICLE_LABEL_PHASE_FOUR);
	return;
}

boolean isEggMountFlagged(obj_id egg)
{
	
	if(!isIdValid(egg) || !exists(egg))
	{
		return false;
	}
	
	if(hasObjVar(egg, beast_lib.OBJVAR_BEAST_MOUNT_FLAG))
	{
		return true;
	}
	
	return false;
}

//function used to give skill point bonuses to mutations
boolean giveMutationSkillBonus(obj_id station, obj_id player, int[] skillArray, string newTemplate)
{
	blog("INCUBATOR_SKILLS", "giveMutationSkillBonus::start");
	if(!exists(station) || !isIdValid(station))
	{
		return false;
	}
	
	if(!exists(player) || !isIdValid(player))
	{
		return false;
	}

	if(skillArray.length <= 0)
	{
		return false;
	}
	
	for(int i = 0; i < skillArray.length; ++i)
	{
		skillArray[i] += MUTATION_SKILL_BONUS_AMT;
		blog("INCUBATOR_SKILLS", "giveMutationSkillBonus::skillArray[i]" + skillArray[i]);
	}
	
	
	CustomerServiceLog("incubatorMutationLog: ", "Player '" + getPlayerName(player) + "' (" + player + ") received a template mutation. This type of mutation gives a bonus of " + MUTATION_SKILL_BONUS_AMT + " to all skills and a template appearance change. They now have the template of " + newTemplate + " in their incubator.");
	return true;
}

boolean setEggHue(obj_id egg)
{
	return setEggHue(egg, obj_id.NULL_ID);
}
//used to set the eggs hue to match the beasts hue
boolean setEggHue(obj_id egg, obj_id player)
{
	if(!exists(egg) || !isIdValid(egg))
	{
		return false;
	}
	
	boolean hasPlayerId = false;
	
	if(isIdValid(player))
		hasPlayerId = true;
	
	if(hasObjVar(egg, beast_lib.OBJVAR_BEAST_HUE))
	{
		int eggHue = getIntObjVar(egg, beast_lib.OBJVAR_BEAST_HUE);
		
		int crcType = getIntObjVar(egg, beast_lib.OBJVAR_BEAST_TYPE);
		
		int row = dataTableSearchColumnForInt(crcType, "hashBeastType", beast_lib.BEASTS_TABLE);
		if(row < 0)
		{
			blog("EggHue", "setEggHue row " + row + " bailing out.");
			return false;
		}
		
		int paletteLength = dataTableGetInt(beast_lib.BEASTS_TABLE, row, "palette_length");
		
		if(paletteLength < 0)
		{
			//something is wrong, we didnt find the entry
			return false;
		}
		
		//all creature palettes end with the mutation palette. The egg uses the mutation palette
		//so we take the length of the creatures palette
		//subract the mutation palettes length
		//this gives us the creaturs base palette length
		int paletteMinusMutation = paletteLength - MUTATION_PALETTE_LENGTH;
		
		//Our eggs hue will be the objvars value minus the creatures base palette length
		eggHue -= paletteMinusMutation;

		if(hasPlayerId)
			debugSpeakMsg(player, "eggHue is " + eggHue);
			
		hue.setColor(egg, "/private/index_color_1", eggHue);
		return true;
	}
	else
		return false;
}
//determines creatureType from the hashTemplate stored on the Incubator
string getCreatureTypeFromHashTemplateDna(obj_id dna, int hashTemplate)
{
	if(!isValidId(dna) || !exists(dna))
	{
		return "";
	}
	
	//convert the hash to a workable string
	string creatureTemplate = convertHashTemplateToString(hashTemplate, dna);
		blog("INCUBATOR", "creatureTemplate = " + creatureTemplate);
	//remove the .iff
	string[] splitCreatureTemplate = split(creatureTemplate, '.');
		blog("INCUBATOR", "splitCreatureTemplate[0] = "+splitCreatureTemplate[0]+" splitCreatureTemplate[1] = "+splitCreatureTemplate[1]);
	//remove all the previous folder locations, so you end up with
	string[] finalCreatureTemplate = split(splitCreatureTemplate[0], '/');
	
	//get the last index of that split
	int finalIndex = finalCreatureTemplate.length - 1;
		blog("INCUBATOR", "finalCreatureTemplate[finalIndex] = "+finalCreatureTemplate[finalIndex]);
	//set creature name to that final index value
	string creatureName = finalCreatureTemplate[finalIndex];
		blog("INCUBATOR", "creatureName = " + creatureName);
	
	return creatureName;
}

//function to convert a creature template in hash form to a string form
string convertHashTemplateToStringDna(int hashTemplate, obj_id dna)
{
	//validation
	if(hashTemplate == 0)
	{
		blog("INCUBATOR", "convertHashTemplateToString hashTemplate == 0");
		return "";
	}
	
	if(!isValidId(dna) || !exists(dna))
	{
		blog("INCUBATOR", "convertHashTemplateToString !isValidId(dna) || !exists(dna)");
		return "";
	}
	
	blog("INCUBATOR", "convertHashTemplateToString start");
	blog("INCUBATOR", "convertHashTemplateToString hashTemplate " + hashTemplate);
	
	//intialize variables
	int row = -1;
	string template = "";
	
	//no mutation yet, so we look at the initial template
	row = dataTableSearchColumnForInt(hashTemplate, "hash_initial_template", DATATABLE_INCUBATOR_TEMPLATES);
	if(row < 0)
	{
		blog("INCUBATOR", "convertHashTemplateToString row " + row + " bailing out.");
		return "";
	}

	blog("INCUBATOR", "convertHashTemplateToString row " + row);
	template = dataTableGetString(DATATABLE_INCUBATOR_TEMPLATES, row, "initial_template");

	//lets return our template
	blog("INCUBATOR", "convertHashTemplateToString returning " + template);
	return template;
}


void awardEnzymeCollection(obj_id enzyme)
{
	if(!isIdValid(enzyme) || !exists(enzyme))
	{
		return;
	}

	if(!hasObjVar(enzyme, "collection_enzyme"))
	{
		return;
	}

	if(hasObjVar(enzyme, incubator.ENZYME_COLOR_OBJVAR))
	{
		int color = getIntObjVar(enzyme, incubator.ENZYME_COLOR_OBJVAR);
		
		if(color >= ENZYME_COLLECTION_NAMES.length)
		{
			return;
		}
		
		obj_id player = utils.getContainingPlayer(enzyme);
		
		if(!isIdValid(player) || !exists(player) || !isPlayer(player))
		{
			return;
		}
			
		removeObjVar(enzyme, "collection_enzyme");

		int collectionSlot = (int)getCollectionSlotValue(player, ENZYME_COLLECTION_NAMES[color]);
		
		if(collectionSlot <= 0)
		{
			boolean modified = modifyCollectionSlotValue(player, ENZYME_COLLECTION_NAMES[color], 1);
		}
	}
}
