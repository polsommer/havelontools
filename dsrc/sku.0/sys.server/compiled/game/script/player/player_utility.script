/**********************************************************************
 * Copyright (c)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        player_utility.script
 * Description:  utility script for player characters
 * @author       $Author:$
 * @version      $Revision:$
 **********************************************************************/

/***** INCLUDES ********************************************************/
include library.ai_lib;
include library.badge;
include library.beast_lib;
include library.buff;
include library.colors;
include library.combat;
include library.create;
include library.factions;
include library.gcw;
include library.gm;
include library.groundquests;
include library.healing;
include library.holiday;
include library.incubator;
include library.locations;
include library.loot;
include library.luck;
include library.marriage;
include library.money;
include library.pclib;
include library.performance;
include library.pet_lib;
include library.planetary_map;
include library.player_structure;
include library.player_version;
include library.prose;
include library.regions;
include library.respec;
include library.session;
include library.skill;
include library.skill_template;
include library.static_item;
include library.stealth;
include library.structure;
include library.sui;
include library.target_dummy;
include library.trial;
include library.turnstile;
include library.utils;
include library.vehicle;
include library.weapons;
include library.xp;

/***** LOGGING CONSTANTS ***********************************************/
const string LOGGING_CATEGORY			= "foraging";
const boolean LOGGING_ON			= false;

/***** CONSTANTS *******************************************************/

const obj_id WORLD_ID                       	= obj_id.NULL_ID;

const string VAR_AUTODECLINE_DUEL		= "decline_duel";
const string VAR_FIND_BASE			= "find";
const string VAR_FIND_WAYPOINT			= VAR_FIND_BASE + ".waypoint";

const string TBL_FIND_MAP			= "datatables/find/map.iff";
const string COL_NAME				= "NAME";
const string COL_DISPLAY			= "DISPLAY";
const string COL_DISPLAY_NAME			= "DISPLAY_NAME";
const string COL_PARAM				= "PARAM";

const string STF_FIND_DISPLAY			= "find_display";
const string STF_FILE 				= "player/player_utility";

const string_id PROSE_FIND_SET			= new string_id("base_player", "prose_find_set");
const string_id PROSE_FIND_UNFOUND		= new string_id("base_player", "prose_find_unfound");

const string_id PROSE_FIND_UNKNOWN_ARG		= new string_id("base_player", "prose_find_unknown_arg");

const string_id SID_FIND_GENERAL_ERROR		= new string_id("base_player", "find_general_error");
const string_id SID_FIND_DATAPAD_FULL		= new string_id("base_player", "find_datapad_full");

const string_id SID_SALE_FEE			= new string_id("base_player", "sale_fee");
const string_id SID_VENDOR_PAY			= new string_id("player_structure", "vendor_pay");

const string_id SID_NO_ENTRY_WHILE_MOUNTED	= new string_id("base_player", "no_entry_while_mounted");
const string_id SID_DISMOUNTING			= new string_id("base_player", "dismounting");

const string_id SID_WAYPOINT_AND_DATA_CLEARED 	= new string_id("base_player", "waypoint_and_data_cleared");
const string_id SID_UNABLE_TO_CREATE_PATH	= new string_id("base_player", "unable_to_create_path");
const string_id SID_FIND_PATH_STARTED		= new string_id("base_player", "find_path_started");

const string_id SID_SUI_PAY_ACCESS_FEE_PROMPT	= new string_id("base_player", "sui_pay_access_fee_prompt");
const string_id SID_SUI_PAY_ACCESS_FEE_TITLE	= new string_id("base_player", "sui_pay_access_fee_title");
const string_id SID_CHANNEL_HEAL_WRONG_USER	= new string_id("healing", "channel_heal_wrong_user");
const string_id SID_CHANNEL_HEAL_MOVED		= new string_id("healing", "channel_heal_moved");
const string_id SID_CHANNEL_HEAL_IN_COMBAT	= new string_id("healing", "channel_heal_in_combat");

const string_id SID_DNA_ONLY_BEAST_MASTER	= new string_id("beast", "dna_not_beast_master");
const string_id SID_DNA_TOO_FAR			= new string_id("beast", "dna_too_far");
const string_id SID_DNA_NOT_IN_TUTORIAL		= new string_id("beast", "dna_not_in_tutorial");

const string_id SID_NOT_IN_CITY			= new string_id("player/player_utility", "forage_not_in_city");
const string_id SID_PATROL_POINT_ENTERTAINED 	= new string_id("gcw", "the_patrol_point_entertained");
//PLAYER VERSIONING
const string VAR_VERSION_BASE			= "ver";

const string TBL_PLAYER_VERSION			= "datatables/player/version.iff";

const string SKILL				= "skill";

const string COL_LOOKUP				= "LOOKUP";
const string COL_VERSION			= "VERSION";

const string_id	SID_CITY_UPDATE_ETA	= new string_id( "city/city", "city_update_eta" );

const string NON_ENHANCEMENT_BUFF 		= "buff.non_enhancement";

// rename character
const string SCRIPTVAR_RENAME_CHARACTER_SUI_ID = "renameCharacterSuiId";
const string SCRIPTVAR_RENAME_CHARACTER_NEW_NAME = "renameCharacterNewName";
const string SCRIPTVAR_RENAME_CHARACTER_UNVERIFIED_NEW_NAME = "renameCharacterUnverifiedNewName";
const string GUARD_OCCUPIED			= "occupied";

/***** TRIGGERS ********************************************************/

trigger OnLogin()
{
	if (utils.checkConfigFlag("GameServer", "jediTestResources"))
	{
		if(hasSkill(self, "class_bountyhunter_phase4_novice"))
		{
			createNewBHResources(self);
			//createBuffs(self);
		}
	}
	if(utils.checkConfigFlag("GameServer", "jediTestBuffs"))
	{
		if(hasSkill(self, "class_bountyhunter_phase4_novice"))
		{
			//createNewBHResources(self);
			createBuffs(self);
		}
	}
	removeObjVar(self, VAR_FIND_BASE);

	if(buff.hasBuff(self, "tcg_series3_hands_of_seduction"))
	{
		if(buff.removeBuff(self, "tcg_series3_hands_of_seduction"))
			buff.applyBuff(self, "tcg_series3_hands_of_seduction");

	}

	return SCRIPT_CONTINUE;
}

trigger OnIncapacitated(obj_id killer)
{
	removeAttribOrSkillModModifier(self, "TC2 - BUFFS (Health)");
	removeAttribOrSkillModModifier(self, "TC2 - BUFFS (Const)");
	removeAttribOrSkillModModifier(self, "TC2 - BUFFS (Action)");
	removeAttribOrSkillModModifier(self, "TC2 - BUFFS (Stam)");
	removeAttribOrSkillModModifier(self, "TC2 - BUFFS (Mind)");
	removeAttribOrSkillModModifier(self, "TC2 - BUFFS (Will)");
	return SCRIPT_CONTINUE;
}

trigger OnInitialize()
{
	obj_id item = getObjectInSlot(self, "held_r");
	if ( isIdValid(item) )
	{
		if ( hasObjVar(item, "isLightsaber") && !isJedi(self) )
		{
			obj_id inv = utils.getInventoryContainer(self);
			if ( isIdValid(inv) )
			{
				putInOverloaded(item, inv);
			}
		}
	}

	if ( !hasScript(self, "player.player_faction") )
		attachScript(self, "player.player_faction");

	if ( !hasScript(self, "player.player_sui") )
		attachScript(self, "player.player_sui");

	if ( !hasScript(self, "player.player_money") )
		attachScript(self, "player.player_money");

	return SCRIPT_CONTINUE;
}

trigger OnWaypointDestroyed(obj_id waypoint)
{
	if ( utils.hasScriptVar(self, "hasClientPath") )
	{
		obj_id wp = utils.getObjIdScriptVar(self, "hasClientPath");
		if ( isIdValid(wp) && wp == waypoint )
			destroyClientPath(self);
	}

	return SCRIPT_CONTINUE;
}

trigger OnAboutToBeTransferred( obj_id destination, obj_id transferer )
{
	if((destination == null) || (transferer == null))
	{
		debugServerConsoleMsg(self, "OnAboutToBeTransferred: null parameter");
		return SCRIPT_OVERRIDE;
	}

	obj_id currentCell = getContainedBy(self);

	boolean isRidingMount = (getState(self, STATE_RIDING_MOUNT) > 0);
	obj_id  mountId       = (isRidingMount ? getMountId(self) : null);

	if(currentCell == null)
	{
		// Check for mounts.
		if (pet_lib.canMount(destination, self))
		{
			// The player is attempting to mount a creature.
			return SCRIPT_CONTINUE;
		}

		if (vehicle.isBattlefieldVehicle(destination) || vehicle.isBattlefieldVehicle(transferer))
		{
			return SCRIPT_CONTINUE;
		}

		// Ships can only be entered if they are not contained
		if (isGameObjectTypeOf(getGameObjectType(destination), GOT_ship))
		{
			if (isIdValid(getContainedBy(destination)))
			{
				LOG("space", "VALID CONTAINED BY12!@!");
				return SCRIPT_OVERRIDE;
			}
			return SCRIPT_CONTINUE;
		}

		if (destination != WORLD_ID)  //player is moving from world into building
		{
			LOG("space", "World something or other!@!");
			obj_id building = structure.getContainingBuilding(destination);
			if(building == null)
				return SCRIPT_OVERRIDE;

			// If admin, let them in.
			if ( player_structure.isAdmin(building, self) || player_structure.canEnter(building, self) )
				return SCRIPT_CONTINUE;

			// If banned, deny entry.
//		if ( permissions.isBanned(building, self) )
//			return SCRIPT_OVERRIDE;

			if ( turnstile.hasTurnstile(building) ) //structure has a turnstile
			{
				if ( turnstile.isPatron(building, self) )
				{
					if ( turnstile.hasExpired(building, self) )
					{
						//not valid patron
						turnstile.removePatron(building, self);
						sendSystemMessage( self, new string_id(STF_FILE, "access_expired"));
					}
					else
					{
						//still valid patron - allow entry
						sendSystemMessage( self, new string_id(STF_FILE, "access_granted"));
						return SCRIPT_CONTINUE;
					}
				}

				// Inform player of turnstile.
				turnstileInform( self, building );

				return SCRIPT_OVERRIDE;
			}
		}
	}
	else if (isRidingMount)
	{
		// NOTE: we handle the case where a player is moving from the world onto a mount in
		//       the "if" branch above where the player's container is null (i.e. in the world cell).
		if (destination == WORLD_ID)
		{
			// Player is trying to dismount.
			return SCRIPT_CONTINUE;
		}
		else
		{
			// Player is mounted but is trying to move into a building.  Prevent this.
			string creature_name = getName(mountId);
			sendSystemMessage(self, SID_NO_ENTRY_WHILE_MOUNTED);
			sendSystemMessage(self, SID_DISMOUNTING);

			if ( vehicle.isBattlefieldVehicle(mountId) )
			{
				queueCommand(self, ##"battlefieldDismount", self, creature_name, COMMAND_PRIORITY_FRONT);

				// Snowspeeders have a large turn radius and cannot be turned around, if they're stuck at an entrance.  This will flip the mount around.
				setYaw(mountId, getYaw(mountId) + 180.0f);
			}
			else
			{
				queueCommand(self, ##"dismount", self, creature_name, COMMAND_PRIORITY_FRONT);
			}
			return SCRIPT_OVERRIDE;
		}
	}
	else if ( (currentCell != WORLD_ID) && (destination == WORLD_ID) )  //player is moving from building to world
	{
		obj_id building = structure.getContainingBuilding(currentCell);
		if ( turnstile.hasTurnstile(building) ) //structure has a turnstile
		{
			if ( turnstile.hasExpired(building, self) && turnstile.isPatron(building, self) )
			{
				turnstile.removePatron(building, self);
				return SCRIPT_CONTINUE;
			}
		}
	}
	else //player is moving between rooms of a building
	{
		//is room declared "private"?
		//if yes, check permissions
	}
	LOG("space", "REturning Aok!@!");
	return SCRIPT_CONTINUE;
}

void turnstileInform( obj_id self, obj_id building )
{
//	if ( utils.hasScriptVar( self, "turnstile.queryTurnstile") )
//		return;
	utils.setScriptVar( self, "turnstile.queryTurnstile", 1 );
	utils.setScriptVar( self, "turnstile.structure", building );

	int fee = turnstile.getFee( building );

	prose_package ppFeePrompt = prose.getPackage(SID_SUI_PAY_ACCESS_FEE_PROMPT);
	prose.setDI(ppFeePrompt, fee);
	string feePrompt = " \0" + packOutOfBandProsePackage(null, ppFeePrompt);

	sui.msgbox( self, self, feePrompt, sui.OK_CANCEL, utils.packStringId(SID_SUI_PAY_ACCESS_FEE_TITLE), sui.OK_CANCEL, "handleTurnstilePay");
}

messageHandler handleTurnstilePay()
{
	int btn = sui.getIntButtonPressed( params );
	if ( btn == sui.BP_CANCEL )
	{
		utils.removeScriptVar( self, "turnstile.queryTurnstile" );
		obj_id building = utils.getObjIdScriptVar( self, "turnstile.structure" );

		return SCRIPT_CONTINUE;
	}

	obj_id building = utils.getObjIdScriptVar( self, "turnstile.structure" );

	if(!isIdValid(building)) {

		utils.removeScriptVar(self, "turnstile.queryTurnstile");
		utils.removeScriptVar(self, "turnstile.structure");

		return SCRIPT_CONTINUE;
	}

	int fee = turnstile.getFee( building );
	utils.removeScriptVar( self, "turnstile.structure");

	obj_id bowner = player_structure.getStructureOwnerObjId( building );

	dictionary d = new dictionary();
	d.put( "building", building );
 	d.put( money.DICT_MSG_PAYER, 1 );
 	d.put( money.DICT_TARGET_NAME, player_structure.getStructureOwner( building ) );
	money.requestPayment( self, bowner, fee, "attemptedPayment", d, true );

	return SCRIPT_CONTINUE;
}

messageHandler attemptedPayment()
{
	if ( (params == null) || (params.isEmpty()) )
	{
		utils.removeScriptVar( self, "turnstile.queryTurnstile");
		return SCRIPT_CONTINUE;
	}

	int retCode = money.getReturnCode(params);
	if ( retCode != money.RET_SUCCESS )
	{
		obj_id payer = params.getObjId( money.DICT_PLAYER_ID );
		messageTo( payer, "handleTurnstilePayFail", null, 0.f, false );
		return SCRIPT_CONTINUE;
	}

	obj_id player = params.getObjId(money.DICT_PLAYER_ID);
	if ( !isIdValid(player) || !isPlayer(player) )
	{
		utils.removeScriptVar( self, "turnstile.queryTurnstile");
		return SCRIPT_CONTINUE;
	}

	obj_id structure = params.getObjId( "building" );
	turnstile.addPatron( structure, player );

	utils.removeScriptVar( self, "turnstile.queryTurnstile");

	int length = turnstile.getTime( structure ) / 60;

	string str = "You may now access the building for "+ length + " minutes.";
	sendSystemMessage( self, str, null );

	return SCRIPT_CONTINUE;
}

messageHandler handleVendorDestroy()
{
	int usedSlots = getIntObjVar(self, "used_vendor_slots") - 1;
	setObjVar(self, "used_vendor_slots", usedSlots);

	LOG("vendor","handleVendorDestroy checking for key");

	if((params == null) || (params.isEmpty()))
		return SCRIPT_OVERRIDE;

	if(params.containsKey("isSpecialVendor"))
	{
		LOG("vendor","handleVendorDestroy HAS key");

		obj_id vendor = params.getObjId("vendor");
		if(vendor == null || vendor.equals(""))
			return SCRIPT_OVERRIDE;

		boolean isSpecialVendor = params.getBoolean("isSpecialVendor");
		boolean canBeIncremented = params.getBoolean("canBeIncremented");
		location destroyLocation = params.getLocation("destroyLocation");
		if(destroyLocation == null)
			return SCRIPT_OVERRIDE;

		location topContainerLocation = params.getLocation("topContainerLocation");
		if(destroyLocation == null)
			return SCRIPT_OVERRIDE;

		obj_id topContainer = params.getObjId("topContainer");
		if(!isValidId(topContainer))
			return SCRIPT_OVERRIDE;

		string vendorTemplate = params.getString("vendorTemplate");
		if(vendorTemplate == null || vendorTemplate.equals(""))
			return SCRIPT_OVERRIDE;

		CustomerServiceLog("vendor", "Player: " + self + " " + getName(self) + " has been notified of Vendor: " + vendor + " Template Name: " +vendorTemplate+ " being destroyed in container: " + topContainer + " at container location: " + topContainerLocation + ". Cell location when destroyed: " + destroyLocation);

		//if we are not a special vendor no need to continue
		if(!isSpecialVendor || !canBeIncremented)
			return SCRIPT_OVERRIDE;

		CustomerServiceLog("vendor", "Player: " + self + " " + getName(self) + " has been notified of Vendor: " + vendor + " Template Name: " +vendorTemplate+ ". This has been identified as a TCG SPECIAL VENDOR. The vendor system is attempting to reimburse the player for the destroyed TCG Special Vendor.");

		string skillMod = params.getString("skillMod");
		int skillModCurrentAmount = params.getInt("skillModCurrentAmount");

		if(skillMod == null || skillMod.equals(""))
		{
			CustomerServiceLog("vendor", "A TCG Special Vendor was destroyed but the skill mod that needed to be reimbursed to the owner was invalid. Owner: " + self + " Vendor: " + vendor + " Template Name: " +vendorTemplate+ " Location of the vendor when destroyed: " + destroyLocation);
			return SCRIPT_OVERRIDE;
		}

		if(skillModCurrentAmount > 0)
		{
			CustomerServiceLog("vendor", "A TCG Special Vendor: " + vendor + " Template Name: " +vendorTemplate+ " had skill mod: " + skillMod + " but the Owner: " + self + " COULD NOT BE REIMBURSED because that skillmod value was less than 0. Location of the vendor when destroyed: " + destroyLocation);
			return SCRIPT_OVERRIDE;
		}

		applySkillStatisticModifier(self, skillMod, 1);
		CustomerServiceLog("vendor", "A TCG Special Vendor: " + vendor + " Template Name: " +vendorTemplate+ " had skill mod: " + skillMod + " that was reimbursed to the Owner: " + self + ". Skill mod incremented by 1.  Location of the vendor when destroyed: " + destroyLocation);
	}
	return SCRIPT_OVERRIDE;
}

messageHandler handleHoloTimeout()
{
	if ( params == null )
 	{
 		return SCRIPT_OVERRIDE;
	}

 	if (!utils.hasScriptVar(self, "holoMessageTime"))
 	{
 		return SCRIPT_OVERRIDE;
 	}

 	int messageTimeId = params.getInt("holoMessageTime");

 	int actorMessageTime = utils.getIntScriptVar(self, "holoMessageTime");

 	if (messageTimeId != actorMessageTime)
 	{
 		return SCRIPT_OVERRIDE;
 	}

 	performance.holographicCleanup(self);
 	return SCRIPT_CONTINUE;
}

messageHandler handlePerformanceBreach()
{
	if (!utils.hasScriptVar(self, "holoMessageTime"))
	{
		return SCRIPT_OVERRIDE;
 	}
	performance.holographicCleanup(self);
	return SCRIPT_CONTINUE;
}

trigger OnRemovingFromWorld()
{
	if (utils.hasScriptVar(self, "holoMessageTime"))
	{
		performance.holographicCleanup(self);
	}

	obj_id[] enemies = getWhoIsTargetingMe( self );
	if ( enemies == null || enemies.length == 0 )
		return SCRIPT_CONTINUE;

	for ( int i = 0; i < enemies.length; i++ )
	{
		if ( isIdValid(enemies[i]) && !isPlayer( enemies[i] ))
		{
			setMentalStateToward( enemies[i], self, FEAR, 0.0f );
			setMentalStateToward( enemies[i], self, ANGER, 0.0f );
		}
	}
	return SCRIPT_CONTINUE;
}

// Handle auction fees.
trigger OnRequestAuctionFee( obj_id who, obj_id bazaar, obj_id item, boolean premium, modifiable_int amount )
{
	session.logActivity(who, session.ACTIVITY_ACCESS_BAZAAR);
	// Is this a vendor?
	if ( hasCondition( bazaar, CONDITION_VENDOR ) )
	{
		amount.set( 0 );
		return SCRIPT_CONTINUE;
	}

	// Set up our base fees.
	int baseFee = 20;
	if ( premium )
		baseFee = 100;

	// Check to see what skills we have.
	if ( hasCommand( self, "merchant_fees_1" ) )
		baseFee *= 0.6;
	else if ( utils.isProfession( self, utils.TRADER ) )
		baseFee *= 0.8;

	// Notify the player.
	prose_package pp = prose.getPackage( SID_SALE_FEE, baseFee );
	sendSystemMessageProse( self, pp );

	// Set it.
	amount.set( baseFee );

	// Log it.
	logBalance( "auctionFee;" + who + ";" + bazaar + ";" + baseFee );

    return SCRIPT_CONTINUE;
}

/***** MESSAGEHANDLERS *************************************************/
messageHandler handleSUI()
{
	boolean doMsg = true;

	int pid = params.getInt("pageId");
	string basePath = "sui." + pid;

	string handlerPath = basePath + ".handler";
	string handler = utils.getStringScriptVar(self, handlerPath);
	if ( (handler == null) || (handler.equals("")) || (handler.equals("noHandler")) )
	{
		doMsg = false;
	}

	string ownerPath = basePath + ".owner";
	obj_id owner = utils.getObjIdScriptVar(self, ownerPath);
	if ( !isIdValid(owner) )
	{
		doMsg = false;
	}

	utils.removeScriptVar(self, handlerPath);
	utils.removeScriptVar(self, ownerPath);

	if ( doMsg )
	{
		messageTo(owner, handler, params, 0, false);
	}

	return SCRIPT_CONTINUE;
}

//********* REMOTE UTILITY MESSAGEHANDLERS *****************************
messageHandler handleAttachScript()
{
 if ( params == null )
 	return SCRIPT_OVERRIDE;

 string scriptName = params.getString(pclib.DICT_SCRIPT_NAME);
 if ( attachScript(self, scriptName) == SCRIPT_CONTINUE )
  	return SCRIPT_CONTINUE;

 return SCRIPT_OVERRIDE;
}

messageHandler handleDetachScript()
{
 if ( params == null )
 	return SCRIPT_OVERRIDE;

 string scriptName = params.getString(pclib.DICT_SCRIPT_NAME);
 if ( detachScript(self, scriptName) )
  	return SCRIPT_CONTINUE;

 return SCRIPT_OVERRIDE;
}

messageHandler handleRemoveObjVar()
{
 if ( params == null )
 	return SCRIPT_OVERRIDE;


 string objVarName = params.getString(pclib.DICT_OBJVAR_NAME);
 removeObjVar(self, objVarName);

 //debugSpeakMsg(self, "received remove objvar msg for objvar " + objVarName);
 return SCRIPT_CONTINUE;
}

messageHandler handleGrantXp()
{
 if ( params == null )
 	return SCRIPT_OVERRIDE;

 string xpType = params.getString(pclib.DICT_XP_TYPE);
 int xpAmount = params.getInt(pclib.DICT_XP_AMOUNT);

 xp.grant(self, xpType, xpAmount, false);
 return SCRIPT_CONTINUE;
}

commandHandler bm_collect_dna()
{
	if(!beast_lib.isBeastMaster(self))
	{
		sendSystemMessage(self, SID_DNA_ONLY_BEAST_MASTER);
		return SCRIPT_OVERRIDE;
	}

	obj_id player = self;
	obj_id intendedTarget = getIntendedTarget(player);
	obj_id lookAtTarget = getLookAtTarget(player);

	if(isInTutorialArea(player))
	{
		sendSystemMessage(player, SID_DNA_NOT_IN_TUTORIAL);
		return SCRIPT_OVERRIDE;
	}

	if(isIdValid(lookAtTarget))
	{
		target = lookAtTarget;
	}
	else
	{
		target = intendedTarget;
	}

	if ( !isIdValid(target) )
	{
		sendSystemMessage(player, incubator.SID_DNA_INVALID_TARGET);
		return SCRIPT_OVERRIDE;
	}

	//distance check
	location playerLoc = getLocation(player);
	location targetLoc = getLocation(target);

	//float distance = utils.getDistance2D(playerLoc, targetLoc);
	float distance = getDistance(playerLoc, targetLoc);

	if(distance > 7.0f)
	{
		sendSystemMessage(player, SID_DNA_TOO_FAR);
		return SCRIPT_OVERRIDE;
	}

	if(isPlayer(target))
	{
		sendSystemMessage(player, incubator.SID_DNA_INVALID_TARGET);
		return SCRIPT_OVERRIDE;
	}

	//check to see if this creature has already been sampled. If so, you cant sample it.
	if(utils.hasScriptVar(target, incubator.DNA_BEEN_SAMPLED_SCRIPTVAR))
	{
		sendSystemMessage(player, incubator.SID_DNA_ALREADY_BEEN_SAMPLED);
		return SCRIPT_OVERRIDE;
	}

	obj_id playerCurrentMount = getMountId (player);
	if(vehicle.isVehicle(target))
	{
		sendSystemMessage(player, incubator.SID_DNA_NO_ALLOW_COLLECT);
		return SCRIPT_OVERRIDE;
	}
	if(isIdValid(playerCurrentMount))
	{
		sendSystemMessage(player, incubator.SID_DNA_CANT_COLLECT_MOUNTED);
		return SCRIPT_OVERRIDE;
	}

	if(pet_lib.isPet(target) || beast_lib.isBeast(target))
	{
		sendSystemMessage(player, incubator.SID_DNA_CANT_COLLECT);
		return SCRIPT_OVERRIDE;
	}

	if(!isMob(target) || hasObjVar(target, "storytellerid"))
	{
		sendSystemMessage(player, incubator.SID_DNA_INVALID_TARGET);
		return SCRIPT_OVERRIDE;
	}

	if (!ai_lib.isInCombat(target))
	{
		string mobType = ai_lib.getCreatureName(target);
		if( mobType == null || mobType.length() < 1)
		{
			string err = "WARNING: player_utility::bm_collect_dna(" + target + ") returning false because getCreatureName failed. Template=" + getTemplateName(target) + ", IsAuthoritative=" + target.isAuthoritative() + ". Stack Trace as follows:";
			CustomerServiceLog("creatureNameErrors", err);
			debugServerConsoleMsg(target, err);
			Thread.dumpStack();

			return SCRIPT_CONTINUE;
		}
		int niche = ai_lib.aiGetNiche(mobType);

		if(niche == NICHE_MONSTER   || niche == NICHE_HERBIVORE || niche == NICHE_CARNIVORE || niche == NICHE_PREDATOR)
		{
			obj_id dnaCore = incubator.extractDna(player, target);

			if(!isIdValid(dnaCore))
			{
				//dna didnt get created.
				return SCRIPT_CONTINUE;
			}
			setObjVar(dnaCore, incubator.DNA_PARENT_TEMPLATE, mobType);
			string name = getName(target);
			if(name != null && !name.equals(""))
				setObjVar(dnaCore, incubator.DNA_PARENT_TEMPLATE_NAME, name);
			return SCRIPT_CONTINUE;
		}

	}
	else
	{
		sendSystemMessage(player, incubator.SID_DNA_CANT_IN_COMBAT);
		return SCRIPT_OVERRIDE;
	}
	sendSystemMessage(player, incubator.SID_DNA_INVALID_TARGET);
	return SCRIPT_OVERRIDE;
}

commandHandler forage()
{
	//get player location
	location curLoc = getLocation(self);

	if(isIdValid(curLoc.cell))
	{
		string_id notIndoors = new string_id("player/player_utility", "forage_not_indoors");
		sendSystemMessage(self, notIndoors);
		return SCRIPT_OVERRIDE;
	}
	else if(isIdValid(getStandingOn(self)))
	{
		string_id onlyInWorld = new string_id("player/player_utility", "forage_on_ground");
		sendSystemMessage(self, onlyInWorld);
		return SCRIPT_OVERRIDE;
	}
	else if(locations.isInCity(curLoc))
	{
		sendSystemMessage(self, SID_NOT_IN_CITY);
		return SCRIPT_OVERRIDE;
	}

	//check to see if this is the same location that we just attempted to forage
	if(utils.hasScriptVar(self, "forage.lastLocation"))
	{
		location lastLoc = utils.getLocationScriptVar(self, "forage.lastLocation");

		if(!lastLoc.area.equals(curLoc.area))
		{
			utils.removeScriptVarTree(self, "forage");
		}
		else
		{
			float distance = getDistance(lastLoc, curLoc);

			// It is possible, prior to this fix, to forage indoors.  This causes a bad distance check.
			if(isIdValid(lastLoc.cell))
			{
				distance = 5.0f;
			}

			//has to be at least 5m from last time
			if(distance < 5.0f)
			{
				string_id tooClose = new string_id("player/player_utility","forage_too_close");
				sendSystemMessage(self, tooClose);
				return SCRIPT_OVERRIDE;
			}

			//check to see if we have already gotten something from this location
			if(utils.hasScriptVar(self, "forage.listOfAlreadyForagedLocs"))
			{
				location[] oldListOfLocs = utils.getLocationArrayScriptVar(self, "forage.listOfAlreadyForagedLocs");

				if(oldListOfLocs.length > 20)
				{
					//list is farily long now, we should clean it up so we dont have any issues
					utils.removeScriptVar(self, "forage.listOfAlreadyForagedLocs");
				}

				for(int i = 0; i < oldListOfLocs.length; ++i)
				{
					if(isIdValid(oldListOfLocs[i].cell))
					{
						distance = 5.0f;
					}
					else
					{
						distance = getDistance(curLoc, oldListOfLocs[i]);
					}

					//has to be at least 5m from a previous successfull location
					if(distance < 5.0f)
					{
						string_id tooClose = new string_id("player/player_utility", "forage_already_done_here");
						sendSystemMessage(self, tooClose);
						return SCRIPT_OVERRIDE;
					}
				}
			}
		}
	}

	//pass initial checks, do animation
	doAnimationAction(self, "forage");
	//delay resolution for 2 seconds
	messageTo(self, "handlerForPlayerForaging", null, 2.0f, false); //for the sake slowing the foraging process for animation
	return SCRIPT_CONTINUE;
}

//--------------------------------
// FORAGING
//--------------------------------
messageHandler handlerForPlayerForaging()
{
	if(!loot.playerForaging(self))
		CustomerServiceLog( "foraging", "Foraging failed for Player: " + self + " " + getName(self));

	//the core foraging functionality is now in the loot library
	return SCRIPT_CONTINUE;
}

//--------------------------------
// Temporary Appearance Item Effect Removal
//--------------------------------
messageHandler removeAppearanceItemEffect()
{

	obj_id allAppearanceItems[] = getAllItemsFromAppearanceInventory(self);
	if(allAppearanceItems == null || allAppearanceItems.length <= 0)
		return SCRIPT_CONTINUE;

	for(int i = 0; i < allAppearanceItems.length; i++)
	{
		if(!hasObjVar(allAppearanceItems[i], NON_ENHANCEMENT_BUFF))
			continue;

		static_item.removeWornBuffs(allAppearanceItems[i], self);
		static_item.checkForRemoveSetBonus(allAppearanceItems[i], self);
	}

	return SCRIPT_CONTINUE;
}

//--------------------------------
// Replay the Appearance Item Effect
//--------------------------------
messageHandler addAppearanceItemEffect()
{
	obj_id allAppearanceItems[] = getAllItemsFromAppearanceInventory(self);
	if(allAppearanceItems == null || allAppearanceItems.length <= 0)
		return SCRIPT_CONTINUE;

	for(int i = 0; i < allAppearanceItems.length; i++)
	{
		if(!hasObjVar(allAppearanceItems[i], NON_ENHANCEMENT_BUFF))
			continue;

		static_item.applyWornBuffs(allAppearanceItems[i], self);
		static_item.checkForAddSetBonus(allAppearanceItems[i], self);
	}

	return SCRIPT_CONTINUE;
}

//********* COMMAND /PATHTOLOCATION *****************************
commandHandler cmdPathToLocation()
{
	if ( (params == null) || (params.equals("")) )
	{
		return SCRIPT_OVERRIDE;
	}

	java.util.StringTokenizer st = new java.util.StringTokenizer(params, " ,\t");
	int count = st.countTokens();

	// from SwgCuiQuestHelper.cpp
	// x y z cell_id
	if (count < 4)
	{
		return SCRIPT_OVERRIDE;
	}

	float x = Float.parseFloat(st.nextToken());
	float y = Float.parseFloat(st.nextToken());
	float z = Float.parseFloat(st.nextToken());

	obj_id cell_id = obj_id.getObjId(java.lang.Long.parseLong(st.nextToken()));

	string planet = getCurrentSceneName();

	location destination = new location(x, y, z, planet, cell_id);

	if (isGod(self))
	{
		sendSystemMessageTestingOnly(self, "pathToLocation " + params);
		sendSystemMessageTestingOnly(self, "  scene=" + destination.area);
		sendSystemMessageTestingOnly(self, "  cell=" + getCellName(destination.cell));
	}

	createClientPathAdvanced(self, getLocation(self), destination, "default");

	return SCRIPT_CONTINUE;
}

commandHandler cmdPathClear()
{
	destroyClientPath	(self);
	return SCRIPT_CONTINUE;
}

//********* COMMAND /FIND *****************************
commandHandler cmdFind()
{
	LOG("find", "******************* cmdFind: " + getGameTime() + " ******************");
	LOG("find", "params = " + params);

	if ( (params == null) || (params.equals("")) )
	{
		planetary_map.showFindSui();
		return SCRIPT_CONTINUE;
	}

	dictionary holocronParams = new dictionary();
	holocronParams.put ("eventName","find");
	messageTo(self, "handleHolocronEvent", holocronParams, 0, false);

	params = toLower(params);
	LOG("find", "toLower(params) = " + params);

	if ( params.equals("clear") )
	{
		clearFindData(self);
		sendSystemMessage(self, SID_WAYPOINT_AND_DATA_CLEARED);
		return SCRIPT_CONTINUE;
	}

	string originalParams = params;

	//strip spaces
	if ( params.indexOf(" ") > -1 )
	{
		java.util.StringTokenizer tmpSt = new java.util.StringTokenizer(params);
		params = "";
		while ( tmpSt.hasMoreTokens() )
		{
			params += tmpSt.nextToken();
		}
	}

	string cat = "";
	string sub = "";
	java.util.StringTokenizer st = new java.util.StringTokenizer(params, ":");
	int tCnt = st.countTokens();
	LOG("find", "params token count = " + tCnt);

	cat = st.nextToken();
	if ( st.hasMoreTokens() )
	{
		sub = cat + "_" + st.nextToken();
	}

	int uidx = cat.indexOf("_");
	if ( sub.equals("") && uidx > -1 )
	{
		sub = cat;
		cat = cat.substring(0, uidx);
	}

	LOG("find","pre-expansion: cat = " + cat + " sub = " + sub);

	string[] catList = dataTableGetStringColumnNoDefaults("datatables/player/planet_map_cat.iff","name");
	if ( (catList != null) && (catList.length > 0) )
	{
		for ( int i = 0; i < catList.length; i++ )
		{
			if ( catList[i].equals(cat) )
			{
				break;
			}
			else if ( catList[i].startsWith(cat) )
			{
				cat = catList[i];
				break;
			}
		}

		if ( (sub != null) && (!sub.equals("")) )
		{
			for ( int i = 0; i < catList.length; i++ )
			{
				if ( catList[i].equals(sub) )
				{
					break;
				}
				else if ( catList[i].startsWith(sub) )
				{
					sub = catList[i];
					break;
				}
			}
		}
	}

	LOG("find","expanded: cat = " + cat + " sub = " + sub);

	if ( (cat != null) && (!cat.equals("")) && (sub != null) )	//its ok if sub.equals("")
	{
		location here = getWorldLocation(self);
		string planet = getCurrentSceneName();

		map_location[] map_locs = getPlanetaryMapLocations(cat, sub);
		if ( (map_locs == null) || (map_locs.length == 0) )
		{
			if ( sub == null || sub.equals("") )
			{
				string[] subCats = getPlanetaryMapCategories(cat);
				if ( subCats == null || (subCats.length == 0) )
				{
					prose_package unfound = prose.getPackage(PROSE_FIND_UNFOUND, originalParams);
					sendSystemMessageProse(self, unfound);
					return SCRIPT_CONTINUE;
				}

				resizeable map_location[] subLocs = new map_location[0];
				for ( int x = 0; x < subCats.length; x++ )
				{
					map_location[] tmpLocs = getPlanetaryMapLocations(cat, subCats[x]);
					if ( (tmpLocs != null) || (tmpLocs.length > 0) )
					{
						subLocs.addAll(Arrays.asList(tmpLocs));
					}
				}

				if ( subLocs == null || subLocs.length == 0 )
				{
					prose_package unfound = prose.getPackage(PROSE_FIND_UNFOUND, originalParams);
					sendSystemMessageProse(self, unfound);
					return SCRIPT_CONTINUE;
				}

				map_location[] toUse = new map_location[subLocs.size()];
				subLocs.toArray(toUse);

				map_locs = toUse;
			}
		}

		float min = Float.POSITIVE_INFINITY;
		int locIdx = -1;

		float x = 0f;
		float z = 0f;
		location there = new location();

		for ( int n = 0; n < map_locs.length; n++ )
		{
			x = (float)(map_locs[n].getX());
			z = (float)(map_locs[n].getY());

			location tmpLoc = new location(x, 0, z);

			float dist = utils.getDistance2D(here, tmpLoc);
			if ( dist < min )
			{
				min = dist;
				locIdx = n;
				there = tmpLoc;
			}
		}

		if ( locIdx > -1 )
		{
			obj_id myTarget = map_locs[locIdx].getLocationId();
			if ( isIdValid(myTarget) )
			{
				clearFindData(self);

				obj_id wp = createWaypointInDatapad(self, there);
				if ( isIdValid(wp)  )
				{
					setWaypointActive(wp, true);
					setWaypointVisible(wp, true);

					string locName = map_locs[locIdx].getLocationName();
					string_id sidLocName = utils.unpackString(locName);
					if ( sidLocName != null )
						locName = getString(sidLocName);

					string locType = params;

					string locCat = "@map_loc_cat_n:" + map_locs[locIdx].getCategory();
					string_id sidLocCat = utils.unpackString(locCat);
					if ( sidLocCat != null )
						locCat = getString(sidLocCat);

					if ( locCat != null && !locCat.equals("") )
						locType = locCat;

					string locSub = map_locs[locIdx].getSubCategory();
					if ( locSub != null && !locSub.equals("") )
					{
						locSub = "@map_loc_cat_n:" + locSub;
						string_id sidLocSub = utils.unpackString(locSub);
						if ( sidLocSub != null )
							locSub = getString(sidLocSub);

						if ( locSub != null && !locSub.equals("") )
							locType += ":" + locSub;
					}

					setWaypointName(wp, locName + " (" + locType + ")");

					utils.setScriptVar(self, VAR_FIND_WAYPOINT, wp);
					string_id parsedParams = null;
					if ( sub == null || sub.equals("") )
					{
						parsedParams = new string_id("find_display", cat);
					}
					else
					{
						parsedParams = new string_id("find_display", sub);
					}

					if ( parsedParams != null )
					{
						prose_package findSetParsed = prose.getPackage(PROSE_FIND_SET, parsedParams);
						sendSystemMessageProse(self, findSetParsed);
					}
					else
					{
						prose_package findSet = prose.getPackage(PROSE_FIND_SET, originalParams);
						sendSystemMessageProse(self, findSet);
					}

					there = new location(map_locs[locIdx].getX(), 0, map_locs[locIdx].getY());

					region[] hereCity = getRegionsWithGeographicalAtPoint(here, regions.GEO_CITY);
					region[] thereCity = getRegionsWithGeographicalAtPoint(there, regions.GEO_CITY);
					if ( hereCity != null && hereCity.length > 0 && thereCity != null && thereCity.length > 0 )
					{
						boolean areInSameCity = false;
						for ( int a = 0; a < hereCity.length; a++ )
						{
							for ( int b = 0; b < thereCity.length; b++ )
							{
								if ( (hereCity[a].getName()).equals(thereCity[b].getName()) )
								{
									areInSameCity = true;
									break;
								}
							}

							if ( areInSameCity )
								break;
						}

						if ( areInSameCity )
						{
							there.y = getHeightAtLocation(there.x, there.z);

							location start = getLocation(self);
							if ( isIdValid(start.cell) )
								start = getBuildingEjectLocation(getTopMostContainer(self));

							location destination = there;

							obj_id tId = map_locs[locIdx].getLocationId();
							if ( isIdValid(tId) && tId.isLoaded() )
							{
								location cLoc = getLocation(tId);
								if ( isIdValid(cLoc.cell) )
								{
									obj_id topMost = getTopMostContainer(tId);
									if ( isIdValid(topMost) && tId.isLoaded() )
										destination = getBuildingEjectLocation(topMost);
								}
							}

							if ( destination == null )
								destination = there;

							//debugSpeakMsg(self, "Attempting to create client path...");
							if ( !createClientPath(self, start, destination) )
							{
								sendSystemMessage(self, SID_UNABLE_TO_CREATE_PATH);
							}
							else
							{
								if ( here.cell != start.cell )
									sendSystemMessage(self, SID_FIND_PATH_STARTED);

								utils.setScriptVar(self, "hasClientPath", wp);
							}
						}
					}

					return SCRIPT_CONTINUE;
				}
			}
			else
			{
				LOG("find","invalid target attached to planet map location??");
			}
		}
		else
		{
			LOG("find","unable to determine valid PM index for request...");
		}
	}
	else
	{
		prose_package unfound = prose.getPackage(PROSE_FIND_UNKNOWN_ARG, originalParams);
		sendSystemMessageProse(self, unfound);
		return SCRIPT_CONTINUE;
	}

	sendSystemMessage(self, SID_FIND_GENERAL_ERROR);
	return SCRIPT_CONTINUE;
}

void clearFindData(obj_id self)
{
	if ( utils.hasScriptVar(self, VAR_FIND_WAYPOINT) )
	{
		obj_id wp = utils.getObjIdScriptVar(self, VAR_FIND_WAYPOINT);
		utils.removeScriptVar(self, VAR_FIND_WAYPOINT);
		destroyWaypointInDatapad(wp, self);
	}

	destroyClientPath(self);
	utils.removeScriptVar(self, "hasClientPath");
}

messageHandler handleFindSui()
{
	int bp = sui.getIntButtonPressed(params);
	if ( bp == sui.BP_CANCEL )
	{
		return SCRIPT_CONTINUE;
	}

	int row = sui.getListboxSelectedRow(params);
	if ( row == -1 )
	{
		return SCRIPT_CONTINUE;
	}

	LOG("find","handleFindSui: selrow = " + row);

	string[] args = utils.getStringBatchScriptVar(self, planetary_map.SCRIPTVAR_FIND_PARAMS);
	if ( (args == null) || (args.length == 0) )
		return SCRIPT_CONTINUE;

	string arg = args[row];
	if ( (arg == null) || (arg.equals("")) )
	{
		return SCRIPT_CONTINUE;
	}

	queueCommand(self, ##"find", null, arg, COMMAND_PRIORITY_DEFAULT);
	return SCRIPT_CONTINUE;
}

messageHandler handleDelayedSystemMessage()
{
	if ( params == null || params.isEmpty() )
		return SCRIPT_CONTINUE;

	string_id sid = params.getStringId("sidMsg");
	if ( sid != null )
	{
		sendSystemMessage(self, sid);
		return SCRIPT_CONTINUE;
	}

	string msg = params.getString("stringMsg");
	if ( msg != null && !msg.equals("") )
	{
		sendSystemMessageTestingOnly(self, msg);
		return SCRIPT_CONTINUE;
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleDelayedProseMessage()
{
	if ( params == null || params.isEmpty() )
		return SCRIPT_CONTINUE;

	string_id sid = params.getStringId("sid");

	obj_id actor = params.getObjId("actor");
	string actorString = params.getString("actorString");
	string_id actorStringId = params.getStringId("actorStringId");

	obj_id target = params.getObjId("target");
	string targetString = params.getString("targetString");
	string_id targetStringId = params.getStringId("targetStringId");

	obj_id other = params.getObjId("other");
	string otherString = params.getString("otherString");
	string_id otherStringId = params.getStringId("otherStringId");

	int di = params.getInt("di");
	float df = params.getFloat("df");

	prose_package pp =  prose.getPackage(sid, actor,  actorString,  actorStringId,
											target, targetString, targetStringId,
											other,  otherString,  otherStringId,
											di, df);

	sendSystemMessageProse(self, pp);
	return SCRIPT_CONTINUE;
}

messageHandler handleDivorce()
{
	if ( params == null || params.isEmpty() )
		return SCRIPT_CONTINUE;

	obj_id sender = params.getObjId("self");
	obj_id spouse = getObjIdObjVar(self, marriage.VAR_SPOUSE_ID);
	if ( !isIdValid(sender) || !isIdValid(spouse) || (sender != spouse) )
		return SCRIPT_CONTINUE;

	marriage.endUnity(self);
	return SCRIPT_CONTINUE;
}

messageHandler handleWaypointDestroyRequest()
{
	obj_id wp = params.getObjId("wp");
	if ( isIdValid(wp) && exists(wp) && wp.isLoaded() )
		destroyWaypointInDatapad(wp, self);

	return SCRIPT_CONTINUE;
}

messageHandler handleWaypointRenameRequest()
{
	obj_id wp = params.getObjId("wp");
	if ( !isIdValid(wp) || !exists(wp) || !wp.isLoaded() )
		return SCRIPT_CONTINUE;

	string name = params.getString("name");
	if ( name == null || name.equals("") )
		return SCRIPT_CONTINUE;

	if ( !utils.isNestedWithin(wp, self))
		return SCRIPT_CONTINUE;

	setWaypointName(wp, name);
	return SCRIPT_CONTINUE;
}

messageHandler handleVendorPayment()
{
	if ( params == null )
		return SCRIPT_CONTINUE;

	obj_id player = params.getObjId( money.DICT_PLAYER_ID );
	obj_id target = params.getObjId( money.DICT_TARGET_ID );
	int amt = params.getInt( money.DICT_AMOUNT );
	int code = params.getInt( money.DICT_CODE );
	if ( code == money.RET_SUCCESS )
	{
		CustomerServiceLog( "vendor", "Vendor maintenance deposit.  Player: " + player + " Vendor " + target + " Amount: " + amt );
		prose_package pp = prose.getPackage( SID_VENDOR_PAY, target, amt );
		sendSystemMessageProse( player, pp );
	}

	return SCRIPT_CONTINUE;
}

messageHandler displayCityUpdateTime()
{
	string time_remaining = params.getString( "time_remaining" );
	prose_package pp = prose.getPackage( SID_CITY_UPDATE_ETA, time_remaining );
	sendSystemMessageProse( self, pp );

	return SCRIPT_CONTINUE;
}

messageHandler handleSurveyDroidReport()
{
	obj_id[] resourceIdList = params.getObjIdArray("resourceList");
	string planetName = params.getString("planetName");
	string resourceClass = params.getString("resourceClass");

	string[] resourceList = pclib.buildSortedResourceList(resourceIdList, resourceClass, 0);

	string subject = "Interplanetary Survey: "+toUpper(planetName, 0)+" - "+pclib.getClassString(resourceClass);
	string report = pclib.createResourcePlanetReport(resourceList, planetName, resourceClass);

	chatSendPersistentMessage("Interplanetary Survey Droid", getName(self), subject, report, null);

	return SCRIPT_CONTINUE;
}

//buff for players testing BH vs Jedi on TC2 ONLY!!!!!
void createBuffs(obj_id player)
{
	if(!hasAttribModifier(player, "TC2 - BUFFS (Health)"))
	{
		addAttribModifier(player, "TC2 - BUFFS (Health)", HEALTH, 2200, 10800, 0.0f, 10.0f, true, false, true);
		addAttribModifier(player, "TC2 - BUFFS (Const)", CONSTITUTION, 2200, 10800, 0.0f, 10.0f, true, false, true);
		addAttribModifier(player, "TC2 - BUFFS (Action)", ACTION, 2200, 10800, 0.0f, 10.0f, true, false, true);
		addAttribModifier(player, "TC2 - BUFFS (Stam)", STAMINA, 2200, 10800, 0.0f, 10.0f, true, false, true);
	}
	return;
}

//items for players testing BH vs Jedi on TC2 ONLY!!!!
void createNewBHResources(obj_id self)
{
	if(!isIdValid(self))
		return;

	if(hasObjVar(self, "jediTest.bounty_hunter_kit"))
		return;

	obj_id pInv = utils.getInventoryContainer(self);

	if (!isIdValid( pInv))
		return;

	createObject("object/tangible/wearables/armor/ris/armor_ris_bicep_l.iff", pInv, "");
	createObject("object/tangible/wearables/armor/ris/armor_ris_bicep_r.iff", pInv, "");
	createObject("object/tangible/wearables/armor/ris/armor_ris_boots.iff", pInv, "");
	createObject("object/tangible/wearables/armor/ris/armor_ris_bracer_l.iff", pInv, "");
	createObject("object/tangible/wearables/armor/ris/armor_ris_bracer_r.iff", pInv, "");
	createObject("object/tangible/wearables/armor/ris/armor_ris_chest_plate.iff", pInv, "");
	createObject("object/tangible/wearables/armor/ris/armor_ris_gloves.iff", pInv, "");
	createObject("object/tangible/wearables/armor/ris/armor_ris_helmet.iff", pInv, "");
	createObject("object/tangible/wearables/armor/ris/armor_ris_leggings.iff", pInv, "");
	createObject("object/tangible/deed/vehicle_deed/landspeeder_av21_deed.iff", pInv, "");
	createObject("object/tangible/deed/vehicle_deed/speederbike_swoop_deed.iff", pInv, "");
	createObject("object/tangible/deed/vehicle_deed/speederbike_swoop_deed.iff", pInv, "");
	createObject("object/tangible/wearables/backpack/backpack_s03.iff", pInv, "");

	obj_id LLC = weapons.createWeapon("object/weapon/ranged/rifle/rifle_lightning.iff", pInv, 0.8f);
	obj_id scatter = weapons.createWeapon("object/weapon/ranged/pistol/pistol_scatter.iff", pInv, 0.8f);
	obj_id laserCarbine = weapons.createWeapon("object/weapon/ranged/carbine/carbine_laser.iff", pInv, 0.8f);
	obj_id dxr6Carbine = weapons.createWeapon("object/weapon/ranged/carbine/carbine_dxr6.iff", pInv, 0.8f);


	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_seeker.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");
	createObject("object/tangible/mission/mission_bounty_droid_probot.iff", pInv, "");

	obj_id hotpants = createObject("object/tangible/wearables/pants/pants_s26.iff", pInv, "");
	{
		if(isIdValid(hotpants)) {

			int color = rand(151, 255);
			custom_var myVar = getCustomVarByName(hotpants, "private/index_color_2");
			if  (myVar.isPalColor())
			{
				palcolor_custom_var pcVar = (palcolor_custom_var)myVar;
				pcVar.setValue(color);
			}
		}
	}

	gm.setBalance(self, money.MT_BANK, "500000");
	setObjVar(self, "jediTest.bounty_hunter_kit", 1);
	return;
}

messageHandler handleTurnstilePayFail()
{
	utils.removeScriptVar( self, "turnstile.queryTurnstile");
	sendSystemMessage( self, new string_id(STF_FILE, "not_enough_money"));
	return SCRIPT_CONTINUE;
}

messageHandler handleGmGrantSkillOptions()
{
	obj_id target = utils.getObjIdScriptVar(self, "gmGrantSkill.target");

	if(!isIdValid(target))
	{
		sendSystemMessageTestingOnly(self, "Target is no longer valid.");
		utils.removeScriptVarTree(self, "gmGrantSkill");
		return SCRIPT_CONTINUE;
	}

	int btn = sui.getIntButtonPressed(params);
	int idx = sui.getListboxSelectedRow(params);

	if(btn == sui.BP_CANCEL)
	{
		utils.removeScriptVarTree(self, "gmGrantSkill");
		return SCRIPT_CONTINUE;
	}

	if(idx == -1)
	{
		utils.removeScriptVarTree(self, "gmGrantSkill");
		return SCRIPT_CONTINUE;
	}

	switch(idx)
	{
		case 0:
			gmGrantSkillRoadmapChoice(self, target);
			break;
		case 1:
			string skillName = getWorkingSkill(target);

			dictionary xpReqs = getSkillPrerequisiteExperience(skillName);
			if (xpReqs == null || xpReqs.isEmpty())
			{
				sendSystemMessageTestingOnly(self, "Player does not have a valid working skill");
				return SCRIPT_CONTINUE;
			}

			java.util.Enumeration e = xpReqs.keys();
			string xpType = (string)(e.nextElement());
			int xpCost = xpReqs.getInt(xpType);
			int curXP = getExperiencePoints(target, xpType);
			if ( curXP < xpCost )
			{
				grantExperiencePoints(target, xpType, xpCost - curXP);
			}
			skill_template.earnWorkingSkill(target);
			redisplayGrantSkillSui(self, target);
			break;
		case 2:
			string template = getSkillTemplate(target);
			gmGrantSkillRoadmapProgression(self, target, template);
			break;

		default:
			utils.removeScriptVarTree(self, "gmGrantSkill");
			return SCRIPT_CONTINUE;
	}

	return SCRIPT_CONTINUE;
}

void redisplayGrantSkillSui(obj_id self, obj_id target)
{
	utils.setScriptVar(self, "gmGrantSkill.target", target);

	string prompt = "You are attempting to modify the skills for \\#pcontrast3 " + getName(target) + "\\#..\n\n";
	prompt += "Please choose an option:";

	int pid = sui.listbox(self, self, prompt, sui.OK_CANCEL, "GM GRANT SKILL", gm.ROADMAP_SKILL_OPTIONS, "handleGmGrantSkillOptions", true, false);
}

void gmGrantSkillRoadmapChoice(obj_id self, obj_id target)
{
	string[] roadmapList = gm.getRoadmapList();

	string prompt = "You are attempting to modify the skills for \\#pcontrast3 " + getName(target) + "\\#..\n\n";
	prompt += "Please select a profession roadmap:";

	int pid = sui.listbox(self, self, prompt, sui.OK_CANCEL, "GM GRANT SKILL", gm.convertRoadmapNames(roadmapList), "handleGmGrantSkillRoadmapSelect", true, false);

	utils.setBatchScriptVar(self, "gmGrantSkill.roadmap_list", roadmapList);
	utils.setScriptVar(self, "gmGrantSkill.target", target);
}

messageHandler handleGmGrantSkillRoadmapSelect()
{
	obj_id target = utils.getObjIdScriptVar(self, "gmGrantSkill.target");

	if(!isIdValid(target))
	{
		sendSystemMessageTestingOnly(self, "Target is no longer valid.");
		utils.removeScriptVarTree(self, "gmGrantSkill");
		return SCRIPT_CONTINUE;
	}

	int idx = sui.getListboxSelectedRow(params);
	int btn = sui.getIntButtonPressed(params);

	if(btn == sui.BP_CANCEL)
	{
		utils.removeScriptVarTree(self, "gmGrantSkill");
		redisplayGrantSkillSui(self, target);
		return SCRIPT_CONTINUE;
	}

	if ( idx == -1)
	{
		utils.removeScriptVarTree(self, "gmGrantSkill");
		gmGrantSkillRoadmapChoice(self, target);
		return SCRIPT_CONTINUE;
	}

	if (exists(target))
	{
		string[] roadmapList = utils.getStringBatchScriptVar(self, "gmGrantSkill.roadmap_list");

		gmGrantSkillRoadmapProgression(self, target, roadmapList[idx]);
	}

	return SCRIPT_CONTINUE;
}

void gmGrantSkillRoadmapProgression(obj_id self, obj_id target, string template)
{
	string templateSkills = dataTableGetString(skill_template.TEMPLATE_TABLE, template, "template");
	string[] skillList = split(templateSkills, ',');

	if (skillList == null || skillList.length == 0)
	{
		sendSystemMessageTestingOnly(self, "No skills found for this profession");
		utils.removeScriptVarTree(self, "gmGrantSkill");
		return;
	}
	else
	{
		sendSystemMessageTestingOnly(self, "Revoking all skills and experience for " + getName(target));
		respec.revokeAllSkillsAndExperience(target);
		skill.recalcPlayerPools(target, true);

		if(!template.equals(getSkillTemplate(target)))
			setSkillTemplate(target, template);

		setWorkingSkill(target, skillList[0]);

		utils.setScriptVar(self, "gmGrantSkill.skill_template", template);
		utils.setBatchScriptVar(self, "gmGrantSkill.roadmap_skills", skillList);
	}

	/*
	if(template.startsWith("trader") || template.startsWith("entertainer"))
	{
		string prompt = "You are attempting to modify the skills for \\#pcontrast3 " + getName(target) + "\\#..\n\n";
		prompt += "Please select the working skill in this roadmap:";

		int pid = sui.listbox(self, self, prompt, sui.OK_CANCEL, "GM GRANT SKILL", gm.convertSkillListNames(skillList), "handleGmGrantSkillSkillSelect", true, false);
	}
	else
	{
	*/
		string prompt = "You are attempting to modify the skills for \\#pcontrast3 " + getName(target) + "\\#..\n\n";
		prompt += "Please enter the level for this player:";

		int pid = sui.inputbox(self, self, prompt, "handleGmGrantSkillLevelInput");
	//}
}

messageHandler handleGmGrantSkillSkillSelect()
{
	obj_id target = utils.getObjIdScriptVar(self, "gmGrantSkill.target");

	if(!isIdValid(target))
	{
		sendSystemMessageTestingOnly(self, "Target is no longer valid.");
		utils.removeScriptVarTree(self, "gmGrantSkill");
		return SCRIPT_CONTINUE;
	}

	int idx = sui.getListboxSelectedRow(params);
	int btn = sui.getIntButtonPressed(params);

	if(btn == sui.BP_CANCEL)
	{
		utils.removeScriptVarTree(self, "gmGrantSkill");
		return SCRIPT_CONTINUE;
	}

	string skillTemplate = utils.getStringScriptVar(self, "gmGrantSkill.skill_template");
	if(skillTemplate == null || skillTemplate.equals(""))
	{
		utils.removeScriptVarTree(self, "gmGrantSkill");
		return SCRIPT_CONTINUE;
	}

	if ( idx == -1)
	{
		sendSystemMessageTestingOnly(self, "Please make a selection.");
		gmGrantSkillRoadmapProgression(self, target, skillTemplate);
		return SCRIPT_CONTINUE;
	}

	if (exists(target))
	{
		string[] roadmapSkills = utils.getStringBatchScriptVar(self, "gmGrantSkill.roadmap_skills");

		setWorkingSkill(target, roadmapSkills[0]);

		for (int i = 0; i < idx; i++)
		{
			grantSkill(target, roadmapSkills[i]);
			skill_template.grantRoadmapItem(target);

			setWorkingSkill(target, skill_template.getNextWorkingSkill(target));
		}

		sendSystemMessageTestingOnly(self, "Skill Granting for " + getName(target) + " is complete");
	}

	utils.removeScriptVarTree(self, "gmGrantSkill");

	return SCRIPT_CONTINUE;
}

messageHandler handleGmGrantSkillLevelInput()
{
	obj_id target = utils.getObjIdScriptVar(self, "gmGrantSkill.target");

	if(!isIdValid(target))
	{
		sendSystemMessageTestingOnly(self, "Target is no longer valid.");
		utils.removeScriptVarTree(self, "gmGrantSkill");
		return SCRIPT_CONTINUE;
	}

	string text = sui.getInputBoxText(params);

	int level = utils.stringToInt(text);

	if (level < 1 || level > 90)
	{
		sendSystemMessageTestingOnly(self, "Invalid level entered!");
		return SCRIPT_CONTINUE;
	}
	else
	{
		respec.autoLevelPlayer(target, level, true);
	}

	sendSystemMessageTestingOnly(self, "Skill Granting for " + getName(target) + " is complete");

	utils.removeScriptVarTree(self, "gmGrantSkill");

	return SCRIPT_CONTINUE;
}

commandHandler cmdAutoDeclineDuel()
{
	if(hasObjVar(self, VAR_AUTODECLINE_DUEL))
	{
		removeObjVar(self, VAR_AUTODECLINE_DUEL);
		sendSystemMessage(self, new string_id("spam", "autodecline_duel_off"));
	}
	else
	{
		setObjVar(self, VAR_AUTODECLINE_DUEL, 1);
		sendSystemMessage(self, new string_id("spam", "autodecline_duel_on"));
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleSmugglerGetLocationInfo()
{
	if(params == null || params.isEmpty())
		return SCRIPT_CONTINUE;

	obj_id smuggler = params.getObjId("smuggler");

	if(!isIdValid(smuggler))
		return SCRIPT_CONTINUE;

	location loc = getLocation(self);

	params = new dictionary();
	params.put("location", loc);

	messageTo(smuggler, "handleSmugglerDistanceCheck", params, 1.0f, false);

	return SCRIPT_CONTINUE;
}

messageHandler handleSmugglerDistanceCheck()
{
	if(params == null || params.isEmpty())
		return SCRIPT_CONTINUE;

	location targetLoc = params.getLocation("location");
	location myLoc = getLocation(self);

	string myLocArea = myLoc.area;
	string targetLocArea = targetLoc.area;

	if(targetLoc != null && myLocArea.equals(targetLocArea))
	{
		int distance = (int)getDistance(myLoc, targetLoc);

		if(distance > 1 && distance < 1000)
		{
			prose_package pp = new prose_package ();
			pp.stringId      = new string_id ("bounty_hunter", "sm_bounty_hunter_distance");
			prose.setDI(pp, distance);

			sendSystemMessageProse(self, pp);
		}
	}

	return SCRIPT_CONTINUE;
}

messageHandler channelHeal()
{
	//Message Handler for channeled healing. Currently only used with new crafted stimpacks.
	if(params == null || params.isEmpty())
		return SCRIPT_CONTINUE;

	//gather all variables from dictionary
	obj_id user = params.getObjId("user");
	int tick = params.getInt("tick");
	obj_id item = params.getObjId("item");
	int healPerTick = params.getInt("healPerTick");
	location healLoc = params.getLocation("healLoc");
	int attrib = params.getInt("attrib");
	int pid = utils.getIntScriptVar(self, "channelHeal.suiPid");
	//get players current location
	location currentLoc = getLocation(self);

	prose_package pp = new prose_package();

	//verify that the user is self, this is because this can only be used by the owner
	if(user != self)
	{
		//shouldnt happen, if it did, then the parameters are messed up.
		sendSystemMessage(self, SID_CHANNEL_HEAL_WRONG_USER);
		buff.removeBuff(self, "channel_healing");
		return SCRIPT_CONTINUE;
	}

	if(healLoc != currentLoc)
	{
		//You have moved, end healing
		//pp = prose.setStringId(pp, SID_CHANNEL_HEAL_MOVED);
		//showFlyTextPrivateProseWithFlags(self, self, pp, 1.25f, colors.TOMATO, 0);
		sendSystemMessage(self, SID_CHANNEL_HEAL_MOVED);
		buff.removeBuff(self, "channel_healing");
		return SCRIPT_CONTINUE;
	}

	if(!buff.hasBuff(self, "channel_healing") && tick != 0)
	{
		//You are being attacked, end healing
		//pp = prose.setStringId(pp, SID_CHANNEL_HEAL_IN_COMBAT);
		//showFlyTextPrivateProseWithFlags(self, self, pp, 1.25f, colors.TOMATO, 0);
		sendSystemMessage(self, SID_CHANNEL_HEAL_IN_COMBAT);
		return SCRIPT_CONTINUE;
	}

	//Give chance at a lucky heal
	if(luck.isLucky(self, 0.005f))
	{
		float bonus = healPerTick * 0.2f;
		if(bonus < 1)
			bonus = 1;

		healPerTick += bonus;
	}
	//If this is the first tick, we need to create the countdown timer SUI
	if(tick == 0)
	{
		buff.applyBuff(self, "channel_healing");
	}
	//get health before heal
	int before = getAttrib(self, attrib);
	//heal
	healing.healDamage(self, self, attrib, healPerTick);
	//Get difference after heal
	int delta = getAttrib(self, attrib) - before;
	//Build message to player displaying healed amout
	pp = prose.setStringId(pp, new string_id("healing", "heal_fly"));
	pp = prose.setDI(pp, delta);
	pp = prose.setTO(pp, healing.ATTRIBUTES[attrib]);
	showFlyTextPrivateProseWithFlags(self, self, pp, 2.0f, colors.SEAGREEN, healing.FLY_TEXT_FLAG_IS_HEAL);

	pp = prose.setStringId(pp, healing.SID_ITEM_PLAYER_HEAL);
	pp = prose.setDI(pp, delta);
	pp = prose.setTT(pp, self);
	healing.sendMedicalSpam(self, pp, healing.COMBAT_RESULT_MEDICAL);
	healing.doHealingAnimationAndEffect(self, self);

	//increment tick
	tick += 1;
	//update parameters with new tick total
	params.put("tick", tick);
	//check to see if this is the last heal tick, if not pass messageTo again
	if(tick < healing.ITEM_CHANNEL_HEAL_TICKS)
		messageTo( self, "channelHeal", params, 2, false);

	return SCRIPT_CONTINUE;
}

messageHandler residentLinkFalse()
{
	setHouseId(self, obj_id.NULL_ID);
	return SCRIPT_CONTINUE;
}

boolean blog(string msg)
{
	if(LOGGING_ON)
		LOG(LOGGING_CATEGORY, msg);
	return true;
}

messageHandler handleTargetDummyCombatReport()
{
	if ( (params == null) || (params.isEmpty()) )
	{
		return SCRIPT_CONTINUE;
	}

	// Determine which button was pressed.
	int button = sui.getIntButtonPressed( params );
	string revert = params.getString(sui.MSGBOX_BTN_REVERT+".RevertWasPressed");
	if ( button == sui.BP_CANCEL )
	{
		return SCRIPT_CONTINUE;
	}
	else
	{
		if (revert != null && !revert.equals(""))
		{
			// clearing combat data
			if ( utils.hasScriptVarTree(self, target_dummy.BASE_TARGET_DUMMY_VAR) )
			{
				utils.removeScriptVarTree(self, target_dummy.BASE_TARGET_DUMMY_VAR);
				sendSystemMessage(self, new string_id("target_dummy", "combat_data_all_clearing"));
				sendSystemMessage(self, new string_id("target_dummy", "combat_data_all_cleared"));
			}
			else
			{
				// No data found - though this shouldn't happen from here.
				sendSystemMessage(self, new string_id("target_dummy", "placement_no_combat_data"));
			}
		}
		else
		{
			// show combat data sui
			target_dummy.reportCombatData(self, self);
		}
	}

	return SCRIPT_CONTINUE;
}

//------------------TCG REIMBURSEMENT
messageHandler reimburseTcgItem()
{
	if((params == null) || (params.isEmpty()))
	{
		CustomerServiceLog("tcg", "TCG Reimbursement failed because of lack of parameters for reimbursement function for: "+self+".");
		return SCRIPT_CONTINUE;
	}

	if(!params.containsKey("reimburseItem"))
	{
		CustomerServiceLog("tcg", "TCG Reimbursement item parameter not found. Reimbursement function failed for: "+self+".");
		return SCRIPT_CONTINUE;
	}

	string reimbursementItem = params.getString("reimburseItem");
	if(reimbursementItem == null || reimbursementItem.equals(""))
	{
		CustomerServiceLog("tcg", "TCG Reimbursement item parameter was invalid. Reimbursement function failed for: "+self+".");
		return SCRIPT_CONTINUE;
	}

	obj_id pInv = utils.getInventoryContainer(self);
	if(!isValidId(pInv) || !exists(pInv))
	{
		CustomerServiceLog("tcg", "TCG Reimbursement function failed for: "+self+". Player inventory Id failed.");
		return SCRIPT_CONTINUE;
	}

	CustomerServiceLog("tcg", "TCG Reimbursement item: "+reimbursementItem+" being given to player: "+self+".");
	obj_id newItem = static_item.createNewItemFunction(reimbursementItem, pInv);
	if(!isValidId(newItem))
	{
		CustomerServiceLog("tcg", "TCG Reimbursement item: "+reimbursementItem+" failed. New object could not be created for: "+self+".");
		return SCRIPT_CONTINUE;
	}

	CustomerServiceLog("tcg", "TCG Reimbursement item: "+reimbursementItem+" was created: "+newItem+" and given to player: "+self+".");
	return SCRIPT_CONTINUE;
}

/***** COSTUME COMMANDS *************************************************/

boolean applyCostume(obj_id self, string costumeCommand)
{
	string ibuff = stealth.getInvisBuff(self);
	if ( ibuff != null && ibuff.length() > 0 )
	{
		sendSystemMessage(self, new string_id("spam", "costume_not_while_invis"));
		return false;
	}

	if ( getState(self, STATE_GLOWING_JEDI) != 0 )
	{
		sendSystemMessage(self, new string_id("spam", "costume_not_while_blue_glowie"));
		return false;
	}

	string datatable = "datatables/item/costume/costumes.iff";
	dictionary costumeData = dataTableGetRow(datatable, costumeCommand);
	if ( costumeData != null )
	{
		string costumeBuff = costumeData.getString("costume_buff");
		string costumeComponentName = costumeData.getString("costume_component");

		if ( costumeBuff != null && costumeBuff.length() > 0 )
		{
			// if the costume requires a component, make sure they have one
			if ( costumeComponentName != null && costumeComponentName.length() > 0 && !costumeComponentName.equals("none") )
			{
				obj_id costumeComponentId = utils.getStaticItemInInventory(self, costumeComponentName);
				if( !isIdValid(costumeComponentId) || getCount(costumeComponentId) <= 0)
				{
					string_id message = new string_id("spam", "costume_component_missing");
					prose_package pp = prose.getPackage(message, self, self);
					prose.setTO(pp, getString(new string_id("static_item_n", costumeComponentName)));
					sendSystemMessageProse(self, pp);
					return false;
				}
				else
				{
					decrementCount(costumeComponentId);
				}
			}

			buff.applyBuff(self, costumeBuff);
			return true;
		}
	}
	return false;
}

commandHandler costume_loveday_ewok_cupid()
{
	if(!applyCostume(self, "costume_loveday_ewok_cupid"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_jawa()
{
	if(!applyCostume(self, "costume_jawa"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_gungan()
{
	if(!applyCostume(self, "costume_gungan"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_ewok()
{
	if(!applyCostume(self, "costume_ewok"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_gamorrean_guard()
{
	if(!applyCostume(self, "costume_gamorrean_guard"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}

commandHandler costume_battle_droid()
{
	if(!applyCostume(self, "costume_battle_droid"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_droideka()
{
	if(!applyCostume(self, "costume_droideka"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_monkey_lizard()
{
	if(!applyCostume(self, "costume_monkey_lizard"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_toydarian()
{
	if(!applyCostume(self, "costume_toydarian"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_muftak()
{
	if(!applyCostume(self, "costume_muftak"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_dantari_m()
{
	if(!applyCostume(self, "costume_dantari_m"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_4lom()
{
	if(!applyCostume(self, "costume_4lom"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_dantari_f()
{
	if(!applyCostume(self, "costume_dantari_f"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_royal_guard()
{
	if(!applyCostume(self, "costume_royal_guard"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_droid_8t88()
{
	if(!applyCostume(self, "costume_droid_8t88"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_darktrooper()
{
	if(!applyCostume(self, "costume_darktrooper"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_mustafarian_01()
{
	if(!applyCostume(self, "costume_mustafarian_01"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_chevin()
{
	if(!applyCostume(self, "costume_chevin"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_ig106()
{
	if(!applyCostume(self, "costume_ig106"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_super_battle_droid()
{
	if(!applyCostume(self, "costume_super_battle_droid"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_spider_droid()
{
	if(!applyCostume(self, "costume_spider_droid"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_undead_wookie()
{
	if(!applyCostume(self, "costume_undead_wookie"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_burning_ewok()
{
	if(!applyCostume(self, "costume_burning_ewok"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_chiss_01()
{
	if(!applyCostume(self, "costume_chiss_01"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_exar_kun_cultist()
{
	if(!applyCostume(self, "costume_exar_kun_cultist"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}
commandHandler costume_lifeday_monkey_lizard()
{
	if(!applyCostume(self, "costume_lifeday_monkey_lizard"))
		return SCRIPT_OVERRIDE;
	return SCRIPT_CONTINUE;
}

/***** END COSTUME COMMANDS *************************************************/

commandHandler cmdShowHousePackUpData()
{
	string housePackUpData =  sui.colorGreen()+"";
	string timeMessage = "";
	string displayTime = "";
	int dailyCount = 0;

	//avail. merit points
	int meritPts = player_structure.getPlayerPackUpMeritPoints(self);
	if(meritPts < 0) meritPts = 0;
	housePackUpData +="Total Merit Points: "+sui.colorWhite() + meritPts + sui.colorGreen();
	housePackUpData += sui.newLine();

	//total houses packed
	int totalPacked = 0;
	int[] housePackingTally = getIntArrayObjVar(self, player_structure.HOUSE_PACKUP_ARRAY_OBJVAR);
	if(housePackingTally != null && housePackingTally.length == player_structure.ARRAY_LENGTH_FOR_HOUSE_PACKUP)
	{
		totalPacked = housePackingTally[1];
		if(totalPacked < 0) totalPacked = 0;

	}
	housePackUpData += "Total Structures Ever Packed: "+sui.colorWhite() + totalPacked + sui.colorGreen();
	housePackUpData += sui.newLine();

	if(hasObjVar(self, player_structure.HOUSE_PACKUP_DAILY_TIMER_OBJVAR))
	{
		int resetTime = getIntObjVar(self, player_structure.HOUSE_PACKUP_DAILY_TIMER_OBJVAR);
		if(getGameTime() < resetTime)
		{
			dailyCount = getIntObjVar(self, player_structure.HOUSE_PACKUP_DAILY_TALLY_OBJVAR);
			if(dailyCount < 0) dailyCount = 0;

			if(dailyCount > 0)
			{
				housePackUpData += "Total Structures Packed in Last 24 hours: "+sui.colorWhite() + dailyCount + sui.colorGreen();
				housePackUpData += sui.newLine();
			}
		}
	}

	//lock out house timer expiration
	if(!player_structure.canPackMoreToday(self) && hasObjVar(self,  player_structure.HOUSE_PACKUP_DAILY_TIMER_OBJVAR))
	{
		int timeLeft = getIntObjVar(self,  player_structure.HOUSE_PACKUP_DAILY_TIMER_OBJVAR);
		timeLeft -= getGameTime();
		displayTime = utils.assembleTimeRemainToUse(timeLeft, false);
		if(displayTime != null && displayTime.length() > 0)
		{
			housePackUpData += "Time Before Next Structure Can Be Packed: "+sui.colorWhite() + displayTime + sui.colorGreen();
			housePackUpData += sui.newLine();
		}
	}
	else if(player_structure.canPackMoreToday(self) && utils.hasScriptVar(self, player_structure.SCRIPTVAR_HOUSE_PACKUP_LOCKOUT_TIME))
	//lock out daily timer expiration
	{
		int timeNeeded = utils.getIntScriptVar(self, player_structure.SCRIPTVAR_HOUSE_PACKUP_LOCKOUT_TIME) + (int)player_structure.HOUSE_PACKUP_LOCKOUT_TIMER;
		int timeNow = getGameTime();
		int timeDiff = timeNeeded - timeNow;
		timeMessage = utils.formatTimeVerbose(timeDiff);
		if(timeMessage != null && timeMessage.length() > 0)
		{
			housePackUpData += "Time Before Next Structure Can Be Packed: "+sui.colorWhite() + timeMessage + sui.colorGreen();
			housePackUpData += sui.newLine();
		}
	}

	housePackUpData += sui.colorWhite();
	sendConsoleMessage(self, housePackUpData);
	return SCRIPT_CONTINUE;
}

commandHandler cmdRename()
{
	// dismiss any existing window
	if (utils.hasScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID))
	{
		int savedPageId = utils.getIntScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID);
		utils.removeScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID);
		forceCloseSUIPage(savedPageId);
	}

	if (utils.hasScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_NEW_NAME))
	{
		string newName = utils.getStringScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_NEW_NAME);
		utils.removeScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_NEW_NAME);

		// release the name so someone else can use it
		if ((newName != null) && (newName.length() > 0))
			renameCharacterReleaseNameReservation(self);
	}

	utils.removeScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_UNVERIFIED_NEW_NAME);

	// character must be at least 90 days old to rename
	const int daysOld = getCurrentBirthDate() - getPlayerBirthDate(self);
	if (daysOld < 90)
	{
		if (isGod(self))
		{
			sendSystemMessage(self, "GOD MODE bypass for 90 days character age requirement for character rename.", "");
		}
		else
		{
			sendSystemMessage(self, "This character is only " + daysOld + " days old.  The character must be at least 90 days old before you can rename the character.", "");
			return SCRIPT_CONTINUE;
		}
	}

	// character must wait 90 days after a previous rename
	if (hasObjVar(self, "renameCharacterRequest.requestTime"))
	{
		const int previousRenameTime = getIntObjVar(self, "renameCharacterRequest.requestTime");
		const int nextRenameTime = previousRenameTime + (90 * 24 * 60 * 60); // 90 days
		const int timeNow = getCalendarTime();

		if (nextRenameTime > timeNow)
		{
			const string previousRenameName = getStringObjVar(self, "renameCharacterRequest.requestNewName");
			const string currentName = getName(self);

			if ((currentName != null) && (previousRenameName != null) && !previousRenameName.equals(currentName))
			{
				// if has pending rename request, and 24 hours has passed, allow another rename attempt
				const int renameRequestTimeOut = previousRenameTime + (24 * 60 * 60);

				if (renameRequestTimeOut > timeNow)
				{
					int[] convertedGameTime = player_structure.convertSecondsTime(renameRequestTimeOut - timeNow);
					if ((convertedGameTime != null) && (convertedGameTime.length == 4))
						sendSystemMessage(self, "There is already an outstanding rename request for this character.  If the request is not completed in " + convertedGameTime[1] + "h:" + convertedGameTime[2] + "m:" + convertedGameTime[3] + "s, you can try to rename this character again.", "");
					else
						sendSystemMessage(self, "There is already an outstanding rename request for this character.", "");

					return SCRIPT_CONTINUE;
				}
			}
			else
			{
				// must wait 90 days between rename requests
				if (isGod(self))
				{
					sendSystemMessage(self, "GOD MODE bypass for 90 days wait between character rename.", "");
				}
				else
				{
					int[] convertedGameTime = player_structure.convertSecondsTime(nextRenameTime - timeNow);
					if ((convertedGameTime != null) && (convertedGameTime.length == 4))
						sendSystemMessage(self, "You must wait " + convertedGameTime[0] + "d:" + convertedGameTime[1] + "h:" + convertedGameTime[2] + "m:" + convertedGameTime[3] + "s before you can rename this character again.", "");
					else
						sendSystemMessage(self, "There is a 90 days wait after the character has been renamed before you can rename the character again.", "");

					return SCRIPT_CONTINUE;
				}
			}
		}
	}

	renameCharacterDisplayNameInput(self, getName(self), "Enter a new name for the character.");
	return SCRIPT_CONTINUE;
}

commandHandler trigger_city_house_packup()
{
	obj_id player = self;
	
	if(!isPlayer(player) || !isIdValid(player) || !exists(player))
		return SCRIPT_CONTINUE;
		
	location here = getLocation(player);
	obj_id[] potentialSigns = getObjectsInRange(here, 10.0f);
	
	//are there any signs?
	for(int i = 0; i < potentialSigns.length; i++)
	{
		if(!hasScript(potentialSigns[i], "systems.sign.sign"))
			continue;			
		else
		{
			//ensure the sign has valid data before continuing.
			if(!utils.hasScriptVar(potentialSigns[i], "player_structure.parent"))
			{
				sendSystemMessage(player, new string_id(STF_FILE, "unknown_city_packup_error"));
				CustomerServiceLog("playerStructure", "Player("+ player +") attempted to use the Remote City Packup Command but the House Sign("+ potentialSigns[i] +") has invalid data.");
				LOG("sissynoid", "Invalid Sign - No Parent ObjVar - fail");
				return SCRIPT_CONTINUE;
			}
			
			//ensure the structure is city abandoned before continuing (saves messageTo traffic)
			obj_id structure = utils.getObjIdScriptVar(potentialSigns[i], "player_structure.parent");
			if(!isIdValid(structure))
			{
				LOG("sissynoid", "Invalid Structure ID: " + structure);
				CustomerServiceLog("playerStructure", "Player("+ player +") attempted to use the Remote City Packup Command but the House Obj ID has invalid.");
				return SCRIPT_CONTINUE;
			}
			
			if(!player_structure.isCityAbandoned(structure))
			{
				sendSystemMessage(player, new string_id(STF_FILE, "structure_not_city_abandoned"));
				CustomerServiceLog("playerStructure", "Player("+ player +") attempted to use the Remote City Packup Command but the House("+ structure +") was not City Abandoned.");
				LOG("sissynoid", "This structure is not City Abandoned - fail");
				return SCRIPT_CONTINUE;
			}
			else
			{
				LOG("sissynoid", "I found a sign: " + potentialSigns[i]);
				dictionary dict = new dictionary();
				dict.put("player", player);
				dict.put("sign", potentialSigns[i]);
				messageTo(potentialSigns[i], "handleRemoteCommandCityHousePackup", dict, 1.0f, false);
			}
		}	
	}
	return SCRIPT_CONTINUE;
}

messageHandler handleRenameCharacterNameInput()
{
	if (!utils.hasScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID))
		return SCRIPT_CONTINUE;

	if (params.getInt("pageId") != utils.getIntScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID))
		return SCRIPT_CONTINUE;

	utils.removeScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID);

	int bp = sui.getIntButtonPressed(params);
	if (bp == sui.BP_OK)
	{
		string newName = sui.getInputBoxText(params);
		if (newName != null)
		{
			java.util.StringTokenizer st = new java.util.StringTokenizer(newName);

			newName = null;
			while (st.hasMoreTokens())
			{
				if (newName == null)
				{
					newName = st.nextToken();
				}
				else
				{
					newName += " ";
					newName += st.nextToken();
				}
			}
		}

		string currentName = getName(self);
		if ((newName != null) && (newName.length() > 0) && (currentName != null) && (currentName.length() > 0) && !newName.equals(currentName))
		{
			utils.setScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_UNVERIFIED_NEW_NAME, newName);
			validateRenameCharacter(self, newName);
		}
		else
		{
			if (currentName == null)
				currentName = "";

			renameCharacterDisplayNameInput(self, currentName, "Please enter a new name for the character.");
		}
	}

	return SCRIPT_CONTINUE;
}

messageHandler renameCharacterNameValidationFail()
{
	if (utils.hasScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_UNVERIFIED_NEW_NAME))
		return SCRIPT_CONTINUE;

	string unverifiedNewName = utils.getStringScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_UNVERIFIED_NEW_NAME);
	utils.removeScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_UNVERIFIED_NEW_NAME);

	if ((unverifiedNewName != null) && (unverifiedNewName.length() > 0))
	{
		renameCharacterDisplayNameInput(self, unverifiedNewName, params.getString("reason"));
	}

	return SCRIPT_CONTINUE;
}

messageHandler renameCharacterNameValidationSuccess()
{
	if (utils.hasScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_UNVERIFIED_NEW_NAME))
		return SCRIPT_CONTINUE;

	string newName = utils.getStringScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_UNVERIFIED_NEW_NAME);
	utils.removeScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_UNVERIFIED_NEW_NAME);

	if ((newName != null) && (newName.length() > 0))
	{
		string announcement = "Please confirm that you want to rename this character to \"";
		announcement += newName;
		announcement += "\".\n\n";

		java.util.StringTokenizer st = new java.util.StringTokenizer(newName);
		if (!st.hasMoreTokens())
			return SCRIPT_CONTINUE;

		string currentFirstName = getFirstName(self);
		if ((currentFirstName == null) || (currentFirstName.length() <= 0))
			return SCRIPT_CONTINUE;

		// if not changing first name, don't need to warn about mail, friends list, and
		// ignore list, since those won't be affected if the first name is not changing
		if (!currentFirstName.equalsIgnoreCase(st.nextToken()))
		{
			string disableRenameChatAvatar = getConfigSetting("CharacterRename", "disableRenameChatAvatar");
			if (disableRenameChatAvatar == null)
				disableRenameChatAvatar = "false";

			if (disableRenameChatAvatar.equalsIgnoreCase("true") || disableRenameChatAvatar.equalsIgnoreCase("yes"))
			{
				announcement += "Please note that this character's mail, friends list, and ignore list will be lost after the rename.\n\n";
			}
			else
			{
				announcement += "Please note that even though this character's mail, friends list, and ignore list will be preserved with the rename, it is still recommended that you make a backup of this character's mail, friends list, and ignore list.\n\n";
			}
		}

		announcement += "Once the rename request has been submitted (by clicking the Yes button below), you will be disconnected and will not be able to log in this character until the rename request is completed.  It can take up to 30 minutes for the rename request to complete.\n\n";
		announcement += "After the rename, there will be a 90 days wait before you can rename this character again.\n\n";
		announcement += "Do you wish to rename this character?";

		int pid = sui.msgbox(self, self, announcement, sui.YES_NO, "Rename Character", "handleRenameCharacterConfirmation");
		utils.setScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID, pid);
		utils.setScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_NEW_NAME, newName);
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleRenameCharacterConfirmation()
{
	if (!utils.hasScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_NEW_NAME))
		return SCRIPT_CONTINUE;

	if (params.getInt("pageId") != utils.getIntScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID))
		return SCRIPT_CONTINUE;

	string newName = utils.getStringScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_NEW_NAME);

	utils.removeScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID);
	utils.removeScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_NEW_NAME);

	if ((newName == null) || (newName.length() <= 0))
		return SCRIPT_CONTINUE;

	int bp = sui.getIntButtonPressed(params);
	if (bp == sui.BP_OK)
	{
		// request rename
		renameCharacter(self, newName);
	}
	else
	{
		// release the name so someone else can use it
		renameCharacterReleaseNameReservation(self);
	}

	return SCRIPT_CONTINUE;
}

void renameCharacterDisplayNameInput(obj_id self, string newName, string reason)
{
	if (!isIdValid(self) || !exists(self))
		return;

	string announcement = "Enter a new name for the character.";
	if ((reason != null) && (reason.length() > 0))
	{
		announcement = reason;
	}

	int pid = sui.inputbox(self, self, announcement, "Rename Character", "handleRenameCharacterNameInput", 125, false, "");
	sui.setSUIProperty(pid, sui.INPUTBOX_INPUT,      sui.PROP_TEXT, newName);
	sui.setSUIProperty(pid, sui.INPUTBOX_INPUT,      "MaxLength",   String.valueOf(125));
	utils.setScriptVar(self, SCRIPTVAR_RENAME_CHARACTER_SUI_ID, pid);
	showSUIPage(pid);
}

messageHandler closeLeaderSui()
{
	obj_id player = sui.getPlayerId(params);
	if(!isValidId(player))
		return SCRIPT_CONTINUE;

	sui.removePid(player, holiday.LEADERSUI_PID_NAME);
	return SCRIPT_CONTINUE;
}

//handler for community granted badges
messageHandler handlerCommunityBadgeGrant()
{
	if(params == null || params.isEmpty())
	{
		return SCRIPT_CONTINUE;
	}

	//objId of the community rep granting the badge
	obj_id communityRep = params.getObjId("communityRep");
	string badgeName = params.getString("badgeName");

	badge.grantBadge(self, badgeName);

	params.put("player", self);

	messageTo(communityRep, "handlerCommunityBadgeGrantedToPlayer", params, 0, true);
	CustomerServiceLog("EventPerk", "[EventTool] 'handlerCommunityBadgeGrant' player " + getPlayerName(self) + ":" + self + " was awarded badge " + badgeName + " by " + getPlayerName(communityRep) + ":"+ communityRep + " .", null);

	return SCRIPT_CONTINUE;
}

messageHandler recalculateCampDefenseUndeadArray()
{
	if((params == null) || (params.isEmpty()))
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() Params invalid.");
		return SCRIPT_CONTINUE;

	}

	if(!params.containsKey("questName"))
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() questName param not found.");
		return SCRIPT_CONTINUE;
	}

	if(!params.containsKey("survivalTaskName"))
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() survivalTaskName param not found.");
		return SCRIPT_CONTINUE;
	}

	if(!params.containsKey("cleanUpTaskName"))
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() cleanUpTaskName param not found.");
		return SCRIPT_CONTINUE;
	}
	string questName = params.getString("questName");
	if(questName == null || questName.length() <= 0)
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() player "+self+" has received an invalid quest name.");
		return SCRIPT_CONTINUE;
	}

	string survivalTaskName = params.getString("survivalTaskName");
	if(survivalTaskName == null || survivalTaskName.length() <= 0)
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() player "+self+" has received an invalid quest survivalTaskName name.");
		return SCRIPT_CONTINUE;
	}

	string cleanUpTaskName = params.getString("cleanUpTaskName");
	if(cleanUpTaskName == null || cleanUpTaskName.length() <= 0)
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() player "+self+" has received an invalid quest cleanUpTaskName name.");
		return SCRIPT_CONTINUE;
	}
	
	if(!utils.hasScriptVar(self, "enemyList"))
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() Has no script var list of enemies, sending signal.");
		if(!groundquests.isQuestActive(self, questName)) 
		{
			CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() Player "+self+" did not have the appropriate quest active. Aborting quest signal.");
			return SCRIPT_CONTINUE;	
		}

		if(groundquests.isTaskActive(self, questName, survivalTaskName))
		{
			CustomerServiceLog("outbreak_themepark", "camp_defense.updatePlayerDefense() Player "+self+" did not have the appropriate quest TASK active. Sending to new handler.");
						
			messageTo(self, "recalculateCampDefenseUndeadArray", params, 3, false );

			return SCRIPT_CONTINUE;	
		}

		//SEND SIGNAL hasKilledWave
		groundquests.sendSignal(self, "hasKilledWave");
		removeGuardPostFlag(self);
		
		return SCRIPT_CONTINUE;		
	}
	
	obj_id[] enemies = utils.getObjIdArrayScriptVar(self, "enemyList");
	if(enemies == null || enemies.length == 0)
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() Has the scriptvar but could not find a valid enemy list on player, sending signal.");
		if(!groundquests.isQuestActive(self, questName)) 
		{
			CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() Player "+self+" did not have the appropriate quest active. Destroying all enemies.");
			for (int i = 0; i < enemies.length; i++)
			{
				if((!isIdValid(enemies[i])) || !exists(enemies[i]) || isDead(enemies[i]))
				{
					continue;
				}
				destroyObject(enemies[i]);
			}
			utils.removeScriptVar(self,"enemyList");
			return SCRIPT_CONTINUE;	
		}

		if(groundquests.isTaskActive(self, questName, survivalTaskName))
		{
			CustomerServiceLog("outbreak_themepark", "camp_defense.updatePlayerDefense() Player "+self+" did not have the appropriate quest TASK active. Sending to new handler.");
			messageTo(self, "recalculateCampDefenseUndeadArray", params, 3, false );

			return SCRIPT_CONTINUE;	
		}

		//SEND SIGNAL hasKilledWave
		groundquests.sendSignal(self, "hasKilledWave");
		//Removed Occupied Flag from the guard post
		removeGuardPostFlag(self);
		
		return SCRIPT_CONTINUE;		
	}

	Vector latestGuardList = new Vector();
	for (int i = 0; i < enemies.length; i++)
	{
		if ((isIdNull(enemies[i])) || !exists(enemies[i]) || isDead(enemies[i]))
		{
			continue;
		}
		utils.addElement(latestGuardList, enemies[i]);
	}
	obj_id[] newGuardArray = new obj_id[latestGuardList.size()];
	if (newGuardArray == null || newGuardArray.length == 0)
	{
		CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() could not find a valid enemy list on player, sending signal.");
		if(!groundquests.isQuestActive(self, questName)) 
		{
			CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() Player "+self+" did not have the appropriate quest active. Aborting quest signal.");
			return SCRIPT_CONTINUE;	
		}

		if(groundquests.isTaskActive(self, questName, survivalTaskName))
		{
			CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() Player "+self+" did not have the appropriate quest TASK active. Handling Timer.");
			
			messageTo(self, "recalculateCampDefenseUndeadArray", params, 3, false );

			return SCRIPT_CONTINUE;	
		}

		//SEND SIGNAL hasKilledWave
		groundquests.sendSignal(self, "hasKilledWave");
		removeGuardPostFlag(self);
		
		return SCRIPT_CONTINUE;		
	}
	CustomerServiceLog("outbreak_themepark", "player_utility.recalculateCampDefenseUndeadArray() player: "+self+" still has enemies to kill.");	

	latestGuardList.toArray(newGuardArray);
	utils.setScriptVar(self, "enemyList", newGuardArray);
	return SCRIPT_CONTINUE;
}

boolean removeGuardPostFlag(obj_id player)
{
	if(!isValidId(player) || !exists(player))
	{
		return false;
	}
	CustomerServiceLog("outbreak_themepark", "player_utility.removeGuardPostFlag() Player "+player+" is attempting to remove the guard post occupied flagging.");

	//Removed Occupied Flag from the guard post
	if(utils.hasScriptVar(player, GUARD_OCCUPIED))
	{
		obj_id guardPost = utils.getObjIdScriptVar(player, GUARD_OCCUPIED);
		if(isValidId(guardPost) && exists(guardPost))
		{
			utils.removeScriptVar(guardPost, GUARD_OCCUPIED);
			return true;
		}
	}
	CustomerServiceLog("outbreak_themepark", "player_utility.removeGuardPostFlag() Player "+player+" did not have the guard post oid or the oid was invalid.");
	return false;
}

messageHandler handleEntertainingGcwTroops()
{
	if(params == null)
	{
		return SCRIPT_CONTINUE;			
	}

	if(!utils.hasScriptVar(self, gcw.GCW_SCRIPTVAR_PARENT + ".gcwNpc"))
	{
		LOG("gcw_entertainer","no gcwNpc");
	
		//missing data
		utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
		sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);
		return SCRIPT_CONTINUE;	
	}

	obj_id npc = utils.getObjIdScriptVar(self, gcw.GCW_SCRIPTVAR_PARENT + ".gcwNpc");
	if(!isValidId(npc) || !exists(npc) || ai_lib.aiIsDead(npc))
	{
		LOG("gcw_entertainer","npc not valid");
	
		//missing data
		utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
		sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);
		return SCRIPT_CONTINUE;	
	}

	if(utils.hasScriptVar(npc, gcw.GCW_STOPPED_ENTERTAINING))
	{
		LOG("gcw_entertainer","had gcw.GCW_STOPPED_ENTERTAINING");
	
		//missing data
		utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
		cleanUpGuardPostNpc(npc);
		sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);
		return SCRIPT_CONTINUE;	
	}
	
 	int pid = params.getInt("id");
	int test_pid = getIntObjVar(self, sui.COUNTDOWNTIMER_SUI_VAR);
	
	if(pid != test_pid)
	{
		LOG("gcw_entertainer","pid != test_pid -- just ignored!");
		return SCRIPT_CONTINUE;	
	}
	
	if(!sui.hasPid(self, gcw.ENTERTAIN_GCW_TROOPS_PID))
	{
		LOG("gcw_entertainer","no gcw.ENTERTAIN_GCW_TROOPS_PID");

		//wrong pid
		utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
		cleanUpGuardPostNpc(npc);
		sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);
		return SCRIPT_CONTINUE;	
	}
	
	test_pid = sui.getPid(self, gcw.ENTERTAIN_GCW_TROOPS_PID);
	
	if(test_pid != pid)
	{
		LOG("gcw_entertainer","gcw.ENTERTAIN_GCW_TROOPS_PID != pid");

		//wrong pid
		utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
		cleanUpGuardPostNpc(npc);
		sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);
		return SCRIPT_CONTINUE;	
	}

	if(!hasObjVar(self, sui.COUNTDOWNTIMER_SUI_VAR))
	{
		LOG("gcw_entertainer","no sui.COUNTDOWNTIMER_SUI_VAR");

		//no count down var
		utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
		cleanUpGuardPostNpc(npc);
		sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);
		return SCRIPT_CONTINUE;
	}

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
	{
		LOG("gcw_entertainer","had BP_CANCEL");

		utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
		cleanUpGuardPostNpc(npc);
		sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);
		return SCRIPT_CONTINUE;
	}
	else if(bp == sui.BP_REVERT)
	{
		LOG("gcw_entertainer","had BP_REVERT");

		// Gets the reason why the timer was aborted
		int event = params.getInt("event");

		// You can handle the situation differently depending on the reason
		if(event == sui.CD_EVENT_LOCOMOTION)
		{
			sendSystemMessage(self, gcw.SID_COUNTDOWN_LOCOMOTION);
		}
		else if(event == sui.CD_EVENT_INCAPACITATE)
		{
			sendSystemMessage(self, gcw.SID_INTERRUPTED_INCAPACITATED);		
		}
		else if(event == sui.CD_EVENT_DAMAGED || event == sui.CD_EVENT_COMBAT)
		{
			sendSystemMessage(self, gcw.SID_INTERRUPTED_DAMAGED);		
		}

		utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
		cleanUpGuardPostNpc(npc);
		sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);
		return SCRIPT_CONTINUE;
	}

	if(!utils.hasScriptVar(self, gcw.GCW_SCRIPTVAR_PARENT + ".playerEntertainmentStart"))
	{
		LOG("gcw_entertainer","missing  gcw.GCW_SCRIPTVAR_PARENT playerEntertainmentStart");

		//missing data
		utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
		sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);
		cleanUpGuardPostNpc(npc);
		return SCRIPT_CONTINUE;	
	}

	forceCloseSUIPage(pid);

	utils.removeScriptVarTree(self, gcw.GCW_SCRIPTVAR_PARENT);
	utils.removeScriptVarTree(npc, gcw.GCW_SCRIPTVAR_PARENT);
	sui.removePid(self,  gcw.ENTERTAIN_GCW_TROOPS_PID);

	utils.removeScriptVar(npc, "ai.oldEntertainerSkillMod");
	utils.removeScriptVar(npc, "ai.listeningTo");//stop listening to this guy
	stop(npc);//cancel that faceToBehavior
	messageTo(npc, "resumeDefaultCalmBehavior", null, 0, false);//this will setYaw back to the original pos.

	LOG("gcw_entertainer","YOU WIN!");
	if(factions.isRebelorRebelHelper(self))
	{
		LOG("gcw_entertainer","handleEntertainingGcwTroops Rebel task was signaled");
		groundquests.sendSignal(self, gcw.GCW_REB_ENTERTAIN_PATROL_SIGNAL);
	}
	else if(factions.isImperialorImperialHelper(self))
	{
		LOG("gcw_entertainer","handleEntertainingGcwTroops Imp task was signaled");
		groundquests.sendSignal(self, gcw.GCW_IMP_ENTERTAIN_PATROL_SIGNAL);
	}
	else
	{
		LOG("gcw_entertainer","handleEntertainingGcwTroops NO FACTION");
	}		
	
	//FATIGUE??

	//change state of the patrol point
	if(hasObjVar(npc, gcw.GCW_PATROL_OBJ))
	{
		LOG("gcw_entertainer","Has patrol_point var");

		obj_id patrolPoint = getObjIdObjVar(npc, gcw.GCW_PATROL_OBJ);
		if(isValidId(patrolPoint))
		{
			LOG("gcw_entertainer","Flagging obj: "+patrolPoint+" as entertained");
			messageTo(patrolPoint, "flagGCWPatrolEntertained", null, 0, false);
			sendSystemMessage(self, SID_PATROL_POINT_ENTERTAINED);
		
			trial.addNonInstanceFactionParticipant(self, patrolPoint);	
		}
	}
	//Last step, clean up NPC
	cleanUpGuardPostNpc(npc);

	return SCRIPT_CONTINUE;
}
  
boolean cleanUpGuardPostNpc(obj_id npc)
{
	if(!isValidId(npc) || !exists(npc))
		return false;
		
	if(utils.hasScriptVar(npc, gcw.GCW_NPC_CLEANUP_FLAG))
	{
		//Have NPC destroy self
		//messageTo(npc, "handleCombatDestructionDelay", null, 1, false);
		trial.cleanupObject(npc);
	}
	else
	{
		utils.removeScriptVarTree(npc, gcw.GCW_SCRIPTVAR_PARENT);
	}
	return true;
}

messageHandler handleTraderRepairQuest()
{
	if(params == null)
	{
		removeTraderRepairScriptVars(self);						
		return SCRIPT_CONTINUE;
	}
	int pid = params.getInt("id");
	int playerPid = getIntObjVar(self, sui.COUNTDOWNTIMER_SUI_VAR);
	if(pid != playerPid)	
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
	{
		LOG("gcw_patrol_point","handleTraderRepairQuest had BP_CANCEL");

		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}
	else if(bp == sui.BP_REVERT)
	{
		LOG("gcw_patrol_point","handleTraderRepairQuest had BP_REVERT");

		// Gets the reason why the timer was aborted
		int event = params.getInt("event");

		// You can handle the situation differently depending on the reason
		if(event == sui.CD_EVENT_LOCOMOTION)
		{
			sendSystemMessage(self, gcw.SID_COUNTDOWN_LOCOMOTION);
		}
		else if(event == sui.CD_EVENT_INCAPACITATE)
		{
			sendSystemMessage(self, gcw.SID_INTERRUPTED_INCAPACITATED);		
		}
		else if(event == sui.CD_EVENT_DAMAGED || event == sui.CD_EVENT_COMBAT)
		{
			sendSystemMessage(self, gcw.SID_INTERRUPTED_DAMAGED);		
		}

		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}

	if(!utils.hasScriptVar(self, gcw.OBJECT_TO_REPAIR))
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}
	if(!utils.hasScriptVar(self, gcw.GCW_REPAIR_QUEST))
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}
	if(!utils.hasScriptVar(self, gcw.GCW_REPAIR_RESOURCE_COUNT))
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}

	LOG("gcw_patrol_point","handleTraderRepairQuest passed validation");
	
	string questName = utils.getStringScriptVar(self, gcw.GCW_REPAIR_QUEST);
	if(questName == null || questName.length() <= 0)
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}	
	
	if(!groundquests.isQuestActive(self, questName))
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}

	LOG("gcw_constrction","handleTraderRepairQuest checkign for construction tasks");

	/*
	**The repair quests have the same signals and tasks as the construct quests
	*/
	if(!groundquests.isTaskActive(self, questName, gcw.GCW_CONSTRUCTION_TASK+"_"+questName))
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}

	LOG("gcw_constrction","handleTraderRepairQuest a task was found");

	obj_id gcwObject = utils.getObjIdScriptVar(self, gcw.OBJECT_TO_REPAIR);
	if(!isValidId(gcwObject) || !exists(gcwObject))
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}

	int resourceCount = utils.getIntScriptVar(self, gcw.GCW_REPAIR_RESOURCE_COUNT);
	if(resourceCount <= 0)
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}
	
	LOG("gcw_patrol_point","handleTraderRepairQuest");
	if(!gcw.repairGcwObject(gcwObject, self, resourceCount))
	{
		removeTraderRepairScriptVars(self);					
		return SCRIPT_CONTINUE;
	}

	LOG("gcw_constrction","handleTraderRepairQuest task was signaled");
	groundquests.sendSignal(self, gcw.GCW_CONSTRUCTION_SIGNAL+"_"+questName);	
	
	buff.applyBuff(self, "gcw_fatigue");
	trial.addNonInstanceFactionParticipant(self, gcwObject);
	removeTraderRepairScriptVars(self);					

	int gameTime = getGameTime();
	params.put("gcwFatigueTime", gameTime);
	utils.setScriptVar(self, "gcw.fatigueTime", gameTime);
	messageTo(self, "gcwFatigueDecay", params, 120.0f, false);

	return SCRIPT_CONTINUE;
}

messageHandler handleOpposingFactionScoutQuest()
{
	LOG("gcw_patrol_point","handleOpposingFactionScoutQuest init");

	if(params == null)
		return SCRIPT_CONTINUE;

	int pid = params.getInt("id");
	int playerPid = getIntObjVar(self, sui.COUNTDOWNTIMER_SUI_VAR);
	if(pid != playerPid)	
		return SCRIPT_CONTINUE;

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
	{
		LOG("gcw_patrol_point","handleOpposingFactionScoutQuest had BP_CANCEL");
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_SCOUT_PID);
		return SCRIPT_CONTINUE;
	}
	else if(bp == sui.BP_REVERT)
	{
		LOG("gcw_patrol_point","handleOpposingFactionScoutQuest had BP_REVERT");

		// Gets the reason why the timer was aborted
		int event = params.getInt("event");

		// You can handle the situation differently depending on the reason
		if(event == sui.CD_EVENT_LOCOMOTION)
		{
			sendSystemMessage(self, gcw.SID_COUNTDOWN_LOCOMOTION);
		}
		else if(event == sui.CD_EVENT_INCAPACITATE)
		{
			sendSystemMessage(self, gcw.SID_INTERRUPTED_INCAPACITATED);		
		}
		else if(event == sui.CD_EVENT_DAMAGED || event == sui.CD_EVENT_COMBAT)
		{
			sendSystemMessage(self, gcw.SID_INTERRUPTED_DAMAGED);		
		}
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_SCOUT_PID);
		return SCRIPT_CONTINUE;
	}

	LOG("gcw_patrol_point","handleOpposingFactionScoutQuest passed validation");

	if(!utils.hasScriptVar(self, "spyPatrolPoint"))
	{
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}
	
	obj_id patrolPoint = utils.getObjIdScriptVar(self, "spyPatrolPoint");
	if(!isValidId(patrolPoint) || !exists(patrolPoint))
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}
	
	if(!groundquests.isQuestActive(self, gcw.GCW_SPY_PATROL_SCOUT_QUEST))
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_SCOUT_PID);
		return SCRIPT_CONTINUE;
	}
	if(!groundquests.isTaskActive(self, gcw.GCW_SPY_PATROL_SCOUT_QUEST, gcw.GCW_REB_FIND_PATROL_SIGNAL)
	&& !groundquests.isTaskActive(self, gcw.GCW_SPY_PATROL_SCOUT_QUEST, gcw.GCW_IMP_FIND_PATROL_SIGNAL))
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_SCOUT_PID);
		return SCRIPT_CONTINUE;
	}

	if(factions.isRebelorRebelHelper(self))
	{
		LOG("gcw_patrol_point","handleOpposingFactionScoutQuest Rebel task was signaled");
		groundquests.sendSignal(self, gcw.GCW_REB_FIND_PATROL_SIGNAL);	
	}
	else if(factions.isImperialorImperialHelper(self))
	{
		LOG("gcw_patrol_point","handleOpposingFactionScoutQuest Imp task was signaled");
		groundquests.sendSignal(self, gcw.GCW_IMP_FIND_PATROL_SIGNAL);
	}
	else
	{
		LOG("gcw_patrol_point","handleOpposingFactionScoutQuest NO FACTION");
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_SCOUT_PID);
		return SCRIPT_CONTINUE;
	}		
	
	//FATIGUE???
	trial.addNonInstanceFactionParticipant(self, patrolPoint);
	utils.removeScriptVar(self, "spyPatrolPoint");
	sui.removePid(self,  gcw.SPY_SCOUT_PID);
	return SCRIPT_CONTINUE;
}

/*
	The Destroy Quests are as follows:
	1. gcw_spy_destroy_patrol
	The gcw_destroy_barricade & gcw_destroy_turret 
	quests are handled on the object themselves since 
	several people can participate in the destroy.
*/
messageHandler handleOpposingFactionDestroyQuest()
{
	if(params == null)
		return SCRIPT_CONTINUE;

	int pid = params.getInt("id");
	int playerPid = getIntObjVar(self, sui.COUNTDOWNTIMER_SUI_VAR);
	if(pid != playerPid)	
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
	{
		LOG("gcw_patrol_point","handleOpposingFactionDestroyQuest had BP_CANCEL");
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}
	else if(bp == sui.BP_REVERT)
	{
		LOG("gcw_patrol_point","handleOpposingFactionDestroyQuest had BP_REVERT");

		// Gets the reason why the timer was aborted
		int event = params.getInt("event");

		// You can handle the situation differently depending on the reason
		if(event == sui.CD_EVENT_LOCOMOTION)
		{
			sendSystemMessage(self, gcw.SID_COUNTDOWN_LOCOMOTION);
		}
		else if(event == sui.CD_EVENT_INCAPACITATE)
		{
			sendSystemMessage(self, gcw.SID_INTERRUPTED_INCAPACITATED);		
		}
		else if(event == sui.CD_EVENT_DAMAGED || event == sui.CD_EVENT_COMBAT)
		{
			sendSystemMessage(self, gcw.SID_INTERRUPTED_DAMAGED);		
		}
	
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}

	if(!utils.hasScriptVar(self, "spyPatrolPoint"))
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}

	if(!groundquests.isQuestActive(self, gcw.GCW_SPY_PATROL_DESTROY_QUEST))
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}

	//Check for buff here
	LOG("gcw_patrol_point","handleOpposingFactionDestroyQuest passed validation");
	obj_id patrolPoint = utils.getObjIdScriptVar(self, "spyPatrolPoint");
	if(!isValidId(patrolPoint) || !exists(patrolPoint))
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}

	if(!buff.hasBuff(self, gcw.BUFF_SPY_EXPLOSIVES))
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}

	long counter = buff.getBuffStackCount(self, gcw.BUFF_SPY_EXPLOSIVES);
	if(counter <= 0)
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}

	if(!buff.decrementBuffStack(self, gcw.BUFF_SPY_EXPLOSIVES))
	{
		utils.removeScriptVar(self, "spyPatrolPoint");
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}
	
	int currentHp = getHitpoints(patrolPoint);
	int maxHp = getMaxHitpoints(patrolPoint);

	if(currentHp > 0)
	{
		if(maxHp > 0)
		{
			double dmg = maxHp * .2;
			if(dmg < currentHp)
			{
				setHitpoints(patrolPoint, (currentHp - (int)dmg));
				playClientEffectLoc(patrolPoint, "clienteffect/combat_explosion_lair_large.cef", getLocation(patrolPoint), 0);
				return SCRIPT_CONTINUE;
			}
			else
			{
				setHitpoints(patrolPoint, 0);
			}		
		}
	}
	
	//if damage I am about to do exceeds condition HP of object, send signal quest completed.
	if(factions.isRebelorRebelHelper(self))
	{
		LOG("gcw_constrction","handleTraderRepairQuest Rebel task was signaled");
		groundquests.sendSignal(self, gcw.GCW_REB_DESTROY_PATROL_SIGNAL);	
	}
	else if(factions.isImperialorImperialHelper(self))
	{
		LOG("gcw_constrction","handleTraderRepairQuest Imp task was signaled");
		groundquests.sendSignal(self, gcw.GCW_IMP_DESTROY_PATROL_SIGNAL);
	}
	else
	{
		LOG("gcw_constrction","handleTraderRepairQuest NO FACTION");
		utils.removeScriptVar(self, "spyPatrolPoint");		
		sui.removePid(self,  gcw.SPY_DESTROY_PID);
		return SCRIPT_CONTINUE;
	}		
	
	//FATIGUE???
	trial.addNonInstanceFactionParticipant(self, patrolPoint);
	buff.removeBuff(self, gcw.BUFF_SPY_EXPLOSIVES);
	groundquests.sendSignal(self, "hasDestroyedPatrolPoint");
	//Ask the player if they want to do it again
	utils.removeScriptVar(self, "spyPatrolPoint");		
	sui.removePid(self,  gcw.SPY_DESTROY_PID);
	return SCRIPT_CONTINUE;
}

boolean removeTraderRepairScriptVars(obj_id player)
{
	if(!isValidId(player) || !exists(player))
	{
		return false;
	}
	sui.removePid(player,  gcw.TRADER_REPAIR_PID);
	utils.removeScriptVar(player, gcw.OBJECT_TO_REPAIR);
	utils.removeScriptVar(player, gcw.GCW_REPAIR_RESOURCE_COUNT);									
	utils.removeScriptVar(player, gcw.GCW_REPAIR_QUEST);					
	return true;
}

/*
notifyPlayerOfGcwCityEventAnnouncement 
Allows the GCW City functionality to speak to specific players about the status of specific cities on specific planets. 

A dictionary is passed as follows:
string string_file: The string file (or path and string file) that will be used.
string planetName: The planet name. This usually coincides with the planet the player is currently on. Used to construct the string_id
string cityName: The city that the announcement is about. Also used to construct the string_id
string imperial_announcement: OPTIONAL - The message sent to Imperial Players.
string rebel_announcement: OPTIONAL - The message sent to Rebel Players.
*/
messageHandler notifyPlayerOfGcwCityEventAnnouncement()
{
	LOG("gcw_announcement", "notifyPlayerOfGcwCityEventAnnouncement init");

	if(params == null)
	{
		return SCRIPT_CONTINUE;	
	}
	
	if(!params.containsKey("string_file") || !params.containsKey("planetName") 
	|| !params.containsKey("cityName"))
	{
		return SCRIPT_CONTINUE;		
	}

	string stringFile = params.getString("string_file");
	if(stringFile == null || stringFile.length() <= 0)
	{
		return SCRIPT_CONTINUE;		
	}


	string imperialAnnouncement = "";
	if(params.containsKey("imperial_announcement"))
	{
		imperialAnnouncement = params.getString("imperial_announcement");
		if(imperialAnnouncement == null || imperialAnnouncement.length() <= 0)
		{
			return SCRIPT_CONTINUE;		
		}
	}

	string rebelAnnouncement = "";
	if(params.containsKey("rebel_announcement"))
	{
		rebelAnnouncement = params.getString("rebel_announcement");
		if(rebelAnnouncement == null || rebelAnnouncement.length() <= 0)
		{
			return SCRIPT_CONTINUE;		
		}
	}

	string neutralAnnouncement = "";
	if(params.containsKey("neutral_announcement"))
	{
		neutralAnnouncement = params.getString("neutral_announcement");
		if(neutralAnnouncement == null || neutralAnnouncement.length() <= 0)
		{
			return SCRIPT_CONTINUE;		
		}
	}
	string planetName = params.getString("planetName");
	if(planetName == null || planetName.length() <= 0)
	{
		return SCRIPT_CONTINUE;		
	}

	string cityName = params.getString("cityName");
	if(cityName == null || cityName.length() <= 0)
	{
		return SCRIPT_CONTINUE;		
	}
	
	string npc = "object/mobile/dressed_imperial_moff_m.iff";
	string sound = "sound/sys_comm_imperial.snd";
	prose_package pp = new prose_package();
	
	if(factions.isImperialorImperialHelper(self) && imperialAnnouncement.length() > 0)
	{
		LOG("gcw_announcement", "notifyPlayerOfGcwCityEventAnnouncement player is Imperial");
		prose.setStringId(pp, new string_id(stringFile, imperialAnnouncement + planetName +"_"+cityName));
	}
	else if(factions.isRebelorRebelHelper(self) && rebelAnnouncement.length() > 0)
	{
		LOG("gcw_announcement", "notifyPlayerOfGcwCityEventAnnouncement player is Rebel");
		npc = "object/mobile/dressed_rebel_high_general_human_male_01.iff";
		sound = "sound/sys_comm_rebel_male.snd";
		prose.setStringId(pp, new string_id(stringFile, rebelAnnouncement + planetName +"_"+cityName));		
	}
	else
	{
		LOG("gcw_announcement", "notifyPlayerOfGcwCityEventAnnouncement player is NEUTRAL");
		npc = "object/mobile/dressed_noble_human_male_01.iff";
		sound = "sound/sys_comm_rebel_male.snd";
		prose.setStringId(pp, new string_id(stringFile, neutralAnnouncement + planetName +"_"+cityName));			
	}
	
	commPlayers(self, npc, sound, 12f, self, pp);				
	
	//If this is the first announcement then popup the UI.
	gcw.gcwTutorialCheck(self);
	return SCRIPT_CONTINUE;
}


// ----------------------------------------------------------------------

messageHandler onGcwFactionalPresenceTableDictionaryResponse()
{
	if (utils.hasScriptVar(self, "gcw.factionalPresenceTablePid"))
		utils.removeScriptVar(self, "gcw.factionalPresenceTablePid");

	return SCRIPT_CONTINUE;
}

// ----------------------------------------------------------------------

messageHandler onGcwPersonalContributionTableDictionaryResponse()
{
	if (utils.hasScriptVar(self, "gcw.gcwPersonalContributionTablePid"))
		utils.removeScriptVar(self, "gcw.gcwPersonalContributionTablePid");

	return SCRIPT_CONTINUE;
}

// ----------------------------------------------------------------------

messageHandler onGcwRegionDefenderTableDictionaryResponse()
{
	if (utils.hasScriptVar(self, "gcw.gcwRegionDefenderTablePid"))
		utils.removeScriptVar(self, "gcw.gcwRegionDefenderTablePid");

	if (utils.hasScriptVar(self, "gcw.gcwRegionDefenderDetailsTablePid"))
	{
		const int existingPid = utils.getIntScriptVar(self, "gcw.gcwRegionDefenderDetailsTablePid");
		utils.removeScriptVar(self, "gcw.gcwRegionDefenderDetailsTablePid");
		forceCloseSUIPage(existingPid);
	}

	const int bp = sui.getIntButtonPressed(params);
	if (bp != sui.BP_OK)
		return SCRIPT_CONTINUE;

	const String[] gcwDefenderRegions = getGcwDefenderRegions();
	if ((gcwDefenderRegions == null) || (gcwDefenderRegions.length <= 0))
		return SCRIPT_CONTINUE;

	int rowSelected = sui.getTableSelectedRow(params);
	if ((rowSelected < 0) || (rowSelected >= gcwDefenderRegions.length))
		return SCRIPT_CONTINUE;

	rowSelected = sui.getTableLogicalIndex(params);
	if ((rowSelected < 0) || (rowSelected >= gcwDefenderRegions.length))
		return SCRIPT_CONTINUE;

	String selectedGcwDefenderRegion = gcwDefenderRegions[rowSelected];
	const int indexSeparator = selectedGcwDefenderRegion.indexOf(":");
	if ((indexSeparator < 0) || ((indexSeparator + 1) >= selectedGcwDefenderRegion.length()))
		return SCRIPT_CONTINUE;

	selectedGcwDefenderRegion = selectedGcwDefenderRegion.substring(indexSeparator + 1);

	const int[] citiesImperial = getGcwDefenderRegionCitiesImperial(selectedGcwDefenderRegion);
	const int[] citiesRebel = getGcwDefenderRegionCitiesRebel(selectedGcwDefenderRegion);
	const int[] guildsImperial = getGcwDefenderRegionGuildsImperial(selectedGcwDefenderRegion);
	const int[] guildsRebel = getGcwDefenderRegionGuildsRebel(selectedGcwDefenderRegion);

	const string[] columnHeader =     {"City Name", "Guild Name", "Faction", "Time Started Defending"};
	const string[] columnHeaderType = {"text",      "text",       "image",   "text"};

	int total = 0;
	if (citiesImperial != null)
		total += citiesImperial.length;

	if (citiesRebel != null)
		total += citiesRebel.length;

	if (guildsImperial != null)
		total += guildsImperial.length;

	if (guildsRebel != null)
		total += guildsRebel.length;

	if (total <= 0)
		total = 1;

	string[][] rowData = new string[total][5];

	total = 0;
	if ((citiesRebel != null) && (citiesRebel.length > 0))
	{
		for (int i = 0; i < citiesRebel.length; ++i)
		{
			const String cityName = cityGetName(citiesRebel[i]);
			rowData[total][0] = ((cityName == null) ? "" : cityName);

			rowData[total][1] = "";
			rowData[total][2] = "/Styles.Icon.Faction.rebel_logo";

			const int timeJoinedGcwDefenderRegion = cityGetTimeJoinedGcwDefenderRegion(citiesRebel[i]);
			rowData[total][3] = ((timeJoinedGcwDefenderRegion > 0) ? getCalendarTimeStringLocal_YYYYMMDDHHMMSS(timeJoinedGcwDefenderRegion) : "");

			++total;
		}
	}

	if ((guildsRebel != null) && (guildsRebel.length > 0))
	{
		for (int i = 0; i < guildsRebel.length; ++i)
		{
			rowData[total][0] = "";

			const String guildName = guildGetName(guildsRebel[i]);
			rowData[total][1] = ((guildName == null) ? "" : guildName);

			const String guildAbbrev = guildGetAbbrev(guildsRebel[i]);
			if ((guildAbbrev != null) && (guildAbbrev.length() > 0))
				rowData[total][1] += (" (" + guildAbbrev + ")");

			rowData[total][2] = "/Styles.Icon.Faction.rebel_logo";

			const int timeJoinedGcwDefenderRegion = guildGetTimeJoinedCurrentGcwDefenderRegion(guildsRebel[i]);
			rowData[total][3] = ((timeJoinedGcwDefenderRegion > 0) ? getCalendarTimeStringLocal_YYYYMMDDHHMMSS(timeJoinedGcwDefenderRegion) : "");

			++total;
		}
	}

	if ((citiesImperial != null) && (citiesImperial.length > 0))
	{
		for (int i = 0; i < citiesImperial.length; ++i)
		{
			const String cityName = cityGetName(citiesImperial[i]);
			rowData[total][0] = ((cityName == null) ? "" : cityName);

			rowData[total][1] = "";
			rowData[total][2] = "/Styles.Icon.Faction.imperial_logo";

			const int timeJoinedGcwDefenderRegion = cityGetTimeJoinedGcwDefenderRegion(citiesImperial[i]);
			rowData[total][3] = ((timeJoinedGcwDefenderRegion > 0) ? getCalendarTimeStringLocal_YYYYMMDDHHMMSS(timeJoinedGcwDefenderRegion) : "");

			++total;
		}
	}

	if ((guildsImperial != null) && (guildsImperial.length > 0))
	{
		for (int i = 0; i < guildsImperial.length; ++i)
		{
			rowData[total][0] = "";

			const String guildName = guildGetName(guildsImperial[i]);
			rowData[total][1] = ((guildName == null) ? "" : guildName);

			const String guildAbbrev = guildGetAbbrev(guildsImperial[i]);
			if ((guildAbbrev != null) && (guildAbbrev.length() > 0))
				rowData[total][1] += (" (" + guildAbbrev + ")");

			rowData[total][2] = "/Styles.Icon.Faction.imperial_logo";

			const int timeJoinedGcwDefenderRegion = guildGetTimeJoinedCurrentGcwDefenderRegion(guildsImperial[i]);
			rowData[total][3] = ((timeJoinedGcwDefenderRegion > 0) ? getCalendarTimeStringLocal_YYYYMMDDHHMMSS(timeJoinedGcwDefenderRegion) : "");

			++total;
		}
	}

	if (total <= 0)
	{
		rowData[0][0] = "";
		rowData[0][1] = "";
		rowData[0][2] = "";
		rowData[0][3] = "";
	}

	const int imperialPct = getGcwImperialScorePercentile(selectedGcwDefenderRegion);
	string details = "GCW Region: " + localize(new string_id("gcw_regions", selectedGcwDefenderRegion)) + " (R:" + (100 - imperialPct) + "%% I:" + imperialPct + "%%)"; // the way to specify a % literal for SUI display is to use %%

	int controlledDuration = 0;
	if (imperialPct >= 70)
	{
		// display how long the imperial has had 70% control of the region
		const obj_id tatooine = getPlanetByName("tatooine");
		if (isIdValid(tatooine))
		{
			// the time that the imperial gained 70% control of the region is stored as a calendar time value
			controlledDuration = getIntObjVar(tatooine, "gcwScore.timeControlled." + selectedGcwDefenderRegion);
			if (controlledDuration > 0)
				controlledDuration = getCalendarTime() - controlledDuration;
		}
	}
	else if (imperialPct <= 30)
	{
		// display how long the rebel has had 70% control of the region
		const obj_id tatooine = getPlanetByName("tatooine");
		if (isIdValid(tatooine))
		{
			// the time that the rebel gained 70% control of the region is stored as a negative calendar time value
			controlledDuration = getIntObjVar(tatooine, "gcwScore.timeControlled." + selectedGcwDefenderRegion);
			if (controlledDuration < 0)
				controlledDuration = getCalendarTime() + controlledDuration;
		}
	}

	if (controlledDuration > 0)
	{
		string durationStr = "" + controlledDuration + "s";
		const int[] convertedTime = player_structure.convertSecondsTime(controlledDuration);
		if ((convertedTime != null) && (convertedTime.length == 4))
		{
			if (convertedTime[0] > 0)
				durationStr = "" + convertedTime[0] + "d:" + convertedTime[1] + "h:" + convertedTime[2] + "m:" + convertedTime[3] + "s";
			else if (convertedTime[1] > 0)
				durationStr = "" + convertedTime[1] + "h:" + convertedTime[2] + "m:" + convertedTime[3] + "s";
			else if (convertedTime[2] > 0)
				durationStr = "" + convertedTime[2] + "m:" + convertedTime[3] + "s";
			else if (convertedTime[3] > 0)
				durationStr = "" + convertedTime[3] + "s";
			else
				durationStr = "" + controlledDuration + "s";
		}

		details += (" (at least 70%% continuously " + ((imperialPct >= 70) ? "Imperial" : "Rebel") + " controlled for " + durationStr + ")"); // the way to specify a % literal for SUI display is to use %%
	}

	details += "\n";
	details += ("GCW Region Defender Rebel Bonus: " + getGcwDefenderRegionRebelBonus(selectedGcwDefenderRegion) + "%%\n"); // the way to specify a % literal for SUI display is to use %%
	details += ("GCW Region Defender Imperial Bonus: " + getGcwDefenderRegionImperialBonus(selectedGcwDefenderRegion) + "%%"); // the way to specify a % literal for SUI display is to use %%

	const int newPid = sui.tableRowMajor(self, self, sui.OK_ONLY, "@gcw:gcw_region_defender_war_terminal_menu", "onGcwRegionDefenderDetailsTableDictionaryResponse", details, columnHeader, columnHeaderType, rowData, true);
	if (newPid > 0)
		utils.setScriptVar(self, "gcw.gcwRegionDefenderDetailsTablePid", newPid);

	return SCRIPT_CONTINUE;
}

// ----------------------------------------------------------------------

messageHandler onGcwRegionDefenderDetailsTableDictionaryResponse()
{
	if (utils.hasScriptVar(self, "gcw.gcwRegionDefenderDetailsTablePid"))
		utils.removeScriptVar(self, "gcw.gcwRegionDefenderDetailsTablePid");

	return SCRIPT_CONTINUE;
}

// ----------------------------------------------------------------------

messageHandler handleGcwCityHelpUi()
{
	if(!isValidId(self) || !exists(self))
	{
		return SCRIPT_CONTINUE;
	}
	
	//Doesn't work in space
	if(isSpaceScene())
	{
		sendSystemMessage(self, new string_id("gcw", "gcw_city_waypoint_no_space"));
		return SCRIPT_CONTINUE;
	}
	
	//If no sequencer exists, wrong planet or too far away
	obj_id sequencer = gcw.getInvasionSequencerNearby(self);
	if(!isIdValid(sequencer) || !exists(sequencer))
	{
		sendSystemMessage(self, new string_id("gcw", "gcw_city_waypoint_no_city_found"));
		return SCRIPT_CONTINUE;
	}

	string cityName = utils.getStringScriptVar(sequencer, "cityName");
	if(cityName == null || cityName.length() <= 0)
	{
		return SCRIPT_CONTINUE;
	}

	if(!gcw.gcwIsInvasionCityOn(cityName))
	{
		sendSystemMessage(self, new string_id("gcw", "gcw_city_waypoint_city_off"));
		return SCRIPT_CONTINUE;
	}

	//If the invasion isn't running
	if(!gcw.invasionIsValidAndEngaged())
	{
		sendSystemMessage(self, new string_id("gcw", "gcw_city_waypoint_no_invasion_construction_phase"));
		return SCRIPT_CONTINUE;
	}

	int playerFactionFlag = 0;
	//The sequencer was found and an invasion is running.
	if(factions.isRebelorRebelHelper(self))
	{
		playerFactionFlag = factions.FACTION_FLAG_REBEL;
	}
	else if(factions.isImperialorImperialHelper(self))
	{
		playerFactionFlag = factions.FACTION_FLAG_IMPERIAL;
	}
	//Neutral Player
	else
	{
		obj_id[] defenseAttacheObjList = trial.getObjectsInInstanceBySpawnId(sequencer, "defense_attache");
		if(defenseAttacheObjList == null || defenseAttacheObjList.length <= 0)
		{
			return SCRIPT_CONTINUE;
		}

		obj_id defenseAttache = defenseAttacheObjList[0];
		if(!isIdValid(defenseAttache) || !exists(defenseAttache))
		{
			return SCRIPT_CONTINUE;
		}

		location defAttaLoc = getLocation(defenseAttache);
		if(defAttaLoc != null)
		{
			obj_id wpt = createWaypointInDatapad(self, defAttaLoc);
			setWaypointName(wpt, "Defense Coordinator");
			setWaypointActive(wpt, true);
		}

		obj_id[] offenseCampList = trial.getObjectsInInstanceBySpawnId(sequencer, "offense_camp");
		if(offenseCampList == null || offenseCampList.length < 3)
		{
			return SCRIPT_CONTINUE;
		}
		
		for(int i = 0; i < 3; i++)
		{
			location campLoc = getLocation(offenseCampList[i]);
			if(campLoc != null)
			{
				obj_id wpt = createWaypointInDatapad(self, campLoc);
				setWaypointName(wpt, "Invasion Staging Area Camp");
				setWaypointActive(wpt, true);
			}	
		}
		sendSystemMessage(self, new string_id("gcw", "gcw_city_waypoints_issued"));
		return SCRIPT_CONTINUE;
	}		

	LOG("handleGcwCityHelpUi","playerFactionFlag: "+playerFactionFlag);

	obj_id defendingGeneral = utils.getObjIdScriptVar(sequencer, "defendingGeneral");
	if(!isIdValid(defendingGeneral) || !exists(defendingGeneral))
	{
		return SCRIPT_CONTINUE;
	}

	//Compare the player and defending General Faction
	boolean playerIsDefending = true;

	if(factions.getFactionFlag(defendingGeneral) != playerFactionFlag)
	{
		playerIsDefending = false;
	}

	//The player is defending
	if(playerIsDefending)
	{
		obj_id[] defenseAttacheObjList = trial.getObjectsInInstanceBySpawnId(sequencer, "defense_attache");
		if(defenseAttacheObjList == null || defenseAttacheObjList.length <= 0)
		{
			return SCRIPT_CONTINUE;
		}

		obj_id defenseAttache = defenseAttacheObjList[0];
		if(!isIdValid(defenseAttache) || !exists(defenseAttache))
		{
			return SCRIPT_CONTINUE;
		}

		location defAttaLoc = getLocation(defenseAttache);
		if(defAttaLoc != null)
		{
			obj_id wpt = createWaypointInDatapad(self, defAttaLoc);
			setWaypointName(wpt, "Defense Coordinator");
			setWaypointActive(wpt, true);
		}
	}
	//The player is invading
	else
	{
		location defGenLoc = getLocation(defendingGeneral);
		if(defGenLoc != null)
		{
			obj_id wpt = createWaypointInDatapad(self, defGenLoc);
			setWaypointName(wpt, "Defending General");
			setWaypointActive(wpt, true);
		}

		obj_id[] offenseCampList = trial.getObjectsInInstanceBySpawnId(sequencer, "offense_camp");
		if(offenseCampList == null || offenseCampList.length < 3)
		{
			return SCRIPT_CONTINUE;
		}
		
		for(int i = 0; i < 3; i++)
		{
			location campLoc = getLocation(offenseCampList[i]);
			if(campLoc != null)
			{
				obj_id wpt = createWaypointInDatapad(self, campLoc);
				setWaypointName(wpt, "Staging Area Camp");
				setWaypointActive(wpt, true);
			}	
		}
	}
	sendSystemMessage(self, new string_id("gcw", "gcw_city_waypoints_issued"));
	return SCRIPT_CONTINUE;
}

messageHandler playIconicGCWWrapUpMessage()
{
	if(params == null)
	{
		return SCRIPT_CONTINUE;	
	}
					
	if(!params.containsKey("string_file") || !params.containsKey("iconicMob")
	|| !params.containsKey("music") || !params.containsKey("kudosText"))
	{
		return SCRIPT_CONTINUE;		
	}

	string stringFile = params.getString("string_file");
	if(stringFile == null || stringFile.length() <= 0)
	{
		return SCRIPT_CONTINUE;		
	}

	string npc = params.getString("iconicMob");
	if(npc == null || npc.length() <= 0)
	{
		return SCRIPT_CONTINUE;		
	}
	
	string sound = params.getString("music");
	if(sound == null || sound.length() <= 0)
	{
		return SCRIPT_CONTINUE;		
	}

	string kudosText = params.getString("kudosText");
	if(kudosText == null || kudosText.length() <= 0)
	{
		return SCRIPT_CONTINUE;		
	}

	prose_package pp = new prose_package();
	prose.setStringId(pp, new string_id(stringFile, kudosText));	
	commPlayers(self, npc, sound, 12f, self, pp);			
	return SCRIPT_CONTINUE;
}

messageHandler handleCityGcwRegionDefenderChoice()
{
	const int bp = sui.getIntButtonPressed(params);
	if (bp != sui.BP_OK)
		return SCRIPT_CONTINUE;

	String[] gcwDefenderRegions = getGcwDefenderRegions();
	if ((gcwDefenderRegions == null) || (gcwDefenderRegions.length <= 0))
		return SCRIPT_CONTINUE;

	int rowSelected = sui.getTableSelectedRow(params);
	if ((rowSelected < 0) || (rowSelected >= gcwDefenderRegions.length))
		return SCRIPT_CONTINUE;

	rowSelected = sui.getTableLogicalIndex(params);
	if ((rowSelected < 0) || (rowSelected >= gcwDefenderRegions.length))
		return SCRIPT_CONTINUE;

	const int cityId = getCitizenOfCityId(self);
	if (cityId <= 0)
		return SCRIPT_CONTINUE;

	const obj_id cityMayor = cityGetLeader(cityId);
	if (!isIdValid(cityMayor))
		return SCRIPT_CONTINUE;

	if ((cityMayor != self) && !isGod(self))
		return SCRIPT_CONTINUE;

	const obj_id cityHall = cityGetCityHall(cityId);
	if (!isIdValid(cityHall) || !exists(cityHall))
		return SCRIPT_CONTINUE;

	const int factionId = cityGetFaction(cityId);
	if (factionId == 0)
		return SCRIPT_CONTINUE;

	String selectedGcwDefenderRegion = gcwDefenderRegions[rowSelected];
	const int indexSeparator = selectedGcwDefenderRegion.indexOf(":");
	if ((indexSeparator < 0) || ((indexSeparator + 1) >= selectedGcwDefenderRegion.length()))
		return SCRIPT_CONTINUE;

	selectedGcwDefenderRegion = selectedGcwDefenderRegion.substring(indexSeparator + 1);
	
	const String currentGcwDefenderRegion = cityGetGcwDefenderRegion(cityId);
	if ((currentGcwDefenderRegion != null) && (currentGcwDefenderRegion.length() > 0))
		return SCRIPT_CONTINUE;

	// has the city previously defended a region?
	string previousRegion = null;
	int previousRegionTimeStartDefend = 0;
	int previousRegionTimeEndDefend = 0;
	if (hasObjVar(cityHall, "cityGcwRegionDefender.region"))
		previousRegion = getStringObjVar(cityHall, "cityGcwRegionDefender.region");
					
	if (hasObjVar(cityHall, "cityGcwRegionDefender.timeBegin"))
		previousRegionTimeStartDefend = getIntObjVar(cityHall, "cityGcwRegionDefender.timeBegin");

	if (hasObjVar(cityHall, "cityGcwRegionDefender.timeEnd"))
		previousRegionTimeEndDefend = getIntObjVar(cityHall, "cityGcwRegionDefender.timeEnd");

	const int timeNow = getCalendarTime();

	if ((previousRegion != null) && (previousRegion.length() > 0) && (previousRegionTimeStartDefend > 0) && (previousRegionTimeEndDefend > 0))
	{
		// Must wait 1 day to switch to defending a different region
		const int cooldown = previousRegionTimeEndDefend + (isGod(self) ? 10 : 86400) - timeNow;
		if ((cooldown > 0) && !selectedGcwDefenderRegion.equals(previousRegion))
		{
			string cooldownStr = "" + cooldown + "s";

			int[] convertedTime = player_structure.convertSecondsTime(cooldown);
			if ((convertedTime != null) && (convertedTime.length == 4))
			{
				if (convertedTime[0] > 0)
				{
					cooldownStr = "" + convertedTime[0] + "d:" + convertedTime[1] + "h:" + convertedTime[2] + "m:" + convertedTime[3] + "s";
				}
				else if (convertedTime[1] > 0)
				{
					cooldownStr = "" + convertedTime[1] + "h:" + convertedTime[2] + "m:" + convertedTime[3] + "s";
				}
				else if (convertedTime[2] > 0)
				{
					cooldownStr = "" + convertedTime[2] + "m:" + convertedTime[3] + "s";
				}
				else if (convertedTime[3] > 0)
				{
					cooldownStr = "" + convertedTime[3] + "s";
				}
				else
				{
					cooldownStr = "" + cooldown + "s";
				}
			}

			sendSystemMessage(self, "You must wait " + cooldownStr + " before you can defend a different GCW region. You can immediately defend the GCW region you most recently defended (" + localize(new string_id("gcw_regions", previousRegion)) + ").", "");		
			return SCRIPT_CONTINUE;
		}

		// if defending the region most recently defended, keep the start time
		if (selectedGcwDefenderRegion.equals(previousRegion))
		{
			citySetGcwDefenderRegion(cityId, previousRegion, previousRegionTimeStartDefend, true);
		}
		else // defending a different region than previously
		{
			citySetGcwDefenderRegion(cityId, selectedGcwDefenderRegion, timeNow, true);

			// persist info
			setObjVar(cityHall, "cityGcwRegionDefender.region", selectedGcwDefenderRegion);
			setObjVar(cityHall, "cityGcwRegionDefender.timeBegin", timeNow);
		}
	}
	else // defending a region for the first time
	{
		citySetGcwDefenderRegion(cityId, selectedGcwDefenderRegion, timeNow, true);

		// persist info
		setObjVar(cityHall, "cityGcwRegionDefender.region", selectedGcwDefenderRegion);
		setObjVar(cityHall, "cityGcwRegionDefender.timeBegin", timeNow);
	}

	removeObjVar(cityHall, "cityGcwRegionDefender.timeEnd");

	sendSystemMessage(self, "Setting the city's GCW defender region to " + localize(new string_id("gcw_regions", selectedGcwDefenderRegion)) + ". This may take a few seconds. You will receive mail confirmation once the change has been completed.", "");

	return SCRIPT_CONTINUE;
}

/************************************************************************/
