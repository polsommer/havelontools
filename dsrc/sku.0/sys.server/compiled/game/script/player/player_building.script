

/**********************************************************************
 * Copyright (c)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        player_structure.script
 * Description:  player script for player created structures
 * @author       $Author:$
 * @version      $Revision:$
 **********************************************************************/


/***** INCLUDES ********************************************************/
include java.lang.Math;
include library.ai_lib;
include library.callable;
include library.city;
include library.colors_hex;
include library.create;
include library.dressup;
include library.hq;
include library.incubator;
include library.money;
include library.pclib;
include library.performance;
include library.player_structure;
include library.prose;
include library.resource;
include library.session;
include library.skill;
include library.static_item;
include library.sui;
include library.tcg;
include library.trial;
include library.turnstile;
include library.utils;
include library.vendor_lib;
include library.xp;

/***** LOGGING *******************************************************/

const string LOGGING_CATEGORY				= "vendor";
const boolean LOGGING_ON				= true;

/***** CONSTANTS *******************************************************/

const string DATATABLE_HEIGHT				= "datatables/structure/cell_height.iff";
const string STF 					= "player_structure";

const string SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID = "saveRestoreDecorationSuiId";
const string SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID = "saveRestoreDecorationSaveSlotId";
const string SCRIPTVAR_RESTORE_DECORATION_SAVE_SLOT_CHOICE = "restoreDecorationSaveSlotChoice";
const string SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS = "restoreDecorationTargetRooms";
const string SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOM_INDEX = "restoreDecorationTargetRoomIndex";
const string SCRIPTVAR_RESTORE_DECORATION_CURRENT_POB_ROOMS = "restoreDecorationCurrentPobRooms";

const string_id SID_TRIAL_STRUCTURE			= new string_id(STF, "trial_structure");
const string_id SID_TRIAL_NO_MODIFY			= new string_id(STF, "trial_no_modify");
const string_id SID_NO_DECLARE				= new string_id(STF, "trial_no_declare");
const string_id SID_NO_TRANSFER				= new string_id(STF, "trial_no_transfer");
const string_id SID_NO_VENDOR				= new string_id(STF, "trial_no_vendor");
const string_id SID_NOT_IN_BUILDING        		= new string_id(STF, "not_in_building");
const string_id SID_CONTENTS_NOT_LOADED    		= new string_id(STF, "contents_not_loaded");
const string_id SID_BUILDING_HAS_NOTRADE    		= new string_id(STF, "building_has_notrade");

const string_id SID_CANT_TRANSFER_TO_CITY_BANNED	= new string_id("city/city", "cant_transfer_to_city_banned");

const string_id SID_CONSTRUCTION_COMPLETE         	= new string_id("player_structure", "construction_complete");
const string_id SID_CONSTRUCTION_COMPLETE_LOT_LIMIT_EXCEEDED = new string_id("player_structure", "construction_complete_lot_limit_exceeded");

const string_id SID_CONSTRUCTION_COMPLETE_SUBJECT 	= new string_id("player_structure", "construction_complete_subject");
const string_id SID_CONSTRUCTION_COMPLETE_SENDER  	= new string_id("player_structure", "construction_complete_sender");

const string_id SID_SYS_FULL_VENDORS			= new string_id("player_structure", "full_vendors");
const string_id SID_SYS_ALREADY_CREATING		= new string_id("player_structure", "already_creating_vendor_greeter");
const string_id SID_SYS_VENDOR_NOT_INITIALIZED  	= new string_id("player_structure", "need_to_initialize_vendor");
const string_id SID_SYS_CREATE_FAILED			= new string_id("player_structure", "create_failed");
const string_id SID_SYS_CREATE_SUCCESS			= new string_id("player_structure", "create_success");
const string_id SID_SYS_CREATE_BAZAAR_FAILED		= new string_id("player_structure", "create_bazaar_failed");
const string_id SID_SYS_CREATE_BAZAAR_SUCCESS		= new string_id("player_structure", "create_bazaar_success");
const string_id SID_CANT_VENDOR				= new string_id("player_structure", "cant_move_vendor");
const string_id SID_CANT_MOVE_OBJECT			= new string_id("player_structure", "cant_move_object");
const string_id SID_TURNSTILE_EXPIRE			= new string_id("player_structure", "turnstile_expire");
const string_id SID_CAN_RECLAIM_DEED			= new string_id("player_structure", "can_reclaim_deed");
const string_id SID_DROID_ASSIGNED_TO_MAINTAIN		= new string_id("player_structure", "droid_assigned_to_maintain");
const string_id SID_SUI_AMOUNT_TO_WITHDRAW		= new string_id("player_structure", "sui_amount_to_withdraw");
const string_id INVENTORY_FULL_GENERIC			= new string_id("player_structure", "inventory_full_generic");
const string_id SID_PACKUP_TOO_FAR_AWAY			= new string_id("player_structure", "too_far_away_to_pack_house");
const string_id SID_HOUSE_PACKUP_FAILED			= new string_id("player_structure", "house_packup_failed");

const string TBL_VENDOR_TYPES				= "datatables/vendor/vendor_types.iff";
const string TBL_TERMINAL_TYPES				= "datatables/vendor/vendor_terminal_types.iff";
const string TBL_DROID_TYPES				= "datatables/vendor/vendor_droid_types.iff";
const string TBL_PLAYER_TYPES				= "datatables/vendor/vendor_player_types.iff";
const string TBL_ALLNPC_TYPES				= "datatables/vendor/vendor_allnpc_types.iff";
const string TBL_SPECIAL_PLAYER_VENDOR_TYPES		= "datatables/vendor/vendor_player_types_special.iff";

const string VENDOR_VAR_PREFIX				= "vendor_prefix";
const string CREATING_VENDOR				= VENDOR_VAR_PREFIX+".creatingVendor";//scriptvar: vendor_prefix.creatingVendor

const string_id SID_VENDOR_MAINT_ACCEPTED		= new string_id("player_structure", "vendor_maint_accepted");

const string_id SID_OBSCENE				= new string_id("player_structure", "obscene");

const string_id SID_SET_NAME_TITLE			= new string_id("sui","set_name_title");
const string_id SID_SET_NAME_PROMPT			= new string_id("sui","set_name_prompt");

const string_id SID_ASSIGN_DROID_TITLE			= new string_id("sui","assign_droid_title");
const string_id SID_ASSIGN_DROID_PROMPT			= new string_id("sui","assign_droid_prompt");

const string_id PROSE_SIGN_NAME_UPDATED			= new string_id("player_structure","prose_sign_name_updated");

const string_id SID_DEACTIVATE_FACTORY_FOR_DELETE  	= new string_id("player_structure", "deactivate_factory_for_delete");
const string_id SID_REMOVE_SCHEMATIC_FOR_DELETE    	= new string_id("player_structure", "remove_schematic_for_delete");
const string_id SID_CLEAR_INPUT_HOPPER_FOR_DELETE  	= new string_id("player_structure", "clear_input_hopper_for_delete");
const string_id SID_CLEAR_OUTPUT_HOPPER_FOR_DELETE 	= new string_id("player_structure", "clear_output_hopper_for_delete");

const string_id SID_CLEAR_BUILDING_FOR_DELETE 		= new string_id("player_structure", "clear_building_for_delete");
const string_id SID_STORE_PETS_FOR_DELETE		= new string_id("player_structure", "store_pets_for_delete");

const string_id SID_PENDING_DESTROY			= new string_id("player_structure", "pending_destroy");

const string_id SID_CANT_PLACE_CIVIC			= new string_id("player_structure", "cant_place_civic");
const string_id SID_CANT_PLACE_UNIQUE			= new string_id("player_structure", "cant_place_unique");
const string_id SID_CANT_PLACE_JEDI			= new string_id("player_structure", "cant_place_jedi");
const string_id SID_CANT_PLACE_MOUNTED			= new string_id("player_structure", "cant_place_mounted");

const string_id SID_WRONG_STATE				= new string_id("error_message","wrong_state");

const string_id SID_PLACED_LAST_BASE			= new string_id("faction_perk", "faction_base_unit_last");
const string_id SID_PLACED_NEXT_TO_LAST			= new string_id("faction_perk", "faction_base_one_more");
const string_id SID_NO_RIGHTS				= new string_id("player_structure", "no_transfer_rights");

const string_id SID_EVACUATE_FACILITY			= new string_id("hq", "self_destruct_evacuate");

const string_id MOVED_CTRL_OBJ				= new string_id("spam", "magic_painting_ctrl_moved");
const string_id MOVED_BACKDROP_GENERATOR		= new string_id("spam", "backdrop_generator_moved");
const string_id MOVED_PAINTING				= new string_id("spam", "magic_painting_moved");
const string_id NO_MOVE_ITEM				= new string_id("spam", "no_move_item");
const string_id SID_UNABLE_TO_PARSE			= new string_id(STF, "unable_to_parse");
const string_id SID_VALID_AMOUNT			= new string_id(STF, "enter_valid_over_zero");
const string_id SID_RESERVE_REPORT			= new string_id(STF, "reserve_report");
const string_id SID_DEPOSIT_SUCCESS			= new string_id(STF, "deposit_successful");
const string_id SID_NOT_ENOUGH_ENERGY			= new string_id(STF, "not_enough_energy");
const string_id SID_POWER_DEPOSIT_INCOMPLETE		= new string_id(STF, "power_deposit_incomplete");
const string_id SID_ERROR_POWER_DEPOSIT			= new string_id(STF, "error_power_deposit");
const string_id SID_POWER_DEPOSIT_FAIL			= new string_id(STF, "power_deposit_failed");
const string_id SID_SELECT_POWER_AMOUNT			= new string_id(STF, "select_power_amount");
const string_id SID_CURRENT_POWER_AMOUNT		= new string_id(STF, "current_power_value");
const string_id SID_POWER_NAME				= new string_id(STF, "power_name");
const string_id SID_POWER_QUALITY			= new string_id(STF, "power_quality");
const string_id SID_NO_GEO_POWER			= new string_id(STF, "incubator_no_geothermal");
const string_id SID_POWER_REMOVED			= new string_id(STF, "power_removed");

const string_id SID_TCG_VENDOR_CTS_WARNING		= new string_id("player_vendor", "tcg_vendor_in_player_inventory");

const string_id SID_ROTATE_CONFIRM_SAVE 		= new string_id(STF, "rotate_confirm_save");
const string_id SID_ROTATE_RESTORE_EMPTY_SLOT 		= new string_id(STF, "rotate_restore_empty_slot");

const string_id SID_DESTRUCTION_LOCKED			= new string_id("city/city", "destruction_locked");

const int VAR_TRUE					= 1;

/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/***** TRIGGERS ********************************************************/
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/

/***** TRIGGERS HOUSE PLACEMENT/MAINT ********************************************************/
trigger OnPlaceStructure (obj_id player, obj_id deed, location position, int rotation)
{
	LOG("LOG_CHANNEL", "player_building::OnPlaceStructure");
	LOG("LOG_CHANNEL", "player ->" + player + " deed ->" + deed + " pos ->" + position + " rotation ->" + rotation);

	if(!isIdValid(player))
	{
		LOG("LOG_CHANNEL", "player_structure::OnPlaceStructure -- player is invalid.");
		return SCRIPT_CONTINUE;
	}

	if(!isIdValid(deed))
	{
		LOG("LOG_CHANNEL", "player_structure::OnPlaceStructure -- deed is invalid.");
		return SCRIPT_CONTINUE;
	}

	obj_id owner = utils.getContainingPlayer(deed);

	if(player == owner)
	{
		// Here we do nothing, this is OK
	}
	else
	{
		sendSystemMessage(player, new string_id(STF, "no_possession")); // You no longer are in possession of the deed for this structure. Aborting construction.

		if(isIdValid(owner))
		{
			CustomerServiceLog("playerStructure", "%TU tried to place a building, but no longer possesses the deed (" + deed + ")! %TT currently has the deed.", player, owner);
		}
		else
		{
			CustomerServiceLog("playerStructure", "%TU tried to place a building, but no longer possesses the deed (" + deed + ")!", player);
		}
		return SCRIPT_CONTINUE;
	}
	//if(isJedi(player))
	//{
	//	sendSystemMessage(player, SID_CANT_PLACE_JEDI);
	//	return SCRIPT_CONTINUE;
	//}
	string template = player_structure.getDeedTemplate(deed);
	if(template == null)
	{
		LOG("LOG_CHANNEL", "player_structure::OnPlaceStructure -- Unable to find template on deed.");
		return SCRIPT_CONTINUE;
	}

	string fp_template = player_structure.getFootprintTemplate(template);
	if(fp_template == null || fp_template.equals(""))
		return SCRIPT_CONTINUE;

	// check to see if there is room for the structure
	float placement_height = canPlaceStructure(fp_template, position, rotation);

	LOG("LOG_CHANNEL", "placement_height ->" + placement_height);

	if(placement_height == -9997.0f)
	{
		LOG("LOG_CHANNEL", player + " ->Internal code error: canPlaceStructure");
		sendSystemMessage(player, new string_id(STF, "error_canplacestructure")); // Internal code error: canPlaceStructure
		return SCRIPT_CONTINUE;
	}

	if(placement_height == -9998.0f)
	{
		LOG("LOG_CHANNEL", player + " ->Internal script error: OnPlaceStructure");
		sendSystemMessage(player, new string_id(STF, "error_onplacestructure")); // Internal code error: onPlaceStructure
		return SCRIPT_CONTINUE;
	}

	if(placement_height == -9999.0f)
	{
		LOG("LOG_CHANNEL", player + " ->There is no room to place the structure here.");
		sendSystemMessage(player, new string_id(STF, "no_room")); // There is no room to place the structure here.
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isCivicTemplate(template) && (template.indexOf("cityhall") == -1))
	{
		// Check to see if we are placing this in a city we are the mayor of.
		if(!canPlaceCivic(player, deed, position, template))
		{
			sendSystemMessage(player, SID_CANT_PLACE_CIVIC);
			return SCRIPT_CONTINUE;
		}
		// Check to see if this location is in a city and the deed is a unique type.
		if(!canPlaceUnique(player, deed, position, template))
		{
			sendSystemMessage(player, SID_CANT_PLACE_UNIQUE);
			return SCRIPT_CONTINUE;
		}
	}

	//Check again to see if the player can place.
	if(!player_structure.canPlaceStructure(self, template, position, deed))
		return SCRIPT_CONTINUE;

	// Place temporary structure
	position.y = getHeightAtLocation (position.x, position.z);

	if(isGameObjectTypeOf(getGameObjectType(deed), GOT_data_house_control_device))
	{
		player_structure.replacePackedStructure(deed, self, position, rotation, placement_height);
		return SCRIPT_CONTINUE;
	}

	obj_id structure = player_structure.createTemporaryStructure(deed, self, position, rotation, placement_height);
	if(!isIdValid(structure))
	{
		debugSpeakMsg(self, "OnPlaceStructure: createObject failed");

		return SCRIPT_OVERRIDE;
	}

	//LOG("hq", "+++ player_building:OnPlaceStructure ///////////////////////// Should be about to check 'player_structure.isFactionPerkBaseDeed' so stand by....");
	//LOG("hq", "+++ player_building:OnPlaceStructure ///////////////////////// TEMPLATE name we are checking for isFactionPerkBaseDeed = "+template);

	if(player_structure.isFactionPerkBase(template))
	{
		//LOG("hq", "+++ player_building.OnPlaceStructure ///////////////////////// passed isFactionPerkBaseDeed check. Proceeding");
		if(hasObjVar(player,"factionBaseCount"))
		{
			int factionBaseCount = getIntObjVar(player,"factionBaseCount");
			int updatedFactionBaseCount = factionBaseCount + 1;
			setObjVar(player,"factionBaseCount",updatedFactionBaseCount);
			if(updatedFactionBaseCount == player_structure.MAX_BASE_COUNT)
				sendSystemMessage(self, SID_PLACED_LAST_BASE);
			else if(updatedFactionBaseCount == player_structure.MAX_BASE_COUNT-1)
				sendSystemMessage(self, SID_PLACED_NEXT_TO_LAST);
			else
				sendSystemMessageProse(self, prose.getPackage(new string_id ("faction_perk", "faction_base_unit_used"), (player_structure.MAX_BASE_COUNT-updatedFactionBaseCount)));

			//LOG("hq", "+++ player_building.OnPlaceStructure ///////////////////////////// has 'factionBaseCount' of value: "+factionBaseCount+" and setting new value at: "+updatedFactionBaseCount);
		}
		else
		{
			setObjVar(player,"factionBaseCount",1);
			sendSystemMessageProse(self, prose.getPackage(new string_id ("faction_perk", "faction_base_unit_used"), (player_structure.MAX_BASE_COUNT-1)));
			//LOG("hq", "+++ player_building.OnPlaceStructure //////////////////////////////// doesn't have 'factionBaseCount' objvar. Setting objvar to 1");
		}
	}
	return SCRIPT_CONTINUE;
}

trigger OnPermissionListModify(obj_id player, String name, String listName, String action)
{
	if(utils.isFreeTrial(player))
	{
		sendSystemMessage(player, SID_TRIAL_NO_MODIFY);
		return SCRIPT_CONTINUE;
	}

	LOG("debug", "player_building::OnPermissionListModify");
	//LOG("LOG_CHANNEL", "name ->" + name + " listName ->" + listName + " action ->" + action);

	obj_id structure = player_structure.getStructure(self);
	if((structure == null)||(structure == obj_id.NULL_ID))
	{
		LOG("LOG_CHANNEL", "You must be in a building, be near an installation, or have one targeted to do that.");
		sendSystemMessage(player, new string_id(STF, "no_building")); // You must be in a building, be near an installation, or have one targeted to do that.
		return SCRIPT_CONTINUE;
	}

	if(name == null)
		return SCRIPT_CONTINUE;

	if(name.length() > 40)
	{
		sendSystemMessage(player, new string_id(STF, "permission_40_char")); // Permission list entries cannot be longer than 40 characters.
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;
	if(listName.equals("ENTRY"))
		player_structure.modifyEntryList(structure, name, self);

	if(listName.equals("BAN"))
		player_structure.modifyBanList(structure, name, self);

	if(listName.equals("ADMIN"))
		player_structure.modifyAdminList(structure, name, self);

	if(listName.equals("HOPPER"))
		player_structure.modifyHopperList(structure, name, self);

	return SCRIPT_CONTINUE;
}

/***** TRIGGERS HOUSE PACK UP********************************************************/
trigger OnContentsLoadedForBuildingToBePacked(obj_id structure)
{
	LOG("sissynoid", "Loading Finished - Triggered OnContentsLoadedForBuildingToBePacked");
	if(!isValidId(structure))
		return SCRIPT_CONTINUE;

	if(!player_structure.canPackStructureWithVendors(self, structure))
	{
		if(player_structure.isAbandoned(structure))
			messageTo(self, "handleFailedStructurePackup", null, 0, false);
		if(player_structure.isCityAbandoned(structure))
			sendSystemMessage(self, new string_id("player_structure", "unable_to_city_pack"));
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isAbandoned(structure))
	{
		player_structure.finalizePackUp(self, structure);
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isCityAbandoned(structure))
	{
		player_structure.finalizeCityPackUp(self, structure);
		LOG("sissynoid", "Contents are Now Loaded - Messaging packUpCityAbandonedStructure");
		return SCRIPT_CONTINUE;
	}

	return SCRIPT_CONTINUE;
}

trigger OnMadeAuthoritative()
{
	LOG("sissynoid", "OnMadeAuthoritative: HouseAndPlayer have been made authoritative");
	if(utils.hasScriptVar(self, "requestedSameServerToAbandonHouse"))
	{
		LOG("sissynoid", "Shoud not be here!");
		obj_id house = utils.getObjIdScriptVar(self, "requestedSameServerToAbandonHouse");

		utils.removeScriptVarTree(self, "requestedSameServerToAbandonHouse");
		utils.removeScriptVarTree(self, "timeOfLastSameServerRequest");

		if(!player_structure.canPlayerPackAbandonedStructure(self, house))
		{
			messageTo(self, "handleFailedStructurePackup", null, 0, false);
			sendSystemMessage(self, new string_id("player_structure", "abandoned_structure_pack_up_try_again_later"));
			return SCRIPT_CONTINUE;
		}

		dictionary params = new dictionary();
		params.put("house", house);
		params.put("player", self);

		messageTo(house, "packAbandonedBuilding", params, 4, false);

		if(!hasObjVar(self, "housePackup"))
		{
			string recipient = getPlayerName(self);
			utils.sendMail(new string_id("spam", "email_title"), new string_id("spam", "email_body"), recipient, "Galactic Vacant Building Demolishing Movement");
		}
	}
	if(utils.hasScriptVar(self, "cityRequestedSameServerToAbandonHouse"))
	{		
		obj_id player = self;
		obj_id house = utils.getObjIdScriptVar(self, "cityRequestedSameServerToAbandonHouse");
		LOG("sissynoid", "OnMadeAuthoritative: City Packup is a Go for Structure("+ house +") by player ("+ player +")");
		utils.removeScriptVarTree(self, "cityRequestedSameServerToAbandonHouse");
		utils.removeScriptVarTree(self, "cityTimeOfLastSameServerRequest");
		
		//we do all the checks in the packup code - no need to repeat them here when they'll get called soon.
		player_structure.confirmCityAbandonedAndPack(house, player);
	}
 	return SCRIPT_CONTINUE;
}

/***** TRIGGERS VENDORS********************************************************/

trigger OnPlayerVendorCountReply(int count)
{
	if(count < 0)
	{
		//This is an error condition meaning the CM is not available.
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	int creatingVendor = 0;
	if(utils.hasScriptVar(self, CREATING_VENDOR))
		creatingVendor = utils.getIntScriptVar(self, CREATING_VENDOR);

	blog("player_building.OnPlayerVendorCountReply -- " + creatingVendor + " / " + count);

	if(creatingVendor == 1)
	{
		//oh neat, lets use objvars on a player to count how many
		//slots have been used.
		setObjVar(self, "used_vendor_slots", count);
		// Validate skill mod.
		if(getSkillStatMod(self, "manage_vendor") <= count)
		{
			// Can't manage any more vendors.
			removeVendorVars(self);
			sendSystemMessage(self, SID_SYS_FULL_VENDORS);
			return SCRIPT_CONTINUE;
		}

		// Get vendor types.
		string[] rawVendorTypes = dataTableGetStringColumn(TBL_VENDOR_TYPES, 0);
		if(rawVendorTypes == null)
		{
			removeVendorVars(self);
			return SCRIPT_CONTINUE;
		}
		// We can manage an additional vendor.  Pop up the vendor list.
		// Determine how many types we get based on our hiring skill mod.
		int hiringMod = getSkillStatMod(self, "hiring");
		blog("player_building.OnPlayerVendorCountReply hiringMod: " + hiringMod);
		int hiringRequirement = 10;
		resizeable string[] vendorTypes = new string[0];

		blog("player_building.OnPlayerVendorCountReply rawVendorTypes.length: " + rawVendorTypes.length);

		//initialize a string array of the same size as alll the vendors possible
		string[] possibleVendorTypes = new string[rawVendorTypes.length];
		//loop through and add the vendor types to the possible array list
		for(int i = 0; i < rawVendorTypes.length; i++)
		{
			possibleVendorTypes[i] = "@player_structure:"+rawVendorTypes[i];
		}
		//why is this a hard coded 3???
		for(int i=0; i<3; i++)
		{
			if(hiringMod >= hiringRequirement)
				vendorTypes = utils.addElement(vendorTypes, possibleVendorTypes[i]);
			hiringRequirement += 10;
		}

		if(vendorTypes == null)
		{
			// Not enough hiring mod.
			removeVendorVars(self);
			return SCRIPT_CONTINUE;
		}
		sui.listbox(self, self, "@player_structure:vendor_type_d", sui.OK_CANCEL, "@player_structure:vendor_type_t", vendorTypes, "handleVendorTypeSelect", true);
	}
	return SCRIPT_CONTINUE;
}

/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/***** COMMANDHANDLERS *************************************************/
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/

commandHandler rotateFurniture()
{
	if(hasScript(self, performance.MUSIC_HEARTBEAT_SCRIPT))
	{
		string_id message = new string_id("player_structure", "cant_move_while_entertaining");
		sendSystemMessage(self, message);
		return SCRIPT_CONTINUE;
	}

	boolean canRollAndPitch = (player_structure.canRotateFurnitureInPitchRollAxes(self) || isGod(self));

	// Parse the command
	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if(st.countTokens() == 0)
	{
		if(!canRollAndPitch)
			sendSystemMessage(self, new string_id(STF, "formet_rotratefurniture_degrees"));
		else
			sendSystemMessage(self, new string_id(STF, "formet_enhanced_rotratefurniture_degrees"));

		return SCRIPT_CONTINUE;
	}

	// Get the direction of rotation

	// the list of valid sub-commands ***MUST*** be kept in sync
	// with rotateFurnitureSubCommands in ClientCommandQueue.cpp
	string direction = st.nextToken().toUpperCase();
	boolean actionYaw = false;
	boolean actionPitch = false;
	boolean actionRoll = false;
	boolean actionRandom = false;
	boolean actionReset = false;
	boolean actionCopy = false;
	boolean actionSave = false;
	boolean actionRestore = false;
	boolean actionSetQuaternion = false;
	if(direction.equals("YAW"))
	{
		actionYaw = true;
	}
	else if(direction.equals("PITCH"))
	{
		if(!canRollAndPitch)
		{
			sendSystemMessage(self, new string_id(STF, "formet_rotratefurniture_degrees"));
			return SCRIPT_CONTINUE;
		}

		actionPitch = true;
	}
	else if(direction.equals("ROLL"))
	{
		if(!canRollAndPitch)
		{
			sendSystemMessage(self, new string_id(STF, "formet_rotratefurniture_degrees"));
			return SCRIPT_CONTINUE;
		}

		actionRoll = true;
	}
	else if(direction.equals("RANDOM"))
	{
		if(!canRollAndPitch)
		{
			sendSystemMessage(self, new string_id(STF, "formet_rotratefurniture_degrees"));
			return SCRIPT_CONTINUE;
		}

		actionRandom = true;
	}
	else if(direction.equals("RESET"))
	{
		actionReset = true;
	}
	else if(direction.equals("COPY"))
	{
		actionCopy = true;
	}
	else if(direction.equals("SAVE"))
	{
		actionSave = true;
	}
	else if(direction.equals("RESTORE"))
	{
		actionRestore = true;
	}
	else if(direction.equals("(^-,=+_)INTERNAL_USE_ONLY_" + self + "_QUATERNION(,+-=_^)")) // for obfuscation so players won't manually send us this command
	{
		if(!canRollAndPitch)
		{
			sendSystemMessage(self, new string_id(STF, "formet_rotratefurniture_degrees"));
			return SCRIPT_CONTINUE;
		}

		actionSetQuaternion = true;
	}
	else
	{
		if(!canRollAndPitch)
			sendSystemMessage(self, new string_id(STF, "formet_rotratefurniture_degrees"));
		else
			sendSystemMessage(self, new string_id(STF, "formet_enhanced_rotratefurniture_degrees"));

		return SCRIPT_CONTINUE;
	}

	// Get the amount to rotate
	int saveSlot = 0;
	int rotation = 0;
	float qw = 1.0f;
	float qx = 0.0f;
	float qy = 0.0f;
	float qz = 0.0f;
	if(actionYaw || actionPitch || actionRoll)
	{
		if(st.hasMoreTokens())
		{
			string rot_str = st.nextToken().toUpperCase();
			if(rot_str.equals("RANDOM"))
			{
				actionRandom = true;
			}
			else
			{
				// don't use utils.stringToInt() becase -1 is a valid value and
				// utils.stringToInt() returns -1 to indicate an invalid number
				try
				{
					rotation = Integer.parseInt(rot_str);
				}
				catch (NumberFormatException err)
				{
					sendSystemMessage(self, new string_id(STF, "rotate_params"));
					return SCRIPT_CONTINUE;
				}

				if(rotation < -180 || rotation > 180)
				{
					sendSystemMessage(self, new string_id(STF, "rotate_params"));
					return SCRIPT_CONTINUE;
				}
			}
		}
		else
		{
			rotation = getFurnitureRotationDegree(self);
		}

		if((rotation == 0) && !actionRandom)
		{
			return SCRIPT_CONTINUE;
		}
	}
	else if(actionSave || actionRestore)
	{
		if(st.hasMoreTokens())
		{
			saveSlot = utils.stringToInt(st.nextToken());

			if(saveSlot < 1 || saveSlot > 10)
			{
				sendSystemMessage(self, new string_id(STF, "rotate_save_slot_params"));
				return SCRIPT_CONTINUE;
			}
		}
		else
		{
			if(!canRollAndPitch)
				sendSystemMessage(self, new string_id(STF, "formet_rotratefurniture_degrees"));
			else
				sendSystemMessage(self, new string_id(STF, "formet_enhanced_rotratefurniture_degrees"));

			return SCRIPT_CONTINUE;
		}
	}
	else if(actionSetQuaternion)
	{
		if(!st.hasMoreTokens())
			return SCRIPT_CONTINUE;
		qw = utils.stringToFloat(st.nextToken());

		if(!st.hasMoreTokens())
			return SCRIPT_CONTINUE;
		qx = utils.stringToFloat(st.nextToken());

		if(!st.hasMoreTokens())
			return SCRIPT_CONTINUE;
		qy = utils.stringToFloat(st.nextToken());

		if(!st.hasMoreTokens())
			return SCRIPT_CONTINUE;
		qz = utils.stringToFloat(st.nextToken());

		if(!st.hasMoreTokens())
			return SCRIPT_CONTINUE;
	}

	// Get the target
	obj_id intendedTarget = getIntendedTarget(self);
	obj_id lookAtTarget = getLookAtTarget(self);

	if(st.hasMoreTokens())
	{
		target = obj_id.getObjId(Long.valueOf(st.nextToken()));
	}
	else
	{
		if(!actionCopy)
		{
			if(isIdValid(intendedTarget))
				target = intendedTarget;
			else if(isIdValid(lookAtTarget))
				target = lookAtTarget;
		}
		else
		{
			if(isIdValid(lookAtTarget))
				target = lookAtTarget;
		}
	}

	if(!isIdValid(target))
	{
		sendSystemMessage(self, new string_id(STF, "rotate_what"));
		return SCRIPT_CONTINUE;
	}

	if(actionCopy && !isIdValid(intendedTarget))
	{
		sendSystemMessage(self, new string_id(STF, "rotate_move_copy_no_intended_target"));
		return SCRIPT_CONTINUE;
	}

	// Don't allow pitch/roll/copy/set quaternion on vendor
	boolean isVendor = hasCondition(target, CONDITION_VENDOR);
	if(isVendor && (actionPitch || actionRoll || actionCopy || actionRestore || actionSetQuaternion))
	{
		sendSystemMessage(self, new string_id(STF, "cant_rotate_vendor"));
		return SCRIPT_CONTINUE;
	}

	// Validate rotate object
	if(!actionSave)
	{
		if(!isMoveCommandValid(self, target))
			return SCRIPT_CONTINUE;

		session.logActivity(self, session.ACTIVITY_DECORATE);
	}

	// rotate it
	if(actionYaw)
	{
		if(actionRandom)
			modifyYaw(target, rand(-180, 180));
		else
			modifyYaw(target, rotation);
	}
	else if(actionPitch)
	{
		if(actionRandom)
			modifyPitch(target, rand(-180, 180));
		else
			modifyPitch(target, rotation);
	}
	else if(actionRoll)
	{
		if(actionRandom)
			modifyRoll(target, rand(-180, 180));
		else
			modifyRoll(target, rotation);
	}
	else if(actionRandom)
	{
		modifyYaw(target, rand(-180, 180));

		if(!isVendor)
		{
			modifyPitch(target, rand(-180, 180));
			modifyRoll(target, rand(-180, 180));
		}
	}
	else if(actionReset)
	{
		setQuaternion(target, 1.0f, 0.0f, 0.0f, 0.0f);
	}
	else if(actionCopy)
	{
		if(target != intendedTarget)
		{
			float[] quaternion = getQuaternion(intendedTarget);
			if((quaternion != null) && (quaternion.length == 4))
				setQuaternion(target, quaternion[0], quaternion[1], quaternion[2], quaternion[3]);
		}
	}
	else if(actionSave)
	{
		if(saveSlot >= 1 && saveSlot <= 10)
		{
			float[] quaternion = getQuaternion(target);
			if((quaternion != null) && (quaternion.length == 4))
			{
				setObjVar(self, "rotateFurnitureSaveSlot." + saveSlot, quaternion);

				prose_package pp = prose.getPackage(SID_ROTATE_CONFIRM_SAVE);
				prose.setDI(pp, saveSlot);
				sendSystemMessageProse(self, pp);
			}
		}
	}
	else if(actionRestore)
	{
		if(saveSlot >= 1 && saveSlot <= 10)
		{
			float[] quaternion = getFloatArrayObjVar(self, "rotateFurnitureSaveSlot." + saveSlot);
			if((quaternion != null) && (quaternion.length == 4))
			{
				setQuaternion(target, quaternion[0], quaternion[1], quaternion[2], quaternion[3]);
			}
			else
			{
				prose_package pp = prose.getPackage(SID_ROTATE_RESTORE_EMPTY_SLOT);
				prose.setDI(pp, saveSlot);
				sendSystemMessageProse(self, pp);
			}
		}
	}
	else if(actionSetQuaternion)
	{
		setQuaternion(target, qw, qx, qy, qz);
	}

	messageTo(target, "furniture_rotated", null, 1.0f, false);

	return SCRIPT_CONTINUE;
}

commandHandler moveFurniture()
{
	// Parse the command
	if(hasScript(self, performance.MUSIC_HEARTBEAT_SCRIPT))
	{
		string_id message = new string_id("player_structure", "cant_move_while_entertaining");
		sendSystemMessage(self, message);
		return SCRIPT_CONTINUE;
	}
	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if(st.countTokens() == 0)
	{
		sendSystemMessage(self, new string_id(STF, "format_movefurniture_distance"));
		return SCRIPT_CONTINUE;
	}

	// Get direction of movement
	string direction = st.nextToken().toUpperCase();
	string dist_str = null;

	// the list of valid sub-commands ***MUST*** be kept in sync
	// with moveFurnitureSubCommands in ClientCommandQueue.cpp
	if(!direction.equals("FORWARD") && !direction.equals("BACK") && !direction.equals("LEFT") && !direction.equals("RIGHT") && !direction.equals("UP") && !direction.equals("DOWN") && !direction.equals("COPY"))
	{
		string targetName = getEncodedName(target).toUpperCase();
		if(targetName.startsWith("@"))
			targetName = localize(getNameStringId(target)).toUpperCase();

		if(!targetName.startsWith("FORWARD") && !targetName.startsWith("BACK") && !targetName.startsWith("LEFT") && !targetName.startsWith("RIGHT") && !targetName.startsWith("UP") && !targetName.startsWith("DOWN") && !targetName.startsWith("COPY"))
		{
			sendSystemMessage(self, new string_id(STF, "format_movefurniture_distance"));
			return SCRIPT_CONTINUE;
		}
		else
		{
			dist_str = direction;

			if(targetName.startsWith("UP"))
				direction = "UP";
			else if(targetName.startsWith("DOWN"))
				direction = "DOWN";
			else if(targetName.startsWith("BACK"))
				direction = "BACK";
			else if(targetName.startsWith("FORWARD"))
				direction = "FORWARD";
			else if(targetName.startsWith("LEFT"))
				direction = "LEFT";
			else if(targetName.startsWith("RIGHT"))
				direction = "RIGHT";
			else if(targetName.startsWith("COPY"))
				direction = "COPY";
		}
	}

	// Get the amount to move
	int distance = 0;
	boolean copyLocation = false;
	boolean copyHeight = false;
	if(st.hasMoreTokens() && dist_str == null)
	{
		dist_str = st.nextToken().toUpperCase();
		if(direction == "COPY")
		{
			if(dist_str.equals("LOCATION"))
			{
				copyLocation = true;
			}
			else if(dist_str.equals("HEIGHT"))
			{
				copyHeight = true;
			}
			else
			{
				sendSystemMessage(self, new string_id(STF, "format_movefurniture_distance"));
				return SCRIPT_CONTINUE;
			}
		}
		else
		{
			int dist_int = utils.stringToInt(dist_str);
			if(dist_int != -1)
				distance = dist_int;

			if(distance < 1 || distance > 500)
			{
				sendSystemMessage(self, new string_id(STF, "movefurniture_params"));
				return SCRIPT_CONTINUE;
			}
		}
	}
	else if(dist_str != null)
	{
		dist_str = dist_str.toUpperCase();
		if(direction == "COPY")
		{
			if(dist_str.equals("LOCATION"))
			{
				copyLocation = true;
			}
			else if(dist_str.equals("HEIGHT"))
			{
				copyHeight = true;
			}
			else
			{
				sendSystemMessage(self, new string_id(STF, "format_movefurniture_distance"));
				return SCRIPT_CONTINUE;
			}
		}
		else
		{
			int dist_int = utils.stringToInt(dist_str);
			if(dist_int != -1)
				distance = dist_int;

			if(distance < 1 || distance > 500)
			{
				sendSystemMessage(self, new string_id(STF, "movefurniture_params"));
				return SCRIPT_CONTINUE;
			}
		}
	}
	else if(direction == "COPY")
	{
		sendSystemMessage(self, new string_id(STF, "format_movefurniture_distance"));
		return SCRIPT_CONTINUE;
	}
	else
	{
		distance = 100;
	}

	// Get the target
	obj_id intendedTarget = getIntendedTarget(self);
	obj_id lookAtTarget = getLookAtTarget(self);

	if(st.hasMoreTokens())
	{
		target = obj_id.getObjId(Long.valueOf(st.nextToken()));
	}
	else
	{
		if(direction != "COPY")
		{
			if(isIdValid(intendedTarget))
				target = intendedTarget;
			else if(isIdValid(lookAtTarget))
				target = lookAtTarget;
		}
		else
		{
			if(isIdValid(lookAtTarget))
				target = lookAtTarget;
		}
	}

	if(!isIdValid(target))
	{
		sendSystemMessage(self, new string_id(STF, "move_what"));
		return SCRIPT_CONTINUE;
	}

	if((direction == "COPY") && !isIdValid(intendedTarget))
	{
		sendSystemMessage(self, new string_id(STF, "rotate_move_copy_no_intended_target"));
		return SCRIPT_CONTINUE;
	}

	// Don't move objects marked as unmoveable
	if(hasObjVar(target, "unmoveable"))
	{
		sendSystemMessage(self, SID_CANT_MOVE_OBJECT);
		return SCRIPT_CONTINUE;
	}

	// Don't move vendors
	if(hasCondition(target, CONDITION_VENDOR))
	{
		sendSystemMessage(self, SID_CANT_VENDOR);
		return SCRIPT_CONTINUE;
	}

	// Validate move object
	if(!isMoveCommandValid(self, target))
		return SCRIPT_CONTINUE;

	// Calculate new location
	location move_loc = null;
	session.logActivity(self, session.ACTIVITY_DECORATE);
	if(direction == "FORWARD" || direction == "BACK" || direction == "LEFT" || direction == "RIGHT")
	{
		// Determine the point to move.
		location loc = getLocation(target);
		float facing = getYaw(self);

		// LEFT/RIGHT is the same as FORWARD/BACK after turning 90 degrees
		if(direction == "LEFT")
		{
			facing -= 90;
			direction = "FORWARD";
		}
		else if(direction == "RIGHT")
		{
			facing += 90;
			direction = "FORWARD";
		}

		// distance is in tenths of units so that the player doesn't need to use decimals.
		float dist_scaled = (float)distance / 100.0f;

		float facing_rad = (float)Math.toRadians(facing);
		float x = dist_scaled * (float) Math.sin(facing_rad);
		float z = dist_scaled * (float)Math.cos(facing_rad);

		if(direction.equals("BACK"))
		{
			x = x * -1;
			z = z * -1;
		}

		LOG("LOG_CHANNEL", "x ->" + x + " z ->" + z + " dist ->" + dist_scaled);
		move_loc = new location (x + loc.x, loc.y, z + loc.z, loc.area, loc.cell);
		LOG("LOG_CHANNEL", "move_loc ->" + move_loc);

		// Validate the location
		if(!isValidInteriorLocation(move_loc))
		{
			sendSystemMessage(self, new string_id(STF, "not_valid_location"));
			return SCRIPT_CONTINUE;
		}
	}
	else if(direction == "UP" || direction == "DOWN")
	{
		// Determine the point to move.
		location loc = getLocation(target);
		float facing = getYaw(self);
		// distance is in tenths of units so that the player doesn't need to use decimals.
		float dist_scaled = (float)distance / 100.0f;
		float y = dist_scaled;

		if(direction.equals("DOWN"))
		{
			y = y * -1;
		}

		LOG("LOG_CHANNEL", "y ->" + y + " dist ->" + dist_scaled);
		move_loc = new location (loc.x, y + loc.y, loc.z, loc.area, loc.cell);
		LOG("LOG_CHANNEL", "move_loc ->" + move_loc);

		obj_id building = getTopMostContainer(target);
		string bldgstr = getTemplateName(building);
		string cellname = getCellName(building, loc.cell);
		float new_y = y + loc.y;

		if(!utils.hasScriptVar(target, "vertical.template") || !utils.hasScriptVar(target, "vertical.cell") ||
		    !utils.hasScriptVar(target, "vertical.min_height") || !utils.hasScriptVar(target, "vertical.max_height") ||
		    !utils.getStringScriptVar(target, "vertical.template").equals(bldgstr) ||
		    !utils.getStringScriptVar(target, "vertical.cell").equals(cellname))
		{
			string[] template = dataTableGetStringColumn(DATATABLE_HEIGHT, "template");
			string[] cell = dataTableGetStringColumn(DATATABLE_HEIGHT, "cell");
			float[] max_height = dataTableGetFloatColumn(DATATABLE_HEIGHT, "max_height");
			float[] min_height = dataTableGetFloatColumn(DATATABLE_HEIGHT, "min_height");

			for(int i = 0; i < template.length; i++)
			{
				if((template[i] == bldgstr) && (cell[i] == cellname))
				{
					utils.setScriptVar (target, "vertical.template", template[i]);
					utils.setScriptVar(target, "vertical.cell", cell[i]);
					utils.setScriptVar(target, "vertical.min_height", min_height[i]);
					utils.setScriptVar(target, "vertical.max_height", max_height[i]);
				}
			}
		}

		if(!utils.hasScriptVar(target, "vertical.min_height") || !utils.hasScriptVar(target, "vertical.max_height"))
		{
			sendSystemMessage(self, new string_id(STF, "error_move_item"));
			return SCRIPT_CONTINUE;
		}

		if(new_y < utils.getFloatScriptVar(target, "vertical.min_height") || new_y > utils.getFloatScriptVar(target, "vertical.max_height"))
		{
			sendSystemMessage(self, new string_id(STF, "not_valid_location"));
			return SCRIPT_CONTINUE;
		}
	}
	else if(target != intendedTarget)
	{
		location sourceLoc = getLocation(intendedTarget);
		move_loc = getLocation(target);

		if((sourceLoc != null) && (move_loc != null) && (isIdValid(sourceLoc.cell)) && (isIdValid(move_loc.cell)))
		{
			if(sourceLoc.cell == move_loc.cell)
			{
				if(copyLocation)
				{
					move_loc.x = sourceLoc.x;
					move_loc.z = sourceLoc.z;
				}
				else if(copyHeight)
				{
					move_loc.y = sourceLoc.y;
				}
				else
				{
					return SCRIPT_CONTINUE;
				}
			}
			else
			{
				sendSystemMessage(self, new string_id(STF, "move_copy_objects_not_in_same_cell"));
				return SCRIPT_CONTINUE;
			}
		}
		else
		{
			sendSystemMessage(self, new string_id(STF, "move_copy_objects_not_in_same_cell"));
			return SCRIPT_CONTINUE;
		}
	}

	// Move the object
	if(move_loc != null)
	{
		setLocation(target, move_loc);
		location new_loc = getLocation(target);
		LOG("LOG_CHANNEL", "new_loc ->" + new_loc);

		dictionary parameters = new dictionary();

		parameters.put("newLoc", move_loc);

		messageTo(target, "furniture_moved", parameters, 1.0f, false);
	}

	return SCRIPT_CONTINUE;
}

trigger DoRestoreItemDecorationLayout(obj_id item, obj_id cell, location loc, boolean restoreRotation, float qw, float qx, float qy, float qz)
{
	if (!isIdValid(item) || !exists(item) || !isIdValid(cell) || !exists(cell) || (loc == null))
		return SCRIPT_OVERRIDE;

	if(hasScript(self, performance.MUSIC_HEARTBEAT_SCRIPT))
	{
		string_id message = new string_id("player_structure", "cant_move_while_entertaining");
		sendSystemMessage(self, message);
		return SCRIPT_OVERRIDE;
	}

	// Don't move objects marked as unmoveable
	if(hasObjVar(item, "unmoveable"))
	{
		sendSystemMessage(self, SID_CANT_MOVE_OBJECT);
		return SCRIPT_OVERRIDE;
	}

	// Don't move vendors
	if(hasCondition(item, CONDITION_VENDOR))
	{
		sendSystemMessage(self, SID_CANT_VENDOR);
		return SCRIPT_OVERRIDE;
	}

	// Validate move object
	if(!isMoveCommandValid(self, item))
		return SCRIPT_OVERRIDE;

	session.logActivity(self, session.ACTIVITY_DECORATE);

	// Move the object
	loc.cell = cell;
	setLocation(item, loc);

	// Set the object orientation
	if (restoreRotation)
		setQuaternion(item, qw, qx, qy, qz);

	dictionary parameters = new dictionary();
	parameters.put("newLoc", loc);
	messageTo(item, "furniture_moved", parameters, 1.0f, false);

	if (restoreRotation)
		messageTo(item, "furniture_rotated", null, 1.0f, false);

	return SCRIPT_CONTINUE;
}

trigger DoRestoreItemDecorationLayoutRotationOnly(obj_id item, float qw, float qx, float qy, float qz)
{
	if (!isIdValid(item) || !exists(item))
		return SCRIPT_OVERRIDE;

	if(hasScript(self, performance.MUSIC_HEARTBEAT_SCRIPT))
	{
		string_id message = new string_id("player_structure", "cant_move_while_entertaining");
		sendSystemMessage(self, message);
		return SCRIPT_OVERRIDE;
	}

	if(!isMoveCommandValid(self, item))
		return SCRIPT_OVERRIDE;

	session.logActivity(self, session.ACTIVITY_DECORATE);

	setQuaternion(item, qw, qx, qy, qz);

	messageTo(item, "furniture_rotated", null, 1.0f, false);

	return SCRIPT_CONTINUE;
}

commandHandler nameStructure()
{
	//LOG("LOG_CHANNEL", "player_building::nameStructure");

	//LOG("LOG_CHANNEL", "params ->" + params);

	obj_id structure = player_structure.getStructure(self);
	if(!isIdValid(structure))
	{
		LOG("LOG_CHANNEL", self + " ->You must in a building or near an installation to use that command.");
		sendSystemMessage(self, new string_id(STF, "command_no_building")); // You must in a building or near an installation to use that command.
		return SCRIPT_CONTINUE;
	}

	string template = getTemplateName(structure);

	if(player_structure.isCivic(structure))
	{
		//we are going to allow cloning centers and gardens to be renamed
		if(!(template.indexOf("cloning_") > -1) && !(template.indexOf("garden_") > -1))
		{
			return SCRIPT_CONTINUE;
		}
	}

	if(!player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;

	if(!player_structure.isOwner(structure, self))
	{
		LOG("LOG_CHANNEL", "You must be the owner to rename a structure.");
		sendSystemMessage(self, new string_id(STF, "rename_must_be_owner")); // You must be the owner to rename a structure.
		return SCRIPT_CONTINUE;
	}

	if(hasObjVar(structure, hq.VAR_HQ_BASE))
	{
		sendSystemMessage(self, new string_id(STF, "no_rename_hq")); // You may not rename a factional headquarters.
		return SCRIPT_CONTINUE;
	}

	obj_id nameTarget = structure;

	if(player_structure.isBuilding(structure))
	{
		obj_id sign = getObjIdObjVar(structure, player_structure.VAR_SIGN_ID);
		if(isIdValid(sign))
			nameTarget = sign;
	}

	// remove leading @'s to prevent name from being interpreted as code string
	int i = 0;
	int textlen = params.length();
	while(textlen > i && '@' == params.charAt(i))
	{
		++i;
	}
	params = params.substring(i, textlen);

	if(params == null || params.length() < 1)
	{
		string title  = utils.packStringId (SID_SET_NAME_TITLE);
		string prompt = utils.packStringId (SID_SET_NAME_PROMPT);

		sui.filteredInputbox(self, self, prompt, title, "msgNameStructure", player_structure.getStructureName(structure));
		return SCRIPT_CONTINUE;
	}

	if(!isAppropriateText(params))
	{
		LOG("LOG_CHANNEL", self + " ->That is not a valid name.");
		sendSystemMessage(self, new string_id(STF, "not_valid_name")); // That is not a valid name.
		return SCRIPT_CONTINUE;
	}

	string abandonedText = "";

	// if the structure is abandoned and the name does not contained abandoned text, add it
	if(player_structure.isAbandoned(structure) || player_structure.isPreAbandoned(structure))
	{
		// params is not null
		if(params.indexOf(player_structure.ABANDONED_TEXT) == -1)
		{
			if(params.length() > 100)
				 params = params.substring(0, 99);

			abandonedText = player_structure.ABANDONED_TEXT;
		}
	}

	setName(nameTarget, params + abandonedText);

	LOG("LOG_CHANNEL", nameTarget + " ->Structure renamed to '" + params + abandonedText + "'.");

	if(nameTarget == structure)
	{
		sendSystemMessage(self, new string_id(STF, "structure_renamed")); // Structure renamed.
	}
	else
	{
		setObjVar(structure, player_structure.VAR_SIGN_NAME, params);
		prose_package ppSignNamed = prose.getPackage(PROSE_SIGN_NAME_UPDATED, params);
		sendSystemMessageProse(self, ppSignNamed);
	}

	return SCRIPT_CONTINUE;
}

commandHandler paWithdraw()
{
	//LOG("LOG_CHANNEL", "player_building::paWithdraw");

	obj_id structure = player_structure.getStructure(self);
	if(utils.isFreeTrial(self))
		return SCRIPT_CONTINUE;

	if(!player_structure.isGuildHall(structure))
	{
		LOG("LOG_CHANNEL", self + " ->You can only do that in a guild hall.");
		sendSystemMessage(self, new string_id(STF, "only_in_guildhall")); // You can only do that in a guild hall.
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;

	if(!player_structure.isAdmin(structure, self))
	{
		LOG("LOG_CHANNEL", self + " ->You must be an administrator to remove credits from the treasury.");
		sendSystemMessage(self, new string_id(STF, "withdraw_admin_only")); // You must be an administrator to remove credits from the treasury.
		return SCRIPT_CONTINUE;
	}

	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if(st.countTokens() == 0)
	{
		// if no amount is specified go into sui mode
		int pid = sui.inputbox(self, self, utils.packStringId(SID_SUI_AMOUNT_TO_WITHDRAW), "msgWithdrawMaintenance");

		return SCRIPT_CONTINUE;
	}

	string amt_str = st.nextToken();
	int amt = utils.stringToInt(amt_str);
	if(amt < 1)
	{
		LOG("LOG_CHANNEL", self + " ->The amount must be greater than zero.");
		sendSystemMessage(self, new string_id(STF, "amt_greater_than_zero")); // The amount must be greater than zero.
		return SCRIPT_CONTINUE;
	}

	if(!money.hasFunds(structure, money.MT_TOTAL, amt))
	{
		LOG("LOG_CHANNEL", self + " ->Insufficent funds for withdrawal.");
		sendSystemMessage(self, new string_id(STF, "insufficient_funds_withdrawal")); // Insufficent funds for withdrawal.
	}
	else
		player_structure.withdrawMaintenance(self, structure, amt);

	return SCRIPT_CONTINUE;
}

// Furniture move command handlers.
commandHandler itemRotateRight()
{
	int rotateDegrees = getFurnitureRotationDegree(self);
	queueCommand(self, ##"rotateFurniture", target, "yaw -" + rotateDegrees + " " + target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateLeft()
{
	int rotateDegrees = getFurnitureRotationDegree(self);
	queueCommand(self, ##"rotateFurniture", target, "yaw " + rotateDegrees + " " + target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateForward()
{
	if(player_structure.canRotateFurnitureInPitchRollAxes(self) || isGod(self))
	{
		int rotateDegrees = getFurnitureRotationDegree(self);
		queueCommand(self, ##"rotateFurniture", target, "pitch " + rotateDegrees + " " + target, COMMAND_PRIORITY_DEFAULT);
	}

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateBackward()
{
	if(player_structure.canRotateFurnitureInPitchRollAxes(self) || isGod(self))
	{
		int rotateDegrees = getFurnitureRotationDegree(self);
		queueCommand(self, ##"rotateFurniture", target, "pitch -" + rotateDegrees + " " + target, COMMAND_PRIORITY_DEFAULT);
	}

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateClockwise()
{
	if(player_structure.canRotateFurnitureInPitchRollAxes(self) || isGod(self))
	{
		int rotateDegrees = getFurnitureRotationDegree(self);
		queueCommand(self, ##"rotateFurniture", target, "roll " + rotateDegrees + " " + target, COMMAND_PRIORITY_DEFAULT);
	}

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateCounterclockwise()
{
	if(player_structure.canRotateFurnitureInPitchRollAxes(self) || isGod(self))
	{
		int rotateDegrees = getFurnitureRotationDegree(self);
		queueCommand(self, ##"rotateFurniture", target, "roll -" + rotateDegrees + " " + target, COMMAND_PRIORITY_DEFAULT);
	}

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateRandom()
{
	if(player_structure.canRotateFurnitureInPitchRollAxes(self) || isGod(self))
		queueCommand(self, ##"rotateFurniture", target, "random "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateRandomYaw()
{
	queueCommand(self, ##"rotateFurniture", target, "yaw random "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateRandomPitch()
{
	if(player_structure.canRotateFurnitureInPitchRollAxes(self) || isGod(self))
		queueCommand(self, ##"rotateFurniture", target, "pitch random "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateRandomRoll()
{
	if(player_structure.canRotateFurnitureInPitchRollAxes(self) || isGod(self))
		queueCommand(self, ##"rotateFurniture", target, "roll random "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateReset()
{
	queueCommand(self, ##"rotateFurniture", target, "reset "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemRotateCopy()
{
	queueCommand(self, ##"rotateFurniture", target, "copy "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemMoveForward()
{
	queueCommand(self, ##"moveFurniture", target, "forward 10 "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemMoveBack()
{
	queueCommand(self, ##"moveFurniture", target, "back 10 "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemMoveLeft()
{
	queueCommand(self, ##"moveFurniture", target, "left 10 "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemMoveRight()
{
	queueCommand(self, ##"moveFurniture", target, "right 10 "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemMoveUp()
{
	queueCommand(self, ##"moveFurniture", target, "up 1 "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemMoveDown()
{
	queueCommand(self, ##"moveFurniture", target, "down 1 "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemMoveCopyLocation()
{
	queueCommand(self, ##"moveFurniture", target, "copy location "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler itemMoveCopyHeight()
{
	queueCommand(self, ##"moveFurniture", target, "copy height "+target, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

commandHandler cmdAddPower()
{
	LOG("LOG_CHANNEL", "player_building::cmdAddPower");
	if(utils.hasScriptVar(self, "addPower.pid"))
	{
		int oldpid = utils.getIntScriptVar(self, "addPower.pid");
		sui.closeSUI(self, oldpid);
		utils.removeScriptVarTree(self, "addPower");
	}

	obj_id structure = player_structure.getStructure(self);
	if(!player_structure.isOwner(structure, self))
	{
		if(utils.isFreeTrial(self))
		{
			sendSystemMessage(self, SID_TRIAL_STRUCTURE);
			return SCRIPT_CONTINUE;
		}
	}

	if(!isIdValid(structure))
	{
		LOG("LOG_CHANNEL", "You must be in a building, be near an installation, or have one targeted to do that.");
		sendSystemMessage(self, new string_id(STF, "no_building")); // You must be in a building, be near an installation, or have one targeted to do that.
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.isAdmin(structure, self))
	{
		LOG("LOG_CHANNEL", "You must be a building admin to do that.");
		sendSystemMessage(self, new string_id(STF, "must_be_admin")); // You must be a building admin to do that.
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;

	if(player_structure.isCivic(structure))
		return SCRIPT_CONTINUE;

	if(getPowerRate(structure) <= 0)
	{
		sendSystemMessage(self, new string_id(STF, "no_power_needed")); // This structure does not require power. Aborting...
		return SCRIPT_CONTINUE;
	}

	int amt = 0;
	if(params == null || params.equals(""))
	{

		//sendSystemMessageTestingOnly(self, "SYNTAX: /addPower <amount> (with installation as target)");
		//string_id select_power_amount = new string_id(STF, "select_power_amount");
		//string prompt = getString(select_power_amount) + "\n\n";

		// prompt += prose.getPackage(getString(new string_id (STF, "current_power_value")), (int)getPowerValue(structure));

		int totalEnergy = resource.getEnergyTotalOnTarget(self);
		int maint_pool = getBankBalance(structure);
		int pid = sui.transfer(self, self, getString(new string_id (STF, "select_power_amount")) + "\n\n" + getString(new string_id (STF, "current_power_value")) + (int)getPowerValue(structure), "@player_structure:add_power", "@player_structure:total_energy", totalEnergy, "@player_structure:to_deposit", 0, "msgAddPower");
		if(pid > -1)
		{
			utils.setScriptVar(self, "addPower.pid", pid);
			utils.setScriptVar(self, "addPower.target", structure);
		}
		return SCRIPT_CONTINUE;
	}
	else
	{
		amt = utils.stringToInt(params);
		if(amt < 1)
		{
			sendSystemMessage(self, SID_UNABLE_TO_PARSE); // The system was unable to parse a valid power amount.
			sendSystemMessage(self, SID_VALID_AMOUNT); // Please enter a valid power amount greater than 0.
			return SCRIPT_CONTINUE;
		}
	}

	int inInv = 0;
	dictionary d = new dictionary();

	obj_id[] contents = utils.getFilteredPlayerContents(self);
	if((contents == null) || (contents.length == 0))
	{
		return SCRIPT_CONTINUE;
	}

	for(int n = 0; n < contents.length; n++)
	{
		int got = getGameObjectType(contents[n]);
		if(isGameObjectTypeOf(got, GOT_resource_container))
		{
			obj_id crate = contents[n];
			if(isIdValid(crate))
			{
				obj_id rId = getResourceContainerResourceType(crate);
				if(isIdValid(rId))
				{
					if(isResourceDerivedFrom(rId, "energy") || isResourceDerivedFrom(rId, "radioactive"))
					{
						//int inCrate = getResourceContainerQuantity(crate);
						int inCrate = resource.getPotentialEnergyValue(crate);
						inInv += inCrate;
						d.put(crate.toString(), inCrate);
					}
				}
			}
		}
	}

	if(inInv < 1)
	{
		return SCRIPT_CONTINUE;
	}

	if(amt > inInv)
	{
		//cheater!!
		sendSystemMessage(self, SID_NOT_ENOUGH_ENERGY); // You do not have %DI units of energy in your inventory!
		sendSystemMessage(self, SID_POWER_DEPOSIT_INCOMPLETE); // Power deposit incomplete.
		return SCRIPT_CONTINUE;
	}

	int toTransfer = amt;

	java.util.Enumeration keys = d.keys();
	while (keys.hasMoreElements())
	{
		string key = (string)(keys.nextElement());
		obj_id crate = utils.stringToObjId(key);
		if(isIdValid(crate))
		{
			int inCrate = d.getInt(key);
			if(toTransfer < inCrate)
			{
				obj_id rId = getResourceContainerResourceType(crate);
				if(isIdValid(rId))
				{
					int toRemove = (int)(Math.ceil(toTransfer/resource.getEnergyPowerRatio(rId)));
					removeResourceFromContainer(crate, rId, toRemove);
					toTransfer -= toTransfer;
				}
			}
			else
			{
				destroyObject(crate);
				toTransfer -= inCrate;
			}
		}

		if(toTransfer < 1)
		{
			break;
		}
	}

	if(toTransfer > 0)
	{
		sendSystemMessage(self, SID_ERROR_POWER_DEPOSIT); // There has been an error in your power deposit. Please try again.
		return SCRIPT_CONTINUE;
	}

	float cur = player_structure.powerInstallation(structure, amt);
	if(cur > -1f)
	{
		sendSystemMessageProse(self, prose.getPackage(new string_id (STF, "deposit_successful"), amt)); // You successfully deposit %DI units of energy.
		sendSystemMessageProse(self, prose.getPackage(new string_id (STF, "reserve_report"), (int)cur)); // Energy reserves now at %DI units.
	}
	else
	{
		sendSystemMessage(self, SID_POWER_DEPOSIT_FAIL); // Your power deposit failed for an unknown reason...
	}

	return SCRIPT_CONTINUE;
}

commandHandler assignDroid()
{
	obj_id structure = player_structure.getStructure(self);

	if(!player_structure.isOwner(structure, self))
	{
		if(utils.isFreeTrial(self))
		{
			sendSystemMessage(self, SID_TRIAL_STRUCTURE);
			return SCRIPT_CONTINUE;
		}
	}

	if(!isIdValid(structure))
	{
		LOG("LOG_CHANNEL", self + " ->You must in a building or near an installation to use that command.");
		sendSystemMessage(self, new string_id(STF, "command_no_building")); // You must in a building or near an installation to use that command.
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isCivic(structure))
		return SCRIPT_CONTINUE;

	if(!player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;

	if(!player_structure.isAdmin(structure, self))
	{
		LOG("LOG_CHANNEL", "You must be a building admin to do that.");
		sendSystemMessage(self, new string_id(STF, "must_be_admin")); // You must be a building admin to do that.
		return SCRIPT_CONTINUE;
	}

	obj_id[] droid_list = player_structure.getMaintenanceDroids(self);

	if(droid_list.length <= 0)
	{
		LOG("LOG_CHANNEL", "You do not have any maintenance capable droids.");
		sendSystemMessage(self, new string_id(STF, "no_droids")); // You do not have any maintenance capable droids.
		return SCRIPT_CONTINUE;
	}

	string[] list = new string[droid_list.length];
	for(int i = 0; i < list.length; i++)
	{
		list[i] = getEncodedName(droid_list[i]);
	}

	string title  = utils.packStringId (SID_ASSIGN_DROID_TITLE);
	string prompt = utils.packStringId (SID_ASSIGN_DROID_PROMPT);

	sui.listbox(self, self, prompt, sui.OK_CANCEL, title, list, "msgAssignDroid");

	return SCRIPT_CONTINUE;
}

//First time through handler we have no paramaters so we populate the transfer window
//second time through we should have some params value greater than zero
commandHandler cmdDepositPowerIncubator()
{
	obj_id player = self;
	obj_id station = target;
	int amt = 0;

	//not your station
	if(!incubator.validateActiveUser(station, player))
	{
		return SCRIPT_CONTINUE;
	}

	if(utils.hasScriptVar(player, "depositPowerIncubator.pid"))
	{
		int oldpid = utils.getIntScriptVar(player, "depositPowerIncubator.pid");
		sui.closeSUI(player, oldpid);
		utils.removeScriptVarTree(player, "depositPowerIncubator");
	}

	if(params == null || params.equals(""))
	{
		dictionary energyInfo = resource.getGeoThermalEnergyInformationOnTarget(player);
		int totalEnergy = energyInfo.getInt("cnt");
		int resourceQuality = energyInfo.getInt("resourceQuality");
		string resourceName = energyInfo.getString("resourceName");

		if(resourceName == null || resourceName == "")
			return SCRIPT_CONTINUE;

		if(totalEnergy > 0)
		{

			//lets populate the slider with the max amount that can go into the station
			if(totalEnergy >=incubator.RESOURCE_POWER_AMOUNT_CAP)
				totalEnergy = incubator.RESOURCE_POWER_AMOUNT_CAP;

			//make sure we are still capping at max
			if(incubator.hasPower(station))
			{
				int amountInStation = incubator.getStationPowerAmount(station);
				int totalEnergyCap = incubator.RESOURCE_POWER_AMOUNT_CAP - amountInStation;

				if(totalEnergy >= totalEnergyCap)
					totalEnergy = totalEnergyCap;
			}

			//make sure we arent squashing whats in station
			if(!incubator.addPowerPreCheck(station, player, totalEnergy, resourceName))
				return SCRIPT_CONTINUE;

			int pid = sui.transfer(player, player, getString(SID_SELECT_POWER_AMOUNT) + "\n" + getString(SID_CURRENT_POWER_AMOUNT) + incubator.getStationPowerAmount(station) +"\n" + getString(SID_POWER_NAME) + resourceName  +"\n" + getString(SID_POWER_QUALITY) + resourceQuality , "@player_structure:add_power", "@player_structure:total_energy", totalEnergy, "@player_structure:to_deposit", 0, "msgDepositPowerIncubator");
			if(pid > -1)
			{
				utils.setScriptVar(self, "depositPowerIncubator.pid", pid);
				utils.setScriptVar(self, "depositPowerIncubator.target", station);
				//special scriptvar to remember powerName
				utils.setScriptVar(self, "powerIncubator.resourceName", resourceName);
			}
		}
		else
		{
			//no geothermal in inventory
			sendSystemMessage(player, SID_NO_GEO_POWER);
		}
		return SCRIPT_CONTINUE;
	}
	else
	{
		amt = utils.stringToInt(params);
		if(amt < 1)
		{
			// The system was unable to parse a valid power amount, Please enter a valid power amount greater than 0.
			sendSystemMessage(player, SID_UNABLE_TO_PARSE);
			sendSystemMessage(player, SID_VALID_AMOUNT);
			return SCRIPT_CONTINUE;
		}
	}


	int inInventory = 0;
	int resourceQuality = 0;
	dictionary resourceInfo = new dictionary();
	obj_id[] contents = utils.getFilteredPlayerContents(player);
	resizeable obj_id [] tempList = new obj_id[0];
	string resourceName = utils.getStringScriptVar(self, "powerIncubator.resourceName");

	if(resourceName != null && resourceName != "")
		tempList.addElement(resourceName);


	if((contents == null) || (contents.length == 0) || (tempList.length == 0))
	{
		return SCRIPT_CONTINUE;
	}
	//go through inventory and tag everything in inventory for potential usage
	for(int n = 0; n < contents.length; n++)
	{
		int got = getGameObjectType(contents[n]);
		if(isGameObjectTypeOf(got, GOT_resource_container))
		{
			obj_id resourceCrate = contents[n];
			if(isIdValid(resourceCrate))
			{
				obj_id resourceId = getResourceContainerResourceType(resourceCrate);
				if(isIdValid(resourceId))
				{
					if(isResourceDerivedFrom(resourceId, "energy_renewable_site_limited_geothermal"))
					{
						string tempResourceName=getResourceName(resourceId);
						//if the energy already exists in dictionary add to the count
						if(tempList.contains(tempResourceName))
						{
							resourceQuality = getResourceAttribute(resourceId, "res_quality");
							int inCrate = getResourceContainerQuantity(resourceCrate);
							inInventory += inCrate;
							resourceInfo.put(resourceCrate.toString(), inCrate);
						}
					}
				}
			}
		}
	}

	//no longer need to preserve name of Power
	utils.removeScriptVarTree(player, "powerIncubator");

	if(inInventory < 1)
	{
		return SCRIPT_CONTINUE;
	}

	if(amt > inInventory)
	{
		//cheater!!
		// You do not have %DI units of energy in your inventory!
		sendSystemMessage(player, SID_NOT_ENOUGH_ENERGY);
		sendSystemMessage(player, SID_POWER_DEPOSIT_INCOMPLETE);
		return SCRIPT_CONTINUE;
	}

	//make sure we arent squashing whats in station and not going over the limit cap
	if(!incubator.addPowerPreCheck(station, player, amt, resourceName))
		return SCRIPT_CONTINUE;

	//goes through and removes from the players inventory the flagged power
	int toTransfer = amt;
	java.util.Enumeration keys = resourceInfo.keys();
	while (keys.hasMoreElements())
	{
		string key = (string)(keys.nextElement());
		obj_id resourceCrate = utils.stringToObjId(key);
		if(isIdValid(resourceCrate))
		{
			int inCrate = resourceInfo.getInt(key);
			if(toTransfer < inCrate)
			{
				obj_id resourceId = getResourceContainerResourceType(resourceCrate);
				if(isIdValid(resourceId))
				{
					int toRemove = toTransfer;
					removeResourceFromContainer(resourceCrate, resourceId, toRemove);
					toTransfer -= toTransfer;
				}
			}
			else
			{
				destroyObject(resourceCrate);
				toTransfer -= inCrate;
			}
		}

		if(toTransfer < 1)
		{
			break;
		}
	}

	if(toTransfer > 0)
	{
		// There has been an error in your power deposit. Please try again.
		sendSystemMessage(player, SID_ERROR_POWER_DEPOSIT);
		return SCRIPT_CONTINUE;
	}

	//holy smokes it worked, send the player a message and update station
	if(incubator.addPowerIncubator(station, player, amt, resourceQuality , resourceName))
	{
		// You successfully deposit %DI units of energy.
		sendSystemMessageProse(player, prose.getPackage((SID_DEPOSIT_SUCCESS), amt));

		// Energy reserves now at %DI units.
		sendSystemMessageProse(player, prose.getPackage((SID_RESERVE_REPORT), incubator.getStationPowerAmount(station)));
	}
	else
	{
		// Your power deposit failed for an unknown reason...
		sendSystemMessage(player, SID_POWER_DEPOSIT_FAIL);
	}

	return SCRIPT_CONTINUE;
}

commandHandler cmdRemovePowerIncubator()
{
	obj_id player = self;
	obj_id station = target;

	//not yours
	if(!incubator.validateActiveUser(station, player))
	{
		sendSystemMessage(player, incubator.SID_NOT_YOUR_INCUBATOR);
		return SCRIPT_CONTINUE;
	}
	//removes all power cleans station
	if(incubator.removeAllPowerIncubator(station, player))
		sendSystemMessage(player, SID_POWER_REMOVED);

	return SCRIPT_CONTINUE;
}

commandHandler placeStructureMode()
{
	player_structure.tryEnterPlacementMode(target, self);
	return SCRIPT_CONTINUE;
}

//-----------------------------------------------------------------------------------------

commandHandler failPlaceStructureMode()
{
	LOG("LOG_CHANNEL", "player_building::failPlaceStructureMode");

	sendSystemMessage(self, SID_WRONG_STATE);

	return SCRIPT_CONTINUE;
}

//-----------------------------------------------------------------------------------------

commandHandler setPermission()
{
	LOG("LOG_CHANNEL", "player_building::setPermission-- params ->" + params + " target ->" + target);

	// Get the structre the player is in or the structure he has targeted.
	obj_id structure = player_structure.getStructure(self);

	if(utils.isFreeTrial(self))
	{
		sendSystemMessage(self, SID_TRIAL_NO_MODIFY);
		return SCRIPT_CONTINUE;
	}

	LOG("LOG_CHANNEL", "structure ->" + structure);
	if(!isIdValid(structure))
	{
		LOG("LOG_CHANNEL", "You must be in a building, be near an installation, or have one targeted to do that.");
		sendSystemMessage(self, new string_id(STF, "no_building")); // You must be in a building, be near an installation, or have one targeted to do that.
		return SCRIPT_CONTINUE;
	}

	if(hasObjVar(structure, hq.VAR_HQ_BASE))
		return SCRIPT_CONTINUE;

	string template = getTemplateName(structure);
	if(player_structure.isCivic(structure))
	{
		if(!(template.indexOf("cityhall_") > -1))
		{
			return SCRIPT_CONTINUE;
		}
	}

	if(player_structure.isHarvester(structure) || player_structure.isGenerator(structure))
		return SCRIPT_CONTINUE;

	if(!player_structure.isAdmin(structure, self))
	{
		LOG("LOG_CHANNEL", "You must be a building admin to do that.");
		string_id strSpam = new string_id("player_structure", "not_admin");
		sendSystemMessage(self, strSpam);

		return SCRIPT_CONTINUE;
	}

	if(!player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;

	if(!isPlayer(target) && !isMob(target))
	{
		// We only want players. Ignore any other values for target
		target = obj_id.NULL_ID;
	}

	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if(st.countTokens() == 0)
	{
		LOG("LOG_CHANNEL", "Format: /setPermission <type> <player>");
		sendSystemMessage(self, new string_id(STF, "format_setpermission_type_player")); // Format: /setPermission <type> <player>
		return SCRIPT_CONTINUE;
	}
	// The permission list should be in the first token
	string perm_type = st.nextToken().toUpperCase();

	// If there's a second token, that's the target.
	string target_str = "";
	if(st.hasMoreTokens())
	{
		// Since we want to allow the addition/removal of characters who are off-line,
		// we may not get a valid obj_id in a stringToObjId.  Therefore, we leave it
		// to the player to make certain that the target string is good.
		target_str = st.nextToken();
		if(target_str.length() > 40)
		{
			sendSystemMessage(self, new string_id(STF, "permission_40_char")); // Permission list entries cannot be longer than 40 characters.
			return SCRIPT_CONTINUE;
		}
	}

	// If there's no target yet, check out the player's lookat
	if((target == null)||(target == obj_id.NULL_ID))
	{
		// If we've already got a target string with something in it, that's good enough.
		if(target_str.equals(""))
		{
			target = getLookAtTarget(self);
			// we only want players
			if(!isPlayer(target) && !isMob(target))
			{
				target = obj_id.NULL_ID;
			}
		}
	}

	LOG("LOG_CHANNEL", "perm_type ->" + perm_type + " target ->" + target + " target_str ->" + target_str);

	int perm_switch = -1;

	if(perm_type.equals("ENTRY")) perm_switch = 1;
	if(perm_type.equals("BAN")) perm_switch = 2;
	if(perm_type.equals("ADMIN")) perm_switch = 3;
	//if(perm_type.equals("VENDOR")) perm_switch = 4;
	if(perm_type.equals("HOPPER")) perm_switch = 5;

	// Check to see if the structure can have the specified list.
	// Note: this should be changed to a system where each structure type contains an array of the
	// lists it can have.
	if(player_structure.isBuilding(structure))
	{
		if(perm_switch == 5)
		{
			LOG("LOG_CHANNEL", "Buildings do not have that permission list.");
			sendSystemMessage(self, new string_id(STF, "building_no_permission_list")); // Buildings do not have that permission list.
			return SCRIPT_CONTINUE;
		}
	}

	if(player_structure.isInstallation(structure))
	{
		if(perm_switch == 1 || perm_switch == 2 || perm_switch == 4)
		{
			LOG("LOG_CHANNEL", "Installations do not have that permission list.");
			sendSystemMessage(self, new string_id(STF, "installations_no_permission_list")); // Installations do not have that permission list.
			return SCRIPT_CONTINUE;
		}
	}

	if(isGameObjectTypeOf(getGameObjectType(structure), GOT_ship))
	{
		// ships only have admin lists
		if(perm_switch != 3)
		{
			sendSystemMessage(self, new string_id(STF, "ships_no_permission_list")); // Ships do not have that permission list.
			return SCRIPT_CONTINUE;
		}
	}

	// don't allow editing of admin list on the structure
	// that caused the character to exceed the lot limit
	if ((perm_switch == 3) && (getAccountNumLots(getPlayerObject(self)) > player_structure.MAX_LOTS))
	{
		obj_id lotOverlimitStructure = getObjIdObjVar(self, "lotOverlimit.structure_id");
		if (isIdValid(lotOverlimitStructure) && (lotOverlimitStructure == structure))
		{
			sendSystemMessage(self, new string_id(STF, "lot_overlimit_cannot_edit_admin_list"));
			return SCRIPT_CONTINUE;
		}
	}

	// If no valid target or target string, just show the specified permission list
	if(((target == null) || (target == obj_id.NULL_ID)) && (target_str.equals("")))
	{
		string[] dsrc;
		string title;
		string handler;
		switch (perm_switch)
		{
			case 1:
				if(isGod(self))
				{
					dsrc = player_structure.getCompleteEntryList(structure);
				}
				else
				{
					dsrc = player_structure.getEntryList(structure);
				}
				title = getString(new string_id(STF, "entry_permissions_list"));
				handler = "msgEnterPermissions";
				break;
			case 2:
				dsrc = player_structure.getBanList(structure);
				title = getString(new string_id(STF, "ban_list"));
				handler = "msgBanPermissions";
				break;
			case 3:
				dsrc = player_structure.getAdminListNames(structure);
				title = getString(new string_id(STF, "admin_permissions_list"));
				handler = "msgAdminPermissions";
				break;
			case 4:
				dsrc = player_structure.getVendorList(structure);
				title = getString(new string_id(STF, "vendor_permissions_list"));
				handler = "msgVendorPermissions";
				break;
			case 5:
				dsrc = player_structure.getHopperListNames(structure);
				title = getString(new string_id(STF, "hopper_permissions_list"));
				handler = "msgHopperPermissions";
				break;
			default:
				LOG("LOG_CHANNEL", "You must specify a valid permission list (Entry, Ban, Admin, Hopper)");
				sendSystemMessage(self, new string_id(STF, "must_specify_list")); // You must specify a valid permission list (Entry, Ban, Admin, Hopper)
				return SCRIPT_CONTINUE;
		}
		if(dsrc == null)
		{
			//Listbox can't handle a null dsrc
			dsrc = new string[0];
		}

		// Get players in the building or near the installation.
		obj_id[] players;
		if(player_structure.isBuilding(structure))
		{
			// For buildings get everyone in the building or near it.
			//players = player_structure.getPlayersInBuilding(structure);
			players = getPlayerCreaturesInRange(structure, 30.0f);
		}
		else
			players = player_structure.getPlayersNearInstallation(structure);

		// Determine which can be added to the list. Keep track of their names.
		resizeable string[] player_names = new string[0];
		if(players != null)
		{
			for(int i = 0; i < players.length; i++)
			{
				string player_name = getFirstName(players[i]);
				LOG("LOG_CHANNEL", "Found " + player_name);
				int idx = utils.getElementPositionInArray(dsrc, player_name);
				if(idx == -1)
				{
					LOG("LOG_CHANNEL", "   ...Adding " + player_name);
					player_names = utils.addElement(player_names, player_name);
				}
			}
		}

		LOG("LOG_CHANNEL", "players #->" + player_names.length + " self ->" + self);
		string[] player_names_array = player_names;
		displayStructurePermissionData(self, dsrc, player_names_array, perm_type);

	}
	else
	{
		// We have a target player. Add/Remove that player from the specified list.
		if(target_str.equals(""))
		{
			// We don't have a target string, so take it from the target obj_id
			switch (perm_switch)
			{
				case 1:
					player_structure.modifyEntryList(structure, target, self);
					break;
				case 2:
					player_structure.modifyBanList(structure, target, self);
					break;
				case 3:
					player_structure.modifyAdminList(structure, target, self);
					break;
				case 4:
					player_structure.modifyVendorList(structure, target, self);
					break;
				case 5:
					player_structure.modifyHopperList(structure, target, self);
					break;
				default:
					LOG("LOG_CHANNEL", "You must specify a valid permission list (Entry, Ban, Admin, Hopper)");
					sendSystemMessage(self, new string_id(STF, "must_specify_list")); // You must specify a valid permission list (Entry, Ban, Admin, Hopper)
					return SCRIPT_CONTINUE;
			}
		}
		else
		{
			// We have a target string, so take it from there
			switch (perm_switch)
			{
				case 1:
					player_structure.modifyEntryList(structure, target_str, self);
					break;
				case 2:
					player_structure.modifyBanList(structure, target_str, self);
					break;
				case 3:
					player_structure.modifyAdminList(structure, target_str, self);
					break;
				case 4:
					player_structure.modifyVendorList(structure, target_str, self);
					break;
				case 5:
					player_structure.modifyHopperList(structure, target_str, self);
					break;
				default:
					LOG("LOG_CHANNEL", "You must specify a valid permission list (Entry, Ban, Admin, Hopper)");
					sendSystemMessage(self, new string_id(STF, "must_specify_list")); // You must specify a valid permission list (Entry, Ban, Admin, Hopper)
					return SCRIPT_CONTINUE;
			}
		}

	}
	return SCRIPT_CONTINUE;
}

commandHandler structureStatus()
{
	LOG("house", "commandHandler:structureStatus");
	if(utils.hasScriptVar(self, "player_structure.status.pid"))
	{
		int oldpid = utils.getIntScriptVar(self, "player_structure.status.pid");
		sui.closeSUI(self, oldpid);
		utils.removeScriptVarTree(self, "player_structure.status");
	}

	LOG("LOG_CHANNEL", "player_building::structureStatus");
	obj_id structure = null;
	if(isIdValid(target))
	{
		if(player_structure.isBuilding(target) || player_structure.isInstallation(target))
		{
			structure = target;
		}
		else
		{
			structure = player_structure.getStructure(target);
		}
	}
	if(structure == null)
		structure = player_structure.getStructure(self);

	LOG("house", "structureStatus - structure = " + structure);
	if(!isIdValid(structure))
	{
		LOG("LOG_CHANNEL", "You must be in a building, be near an installation, or have one targeted to do that.");
		sendSystemMessage(self, new string_id(STF, "no_building")); // You must be in a building, be near an installation, or have one targeted to do that.
		return SCRIPT_CONTINUE;
	}

	string buildingTemplateName = getTemplateName(structure);
	//LOG("hq", "player.player_building:commandHandler structureStatus(): ********* got template of structure. It came in as: "+buildingTemplateName);

	//**UPDATE 8** Allowing Status to be viewed on ALL structures (Civic Structures too!)
	//if(player_structure.isCivic(structure))
	//	return SCRIPT_CONTINUE;

	int sGot = getGameObjectType(structure);
	if(!player_structure.isAdmin(structure, self))
	{
		boolean allowContinue = false;

		if(sGot == GOT_building_factional || sGot == GOT_installation_turret || sGot == GOT_installation_minefield)
		{
			int pFac = pvpGetAlignedFaction(self);
			int sFac = pvpGetAlignedFaction(structure);
			if(pFac == sFac)
				allowContinue = true;
		}

		if(!allowContinue)
		{
			LOG("LOG_CHANNEL", "You must be a building admin to do that.");
			sendSystemMessage(self, new string_id(STF, "must_be_admin")); // You must be a building admin to do that.
			return SCRIPT_CONTINUE;
		}
	}

	if(!player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;

	// Get owner name
	resizeable string[] dsrc = new string[0];
	string owner_name = player_structure.getStructureOwner(structure);
	if(owner_name != null)
	{
		owner_name = toUpper(owner_name, 0);
		string_id owner_prompt_text = new string_id(STF, "owner_prompt"); // Owner:
		dsrc = utils.addElement(dsrc, getString(owner_prompt_text) + owner_name);
	}

	// Check for residency
	if(player_structure.isResidence(structure, self))
	{
		string_id residency_declaration = new string_id(STF, "declared_residency"); // You have declared your residency here.
		dsrc = utils.addElement(dsrc, getString(residency_declaration));
	}

	int civic_var = 0;
	int m_rate = 0;
	int m_rate_base = 0;
	//**UPDATE 8** Civic Structres do not need Privacy, Condition or Maintenance
	if(!player_structure.isCivic(structure))
	{
		// Get privacy
		if(permissionsIsPublic(structure))
		{
			string_id public_structure = new string_id(STF, "structure_public"); // This structure is public
			dsrc = utils.addElement(dsrc, getString(public_structure));
		}
		else
		{
			string_id private_structure = new string_id(STF, "structure_private"); // This structure is private
			dsrc = utils.addElement(dsrc, getString(private_structure));
		}

		// Get structure condition
		int condition = player_structure.getStructureCondition(structure);
		int max_condition = player_structure.getMaxCondition(structure);

		int perc_condition = condition * 100 / max_condition;

		if(perc_condition == 100)
		{
			string_id condition_prompt_text = new string_id(STF, "condition_prompt"); // Condition:
			dsrc = utils.addElement(dsrc, getString(condition_prompt_text) + perc_condition + "%");
		}
		else
		{
			int maint_rate = player_structure.getBaseMaintenanceRate(structure);
			int total_cost = (int)((max_condition - condition) * maint_rate / 3.0f);
			string_id condition_prompt_text_damaged = new string_id(STF, "condition_prompt"); // Condition:
			string_id credits_to_repair_suffix = new string_id(STF, "credits_to_repair"); //  credits to repair.)
			// if(!player_structure.isFactionPerkBase(buildingTemplateName))
			if(buildingTemplateName.indexOf ("object/building/faction_perk/hq/") == -1)
				dsrc = utils.addElement(dsrc, getString(condition_prompt_text_damaged) + perc_condition + "%" + "   (" + total_cost + getString(credits_to_repair_suffix));
			else
				dsrc = utils.addElement(dsrc, getString(condition_prompt_text_damaged) + perc_condition + "%");
		}

		// Get maintenance pool and rate
		int m_pool = player_structure.getMaintenancePool(structure);
		m_rate = player_structure.getMaintenanceRate(structure);

		m_rate_base = player_structure.getBaseMaintenanceRate(structure);

		double time_remaining = (double)m_pool * (double)player_structure.getMaintenanceHeartbeat() / (double)m_rate;
		if(time_remaining < 0 || time_remaining > Integer.MAX_VALUE)
			time_remaining = Integer.MAX_VALUE;

		if(m_pool > 0)
		{
			// Express time in days/hours/minutes/seconds
			//int[] convert_time = player_structure.convertSecondsTime((int)time_remaining);
			//string time_str = player_structure.assembleTimeRemaining(convert_time);

			string time_str = utils.assembleTimeRemainToUse((int)time_remaining, false);

			if(player_structure.isGuildHall(structure))
			{
				string_id treasury_prompt_text = new string_id(STF, "treasury_prompt"); // Treasury:
				dsrc = utils.addElement(dsrc, getString(treasury_prompt_text) + m_pool + "   (" + time_str + ")");
			}
			else
			{
				//if(!(player_structure.isFactionPerkBase(buildingTemplateName)));
				if(buildingTemplateName.indexOf ("object/building/faction_perk/hq/") == -1)
				{
					//LOG("hq", "player.player_structure:commandHandler structureStatus(): ********* It's not a factionPerkBase, displaying maintenance pool for positive pool");
					string_id maintenance_prompt_text = new string_id(STF, "maintenance_pool_prompt"); // Maintenance Pool:
					dsrc = utils.addElement(dsrc, getString(maintenance_prompt_text) + m_pool + "   (" + time_str + ")");
				}
			}
		}
		else
		{
			if(player_structure.isGuildHall(structure))
			{
				string_id treasury_empty_text = new string_id(STF, "treasury_prompt"); // Treasury:
				dsrc = utils.addElement(dsrc, getString(treasury_empty_text) + m_pool);
			}
			else
			{
				//if(!(player_structure.isFactionPerkBase(buildingTemplateName)));
				if(buildingTemplateName.indexOf ("object/building/faction_perk/hq/") == -1)
				{
					//LOG("hq", "player.player_structure:commandHandler structureStatus(): ********* It's not a factionPerkBase, displaying maintenance pool for empty pool");

					string_id maintenance_empty_text = new string_id(STF, "maintenance_pool_prompt"); // Maintenance Pool:
					dsrc = utils.addElement(dsrc, getString(maintenance_empty_text) + m_pool);
				}
			}
		}

	}
	int hourly_m_rate = m_rate*(3600/player_structure.getMaintenanceHeartbeat());

	civic_var = getIntObjVar(structure, player_structure.VAR_CIVIC);
	if(civic_var == 1)
		hourly_m_rate = 0;

	//if(!player_structure.isFactionPerkBase(buildingTemplateName));
	if(buildingTemplateName.indexOf ("object/building/faction_perk/hq/") == -1)
	{
		//LOG("hq", "player.player_structure:commandHandler structureStatus(): ********* It's not a factionPerkBase, displaying maintenance pool rate");

		if(m_rate == m_rate_base)
		{
			string_id maintenance_rate_text = new string_id(STF, "maintenance_rate_prompt"); // Maintenance Rate:
			dsrc = utils.addElement(dsrc, getString(maintenance_rate_text) + Integer.toString(hourly_m_rate) + " cr/hr");
		}
		else
		{
			int hourly_m_rate_base = m_rate_base*(3600/player_structure.getMaintenanceHeartbeat());
			string_id maintenance_rate_mod_text = new string_id(STF, "maintenance_rate_prompt"); // Maintenance Rate:
			dsrc = utils.addElement(dsrc, getString(maintenance_rate_mod_text) + Integer.toString(hourly_m_rate) + " cr/hr ("+hourly_m_rate_base+")");
		}
	}

	//if(!player_structure.isFactionPerkBase(buildingTemplateName));
	if(buildingTemplateName.indexOf ("object/building/faction_perk/hq/") == -1)
	{
		//LOG("hq", "player.player_structure:commandHandler structureStatus(): ********* It's not a factionPerkBase, calculating property tax");

		int property_tax = city.getPropertyTax(structure);
		if(property_tax > 0)
		{
			string_id maintenance_rate_mod_text = new string_id(STF, "property_tax_rate_prompt"); // Property Tax:
			dsrc = utils.addElement(dsrc, getString(maintenance_rate_mod_text) + property_tax + "%");
		}
	}
	//if is installation of type harvester or factory...
	if(player_structure.isHarvester(structure) || player_structure.isFactory(structure))
	{
		float p_pool = getPowerValue(structure);
		float p_rate = getPowerRate(structure);
		int p_time = Math.round(p_pool / p_rate * 3600f); //power is per hour!

		if(p_pool > 0)
		{
			// Express time in days/hours/minutes/seconds
			//string p_time_string = utils.formatTime((int)p_time);
			//int[] convert_time = player_structure.convertSecondsTime(p_time);
			//string p_time_string = player_structure.assembleTimeRemaining(convert_time);

			string p_time_string = utils.assembleTimeRemainToUse(p_time, false);

			string_id power_reserve_empty_text = new string_id(STF, "power_reserve_prompt");
			dsrc = utils.addElement(dsrc, getString(power_reserve_empty_text) + (int)p_pool + "   (" + p_time_string + ")");
		}
		else
		{
			string_id power_reserve_text = new string_id(STF, "power_reserve_prompt");
			dsrc = utils.addElement(dsrc, getString(power_reserve_text) + (int)p_pool);
		}
		string_id power_consumption_text = new string_id(STF, "power_consumption_prompt");
		string_id units_per_hour_text = new string_id(STF, "units_per_hour");
		dsrc = utils.addElement(dsrc, getString(power_consumption_text) + Integer.toString((int)p_rate) + getString(units_per_hour_text));
	}

	if(sGot == GOT_building_factional && hasObjVar(structure, hq.VAR_HQ_BASE))
	{
		if(player_structure.isAdmin(structure, self) || pvpGetCurrentGcwRank(self) >= 6)
		{
			int now = getGameTime();

			string_id resource_reserves_text = new string_id(STF, "resource_reserves_prompt");
			string_id units_suffix_text = new string_id(STF, "units_suffix");
			dsrc = utils.addElement(dsrc, getString(resource_reserves_text) + getIntObjVar(structure, hq.VAR_HQ_RESOURCE_CNT) + getString(units_suffix_text));

			if(hasObjVar(structure, player_structure.VAR_LAST_MAINTANENCE))
			{
				int stamp = getIntObjVar(structure, player_structure.VAR_LAST_MAINTANENCE);
				int maint_delta = stamp + player_structure.getMaintenanceHeartbeat() - now;
				if(maint_delta > 0)
				{
					int[] mTime = player_structure.convertSecondsTime(maint_delta);
					string m_time_string = player_structure.assembleTimeRemaining(mTime);
					string_id repair_cycle_text = new string_id(STF, "next_repair_cycle");
					dsrc = utils.addElement(dsrc, getString(repair_cycle_text) + m_time_string);
				}
			}

			if(hasObjVar(structure, hq.VAR_OBJECTIVE_STAMP))
			{
				long current = System.currentTimeMillis();
				long curTime = ((current / 1000) - 1072224000);

				int currentTime = (int) curTime;

				int stamp = getIntObjVar(structure, hq.VAR_OBJECTIVE_STAMP);
				int objective_delta = stamp + (int)(hq.VULNERABILITY_CYCLE) - currentTime;
				if(objective_delta > 0)
				{
					int[] oTime = player_structure.convertSecondsTime(objective_delta);
					string o_time_string = player_structure.assembleTimeRemaining(oTime);
					string_id vulnerability_text = new string_id(STF, "next_vulnerability_prompt");
					dsrc = utils.addElement(dsrc, getString(vulnerability_text) + o_time_string);
				}
			}
		}
	}

	// Get number of items in the structure
	if(player_structure.isBuilding(structure))
	{
		int numItems = player_structure.getStructureNumItems(structure);
		string_id building_items_text = new string_id(STF, "items_in_building_prompt");
		dsrc = utils.addElement(dsrc, getString(building_items_text) + numItems);

		// Display current max capacity of the structure
		int itemLimit = getPobBaseItemLimit(structure);
		//check to see if we have an increase to the structure storage
		if(hasObjVar(structure, "structureChange.storageIncrease"))
		{
			int storageIncrease = getIntObjVar(structure, "structureChange.storageIncrease");
			itemLimit += storageIncrease;
		}
		dsrc = utils.addElement(dsrc, "@player_structure:total_house_storage" + " " + itemLimit);
	}

	// Check for storage increase objvar and report it
	if(hasObjVar(structure, "structureChange.storageIncrease"))
	{
		int storageIncrease = getIntObjVar(structure, "structureChange.storageIncrease");
		string_id storage_increase = new string_id(STF, "structure_storage_increase"); // This structure has increased storage
		dsrc = utils.addElement(dsrc, getString(storage_increase) + storageIncrease);
	}
	// Draw the list box with all of the info.
	string prompt = "";

	string structure_name = player_structure.getStructureName(structure);
	if(structure_name != null && !structure_name.equals(""))
	{
		string_id structure_name_text = new string_id(STF, "structure_name_prompt");
		prompt += getString(structure_name_text) + structure_name;
	}
	int maint_stamp = getIntObjVar(structure, player_structure.VAR_LAST_MAINTANENCE);
	int now = getGameTime();
	if(now < maint_stamp)
	{
		string_id free_maintenance_text = new string_id(STF, "free_maintenance_time");
		prompt += "\n\\#pcontrast1" + getString(free_maintenance_text) + "\\#. ";

		int prepaid_delta = maint_stamp - now;
		int[] prepaidTime = player_structure.convertSecondsTime(prepaid_delta);
		string prepaidTimeString = player_structure.assembleTimeRemaining(prepaidTime);
		if(prepaidTimeString != null && !prepaidTimeString.equals(""))
		{
			prompt += prepaidTimeString;
		}
		else
		{
			string_id seconds_suffix_text = new string_id(STF, "seconds_suffix");
			prompt += Integer.toString(prepaid_delta) + getString(seconds_suffix_text);
		}
	}

	string maint_mods_string = "";
	if(civic_var == 1)
	{
		string_id civic_structure_alert_text = new string_id(STF, "civic_structure_alert");
		maint_mods_string += "\n- " + getString(civic_structure_alert_text);
	}
	else
	{
		if(hasObjVar(structure, player_structure.VAR_MAINTENANCE_MOD_MERCHANT))
		{
			float merchant_mod = getFloatObjVar(structure, player_structure.VAR_MAINTENANCE_MOD_MERCHANT);
			string_id merch_mod_text = new string_id(STF, "merch_mod_prompt");
			maint_mods_string += "\n- " + getString(merch_mod_text) +Integer.toString((int)(merchant_mod*100f))+"%";
		}

		int maint_property_tax = player_structure.getMaintenancePropertyTax(structure);
		if(maint_property_tax > 0)
		{
			int hourly_tax = Math.round(maint_property_tax * (3600f/player_structure.getMaintenanceHeartbeat()));
			string_id property_tax_rate_text = new string_id(STF, "property_tax_rate_prompt");
			maint_mods_string += "\n- " + getString(property_tax_rate_text) +Integer.toString(hourly_tax)+"cr/hr";
		}
	}

	if(maint_mods_string != null && !maint_mods_string.equals(""))
	{
		string_id maintenance_mods_text = new string_id(STF, "maintenance_mods_prompt");
		prompt += "\n\n" + getString(maintenance_mods_text) + maint_mods_string;
	}

	int pid = sui.listbox(self, self, prompt, sui.REFRESH_CANCEL, "@player_structure:structure_status_t", dsrc, "handleStatusUi");
	if(pid > -1)
	{
		utils.setScriptVar(self, "player_structure.status.pid", pid);
		utils.setScriptVar(self, "player_structure.status.target", structure);
		if(isIdValid(target))
		{
			LOG("house", "StructureStatus:: FROM SCD = true");
			utils.setScriptVar(self, "player_structure.status.fromScd", 1);
		}
	}
	return SCRIPT_CONTINUE;
}

commandHandler payMaintenance()
{
	obj_id structure = null;
	if(isIdValid(target))
	{
		if(player_structure.isBuilding(target) || player_structure.isInstallation(target))
		{
			structure = target;
		}
		else
		{
			structure = player_structure.getStructure(target);
		}
	}
	if(structure == null)
		structure = player_structure.getStructure(self);

	if(!isIdValid(structure))
	{
		sendSystemMessage(self, new string_id(STF, "no_building")); // You must be in a building, be near an installation, or have one targeted to do that.
		return SCRIPT_CONTINUE;
	}
	LOG("house", "payMaintenance - structure = " + structure);

	if(!player_structure.isOwner(structure, self))
	{
		if(utils.isFreeTrial(self))
		{
			sendSystemMessage(self, SID_TRIAL_STRUCTURE);
			return SCRIPT_CONTINUE;
		}
	}

	if(player_structure.isCivic(structure))
		return SCRIPT_CONTINUE;

	string buildingTemplate = getTemplateName(structure);
	if(buildingTemplate == null)
	{
		LOG("LOG_CHANNEL", "player_structure::payMaintenance -- Unable to find template for building.");
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isFactionPerkBase(buildingTemplate))
		return SCRIPT_CONTINUE;


	if(utils.hasScriptVar(self, "payMaintenance.pid"))
	{
		int oldpid = utils.getIntScriptVar(self, "payMaintenance.pid");
		sui.closeSUI(self, oldpid);
		utils.removeScriptVarTree(self, "payMaintenance");
	}

	if(!player_structure.isAdmin(structure, self))
	{
		sendSystemMessage(self, new string_id(STF, "must_be_admin")); // You must be a building admin to do that.
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isHarvester(structure) || player_structure.isGenerator(structure))
	{
		if(!player_structure.isOwner(structure, self))
		{
			sendSystemMessage(self, new string_id(STF, "must_be_owner")); // You must be a building admin to do that.
			return SCRIPT_CONTINUE;
		}
	}

	if(!player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;

	java.util.StringTokenizer st = new java.util.StringTokenizer(params);
	if(st.countTokens() == 0)
	{
		// if no amount is specified go into sui mode
		//int pid = sui.inputbox(self, self, "Amount to Pay", "msgPayMaintenance");

		int total = getTotalMoney(self);
		if(total > 0)
		{
			int maint_pool = getBankBalance(structure);
			string_id select_amount = new string_id(STF, "select_maint_amount");
			string prompt = getString(select_amount) + "\n\n ";

			prompt += getString(new string_id(STF, "current_maint_pool")) + maint_pool + "cr.";

			int pid = sui.transfer(self, self, prompt, "@player_structure:select_amount", "@player_structure:total_funds", total, "@player_structure:to_pay", 0, "msgPayMaintenance");
			if(pid > -1)
			{
				utils.setScriptVar(self, "payMaintenance.pid", pid);
				utils.setScriptVar(self, "payMaintenance.target", structure);
			}
		}
		else
		{
			sendSystemMessage(self, new string_id(STF, "no_money")); // You do not have any money to pay maintenance.
		}

		return SCRIPT_CONTINUE;
	}

	string amt_str = st.nextToken();
	int amt = utils.stringToInt(amt_str);
	if(amt < 1 || amt > 100000)
	{
		LOG("LOG_CHANNEL", "The amount must be between 1 and 100000");
		sendSystemMessage(self, new string_id(STF, "amount_params")); // The amount must be between 1 and 100000
		return SCRIPT_CONTINUE;
	}

	player_structure.payMaintenance(self, structure, amt);

	/*
	if(player_structure.payMaintenance(self, structure, amt))
	{
		LOG("LOG_CHANNEL", "You pay " + amt + " into the structure maintenance pool.");
		sendSystemMessageTestingOnly(self, "You pay " + amt + " into the structure maintenance pool.");
	}
	else
	{
		LOG("LOG_CHANNEL", "player_building::payMaintenance -- payMaintenance failed.");
	}
	*/

	return SCRIPT_CONTINUE;
}

commandHandler setPrivacy()
{
	LOG("LOG_CHANNEL", "player_building::setPrivacy");

	obj_id structure = player_structure.getStructure(self);
	if(!player_structure.isOwner(structure, self))
	{
		if(utils.isFreeTrial(self))
			return SCRIPT_CONTINUE;
	}

	if(!isIdValid(structure))
	{
		LOG("LOG_CHANNEL", "You must be in a building to do that.");
		sendSystemMessage(self, new string_id(STF, "must_be_in_building")); // You must be in a building to do that.
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.isBuilding(structure))
	{
		LOG("LOG_CHANNEL", self + " ->You can only alter privacy on a building.");
		sendSystemMessage(self, new string_id(STF, "privacy_building_only")); // You can only alter privacy on a building.
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isCivic(structure))
		return SCRIPT_CONTINUE;

	if(hasObjVar(structure, hq.VAR_HQ_BASE))
	{
		sendSystemMessage(self, new string_id(STF, "no_privacy_faction_hq")); // You may not alter privacy of a factional headquarters.
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.isAdmin(structure, self))
	{
		LOG("LOG_CHANNEL", "You must be a building admin to do that.");
		sendSystemMessage(self, new string_id(STF, "must_be_admin")); // You must be a building admin to do that.
		return SCRIPT_CONTINUE;
	}

	if(hasObjVar(structure, "force_public"))
	{
		sendSystemMessage(self, new string_id(STF, "force_public")); // This structure is always public.
		return SCRIPT_CONTINUE;
	}

	if(permissionsIsPublic(structure))
	{
		// Check for vendors inside this structure.
		string[] cells = getCellNames(structure);
		if(cells != null)
		{
			for(int i=0; i<cells.length; i++)
			{
				obj_id cellid = getCellId(structure, cells[i]);
				obj_id contents[] = getContents(cellid);
				if(contents != null)
				{
					for(int j=0; j<contents.length; j++)
					{
						if(hasCondition(contents[j], CONDITION_VENDOR))
						{
							sendSystemMessage(self, new string_id(STF, "vendor_no_private")); // A structure hosting a vendor cannot be declared private.
							return SCRIPT_CONTINUE;
						}
					}
				}
			}
		}

		LOG("LOG_CHANNEL", "This structure is now private.");
		sendSystemMessage(self, new string_id(STF, "structure_now_private")); // This structure is now private

		// Kick out any mob not on the entry list
		obj_id[] objects = player_structure.getObjectsInBuilding(structure);
		string[] entry_list = player_structure.getCompleteEntryList(structure);
		if(objects != null)
		{
			for(int i = 0; i < objects.length; i++)
			{
				if(hasObjVar(objects[i], "noEject"))
				{
					continue;
				}

				if(isPlayer(objects[i]) || (isMob(objects[i]) && isIdValid(getMaster(objects[i]))) || (isMob(objects[i]) && (getLevel(objects[i])) >= 10))
				{
					int idx = utils.getElementPositionInArray(entry_list, getFirstName(objects[i]));
					if(idx == -1)
						expelFromBuilding(objects[i]);
				}
			}
		}

		permissionsMakePrivate(structure);
	}
	else
	{
		LOG("LOG_CHANNEL", "This structure is now public.");
		sendSystemMessage(self, new string_id(STF, "structure_now_public")); // This structure is now public
		permissionsMakePublic(structure);

		// Remove any existing turnstile.
		if(turnstile.hasTurnstile(structure))
			turnstile.removeTurnstile(structure);
	}

	return SCRIPT_CONTINUE;
}

commandHandler declareResidence()
{
	obj_id structure = player_structure.getStructure(self);
	if(utils.isFreeTrial(self))
	{
		sendSystemMessage(self, SID_NO_DECLARE);
		return SCRIPT_CONTINUE;
	}

	if(!isIdValid(structure))
	{
		LOG("LOG_CHANNEL", "You must be in a building to do that.");
		sendSystemMessage(self, new string_id(STF, "must_be_in_building")); // You must be in a building to do that.
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.isBuilding(structure))
	{
		LOG("LOG_CHANNEL", "Your declared residence must be a building.");
		sendSystemMessage(self, new string_id(STF, "must_be_in_building")); // Your declared residence must be a building.
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isCivic(structure))
		return SCRIPT_CONTINUE;

	if(!player_structure.isOwner(structure, self))
	{
		LOG("LOG_CHANNEL", "You must be the owner of the building to declare residence.");
		sendSystemMessage(self, new string_id(STF, "declare_must_be_owner")); // You may not declare residence at a factional headquarters.
		return SCRIPT_CONTINUE;
	}

	if(hasObjVar(structure, hq.VAR_HQ_BASE))
	{
		sendSystemMessage(self, new string_id(STF, "no_hq_residence")); // You may not declare residence at a factional headquarters.
		return SCRIPT_CONTINUE;
	}

	int current_time = getGameTime();
	if(hasObjVar(self, player_structure.VAR_RESIDENCE_CAN_DECLARE))
	{
		// Check to see that player has not declared residency too recently.
		int declared_time = getIntObjVar(self, player_structure.VAR_RESIDENCE_CAN_DECLARE);
		int duration = current_time - declared_time;
		if(duration < player_structure.MIN_RESIDENCE_DURATION)
		{
			int time_remaining = player_structure.MIN_RESIDENCE_DURATION - duration;
			//int[] time = player_structure.convertSecondsTime(time_remaining);
			string time_str = utils.assembleTimeRemainToUse(time_remaining, false);
			prose_package pp = new prose_package();
			prose.setStringId(pp, new string_id (STF, "change_residence_time"));
			prose.setTT(pp, time_str);
			LOG("LOG_CHANNEL", "You cannot change residence for " + time_str);
			sendSystemMessageProse(self, pp); // You cannot change residence for %NO
			return SCRIPT_CONTINUE;
		}
	}
	if(player_structure.isResidence(structure, self))
	{
		LOG("LOG_CHANNEL", "This building is already your residence.");
		sendSystemMessage(self, new string_id(STF, "already_residence")); // This building is already your residence.
		return SCRIPT_CONTINUE;
	}

	// Mayor cannot declare residence
	int currentCity = getCitizenOfCityId(self);
	obj_id currentCityMayor = cityGetLeader(currentCity);
	if(self == currentCityMayor)
	{
		sendSystemMessage(self, city.SID_MAYOR_RESIDENCE_CHANGE);
		return SCRIPT_CONTINUE;
	}

	// Get old residence.
	obj_id oldresidence = player_structure.getResidence(self);

	// Set new residence.
	LOG("LOG_CHANNEL", "You change your residence to this building");
	sendSystemMessage(self, new string_id(STF, "change_residence")); // You change your residence to this building.
	setHouseId(self, structure);
	setObjVar(self, player_structure.VAR_RESIDENCE_CAN_DECLARE, current_time);

	// For a city's structure/citizen tracking, we need to record the structure's resident
	setObjVar(structure, player_structure.VAR_RESIDENCE_BUILDING, self);

	// Make the player a city citizen if necessary.
	messageTo(oldresidence, "removeResidentVar", null, 0.f, true);
	city.setCityResidence(self, structure);

	//give all the politician skills if you don't already have them:
	skill.grantAllPoliticianSkills(self);

	return SCRIPT_CONTINUE;
}

commandHandler transferStructure()
{
	obj_id structure = player_structure.getStructure(self);
	if(!isIdValid(structure))
	{
		LOG("LOG_CHANNEL", "You must be in a building, be near an installation, or have one targeted to do that.");
		sendSystemMessage(self, new string_id(STF, "no_building")); // You must be in a building, be near an installation, or have one targeted to do that.
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;

	if(!player_structure.isOwner(structure, self))
	{
		LOG("LOG_CHANNEL", self + "-> You are not the owner of this structure.");
		sendSystemMessage(self, new string_id(STF, "not_owner")); // You are not the owner of this structure.
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isCivic(structure))
		return SCRIPT_CONTINUE;

	string structureTemplateName = getTemplateName(structure);
	if(structureTemplateName.indexOf ("object/building/faction_perk/hq/") != -1)
	{
		sendSystemMessage(self, new string_id(STF, "faction_base")); // You cannot transfer a faction base
		return SCRIPT_CONTINUE;
	}

	if(structureTemplateName == "object/building/player/player_house_mustafar_lg.iff")
	{
		sendSystemMessage(self, new string_id(STF, "mustafar_house"));
		return SCRIPT_CONTINUE;
	}
	if(structureTemplateName == "object/building/player/city/barn_no_planet_restriction.iff")
	{
		sendSystemMessage(self, new string_id(STF, "barn_no_transfer"));
		return SCRIPT_CONTINUE;
	}
	if(structureTemplateName == "object/building/player/city/diner_no_planet_restriction.iff")
	{
		sendSystemMessage(self, new string_id(STF, "diner_no_transfer"));
		return SCRIPT_CONTINUE;
	}
	if(structureTemplateName == "object/building/player/player_house_jedi_meditation_room.iff" ||
	structureTemplateName == "object/building/player/player_house_sith_meditation_room.iff")
	{
		sendSystemMessage(self, new string_id(STF, "meditation_room_no_transfer"));
		return SCRIPT_CONTINUE;
	}
	if(structureTemplateName == "object/building/player/player_house_tcg_relaxation_pool.iff")
	{
		sendSystemMessage(self, new string_id(STF, "relaxation_pool_no_transfer"));
		return SCRIPT_CONTINUE;	
	}
	if(structureTemplateName == "object/building/player/player_house_hangar.iff")
	{
		sendSystemMessage(self, new string_id(STF, "hangar_no_transfer"));
		return SCRIPT_CONTINUE;		
	}
	if(structureTemplateName == "object/building/player/player_house_sandcrawler.iff")
	{
		sendSystemMessage(self, new string_id(STF, "sandcrawler_house_no_transfer"));
		return SCRIPT_CONTINUE;		
	}
	if(structureTemplateName == "object/building/player/player_house_atat.iff")
	{
		sendSystemMessage(self, new string_id(STF, "atat_house_no_transfer"));
		return SCRIPT_CONTINUE;		
	}
	if(structureTemplateName == "object/building/player/player_house_tcg_emperors_spire.iff")
	{
		sendSystemMessage(self, new string_id(STF, "tcg_emperors_spire_house_no_transfer"));
		return SCRIPT_CONTINUE;		
	}
	if(structureTemplateName == "object/building/player/player_house_tcg_rebel_spire.iff")
	{
		sendSystemMessage(self, new string_id(STF, "tcg_rebel_spire_house_no_transfer"));
		return SCRIPT_CONTINUE;		
	}
	if( hasObjVar(structure, "playerStructure_noTransfer") )
	{
		sendSystemMessage(self, new string_id(STF, "tcg_player_house_no_transfer"));
		return SCRIPT_CONTINUE;		
	}
	

	if(hasObjVar(structure, "structureChange.storageIncrease"))
	{
		sendSystemMessage(self, new string_id(STF, "storage_increase_transfer")); // You cannot transfer structures containing increased storage		return SCRIPT_CONTINUE;
		return SCRIPT_CONTINUE;
	}

	obj_id notradeItem = null;
	if(player_structure.isBuilding(structure))
	{
		// make sure that a) the player is in the building, b) the contents are loaded, and c) there are no no-drop items
		// in the building
		obj_id[] buildingPlayers = player_structure.getPlayersInBuilding(structure);
		boolean found = false;
		if(buildingPlayers != null)
		{
			for(int i = 0; i < buildingPlayers.length; ++i)
			{
				if(buildingPlayers[i] == self)
				{
					found = true;
					break;
				}
			}
		}
		if(!found)
		{
			sendSystemMessage(self, SID_NOT_IN_BUILDING);
			return SCRIPT_CONTINUE;
		}

		if(!areAllContentsLoaded(structure))
		{
			sendSystemMessage(self, SID_CONTENTS_NOT_LOADED);
			return SCRIPT_CONTINUE;
		}

		notradeItem = utils.findNoTradeItemNotVendor(player_structure.getObjectsInBuilding(structure), false);
	}
	else
	{
		// check non-building structure (like factory, for example) for noTrade item
		obj_id[] structureArray = new obj_id[1];
		structureArray[0] = structure;
		notradeItem = utils.findNoTradeItem(structureArray, false);
	}

	if(isIdValid(notradeItem))
	{
		prose_package pp = new prose_package();
		pp.stringId = SID_BUILDING_HAS_NOTRADE;
		pp.target.id = notradeItem;
		sendSystemMessageProse(self, pp);
		return SCRIPT_CONTINUE;
	}

	// If no target was specified, check the player's lookat
	if(!isIdValid(target))
	{
		target = getLookAtTarget(self);
		if(!isIdValid(target))
		{
			LOG("LOG_CHANNEL", "You must specify a player with whom to transfer ownership");
			sendSystemMessage(self, new string_id(STF, "no_transfer_target")); // You must specify a player with whom to transfer ownership.
			return SCRIPT_CONTINUE;
		}
	}

	if(target == self)
	{
		LOG("LOG_CHANNEL", "You are already the owner.");
		sendSystemMessage(self, new string_id(STF, "already_owner")); // You are already the owner.
		return SCRIPT_CONTINUE;
	}

	if(!isPlayer(target))
	{
		LOG("LOG_CHANNEL", "The target must be a player.");
		sendSystemMessage(self, new string_id(STF, "target_not_player")); // The target must be a player.
		return SCRIPT_CONTINUE;
	}

	//Can't transfer with special sign on structure
	if(hasObjVar(structure, player_structure.SPECIAL_SIGN_OWNER_ONLY) && getBooleanObjVar(structure, player_structure.SPECIAL_SIGN_OWNER_ONLY))
	{
		LOG("LOG_CHANNEL", "You cannot transfer ownership with a special sign attached");
		sendSystemMessage(self, player_structure.SID_SPECIAL_SIGN_NO_TRANSFER);
		return SCRIPT_CONTINUE;
	}

	if(utils.isFreeTrial(target))
	{
		sendSystemMessage(self, SID_NO_TRANSFER);
		return SCRIPT_CONTINUE;
	}

	if(player_structure.isBanned(structure, target))
	{
		LOG("LOG_CHANNEL", "You cannot transfer ownership to a banned player");
		sendSystemMessage(self, new string_id(STF, "no_banned_player")); // You cannot transfer ownership to a banned player.
		return SCRIPT_CONTINUE;
	}

	// You can't transfer ownership to someone who is banned from the city.
	int city_id = getCityAtLocation(getLocation(structure), 0);
	if(city.isCityBanned(target, city_id))
	{
		sendSystemMessage(self, SID_CANT_TRANSFER_TO_CITY_BANNED);
		return SCRIPT_CONTINUE;
	}

	//Check to see if the target can own the structure
	if(!player_structure.canOwnStructure(structure, target))
	{
		LOG("LOG_CHANNEL", getFirstName(target) + " is not able to own this structure.");
		sendSystemMessageProse(self, prose.getPackage(new string_id (STF, "not_able_to_own"), target)); // %NT is not able to own this structure.
		return SCRIPT_CONTINUE;
	}

	// Check to see if we need zoning rights.
	if(cityExists(city_id) && city.isCityZoned(city_id) && isIdValid(target))
	{
		// Check zoning rights time.
		if(!city.hasZoningRights(target, city_id))
		{
			sendSystemMessage(self, SID_NO_RIGHTS);
			return SCRIPT_CONTINUE;
		}
	}

	// owner, structure, and target *MUST* be authoritative on the same
	// game server in order the transfer the structure; tell owner to
	// try the operation again while we get the owner and/or target moved
	// to the same game server as the structure
	if(!structure.isAuthoritative() || !target.isAuthoritative())
	{
		obj_id targetTopmostContainer = getTopMostContainer(target);
		if(!isIdValid(targetTopmostContainer))
			targetTopmostContainer = target;

		requestSameServer(targetTopmostContainer, structure);

		if(!structure.isAuthoritative())
		{
			obj_id selfTopmostContainer = getTopMostContainer(self);
			if(!isIdValid(selfTopmostContainer))
				selfTopmostContainer = self;

			requestSameServer(selfTopmostContainer, structure);
		}

		sendSystemMessage(self, new string_id(STF, "not_authoritative"));
		return SCRIPT_CONTINUE;
	}

	//Go ahead and give the structure to the target
	player_structure.removeStructure(structure, self);
	player_structure.addStructure(structure, target);

	LOG("LOG_CHANNEL", "Ownership of the structure has been transfered to " + getFirstName(target));
	sendSystemMessageProse(self, prose.getPackage(new string_id (STF, "ownership_transferred_out"), target)); // Ownership of the structure has been transfered to %NT.
	LOG("LOG_CHANNEL", target + " ->" + getFirstName(self) + " has transfered ownership of the structure to you");
	sendSystemMessageProse(target, prose.getPackage(new string_id (STF, "ownership_transferred_in"), self)); // %NT has transfered ownership of the structure to you
	CustomerServiceLog("playerStructure", "STRUCTURE("+ structure +") TEMPLATE: "+ structureTemplateName +" was transferred FROM: "+ getFirstName(self) +"("+ self +") TO"+ getFirstName(target) + "(" + target + ").");
	CustomerServiceLog("c","Structure " + structure + " has been transfered from " + getFirstName(self) + " to " + getFirstName(target));

	return SCRIPT_CONTINUE;
}

commandHandler destroyStructure()
{
	if(!isFactionBaseEmpty(trial.getTop(self), self))
	{
		sendSystemMessage(self, SID_EVACUATE_FACILITY);
		return SCRIPT_CONTINUE;
	}

	LOG("LOG_CHANNEL", "player_building::destroyStructure");
	obj_id structure = player_structure.getStructure(self);

	if(!isIdValid(structure))
	{
		LOG("LOG_CHANNEL", self + " ->You must in a building or near an installation to use that command.");
		sendSystemMessage(self, new string_id(STF, "command_no_building")); // You must in a building or near an installation to use that command.
		return SCRIPT_CONTINUE;
	}

	if(utils.hasScriptVar(self, "player_structure.destroy.pid"))
	{
		int oldpid = utils.getIntScriptVar(self, "player_structure.destroy.pid");
		sui.closeSUI(self, oldpid);
		utils.removeScriptVarTree(self, "player_structure.destroy");
	}

	if(!player_structure.isCivic(structure) && !player_structure.isInAdminRange(structure, self))
		return SCRIPT_CONTINUE;

	//If we are destroying a City Hall - It can not be during Election Week!
	string template = getTemplateName(structure);
	if(template.indexOf("cityhall_") > -1)
	{
		//Check the Voting Cycle Status - If it's election week, tell the Mayor and Bail.
		if(hasObjVar(structure, "cityVoteInterval"))
		{
			int cityVoteInterval = getIntObjVar(structure, "cityVoteInterval");
			if(cityVoteInterval == 2)
			{
				sendSystemMessage(self, SID_DESTRUCTION_LOCKED);
				return SCRIPT_CONTINUE;
			}
		}
	}

	if(!player_structure.isOwner(structure, self))
	{
		LOG("LOG_CHANNEL", "You must be the owner to destroy a structure.");
		sendSystemMessage(self, new string_id(STF, "destroy_must_be_owner")); // You must be the owner to destroy a structure.
		return SCRIPT_CONTINUE;
	}


	if(player_structure.isGenerator(structure))
	{
		if(isHarvesterActive(structure))
		{
			sendSystemMessage(self, new string_id(STF, "destroy_deactivate_generator_first")); // You must first deactivate the harvester before you may destroy it or reclaim the deed.
			return SCRIPT_CONTINUE;
		}

		if(!isHarvesterEmpty(structure))
		{
			sendSystemMessage(self, new string_id(STF, "destroy_empty_generator_hopper")); // You must first empty the harvester's hopper before you may destroy it or reclaim the deed.
			return SCRIPT_CONTINUE;
		}
	}

	if(player_structure.isHarvester(structure))
	{
		if(isHarvesterActive(structure))
		{
			sendSystemMessage(self, new string_id(STF, "destroy_deactivate_first")); // You must first deactivate the harvester before you may destroy it or reclaim the deed.
			return SCRIPT_CONTINUE;
		}

		if(!isHarvesterEmpty(structure))
		{
			sendSystemMessage(self, new string_id(STF, "destroy_empty_hopper")); // You must first empty the harvester's hopper before you may destroy it or reclaim the deed.
			return SCRIPT_CONTINUE;
		}
	}
	else if(player_structure.isFactory(structure))
	{
		if(isHarvesterActive(structure))
		{
			prose_package pp = prose.getPackage(SID_DEACTIVATE_FACTORY_FOR_DELETE, self);
			if(pp != null)
				sendSystemMessageProse(self, pp);
			return SCRIPT_CONTINUE;
		}
		string currentSchematicName = getManufactureStationSchematic(structure);
		if(currentSchematicName != null)
		{
			prose_package pp = prose.getPackage(SID_REMOVE_SCHEMATIC_FOR_DELETE, self);
			if(pp != null)
				sendSystemMessageProse(self, pp);
			return SCRIPT_CONTINUE;
		}
		obj_id inputHopper = getManufactureStationInputHopper(structure);
		if(isIdValid(inputHopper))
		{
			if(getNumItemsIn(inputHopper) > 0)
			{
				prose_package pp = prose.getPackage(SID_CLEAR_INPUT_HOPPER_FOR_DELETE, self);
				if(pp != null)
					sendSystemMessageProse(self, pp);
				return SCRIPT_CONTINUE;
			}
		}
		obj_id outputHopper = getManufactureStationOutputHopper(structure);
		if(isIdValid(outputHopper))
		{
			if(getNumItemsIn(outputHopper) > 0)
			{
				prose_package pp = prose.getPackage(SID_CLEAR_OUTPUT_HOPPER_FOR_DELETE, self);
				if(pp != null)
					sendSystemMessageProse(self, pp);
				return SCRIPT_CONTINUE;
			}
		}
	}
	else if(player_structure.isBuilding(structure))
	{
		if(hasObjVar(structure, player_structure.SPECIAL_SIGN_OWNER_ONLY) && getBooleanObjVar(structure, player_structure.SPECIAL_SIGN_OWNER_ONLY))
		{
			//you need to remove the special sign
			sendSystemMessage(self, player_structure.SID_REMOVE_SPCIAL_SIGN_TO_DESTROY);
			return SCRIPT_CONTINUE;

		}
		if ( !areAllContentsLoaded(structure) )
		{
			prose_package pp = prose.getPackage(SID_CONTENTS_NOT_LOADED, self);
			if(pp != null)
				sendSystemMessageProse(self, pp);
			return SCRIPT_CONTINUE;
		}

		fixHouseItemLimit(structure);

		int numItems = player_structure.getStructureNumItems(structure);
		if(numItems > 0)
		{
			prose_package pp = prose.getPackage(SID_CLEAR_BUILDING_FOR_DELETE, self);
			if(pp != null)
				sendSystemMessageProse(self, pp);
			return SCRIPT_CONTINUE;
		}
		
		//Look for pets and droids, if found abort.
		obj_id[] houseContents = trial.getAllObjectsInDungeon(structure);
		if(houseContents != null && houseContents.length > 0)
		{
			for(int i = 0; i < houseContents.length; i++)
			{
				if(isMob(houseContents[i]))
				{
					int callableType = callable.getCallableType(houseContents[i]);
					if(callableType > 0)
					{
						//All pets and droids must be stored when destroying a house.
						prose_package pp = prose.getPackage(SID_STORE_PETS_FOR_DELETE, self);
						if(pp != null)
							sendSystemMessageProse(self, pp);

						return SCRIPT_CONTINUE;							
					}
				}
			}
		}
		
		if(!player_structure.canPackStructureWithVendors(self, structure))
			return SCRIPT_CONTINUE;
	}

	int key = utils.getIntScriptVar(self, "player_structure.destroy.key");
	boolean redeedVar = utils.getBooleanScriptVar(self, "player_structure.destroy.willredeed");
	if(params != null && key != 0 && params.equals(Integer.toString(key)))
	{
		if(utils.getObjIdScriptVar(self, player_structure.VAR_CONFIRM_DESTROY) != structure)
		{
			sendSystemMessage(self, SID_PENDING_DESTROY);
			return SCRIPT_CONTINUE;
		}
		utils.removeScriptVar(self, player_structure.VAR_CONFIRM_DESTROY);

		/*
		// Check to see if the deed may be reclaimed
		int pool = player_structure.getMaintenancePool(structure);
		int reclaim_pool = player_structure.getMaintenanceRate(structure) * 100;
		int max_condition = player_structure.getMaxCondition(structure);
		int condition = player_structure.getStructureCondition(structure);
		*/

		string sname = player_structure.getStructureName(structure);
		CustomerServiceLog("DestroyStructure", "("+self+") "+getFirstName(self)+" has confirmed /destroyStructure on "+structure+" (Template: " + template + " Name: " + sname + "). Owner is "+player_structure.getStructureOwner(structure)+". Will redeed = " + redeedVar);
		CustomerServiceLog("DestroyStructure", getFirstName(self) + "has initiated a destroyStructure on " + structure + " (Template: " + template + " Name: " + sname + "). Owner is " + player_structure.getStructureOwner(structure));
		//if(condition >= max_condition && pool >= reclaim_pool && player_structure.canReclaimDeed(structure))
		if(redeedVar)
		{
			if(player_structure.destroyStructure(structure, true))
			{
				LOG("LOG_CHANNEL", self + " ->Structure destroyed and deed reclaimed.");
				sendSystemMessage(self, new string_id(STF, "deed_reclaimed")); // Structure destroyed and deed reclaimed.
			}
			else
			{
				sendSystemMessage(self, new string_id(STF, "deed_reclaimed_failed")); // Structure destroy and deed reclaimed FAILED!
				return SCRIPT_CONTINUE;
			}
		}
		else
		{
			if(player_structure.destroyStructure(structure, false))
			{
				LOG("LOG_CHANNEL", self + " ->Structure destroyed.");
				sendSystemMessage(self, new string_id(STF, "structure_destroyed")); // Structure destroyed.
			}
			else
			{
				sendSystemMessage(self, new string_id(STF, "structure_destroy_failed")); // Structure destroy without deed reclaim FAILED!
				return SCRIPT_CONTINUE;
			}
		}
	}
	else
	{

		string_id confirm_destruction_title = new string_id(STF, "confirm_destruction_t"); // Confirm Structure Destruction
		string title = getString(confirm_destruction_title);
		string_id confirm_destruction_detail1 = new string_id(STF, "confirm_destruction_d1"); // You have elected to destroy a structure. Pertinent structure data can be found in the list below.
		string prompt = getString(confirm_destruction_detail1);
		string_id confirm_destruction_detail2 = new string_id(STF, "confirm_destruction_d2"); // Please complete the following steps to confirm structure deletion.
		prompt += getString(confirm_destruction_detail2) + "\n\n";
		string_id confirm_destruction_detail3a = new string_id(STF, "confirm_destruction_d3a"); //  If you wish to redeed your structure, all structure data must be
		string_id confirm_destruction_detail3b = new string_id(STF, "confirm_destruction_d3b");	// GREEN
		prompt += getString(confirm_destruction_detail3a) + " \\" + colors_hex.LIMEGREEN + getString(confirm_destruction_detail3b) + "\\#.";
		string_id confirm_destruction_detail4 = new string_id(STF, "confirm_destruction_d4"); //  To continue with structure deletion, click YES. Otherwise, please click NO.
		prompt += getString(confirm_destruction_detail4);

		resizeable string[] entries = new string[0];

		string structure_name = player_structure.getStructureName(structure);
		if(structure_name != null && !structure_name.equals(""))
			title = structure_name;

		boolean canRedeed = false;
		boolean willRedeed = true;
		if(player_structure.canReclaimDeed(structure))
		{
			canRedeed = true;
		}

		if(canRedeed)
		{
			string_id redeed_alert_text = new string_id(STF, "can_redeed_alert"); // CAN REDEED:
			string_id redeed_yes_alert_text = new string_id(STF, "can_redeed_yes_suffix"); // YES
			entries = utils.addElement(entries, getString(redeed_alert_text) + "\\"+colors_hex.LIMEGREEN+getString(redeed_yes_alert_text));

			int max_condition = player_structure.getMaxCondition(structure);
			int condition = player_structure.getStructureCondition(structure);

			string conditionColor = colors_hex.LIMEGREEN;
			if(condition < max_condition)
			{
				conditionColor = colors_hex.TOMATO;
				willRedeed = false;
			}

			string_id redeed_condition_text = new string_id(STF, "redeed_condition"); // CONDITION:
			entries = utils.addElement(entries, " - " + getString(redeed_condition_text) + "\\"+conditionColor+condition+"/"+max_condition);

			int pool = player_structure.getMaintenancePool(structure);
			int reclaim_pool = player_structure.getRedeedCost(structure);

			string maintColor = colors_hex.LIMEGREEN;
			if(pool < reclaim_pool)
			{
				maintColor = colors_hex.TOMATO;
				willRedeed = false;
			}
			string_id redeed_maintenance_text = new string_id(STF, "redeed_maintenance"); // MAINTENANCE:
			entries = utils.addElement(entries, " - " + getString(redeed_maintenance_text) + "\\"+maintColor+pool+"/"+reclaim_pool);
		}
		else
		{
			string_id redeed_alert_text = new string_id(STF, "can_redeed_alert"); // CAN REDEED:
			string_id redeed_no_alert_text = new string_id(STF, "can_redeed_no_suffix"); // NO
			entries = utils.addElement(entries, getString(redeed_alert_text) + "\\"+colors_hex.TOMATO+getString(redeed_no_alert_text));
			willRedeed = false;
		}

		if(willRedeed)
		{
			string_id redeed_confirmation_text = new string_id(STF, "redeed_confirmation"); // WILL REDEED:
			string_id redeed_yes_alert_text = new string_id(STF, "can_redeed_yes_suffix"); // YES
			prompt += "\n" + getString(redeed_confirmation_text) + "\\"+colors_hex.LIMEGREEN+getString(redeed_yes_alert_text);
		}
		else
		{
			string_id redeed_confirmation_text = new string_id(STF, "redeed_confirmation"); // WILL REDEED:
			string_id redeed_no_alert_text = new string_id(STF, "can_redeed_no_suffix"); // NO
			prompt += "\n" + getString(redeed_confirmation_text) + "\\"+colors_hex.TOMATO+getString(redeed_no_alert_text);
		}

		int pid = sui.listbox(self, self, prompt, sui.YES_NO, title, entries, "handleDestroyUi");
		if(pid > -1)
		{
			utils.setScriptVar(self, "player_structure.destroy.pid", pid);
			utils.setScriptVar(self, "player_structure.destroy.target", structure);
			utils.setScriptVar(self, "player_structure.destroy.willredeed", willRedeed);
			utils.setScriptVar(self, "player_structure.destroy.key", rand(100000,999999));
		}

	}

	return SCRIPT_CONTINUE;
}

commandHandler createVendor()
{
	// The player wants to create a vendor.
	blog("player_building:createVendor");

	if(!validateVendorPlacement(self)) //does all the prelim checks to make sure the player can create a vendor
		return SCRIPT_CONTINUE;//do not remove vars. The player must place the vendor or delete.

	// Set the creation script var.
	utils.setScriptVar(self, CREATING_VENDOR, 1);

	requestPlayerVendorCount(self);  //gets the vendor count I assume.  See OnPlayerVendorCountReply trigger
	return SCRIPT_CONTINUE;
}

/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/***** MESSAGEHANDLERS *************************************************/
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/

messageHandler handleSaveDecorationLayout()
{
	// dismiss any existing window
	if (utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
	{
		int savedPageId = utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
		utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
		forceCloseSUIPage(savedPageId);
	}

	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_SAVE_SLOT_CHOICE);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOM_INDEX);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_CURRENT_POB_ROOMS);

	// see if any of the 3 save slots are currently used
	obj_id playerObject = getPlayerObject(self);
	if (!isValidId(playerObject))
		return SCRIPT_CONTINUE;

	string[][] columnData = new string[3][4];

	columnData[0][0] = "1";
	if (hasObjVar(playerObject, "savedDecoration1.saveTime"))
	{
		columnData[0][1] = getStringObjVar(playerObject, "savedDecoration1.pobName");
		if (columnData[0][1] == null)
			columnData[0][1] = "";

		int saveTime = getIntObjVar(playerObject, "savedDecoration1.saveTime");
		if (saveTime > 0)
			columnData[0][2] = getCalendarTimeStringLocal(saveTime);
		else
			columnData[0][2] = "";

		columnData[0][3] = getStringObjVar(playerObject, "savedDecoration1.description");
		if (columnData[0][3] == null)
			columnData[0][3] = "";
	}
	else
	{
		columnData[0][1] = "<EMPTY>";
		columnData[0][2] = "<EMPTY>";
		columnData[0][3] = "<EMPTY>";
	}

	columnData[1][0] = "2";
	if (hasObjVar(playerObject, "savedDecoration2.saveTime"))
	{
		columnData[1][1] = getStringObjVar(playerObject, "savedDecoration2.pobName");
		if (columnData[1][1] == null)
			columnData[1][1] = "";

		int saveTime = getIntObjVar(playerObject, "savedDecoration2.saveTime");
		if (saveTime > 0)
			columnData[1][2] = getCalendarTimeStringLocal(saveTime);
		else
			columnData[1][2] = "";

		columnData[1][3] = getStringObjVar(playerObject, "savedDecoration2.description");
		if (columnData[1][3] == null)
			columnData[1][3] = "";
	}
	else
	{
		columnData[1][1] = "<EMPTY>";
		columnData[1][2] = "<EMPTY>";
		columnData[1][3] = "<EMPTY>";
	}

	columnData[2][0] = "3";
	if (hasObjVar(playerObject, "savedDecoration3.saveTime"))
	{
		columnData[2][1] = getStringObjVar(playerObject, "savedDecoration3.pobName");
		if (columnData[2][1] == null)
			columnData[2][1] = "";

		int saveTime = getIntObjVar(playerObject, "savedDecoration3.saveTime");
		if (saveTime > 0)
			columnData[2][2] = getCalendarTimeStringLocal(saveTime);
		else
			columnData[2][2] = "";

		columnData[2][3] = getStringObjVar(playerObject, "savedDecoration3.description");
		if (columnData[2][3] == null)
			columnData[2][3] = "";
	}
	else
	{
		columnData[2][1] = "<EMPTY>";
		columnData[2][2] = "<EMPTY>";
		columnData[2][3] = "<EMPTY>";
	}

	string[] columnHeader = {"Save Slot #", "Structure/Ship Type", "Save Time", "Description"};
	string[] columnHeaderType = {"integer", "text", "text", "text"};

	int pid = sui.tableRowMajor(self, self, sui.OK_CANCEL, "Save Decoration Layout", "handleSelectSaveDecorationLayout", "Select the save slot where you want to save this decoration layout.", columnHeader, columnHeaderType, columnData);
	utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);

	return SCRIPT_CONTINUE;
}

messageHandler handleSelectSaveDecorationLayout()
{
	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	if (params.getInt("pageId") != utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);

	int bp = sui.getIntButtonPressed(params);
	if (bp == sui.BP_OK)
	{
		int saveSlotId = sui.getTableLogicalIndex(params) + 1;
		if ((saveSlotId < 1) || (saveSlotId > 3))
			return SCRIPT_CONTINUE;

		obj_id playerObject = getPlayerObject(self);
		if (!isValidId(playerObject))
			return SCRIPT_CONTINUE;

		utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
		if (hasObjVar(playerObject, "savedDecoration" + saveSlotId + ".saveTime"))
		{
			int pid = sui.msgbox(self, self, "Are you sure you want to overwrite the decoration layout currently saved in slot " + saveSlotId + "?", sui.YES_NO, "Save Decoration Layout", "handleConfirmOverwriteSaveDecorationLayout");
			utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
		}
		else
		{
			int pid = sui.inputbox(self, self, "Enter an optional (40 characters max) description for the decoration layout that will be saved in slot " + saveSlotId + ".", "Save Decoration Layout", "handleSaveDecorationLayoutEnterDescription", 39, false, "");
			setSUIProperty(pid, sui.INPUTBOX_INPUT, "MaxLength", String.valueOf(39));
			utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
			showSUIPage(pid);
		}
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleConfirmOverwriteSaveDecorationLayout()
{
	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID))
		return SCRIPT_CONTINUE;

	if (params.getInt("pageId") != utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	int saveSlotId = utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);

	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);

	int bp = sui.getIntButtonPressed(params);
	if (bp == sui.BP_OK)
	{
		int pid = sui.inputbox(self, self, "Enter an optional (40 characters max) description for the decoration layout that will be saved in slot " + saveSlotId + ".", "Save Decoration Layout", "handleSaveDecorationLayoutEnterDescription", 39, false, "");
		setSUIProperty(pid, sui.INPUTBOX_INPUT, "MaxLength", String.valueOf(39));
		utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
		utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
		showSUIPage(pid);
	}
	else
	{
		messageTo(self, "handleSaveDecorationLayout", null, 0.1f, false);
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleSaveDecorationLayoutEnterDescription()
{
	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID))
		return SCRIPT_CONTINUE;

	if (params.getInt("pageId") != utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	int saveSlotId = utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);

	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);

	int bp = sui.getIntButtonPressed(params);
	if (bp == sui.BP_OK)
	{
		obj_id structure = getContainedBy(self);
		if (isValidId(structure))
			structure = getContainedBy(structure);

		if (!isValidId(structure))
		{
			sendSystemMessage(self, "You must be standing inside a structure or POB ship to do this.", null );
		}
		else
		{
			string description = sui.getInputBoxText(params);
			if (description == null)
				description = "";

			saveDecorationLayout(self, structure, saveSlotId, description);
		}
	}
	else
	{
		messageTo(self, "handleSaveDecorationLayout", null, 0.1f, false);
	}

	return SCRIPT_CONTINUE;
}

void displayRestoreDecorationRoomMapping(obj_id player, string[] savedRooms, string[] targetRooms, int saveSlotId)
{
	if (!isIdValid(player) || !exists(player))
		return;

	// display table SUI to allow the player to selectively choose the target room for each of the source room
	string[] columnHeader = {"Items that were in this room at the time the layout was saved", "Will be moved/restored into this room"};
	string[] columnHeaderType = {"text", "text"};
	string[][] columnData = new string[2][0];

	string[] tempSavedRooms = new string[savedRooms.length + 1];
	for (int i = 0; i < savedRooms.length; ++i)
		tempSavedRooms[i] = savedRooms[i];
	tempSavedRooms[savedRooms.length] = "Restore Decoration Layout";

	string[] tempTargetRooms = new string[targetRooms.length + 1];
	for (int i = 0; i < targetRooms.length; ++i)
		tempTargetRooms[i] = targetRooms[i];
	tempTargetRooms[targetRooms.length] = "";

	columnData[0] = tempSavedRooms;
	columnData[1] = tempTargetRooms;

	int pid = sui.tableColumnMajor(player, player, sui.OK_CANCEL, "Restore Decoration Layout", "handleSelectRestoreDecorationRoomMapping", "@player_structure:restore_decoration_layout_specify_target_room", columnHeader, columnHeaderType, columnData);
	utils.setScriptVar(player, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
	utils.setScriptVar(player, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
	utils.setScriptVar(player, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS, targetRooms);
}

messageHandler handleRestoreDecorationLayout()
{
	// dismiss any existing window
	if (utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
	{
		int savedPageId = utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
		utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
		forceCloseSUIPage(savedPageId);
	}

	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_SAVE_SLOT_CHOICE);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOM_INDEX);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_CURRENT_POB_ROOMS);

	// see if any of the 3 save slots are currently used
	obj_id playerObject = getPlayerObject(self);
	if (!isValidId(playerObject))
		return SCRIPT_CONTINUE;

	int numberOfSavedSlots = 0;

	string[] saveSlot1 = null;
	if (hasObjVar(playerObject, "savedDecoration1.saveTime"))
	{
		int saveTime = getIntObjVar(playerObject, "savedDecoration1.saveTime");
		if (saveTime > 0)
		{
			++numberOfSavedSlots;

			saveSlot1 = new string[4];

			saveSlot1[0] = "1";

			saveSlot1[1] = getStringObjVar(playerObject, "savedDecoration1.pobName");
			if (saveSlot1[1] == null)
				saveSlot1[1] = "";

			saveSlot1[2] = getCalendarTimeStringLocal(saveTime);

			saveSlot1[3] = getStringObjVar(playerObject, "savedDecoration1.description");
			if (saveSlot1[3] == null)
				saveSlot1[3] = "";
		}
	}

	string[] saveSlot2 = null;
	if (hasObjVar(playerObject, "savedDecoration2.saveTime"))
	{
		int saveTime = getIntObjVar(playerObject, "savedDecoration2.saveTime");
		if (saveTime > 0)
		{
			++numberOfSavedSlots;

			saveSlot2 = new string[4];

			saveSlot2[0] = "2";

			saveSlot2[1] = getStringObjVar(playerObject, "savedDecoration2.pobName");
			if (saveSlot2[1] == null)
				saveSlot2[1] = "";

			saveSlot2[2] = getCalendarTimeStringLocal(saveTime);

			saveSlot2[3] = getStringObjVar(playerObject, "savedDecoration2.description");
			if (saveSlot2[3] == null)
				saveSlot2[3] = "";
		}
	}

	string[] saveSlot3 = null;
	if (hasObjVar(playerObject, "savedDecoration3.saveTime"))
	{
		int saveTime = getIntObjVar(playerObject, "savedDecoration3.saveTime");
		if (saveTime > 0)
		{
			++numberOfSavedSlots;

			saveSlot3 = new string[4];

			saveSlot3[0] = "3";

			saveSlot3[1] = getStringObjVar(playerObject, "savedDecoration3.pobName");
			if (saveSlot3[1] == null)
				saveSlot3[1] = "";

			saveSlot3[2] = getCalendarTimeStringLocal(saveTime);

			saveSlot3[3] = getStringObjVar(playerObject, "savedDecoration3.description");
			if (saveSlot3[3] == null)
				saveSlot3[3] = "";
		}
	}

	if (numberOfSavedSlots <= 0)
	{
		sendSystemMessage(self, "You do not have any saved decoration layout.", null);
		return SCRIPT_CONTINUE;
	}

	string[][] columnData = new string[numberOfSavedSlots][0];
	int[] choicesSaveSlot = {0, 0, 0};
	int choicesSaveSlotIndex = 0;

	if (saveSlot1 != null)
	{
		columnData[choicesSaveSlotIndex] = saveSlot1;
		choicesSaveSlot[choicesSaveSlotIndex] = 1;
		++choicesSaveSlotIndex;
	}

	if (saveSlot2 != null)
	{
		columnData[choicesSaveSlotIndex] = saveSlot2;
		choicesSaveSlot[choicesSaveSlotIndex] = 2;
		++choicesSaveSlotIndex;
	}

	if (saveSlot3 != null)
	{
		columnData[choicesSaveSlotIndex] = saveSlot3;
		choicesSaveSlot[choicesSaveSlotIndex] = 3;
		++choicesSaveSlotIndex;
	}

	string[] columnHeader = {"Save Slot #", "Structure/Ship Type", "Save Time", "Description"};
	string[] columnHeaderType = {"integer", "text", "text", "text"};

	int pid = sui.tableRowMajor(self, self, sui.OK_CANCEL, "Restore Decoration Layout", "handleSelectRestoreDecorationLayout", "Select the decoration layout save slot you wish to restore.", columnHeader, columnHeaderType, columnData);
	utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
	utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_SAVE_SLOT_CHOICE, choicesSaveSlot);

	return SCRIPT_CONTINUE;
}

messageHandler handleSelectRestoreDecorationLayout()
{
	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_SAVE_SLOT_CHOICE))
		return SCRIPT_CONTINUE;

	if (params.getInt("pageId") != utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	int[] choicesSaveSlot = utils.getIntArrayScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_SAVE_SLOT_CHOICE);

	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_SAVE_SLOT_CHOICE);

	if ((choicesSaveSlot == null) || (choicesSaveSlot.length != 3))
		return SCRIPT_CONTINUE;

	int bp = sui.getIntButtonPressed(params);
	if (bp == sui.BP_OK)
	{
		int rowsSelected = sui.getTableLogicalIndex(params);
		if ((rowsSelected < 0) || (rowsSelected >= choicesSaveSlot.length))
			return SCRIPT_CONTINUE;

		int saveSlotId = choicesSaveSlot[rowsSelected];
		if ((saveSlotId < 1) || (saveSlotId > 3))
			return SCRIPT_CONTINUE;

		obj_id playerObject = getPlayerObject(self);
		if (!isValidId(playerObject))
			return SCRIPT_CONTINUE;

		// get the list of rooms that were saved
		string[] savedRooms = getStringArrayObjVar(playerObject, "savedDecoration" + saveSlotId + ".rooms");
		if ((savedRooms == null) || (savedRooms.length <= 0))
			return SCRIPT_CONTINUE;

		// get the list of rooms that are in the current structure
		obj_id structure = getContainedBy(self);
		if (isValidId(structure))
			structure = getContainedBy(structure);

		if (!isValidId(structure))
		{
			sendSystemMessage(self, "You must be standing inside a structure or POB ship to do this.", null);
			return SCRIPT_CONTINUE;
		}

		string[] roomsOfCurrentPob = getCellNames(structure);
		if ((roomsOfCurrentPob == null) || (roomsOfCurrentPob.length <= 0))
		{
			sendSystemMessage(self, "You must be standing inside a structure or POB ship to do this.", null);
			return SCRIPT_CONTINUE;
		}

		// see if there is an existing target room mapping to use
		string[] targetRooms = getStringArrayObjVar(playerObject, "savedDecoration" + saveSlotId + ".targetRooms");
		if ((targetRooms != null) && (targetRooms.length == savedRooms.length))
		{
			// clear out any of the existing target room that doesn't exists in this structure
			for (int i = 0; i < targetRooms.length; ++i)
			{
				boolean found = false;
				for (int j = 0; j < roomsOfCurrentPob.length; ++j)
				{
					if (targetRooms[i].equals(roomsOfCurrentPob[j]))
					{
						found = true;
						break;
					}
				}

				if (!found)
					targetRooms[i] = "(will not be moved/restored)";
			}
		}
		else
		{
			// build a new list of target room, initially populating it
			// with target rooms that have the same name as the source room
			targetRooms = new string[savedRooms.length];

			for (int i = 0; i < savedRooms.length; ++i)
			{
				boolean found = false;
				for (int j = 0; j < roomsOfCurrentPob.length; ++j)
				{
					if (savedRooms[i].equals(roomsOfCurrentPob[j]))
					{
						targetRooms[i] = savedRooms[i];
						found = true;
						break;
					}
				}

				if (!found)
					targetRooms[i] = "(will not be moved/restored)";
			}
		}

		displayRestoreDecorationRoomMapping(self, savedRooms, targetRooms, saveSlotId);
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleSelectRestoreDecorationRoomMapping()
{
	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS))
		return SCRIPT_CONTINUE;

	if (params.getInt("pageId") != utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	int saveSlotId = utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);
	string[] targetRooms = utils.getStringArrayScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS);

	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS);

	int bp = sui.getIntButtonPressed(params);
	if (bp == sui.BP_OK)
	{
		obj_id playerObject = getPlayerObject(self);
		if (!isValidId(playerObject))
			return SCRIPT_CONTINUE;

		// get the list of rooms that were saved
		string[] savedRooms = getStringArrayObjVar(playerObject, "savedDecoration" + saveSlotId + ".rooms");
		if ((savedRooms == null) || (savedRooms.length <= 0))
			return SCRIPT_CONTINUE;

		if ((targetRooms == null) || (targetRooms.length != savedRooms.length))
			return SCRIPT_CONTINUE;

		int rowsSelected = sui.getTableLogicalIndex(params);
		if (rowsSelected == savedRooms.length)
		{
			// get the building the character is in
			obj_id structure = getContainedBy(self);
			if (isValidId(structure))
				structure = getContainedBy(structure);

			if (!isValidId(structure))
			{
				int pid = sui.msgbox(self, self, "You must be standing inside a structure or POB ship to do this.", sui.OK_ONLY, "Restore Decoration Layout", "handleRestoreDecorationReturnToRoomMapping");
				utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
				utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
				utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS, targetRooms);

				return SCRIPT_CONTINUE;
			}

			string[] roomsOfCurrentPob = getCellNames(structure);
			if ((roomsOfCurrentPob == null) || (roomsOfCurrentPob.length <= 0))
			{
				int pid = sui.msgbox(self, self, "You must be standing inside a structure or POB ship to do this.", sui.OK_ONLY, "Restore Decoration Layout", "handleRestoreDecorationReturnToRoomMapping");
				utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
				utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
				utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS, targetRooms);

				return SCRIPT_CONTINUE;
			}

			// clear out any of the existing target room that doesn't exists in this structure
			boolean hasValidTargetRoom = false;
			for (int i = 0; i < targetRooms.length; ++i)
			{
				if ((targetRooms[i] == null) || (targetRooms[i].length() <= 0) || targetRooms[i].equals("(will not be moved/restored)"))
					continue;

				boolean found = false;
				for (int j = 0; j < roomsOfCurrentPob.length; ++j)
				{
					if (targetRooms[i].equals(roomsOfCurrentPob[j]))
					{
						hasValidTargetRoom = true;
						found = true;
						break;
					}
				}

				if (!found)
					targetRooms[i] = "(will not be moved/restored)";
			}

			// make sure at least 1 target room is specified
			if (!hasValidTargetRoom)
			{
				int pid = sui.msgbox(self, self, "You have not specified any room into which to move/restore the decoration layout.", sui.OK_ONLY, "Restore Decoration Layout", "handleRestoreDecorationReturnToRoomMapping");
				utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
				utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
				utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS, targetRooms);

				return SCRIPT_CONTINUE;
			}

			// save off the target room selection, and start the restore process
			for (int k = 0; k < targetRooms.length; ++k)
			{
				if ((targetRooms[k] == null) || targetRooms[k].equals("(will not be moved/restored)"))
					targetRooms[k] = "";
			}

			setObjVar(playerObject, "savedDecoration" + saveSlotId + ".targetRooms", targetRooms);
			restoreDecorationLayout(self, structure, saveSlotId);

			return SCRIPT_CONTINUE;
		}

		if ((rowsSelected < 0) || (rowsSelected >= savedRooms.length))
		{
			int pid = sui.msgbox(self, self, "Please select an action to perform.", sui.OK_ONLY, "Restore Decoration Layout", "handleRestoreDecorationReturnToRoomMapping");
			utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
			utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
			utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS, targetRooms);

			return SCRIPT_CONTINUE;
		}

		// get the list of rooms that are in the current structure
		obj_id structure = getContainedBy(self);
		if (isValidId(structure))
			structure = getContainedBy(structure);

		if (!isValidId(structure))
		{
			int pid = sui.msgbox(self, self, "You must be standing inside a structure or POB ship to do this.", sui.OK_ONLY, "Restore Decoration Layout", "handleRestoreDecorationReturnToRoomMapping");
			utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
			utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
			utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS, targetRooms);

			return SCRIPT_CONTINUE;
		}

		string[] roomsOfCurrentPob = getCellNames(structure);
		if ((roomsOfCurrentPob == null) || (roomsOfCurrentPob.length <= 0))
		{
			int pid = sui.msgbox(self, self, "You must be standing inside a structure or POB ship to do this.", sui.OK_ONLY, "Restore Decoration Layout", "handleRestoreDecorationReturnToRoomMapping");
			utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
			utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
			utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS, targetRooms);

			return SCRIPT_CONTINUE;
		}

		string[] roomsSelection = new string[roomsOfCurrentPob.length + 1];
		roomsSelection[0] = "do not move/restore items in room " + savedRooms[rowsSelected];
		for (int i = 1; i < roomsSelection.length; ++i)
			roomsSelection[i] = roomsOfCurrentPob[i-1];

		// display window to let the player select the target room
		int pid = sui.listbox(self, self, "Select the room into which you wish to move/restore the items that were in room " + savedRooms[rowsSelected] + " at the time the decoration layout was saved.", sui.OK_CANCEL, "Restore Decoration Layout", roomsSelection, "handleSelectRestoreDecorationTargetRoom", true, true);
		utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID, pid);
		utils.setScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID, saveSlotId);
		utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS, targetRooms);
		utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOM_INDEX, rowsSelected);
		utils.setScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_CURRENT_POB_ROOMS, roomsSelection);
	}
	else
	{
		messageTo(self, "handleRestoreDecorationLayout", null, 0.1f, false);
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleRestoreDecorationReturnToRoomMapping()
{
	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS))
		return SCRIPT_CONTINUE;

	if (params.getInt("pageId") != utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	int saveSlotId = utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);
	string[] targetRooms = utils.getStringArrayScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS);

	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS);

	obj_id playerObject = getPlayerObject(self);
	if (!isValidId(playerObject))
		return SCRIPT_CONTINUE;

	// get the list of rooms that were saved
	string[] savedRooms = getStringArrayObjVar(playerObject, "savedDecoration" + saveSlotId + ".rooms");
	if ((savedRooms == null) || (savedRooms.length <= 0))
		return SCRIPT_CONTINUE;

	if ((targetRooms == null) || (targetRooms.length != savedRooms.length))
		return SCRIPT_CONTINUE;

	displayRestoreDecorationRoomMapping(self, savedRooms, targetRooms, saveSlotId);

	return SCRIPT_CONTINUE;
}

messageHandler handleSelectRestoreDecorationTargetRoom()
{
	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOM_INDEX))
		return SCRIPT_CONTINUE;

	if (!utils.hasScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_CURRENT_POB_ROOMS))
		return SCRIPT_CONTINUE;

	if (params.getInt("pageId") != utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID))
		return SCRIPT_CONTINUE;

	int saveSlotId = utils.getIntScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);
	string[] targetRooms = utils.getStringArrayScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS);
	int targetRoomIndex = utils.getIntScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOM_INDEX);
	string[] roomsOfCurrentPob = utils.getStringArrayScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_CURRENT_POB_ROOMS);

	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SUI_ID);
	utils.removeScriptVar(self, SCRIPTVAR_SAVE_RESTORE_DECORATION_SAVE_SLOT_ID);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOMS);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_TARGET_ROOM_INDEX);
	utils.removeScriptVar(self, SCRIPTVAR_RESTORE_DECORATION_CURRENT_POB_ROOMS);

	obj_id playerObject = getPlayerObject(self);
	if (!isValidId(playerObject))
		return SCRIPT_CONTINUE;

	// get the list of rooms that were saved
	string[] savedRooms = getStringArrayObjVar(playerObject, "savedDecoration" + saveSlotId + ".rooms");
	if ((savedRooms == null) || (savedRooms.length <= 0))
		return SCRIPT_CONTINUE;

	if ((targetRooms == null) || (targetRooms.length != savedRooms.length))
		return SCRIPT_CONTINUE;

	if ((targetRoomIndex < 0) || (targetRoomIndex >= targetRooms.length))
		return SCRIPT_CONTINUE;

	int bp = sui.getIntButtonPressed(params);
	if (bp == sui.BP_OK)
	{
		int rowsSelected = sui.getListboxSelectedRow(params);
		if ((rowsSelected >= 0) && (roomsOfCurrentPob != null) && (roomsOfCurrentPob.length > 0) && (rowsSelected < roomsOfCurrentPob.length))
		{
			if (rowsSelected == 0)
				targetRooms[targetRoomIndex] = "(will not be moved/restored)";
			else
				targetRooms[targetRoomIndex] = roomsOfCurrentPob[rowsSelected];
		}
	}

	displayRestoreDecorationRoomMapping(self, savedRooms, targetRooms, saveSlotId);

	return SCRIPT_CONTINUE;
}

messageHandler handleVendorTypeSelect()
{
	if(params == null || params.isEmpty())
		return SCRIPT_CONTINUE;

	blog("player_building.handleVendorTypeSelect: init");

	// Grab params.
	int idx = sui.getListboxSelectedRow(params);
	if(idx < 0) idx = 0;

	obj_id player = sui.getPlayerId(params);
	if(!isValidId(player) || !exists(player))
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	int btn = sui.getIntButtonPressed(params);
	if(btn == sui.BP_CANCEL)
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	blog("player_building.handleVendorTypeSelect: idx: "+idx);

	//init an array of string with one entry?
	string[] randomOnly = { "@player_structure:random" };
	utils.setScriptVar(player, "vendor.checkGender", 0); //VENDOR FUNCTION KNOWS THE PLAYER HAS VENDER GENDER DECISION BY DEFAULT
	int hiringMod = getSkillStatMod(player, "hiring");
	blog("handleVendorTypeSelect - hiringMod: "+hiringMod);
	switch (idx)
	{
		case 0: // Terminal
			// Get terminal types.
			blog("player_building.handleVendorTypeSelect: selected TERMINAL VENDOR TYPE: ");

			string[] rawTerminalTypes = dataTableGetStringColumn(TBL_TERMINAL_TYPES, 0);

			// Determine how many terminals we get based on our skill mod.
			int test = 10;
			resizeable string[] vendorTypes = new string[0];
			for(int i=0; i<rawTerminalTypes.length; i++)
			{
				if(hiringMod >= test)
					vendorTypes = utils.addElement(vendorTypes, "@player_structure:terminal_"+rawTerminalTypes[i]);
				test += 20;
			}
			sui.listbox(player, player, "@player_structure:terminal_type_d", sui.OK_CANCEL, "@player_structure:terminal_type_t", vendorTypes, "handleTerminalDesignSelect", true);
			break;
		case 1: // Droid
			// Get droid types.
			blog("player_building.handleVendorTypeSelect: selected TERMINAL DROID TYPE: ");

			string[] rawDroidTypes = dataTableGetStringColumn(TBL_DROID_TYPES, 0);

			// Determine how many droids we get based on our skill mod.
			int dtest = 20;
			resizeable string[] droidTypes = null;
			for(int i=0; i<rawDroidTypes.length; i++)
			{
				if(hiringMod >= dtest)
					droidTypes = utils.addElement(droidTypes, "@player_structure:droid_"+rawDroidTypes[i]);
				dtest += 20;
			}
			sui.listbox(player, player, "@player_structure:droid_type_d", sui.OK_CANCEL, "@player_structure:droid_type_t", droidTypes, "handleDroidModelSelect", true);
			break;
		case 2: // NPC
			//give low level traders the RANDOM option.
			blog("player_building.handleVendorTypeSelect: selected TERMINAL NPC TYPE: ");
			if(hiringMod < 50)
			{
				blog("player_building.handleVendorTypeSelect: player hiringMod < 50");
				sui.listbox(player, player, "@player_structure:race_type_d", sui.OK_CANCEL, "@player_structure:race_type_t", randomOnly, "handleVendorRaceSelect", true);
				break;
			}
			else
			{
				blog("player_building.handleVendorTypeSelect: player hiringMod > 50");

				//returns an array of any special vendors of the player hiring skill, if that player has
				//the appropriate skill mod
				string[] allSpecialVendors = getSpecialVendors(self, hiringMod); //this can come back null and that is fine
				blog("player_building.handleVendorTypeSelect: allSpecialVendors.length: "+allSpecialVendors.length);
				//create a resizeable to fill with localized data
				resizeable string[] localizedRaceTypes = new string[0];
				//create a resizeable to fill with raw vendor race data
				resizeable string[] modifiedRawRaceTypes = new string[0];

				//add the other vendors according to hiremod
				if(hiringMod >= 60)
				{
					blog("player_building.handleVendorTypeSelect: player hiringMod >= 60");

					//get all 20 (or more) of the vendor creature types
					//for hiremod 60 and higher
					string[] rawRaceTypesHiLvl = dataTableGetStringColumn(TBL_ALLNPC_TYPES, 0);//TBL_ALLNPC_TYPES = "datatables/vendor/vendor_allnpc_types.iff";
					if(rawRaceTypesHiLvl == null)
						break;

					//LOOP THROUGH THE RACE TYPES
					for(int i = 0; i < rawRaceTypesHiLvl.length; i++)
					{
						 utils.addElement(localizedRaceTypes, "@player_structure:race_"+rawRaceTypesHiLvl[i]); //vendor string for menu
						 utils.addElement(modifiedRawRaceTypes, rawRaceTypesHiLvl[i]); //vendor race
					}
					//if the player is high lvl they can check/change the gender
					utils.setScriptVar(self, "vendor.checkGender", 1);  //VENDOR FUNCTION NEEDS TO CHECK VENDER SPECIFIC GENDER DATA
				}
				else
				{
					//get all 9 (or more) of the vendor creature types
					//for hiremod 50 and below
					string[] rawRaceTypesLowLvl = dataTableGetStringColumn(TBL_PLAYER_TYPES, 0);//TBL_PLAYER_TYPES = "datatables/vendor/vendor_player_types.iff";
					if(rawRaceTypesLowLvl == null)
						break;

					//LOOP THROUGH THE RACE TYPES
					for(int i = 0; i < rawRaceTypesLowLvl.length; i++)
					{
						 utils.addElement(localizedRaceTypes, "@player_structure:race_"+rawRaceTypesLowLvl[i]); //vendor string for menu
						 utils.addElement(modifiedRawRaceTypes, rawRaceTypesLowLvl[i]); //vendor race
					}
				}
				//Get any special Vendor Race Types - these have to go at bottom because of the random option
				if(allSpecialVendors != null)
				{
					//blog("player_building.handleVendorTypeSelect: allSpecialVendors != null. allSpecialVendors[0]: "+allSpecialVendors[0]);

					for(int i = 0; i < allSpecialVendors.length; i++)
					{
						 utils.addElement(localizedRaceTypes, "@player_structure:race_"+allSpecialVendors[i]);  //special vendor string for menu
						 utils.addElement(modifiedRawRaceTypes, allSpecialVendors[i]); //special vendor race
					}
					//if the player has special vendors, make sure they get option to check the gender in a future SUI
					utils.setScriptVar(self, "vendor.checkGender", 1); //VENDOR FUNCTION NEEDS TO CHECK VENDER SPECIFIC GENDER DATA
				}

				if(localizedRaceTypes == null || modifiedRawRaceTypes == null)
					break;

				utils.setScriptVar(player, "vendor.races", modifiedRawRaceTypes);
				sui.listbox(self, self, "@player_structure:race_type_d", sui.OK_CANCEL, "@player_structure:race_type_t", localizedRaceTypes, "handleVendorRaceSelect", true);
			}
			break;
		default: // Terminal
			// Get terminal types.
			string[] defaultTerminalTypes = dataTableGetStringColumn(TBL_TERMINAL_TYPES, 0);

			// Determine how many terminals we get based on our skill mod.
			int hireVar = 10;
			resizeable string[] defaultVendorTypes = new string[0];
			for(int i=0; i < defaultTerminalTypes.length; i++)
			{
				if(hiringMod >= hireVar)
					vendorTypes = utils.addElement(defaultVendorTypes, "@player_structure:terminal_"+defaultTerminalTypes[i]);
				hireVar += 20;
			}
			sui.listbox(player, player, "@player_structure:terminal_type_d", sui.OK_CANCEL, "@player_structure:terminal_type_t", defaultVendorTypes, "handleTerminalDesignSelect", true);
			break;
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleTerminalDesignSelect()
{
	// Grab params.
	int idx = sui.getListboxSelectedRow(params);
	if(idx < 0) idx = 0;
	obj_id player = sui.getPlayerId(params);
	int btn = sui.getIntButtonPressed(params);
	if(btn == sui.BP_CANCEL)
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	// Select terminal type.
	string[] rawTerminalTypes = dataTableGetStringColumn(TBL_TERMINAL_TYPES, 0);
	string terminalsuffix = "terminal_" + rawTerminalTypes[idx] + ".iff";

	// Store the info about the terminal we want to make.
	utils.setScriptVar(player, "vendor.terminalSuffix", terminalsuffix);

	// Ask them about the name.
	sui.inputbox(player, player, "@player_structure:name_d", sui.OK_CANCEL, "@player_structure:name_t", sui.INPUT_NORMAL, null, "handleSetVendorName", null);

	return SCRIPT_CONTINUE;
}

messageHandler handleDroidModelSelect()
{
	// Grab params.
	int idx = sui.getListboxSelectedRow(params);
	if(idx < 0) idx = 0;
	obj_id player = sui.getPlayerId(params);
	int btn = sui.getIntButtonPressed(params);
	if(btn == sui.BP_CANCEL)
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	// Select droid type.
	string[] rawDroidTypes = dataTableGetStringColumn(TBL_DROID_TYPES, 0);
	string droidsuffix = "droid_" + rawDroidTypes[idx] + ".iff";

	// Store the info about the terminal we want to make.
	utils.setScriptVar(player, "vendor.terminalSuffix", droidsuffix);

	// Ask them about the name.
	sui.inputbox(player, player, "@player_structure:name_d", sui.OK_CANCEL, "@player_structure:name_t", sui.INPUT_NORMAL, null, "handleSetVendorName", null);

	return SCRIPT_CONTINUE;
}

messageHandler handleVendorRaceSelect()
{
	blog("player_building.handleVendorRaceSelect: init");
	// Grab params.
	if(params == null || params.isEmpty())
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	int idx = sui.getListboxSelectedRow(params);
	if(idx < 0) idx = 0;
	obj_id player = sui.getPlayerId(params);
	int btn = sui.getIntButtonPressed(params);
	if(btn == sui.BP_CANCEL)
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	// Store the race index.
	utils.setScriptVar(player, "vendor.raceIndex", idx);
	utils.setScriptVar(player, "vendor.terminalSuffix", "NPC");

	////////////////////////////////////////////////////////
	//CHECK VENDOR GENDER TO SEE IF THEY HAVE FEMALE VER////
	////////////////////////////////////////////////////////

	int checkGender = utils.getIntScriptVar(player, "vendor.checkGender");
	blog("player_building.handleVendorRaceSelect: checkGender: "+checkGender);
	if(checkGender == 1)
	{
		// The chosen race may not have a female counterpart.
		string[] raceTypes = utils.getStringArrayScriptVar(player, "vendor.races");
		string raceChosen = raceTypes[idx];
		blog("player_building.handleVendorRaceSelect: raceChosen: "+raceChosen);

		///////////////////////////////
		//CHECK SPECIAL VENDOR GENDER//
		///////////////////////////////
		if(raceChosen.startsWith("special_vendor_"))
		{
			blog("player_building.handleVendorRaceSelect: Special Vendor = TRUE");
			//int genderIndex = getSpecialVendorVariables(raceChosen);
			int rowNum = dataTableSearchColumnForString(raceChosen, 0, TBL_SPECIAL_PLAYER_VENDOR_TYPES);
			if(rowNum < 0)
			{
				blog("player_building.handleVendorRaceSelect: rowNum is BAD");
				removeVendorVars(self);
				return SCRIPT_CONTINUE;
			}
			blog("player_building.handleVendorRaceSelect: rowNum: "+rowNum);

			dictionary dict = dataTableGetRow(TBL_SPECIAL_PLAYER_VENDOR_TYPES, rowNum);
			if(dict == null)
			{
				blog("player_building.handleVendorRaceSelect: Dictionary is NULL");

				removeVendorVars(self);
				return SCRIPT_CONTINUE;
			}
			blog("player_building.handleVendorRaceSelect: dict: "+dict);

			//can this special vendor speak basic?
			int vendorSpeaksBasic = dict.getInt("vendor_basic");
			if(vendorSpeaksBasic > 0)
				utils.setScriptVar(player, "vendor.special_vendor_basic", 1);
			else
				utils.setScriptVar(player, "vendor.special_vendor_basic", 0);

			blog("player_building.handleVendorRaceSelect: vendorSpeaksBasic: "+vendorSpeaksBasic);

			//can we clothe this special vendor?
			int vendor_clothing = dict.getInt("vendor_give");
			if(vendor_clothing > 0)
				utils.setScriptVar(player, "vendor.special_vendor_clothing", 1);
			else
				utils.setScriptVar(player, "vendor.special_vendor_clothing", 0);

			blog("player_building.handleVendorRaceSelect: vendor_clothing: "+vendor_clothing);

			//can we decrement the skill mod on the player?
			int decr_skillmod = dict.getInt("decrement_mod");
			blog("player_building.handleVendorRaceSelect: decr_skillmod equals: "+decr_skillmod);

			if(decr_skillmod > 0)
			{
				blog("player_building.handleVendorRaceSelect: decrementing skillmod: "+decr_skillmod);

				string skillModName = dict.getString("skill_mod");
				blog("player_building.handleVendorRaceSelect: skillModName: "+skillModName);

				if(skillModName != null && !skillModName.equals(""))
				{
					blog("player_building.handleVendorRaceSelect: setting skill mod to decrement");

					utils.setScriptVar(player, "vendor.special_decrement_skillmod", true);
					utils.setScriptVar(player, "vendor.special_vendor_skillmod", skillModName);
				}

			}
			//Are there any gender limitations on the special vendor??

			int specialVendorMale = dict.getInt("vendor_has_male");//if this equals zero, there are no males
			int specialVendorFemale = dict.getInt("vendor_has_female");//if this equals zero, there are no females
			if(specialVendorMale == 0 && specialVendorFemale == 0)//if this is true then we bail
			{
				blog("player_building.handleVendorRaceSelect: both Male and Female == 0");

				removeVendorVars(self);
				return SCRIPT_CONTINUE;
			}

			if(specialVendorMale == 1 && specialVendorFemale == 0)//male only
			{
				// Don't ask about gender.
				utils.setScriptVar(player, "vendor.genderIndex", 0);
				utils.setScriptVar(player, "vendor.gender.male_only_no_female", true);
				utils.setScriptVar(player, "vendor.gender.female_only_no_male", false);
			}
			else if(specialVendorMale == 0 && specialVendorFemale == 1) //female only
			{
				blog("player_building.handleVendorRaceSelect:Female ONLY");

				// Don't ask about gender.
				utils.setScriptVar(player, "vendor.genderIndex", 1);
				utils.setScriptVar(player, "vendor.gender.female_only_no_male", true);
				utils.setScriptVar(player, "vendor.gender.male_only_no_female", false);
			}
			//if the special vendor has both than we drop out and go to handleVendorGenderSelect via bottom SUI
		}
		else
		{
			blog("player_building.handleVendorRaceSelect: NOT A Special Vendor");

			int row = dataTableSearchColumnForString(raceChosen, "VENDOR_TYPES", TBL_ALLNPC_TYPES);
			dictionary dict = dataTableGetRow(TBL_ALLNPC_TYPES, row);
			int hasFemale = dict.getInt("HAS_FEMALE"); //this means they either have a female or not...no just female in this group
			blog("player_building.handleVendorRaceSelect: Has Female(0=no, 1=yes): "+hasFemale);
			if(hasFemale == 0)
			{
				blog("player_building.handleVendorRaceSelect: No female, no gender UI needed");
				// Don't ask about gender.
				utils.setScriptVar(player, "vendor.genderIndex", 0);
				utils.setScriptVar(player, "vendor.gender.male_only_no_female", true);
			}
			else
			{
				blog("player_building.handleVendorRaceSelect: Female exists, we'll need to decide which gender");
				// DO ASK about gender.
				utils.setScriptVar(player, "vendor.genderIndex", 1);
			}
		}
	}

	if(utils.getBooleanScriptVar(player, "vendor.gender.male_only_no_female") || utils.getBooleanScriptVar(player, "vendor.gender.female_only_no_male"))
	{
		blog("player_building.handleVendorRaceSelect: Either there is No female or No Male in this vendor");

		//Since there is only one gender ask the player about the vendor name.
		if(utils.getIntScriptVar(player, "vendor.genderIndex") == 0 || utils.getIntScriptVar(player, "vendor.genderIndex") == 1) //male or female only
		{
			blog("player_building.handleVendorRaceSelect: Male only for this vendor");
			sui.inputbox(player, player, "@player_structure:name_d", sui.OK_CANCEL, "@player_structure:name_t", sui.INPUT_NORMAL, null, "handleSetVendorName", null);
			return SCRIPT_CONTINUE;
		}
	}

	//Since there are both genders ask the player to decided
	utils.setScriptVar(player, "vendor.gender.female_only_no_male", false);
	utils.setScriptVar(player, "vendor.gender.male_only_no_female", false);
	blog("player_building.handleVendorRaceSelect: Setting female and male only to false");

	string[] possibleNPCGender = { "@player_structure:male", "@player_structure:female" };
	sui.listbox(player, player, "@player_structure:gender_d", sui.OK_CANCEL, "@player_structure:gender_t", possibleNPCGender, "handleVendorGenderSelect", true);
	return SCRIPT_CONTINUE;
}

messageHandler handleVendorGenderSelect()
{
	blog("player_building.handleVendorGenderSelect: init");

	if(params == null || params.isEmpty())
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	// Grab params.
	int idx = sui.getListboxSelectedRow(params);
	if(idx < 0) idx = 0;
	obj_id player = sui.getPlayerId(params);
	int btn = sui.getIntButtonPressed(params);
	if(btn == sui.BP_CANCEL)
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	// Store the gender index.
	utils.setScriptVar(player, "vendor.genderIndex", idx);
	blog("player_building.handleVendorGenderSelect: idx: "+idx);
	// Ask them about the name.
	sui.inputbox(player, player, "@player_structure:name_d", sui.OK_CANCEL, "@player_structure:name_t", sui.INPUT_NORMAL, null, "handleSetVendorName", null);

	return SCRIPT_CONTINUE;
}

messageHandler handleSetVendorName()
{
	blog("player_building.handleSetVendorName: init");

	if(params == null || params.isEmpty())
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	// Store the vendor name.
	obj_id player = sui.getPlayerId(params);
	string vendorName = sui.getInputBoxText(params);
	int btn = sui.getIntButtonPressed(params);
	if(btn == sui.BP_CANCEL)
	{
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	// No zero length or obscene names.
	if((vendorName == "") || isNameReserved(vendorName))
	{
		// Ask them about the name.
		sendSystemMessage(player, SID_OBSCENE);
		sui.inputbox(player, player, "@player_structure:name_d", sui.OK_CANCEL, "@player_structure:name_t", sui.INPUT_NORMAL, null, "handleSetVendorName", null);
		return SCRIPT_CONTINUE;
	}

	if(vendorName.length() > 40)
		vendorName = vendorName.substring(0, 39);

	blog("player_building.handleSetVendorName: vendorName: "+vendorName);

	utils.setScriptVar(player, "vendor.vendorName", vendorName);

	// Send message to create the vendor.
	messageTo(player, "buildVendor", null, 0, false);

	return SCRIPT_CONTINUE;
}

//test permissions!!!!
messageHandler buildVendor()
{
	blog("player_building.buildVendor: init");
	obj_id player = self;

	// THERE ARE NO PARAMS - This was a msgto.

	string terminalSuffix = utils.getStringScriptVar(player, "vendor.terminalSuffix");
	if(terminalSuffix == null || terminalSuffix.equals(""))
	{
		removeVendorVars(player);
		return SCRIPT_CONTINUE;
	}

	string vendorName = utils.getStringScriptVar(player, "vendor.vendorName");
	if(vendorName == null || vendorName.equals(""))
	{
		blog("player_building.buildVendor: vendorName was null");
		removeVendorVars(player);
		return SCRIPT_CONTINUE;
	}
	if(utils.isFreeTrial(player))
	{
		removeVendorVars(player);
		return SCRIPT_CONTINUE;
	}

	blog("player_building.buildVendor: vendor data initial validation pass");

	// Validate structure.
	obj_id structure = player_structure.getStructure(player);
	obj_id inventory = getObjectInSlot(player, "inventory");
	if(!isIdValid(structure))
	{
		removeVendorVars(player);
		return SCRIPT_CONTINUE;
	}
	if(inventory == null || inventory == obj_id.NULL_ID)
	{
		removeVendorVars(player);
		return SCRIPT_CONTINUE;
	}

	//Create a null vendor object. The original scripter persists this object at the
	//bottom of this function.
	obj_id vendor = null;
	if(terminalSuffix == "NPC")
	{
		string[] genderList = { "male", "female" }; //used to construct the template name
		string creatureName = "vendor";
		string templateName;

		int raceIndex = utils.getIntScriptVar(player, "vendor.raceIndex"); //a specific row in TBL_PLAYER_TYPES
		if(raceIndex < 0)
		{
			removeVendorVars(player);
			return SCRIPT_CONTINUE;
		}

		int genderIndex = utils.getIntScriptVar(player, "vendor.genderIndex"); //either 0 or 1
		if(genderIndex < 0 || genderIndex > 1)
			genderIndex = 0;

		if(raceIndex == 0) //In other words, if the player selected the RANDOM Race Option we create a random vendor from 9 creature types
		{
			string[] playerTypes = dataTableGetStringColumn(TBL_PLAYER_TYPES, 0); //TBL_PLAYER_TYPES, basic creatures with length of 9
			if(playerTypes == null)
			{
				removeVendorVars(player);
				return SCRIPT_CONTINUE;
			}

			templateName = playerTypes[rand(1,playerTypes.length-1)] + "_" + genderList[genderIndex] + ".iff";
		}
		//not a random vendor, player specific
		else
		{
			//vendor races based off of hire mod plus possible special vendors based off of hire mod
			string[] raceTypes = utils.getStringArrayScriptVar(player, "vendor.races");
			if(raceTypes == null)
			{
				removeVendorVars(player);
				return SCRIPT_CONTINUE;
			}

			string specificRace = raceTypes[raceIndex];
			if(specificRace == null || specificRace.equals(""))
				return SCRIPT_CONTINUE;

			boolean maleOnly = utils.getBooleanScriptVar(player, "vendor.gender.male_only_no_female");
			boolean femaleOnly = utils.getBooleanScriptVar(player, "vendor.gender.female_only_no_male");
			//in some cases there are only male or female. make sure to catch this
			if(maleOnly)
			{
				genderIndex = 0;
			}
			else if(femaleOnly)
			{
				genderIndex = 1;
			}

			templateName = specificRace + "_" + genderList[genderIndex] + ".iff";
		}

		if(templateName == null || templateName.equals(""))
		{
			removeVendorVars(player);
			return SCRIPT_CONTINUE;
		}

		vendor = createObject(create.TEMPLATE_PREFIX + "vendor/" + templateName, inventory, ""); //create.TEMPLATE_PREFIX = "object/mobile/"
		if(!isIdValid(vendor) || !exists(vendor))
		{
			removeVendorVars(player);
			return SCRIPT_CONTINUE;
		}

		obj_id inv = getObjectInSlot(self, "inventory");
		if((inv == null) || (inv == obj_id.NULL_ID))
		{
			sendSystemMessage(player, SID_SYS_CREATE_FAILED);
			destroyObject(vendor);
			removeVendorVars(self);
			return SCRIPT_CONTINUE;
		}

		if((vendor != null))
		{
			// Set flags.
			setInvulnerable(vendor, true);
			ai_lib.setDefaultCalmBehavior(vendor, ai_lib.BEHAVIOR_SENTINEL);
			setObjVar(vendor, "vendor.NPC", 1);

			// Attach vendor script (cos the template won't do it for us).
			detachAllScripts(vendor);
			attachScript(vendor, "terminal.vendor");
			attachScript(vendor, "terminal.npc_vendor");

			boolean specialVendor = templateName.startsWith("special_vendor_");
			//check for any special vendors
			if(specialVendor)
			{

				sendSystemMessage(player, SID_TCG_VENDOR_CTS_WARNING);

				//this objvar is used to identify the vendor as special
				setObjVar(vendor, vendor_lib.SPECIAL_VENDOR_IDENTIFIER, true);

				//this special vendor can/can't speak basic
				if(utils.hasScriptVar(player, "vendor.special_vendor_basic"))
					setObjVar(vendor, "vendor.special_vendor_basic", utils.getIntScriptVar(player, "vendor.special_vendor_basic"));

				//this special vendor can/can't be dressed
				if(utils.hasScriptVar(player, "vendor.special_vendor_clothing"))
					setObjVar(vendor, "vendor.special_vendor_clothing", utils.getIntScriptVar(player, "vendor.special_vendor_clothing"));

				//this special vendor skill mod must be removed when used by player.
				if(utils.hasScriptVar(player, "vendor.special_decrement_skillmod") && utils.hasScriptVar(player, "vendor.special_vendor_skillmod"))
				{
					string skillMod = utils.getStringScriptVar(player, "vendor.special_vendor_skillmod");
					if(skillMod == null || skillMod.equals(""))
					{
						sendSystemMessage(player, SID_SYS_CREATE_FAILED);
						destroyObject(vendor);
						removeVendorVars(self);
						return SCRIPT_CONTINUE;
					}

					setObjVar(vendor, "vendor.special_decrement_skillmod", true);
					setObjVar(vendor, "vendor.special_vendor_skillmod", skillMod);

					CustomerServiceLog("vendor", "Vendor requires a skill mod: "+skillMod+" that is being decremented on the owner. Owner: " + player + " Vendor: " + vendor + " Location created is player inventory");
					if(getSkillStatMod(self, skillMod) <= 0)
					{
						CustomerServiceLog("vendor", " POSSIBLE EXPLOIT!!! Vendor: " + vendor + " had skill mod: " + skillMod + " that was supposed to be decremented on Owner: " + player + " but the owner did not have the skill mod. Possible exploit or other problematic issue. Notify design.");
						sendSystemMessage(player, SID_SYS_CREATE_FAILED);
						destroyObject(vendor);
						removeVendorVars(self);
						return SCRIPT_CONTINUE;
					}
					applySkillStatisticModifier(player, skillMod, -1);
					CustomerServiceLog("vendor", " Vendor: " + self + " had skill mod: " + skillMod + " that was reimbursed to the Owner: " + player + ". Skill mod decremented by 1. Location created is player inventory");
				}
			}
			else if(templateName.indexOf("ithorian") > -1)// Give ITHORIAN clothes.
			{
				dressup.dressNpc(vendor, "random_ithorian", true);
				setObjVar(vendor, "dressed", 1);
			}
			else //all else gets the following
			{
				dressup.dressNpc(vendor, "rich_no_jacket");
			}
		}
		else
		{
			sendSystemMessage(player, SID_SYS_CREATE_FAILED);
			destroyObject(vendor);
			removeVendorVars(self);
			return SCRIPT_CONTINUE;
		}
	}
	else
	{
		// Get object template.
		string vendorTemplate = "object/tangible/vendor/vendor_" + terminalSuffix;
		if(vendorTemplate == null || vendorTemplate.equals(""))
		{
			CustomerServiceLog("playerStructure", "Vendor Placement: Player: "+getName(self)+" "+self+" selected vendor type: "+terminalSuffix+" but the selection type failed.");
			return SCRIPT_CONTINUE;
		}
		vendor = createObject(vendorTemplate, inventory, "");
	}
	if(!isIdValid(vendor))
	{
		sendSystemMessage(player, SID_SYS_CREATE_FAILED);
		removeVendorVars(self);
		return SCRIPT_CONTINUE;
	}

	// Persist vendor.
	persistObject(vendor);
	setCondition(vendor, CONDITION_VENDOR);
	setName(vendor, "Vendor: " + vendorName);

	// Update player.
	int usedSlots = getIntObjVar(player, "used_vendor_slots") + 1;
	setObjVar(player, "used_vendor_slots", usedSlots);
	setObjVar(vendor, "vendor_owner", player); // Suppress linting - The lint script is incorrectly catching
	setOwner(vendor, player);											//					  this due to a similarly named array
	setObjVar(player, "vendor_not_initialized", vendor);//this is removed IN C++ when the player sets the vendor in a valid location
	removeVendorVars(self);

	// Set up vendor maintenance.
	int condition = 1000;
	int items_stored = 0;
	setObjVar(vendor, vendor_lib.VAR_MAINTENANCE_RATE, vendor_lib.BASE_MAINT_RATE);
	setObjVar(vendor, vendor_lib.VAR_DECAY_RATE, vendor_lib.BASE_DECAY_RATE);
	if(condition > 0)
	{
		setObjVar(vendor, vendor_lib.VAR_MAX_CONDITION, 1000);
		setObjVar(vendor, vendor_lib.VAR_CONDITION, 1000);
	}

	// Start the maintenance loop.
	int time_stamp = getGameTime();
	setObjVar(vendor, vendor_lib.VAR_LAST_MAINTANENCE, time_stamp);
	dictionary outparams = new dictionary();
	outparams.put("timestamp", time_stamp);

	messageTo(vendor, "OnMaintenanceLoop", outparams, vendor_lib.MAINTENANCE_HEARTBEAT, false);

	// Success.
	sendSystemMessage(player, SID_SYS_CREATE_SUCCESS);

	return SCRIPT_CONTINUE;
}

//bottom
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************

messageHandler msgAssignDroid()
{
	LOG("LOG_CHANNEL", "player_building::msgAssignDroid --" + self);

	obj_id[] droid_list = player_structure.getMaintenanceDroids(self);

	if(droid_list.length <= 0)
	{
		LOG("LOG_CHANNEL", "Error retrieving your list of maintenance capable droids.");
		sendSystemMessage(self, new string_id(STF, "error_droid_list")); // Error retrieving your list of maintenance capable droids.
		return SCRIPT_CONTINUE;
	}

	int bp = sui.getIntButtonPressed(params);

	if(bp == sui.BP_REVERT)
	{
		return SCRIPT_CONTINUE;
	}
	else if(bp == sui.BP_OK)
	{

		int row_selected = sui.getListboxSelectedRow(params);

		if(row_selected != -1)
		{
			int max_maint = (((getIntObjVar(droid_list[row_selected], "module_data.struct_maint") - 1) / 5) + 1) * 3;
			obj_id[] maint_list = getObjIdArrayObjVar(droid_list[row_selected], "module_data.maint_list.ids");

			if(maint_list == null || maint_list.length == 0)
			{
				maint_list = new obj_id[max_maint];
			}

			obj_id structure = player_structure.getStructure(self);

			if(!isIdValid(structure))
			{
				return SCRIPT_CONTINUE;
			}

			for(int i = 0; i < maint_list.length; i++)
			{
				if(maint_list[i] == structure)
				{
					sendSystemMessage(self, new string_id(STF, "structure_on_list")); // This structure is already on that droid's maintenance list.
					return SCRIPT_CONTINUE;
				}

				if(!isIdValid(maint_list[i]))
				{
					maint_list[i] = structure;
					setObjVar(droid_list[row_selected], "module_data.maint_list.ids", maint_list);
					setObjVar(droid_list[row_selected], "module_data.maint_list.loc_"+i, getLocation(structure));

					if(callable.hasCDCallable(droid_list[row_selected]))
					{
						obj_id droid = callable.getCDCallable(droid_list[row_selected]);

						setObjVar(droid, "module_data.maint_list.ids", maint_list);
						setObjVar(droid, "module_data.maint_list.loc_"+i, getLocation(structure));
					}

					string structName = "";

					prose_package ppDroidAssigned = prose.getPackage(SID_DROID_ASSIGNED_TO_MAINTAIN);
					prose.setTT(ppDroidAssigned, droid_list[row_selected]);

					if(!player_structure.isInstallation(structure) && hasObjVar(structure, player_structure.VAR_SIGN_NAME))
					{
						prose.setTO(ppDroidAssigned, getStringObjVar(structure, player_structure.VAR_SIGN_NAME));
					}
					else
					{
						prose.setTO(ppDroidAssigned, structure);
					}

					sendSystemMessageProse(self, ppDroidAssigned);

					return SCRIPT_CONTINUE;
				}
			}

			sendSystemMessage(self, new string_id(STF, "droid_full")); // That droid has the maximum number of structures assigned to it already.  Call the droid and edit it's maintenance list before assigning more structures to it.
		}
	}

	return SCRIPT_CONTINUE;
}

messageHandler turnstileExpire()
{
	if(params == null)
		return SCRIPT_CONTINUE;

	// Are we in that building still?
	obj_id building = params.getObjId("building");
	if(isIdValid(building))
	{
		obj_id cont = getTopMostContainer(self);
		if(cont == building)
		{
			params.put("sender", building);
			messageTo(self, "handleEjection", params, 1.f, false);
			sendSystemMessage(self, SID_TURNSTILE_EXPIRE);
		}
	}

	return SCRIPT_CONTINUE;
}

messageHandler msgEnterPermissions()
{
	LOG("LOG_CHANNEL", "player_building::msgEnterPermissions--" + params);
	int row_selected = sui.getListboxSelectedRow(params);
	obj_id structure = player_structure.getStructure(self);

	if((structure == null)||(structure == obj_id.NULL_ID))
	{
		return SCRIPT_CONTINUE;
	}

	if(row_selected != -1)
	{
		string[] enter_list;
		if(isGod(self))
		{
			enter_list = player_structure.getCompleteEntryList(structure);
		}
		else
		{
			enter_list = player_structure.getEntryList(structure);
		}
		string player_name = enter_list[row_selected];
		player_structure.modifyEntryList(structure, player_name, self);
	}

	return SCRIPT_CONTINUE;
}

messageHandler msgBanPermissions()
{
	LOG("LOG_CHANNEL", "player_building::msgBanPermissions--" + params);
	int row_selected = sui.getListboxSelectedRow(params);
	obj_id structure = player_structure.getStructure(self);

	if((structure == null)||(structure == obj_id.NULL_ID))
	{
		return SCRIPT_CONTINUE;
	}

	if(row_selected != -1)
	{
		string[] ban_list = player_structure.getBanList(structure);
		string player_name = ban_list[row_selected];
		player_structure.modifyBanList(structure, player_name, self);
	}

	return SCRIPT_CONTINUE;
}

messageHandler msgAdminPermissions()
{
	LOG("LOG_CHANNEL", "player_building::msgAdminPermissions--" + params);
	int row_selected = sui.getListboxSelectedRow(params);
	obj_id structure = player_structure.getStructure(self);

	if((structure == null)||(structure == obj_id.NULL_ID))
	{
		return SCRIPT_CONTINUE;
	}

	if(row_selected != -1)
	{
		string[] admin_list = player_structure.getAdminListNames(structure);
		string player = admin_list[row_selected];
		player_structure.modifyAdminList(structure, player, self);
	}

	return SCRIPT_CONTINUE;
}

messageHandler msgVendorPermissions()
{
	LOG("LOG_CHANNEL", "player_building::msgVendorPermissions--" + params);
	int row_selected = sui.getListboxSelectedRow(params);
	obj_id structure = player_structure.getStructure(self);

	if((structure == null)||(structure == obj_id.NULL_ID))
	{
		return SCRIPT_CONTINUE;
	}

	if(row_selected != -1)
	{
		string[] vendor_list = player_structure.getVendorList(structure);
		string player_name = vendor_list[row_selected];
		player_structure.modifyVendorList(structure, player_name, self);
	}

	return SCRIPT_CONTINUE;
}

messageHandler msgHopperPermissions()
{
	LOG("LOG_CHANNEL", "player_building::msgHopperPermissions--" + params);
	int row_selected = sui.getListboxSelectedRow(params);
	obj_id structure = player_structure.getStructure(self);

	if((structure == null)||(structure == obj_id.NULL_ID))
	{
		return SCRIPT_CONTINUE;
	}

	if(row_selected != -1)
	{
		string[] hopper_list = player_structure.getHopperListNames(structure);
		string player = hopper_list[row_selected];
		player_structure.modifyHopperList(structure, player, self);
	}

	return SCRIPT_CONTINUE;
}

messageHandler msgPayMaintenance()
{
	LOG("LOG_CHANNEL", "player_building::msgPayMaintenance --" + self);
	obj_id target = utils.getObjIdScriptVar(self, "payMaintenance.target");
	boolean fromScd = pclib.isContainedByPlayer(self, target);

	utils.removeScriptVarTree(self, "payMaintenance");

	if(!isIdValid(target))
	{
		return SCRIPT_CONTINUE;
	}

	if(!fromScd && player_structure.getStructure(self) != target)
	{
		sendSystemMessage(self, new string_id(STF, "pay_out_of_range")); // You have moved out of range of your original /payMaintenance target. Aborting...
		return SCRIPT_CONTINUE;
	}

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
		return SCRIPT_CONTINUE;

	int amt = sui.getTransferInputTo(params);
	if(amt < 1)
		return SCRIPT_CONTINUE;

	if(fromScd)
	{
		queueCommand(self, ##"payMaintenance", target, Integer.toString(amt), COMMAND_PRIORITY_DEFAULT);
	}
	else
	{
		queueCommand(self, ##"payMaintenance", null, Integer.toString(amt), COMMAND_PRIORITY_DEFAULT);
	}
	return SCRIPT_CONTINUE;
}

messageHandler msgAddPower()
{
	LOG("LOG_CHANNEL", "player_building::msgAddPower --" + self);
	obj_id target = utils.getObjIdScriptVar(self, "addPower.target");
	utils.removeScriptVarTree(self, "addPower");

	if(isIdValid(target) && player_structure.getStructure(self) != target)
	{
		sendSystemMessage(self, new string_id(STF, "power_out_of_range")); // You have moved out of range of your original /addPower target. Aborting...
		return SCRIPT_CONTINUE;
	}

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
		return SCRIPT_CONTINUE;

	int amt = sui.getTransferInputTo(params);
	if(amt < 1)
		return SCRIPT_CONTINUE;

	queueCommand(self, ##"addPower", null, Integer.toString(amt), COMMAND_PRIORITY_DEFAULT);
	return SCRIPT_CONTINUE;
}

messageHandler msgDepositPowerIncubator()
{
	obj_id target = utils.getObjIdScriptVar(self, "depositPowerIncubator.target");
	utils.removeScriptVarTree(self, "depositPowerIncubator");

	if(isIdValid(target) && !incubator.validateActiveUser(target, self))
	{
		// You are not the owner of the incubator...
		sendSystemMessage(self, incubator.SID_NOT_YOUR_INCUBATOR);
		return SCRIPT_CONTINUE;
	}

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
	{
		//clean dangling scriptVars
		utils.removeScriptVarTree(self, "powerIncubator");
		return SCRIPT_CONTINUE;
	}

	int amt = sui.getTransferInputTo(params);
	if(amt < 1)
		return SCRIPT_CONTINUE;

	queueCommand(self, ##"depositPowerIncubator", target, Integer.toString(amt), COMMAND_PRIORITY_DEFAULT);
	return SCRIPT_CONTINUE;
}

messageHandler msgWithdrawMaintenance()
{
	LOG("LOG_CHANNEL", "player_building::msgWithdrawMaintenance --" + self);

	string amount_str = sui.getInputBoxText(params);

	if(utils.stringToInt(amount_str) > 0)
		queueCommand(self, ##"paWithdraw", null, amount_str, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

messageHandler msgNameStructure()
{
	LOG("LOG_CHANNEL", "player_building::msgNameStructure --" + self);

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
		return SCRIPT_CONTINUE;

	string name = sui.getInputBoxText(params);
	if(name == null || name.length() < 1)
	{
		LOG("LOG_CHANNEL", self + " ->That is not a valid name.");
		sendSystemMessage(self, new string_id(STF, "not_valid_name")); // That is not a valid name.
		return SCRIPT_CONTINUE;
	}

	queueCommand(self, ##"nameStructure", null, name, COMMAND_PRIORITY_DEFAULT);

	return SCRIPT_CONTINUE;
}

messageHandler OnAddStructure()
{
	LOG("LOG_CHANNEL", "player_building::OnAddStructure");

	obj_id structure = params.getObjId("structure");
	string template = params.getString("template");
	string structure_name = params.getString("structure_name");
	location structure_loc = params.getLocation("structure_loc");

	LOG("LOG_CHANNEL", "structure_name ->" + structure_name);

	// Update the players ownership list
	player_structure.addStructure(structure, template, structure_name, structure_loc, self, getFirstName(self), false, true);

	// Add a waypoint at the structure's location
	if(structure_loc != null)
		player_structure.addStructureWaypoint(self, structure_loc, structure_name, structure);

	return SCRIPT_CONTINUE;
}

messageHandler OnRemoveStructure()
{
	LOG("LOG_CHANNEL", "player_building::OnRemoveStructure");

	obj_id structure = params.getObjId("structure");
	string template = params.getString("template");
	obj_id waypoint = params.getObjId("waypoint");

	// Update the players ownership list
	player_structure.removeStructure(structure, template, self, getFirstName(self), false, true);

	// remove waypoint
	if(waypoint != null)
		destroyWaypointInDatapad(waypoint, self);

	// We must clean up any droids that have structure maintenance on them and this structure.
	obj_id[] callables = callable.getDatapadCallablesByType(self, callable.CALLABLE_TYPE_COMBAT_PET); // Droids are combat pets.
	
	if(callables == null || callables.length <= 0)
	{
		return SCRIPT_CONTINUE;
	}
	
	// This loop finds all droid pcd's and removes maintenance for this structure off them.
	for(int i = 0, j = callables.length; i < j; i++)
	{
		if(!isIdValid(callables[i]) || !exists(callables[i]))
		{
			continue;
		}

		// Does this pet have a maintenance list?
		if(!hasObjVar(callables[i], "module_data.maint_list.ids"))
		{
			continue;
		}

		obj_id[] struct_list = getObjIdArrayObjVar(callables[i], "module_data.maint_list.ids");
		
		// Empty structures list for maintenance?
		if(struct_list == null || struct_list.length <= 0)
		{
			continue;
		}

		int structureIndex = utils.getElementPositionInArray(struct_list, structure);

		// Is the structure in the maintenance list?
		if(structureIndex < 0)
		{
			continue;
		}

		// At this point, the structure is in a droid's maintenance list and we know the control object.
		// We must make sure we get the droid's obj_id if it is out.
		
		obj_id droid = callable.getCDCallable(callables[i]);
		
		player_structure.removeStructureFromMaintenance(droid, callables[i], structureIndex);
	}

	return SCRIPT_CONTINUE;
}

//this is related to the conversion code for old 9-lot halls vs. new 7-lot halls
messageHandler handleAdjustLotCount()
{
	int numLots = params.getInt("lotAdjust");
	adjustLotCount(getPlayerObject(self), numLots);
	return SCRIPT_CONTINUE;
}

messageHandler OnClearConfirmDestroy()
{
	LOG("LOG_CHANNEL", "player_building::OnClearConfirmDestroy");
	if(utils.hasScriptVar(self, player_structure.VAR_CONFIRM_DESTROY))
		utils.removeScriptVar(self, player_structure.VAR_CONFIRM_DESTROY);

	return SCRIPT_CONTINUE;
}

messageHandler OnConstructionComplete()
{
	// Give the play an e-mail.
	string_id structure_name = params.getStringId("structure_name");
	int lots_remaining = player_structure.MAX_LOTS - getAccountNumLots(getPlayerObject(self));

	prose_package pp_msg = new prose_package();
	pp_msg.stringId = ((lots_remaining >= 0) ? SID_CONSTRUCTION_COMPLETE : SID_CONSTRUCTION_COMPLETE_LOT_LIMIT_EXCEEDED);
	pp_msg.actor.set(self);
	pp_msg.other.set(structure_name);
	pp_msg.digitInteger = ((lots_remaining >= 0) ? lots_remaining : -lots_remaining);

	string send_msg    = "@" + SID_CONSTRUCTION_COMPLETE_SENDER.toString  ();
	string subject_str = "@" + SID_CONSTRUCTION_COMPLETE_SUBJECT.toString ();
	string body_msg    = chatMakePersistentMessageOutOfBandBody (null, pp_msg);
	chatSendPersistentMessage(send_msg, getFirstName(self), subject_str, null, body_msg);

	return SCRIPT_CONTINUE;
}

messageHandler msgPAWithdrawSuccess()
{
	//LOG("LOG_CHANNEL", "player_building::msgPAWithdrawSuccess");
	if(params != null)
	{
		int amt = params.getInt("amount");
		if(amt > 0)
		{
			sendSystemMessageProse(self, prose.getPackage(new string_id (STF, "withdraw_credits"), amt)); // You withdraw %DI credits from the treasury.
		}
	}

	return SCRIPT_CONTINUE;
}

messageHandler msgPAWithdrawFail()
{
	sendSystemMessage(self, new string_id(STF, "withdrawal_failed")); // Withdrawal from treasury failed.

	return SCRIPT_CONTINUE;
}

messageHandler handleStatusUi()
{
	obj_id target = utils.getObjIdScriptVar(self, "player_structure.status.target");
	boolean fromScd = utils.hasScriptVar(self, "player_structure.status.fromScd");
	utils.removeScriptVarTree(self, "player_structure.status");

	obj_id newTarget = fromScd? target : player_structure.getStructure(self);
	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_OK)	//refresh
	{
		if(!isIdValid(target))
			sendSystemMessage(self, new string_id(STF, "no_valid_structurestatus")); // Your /structureStatus target is no longer valid. Cancelling refresh.
		else
		{
			if(newTarget == target)
				queueCommand(self, ##"structureStatus", fromScd? newTarget : null, "", COMMAND_PRIORITY_DEFAULT);
			else
				sendSystemMessage(self, new string_id(STF, "changed_structurestatus")); // Your /structureStatus target has changed. Cancelling refesh.
		}
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleDestroyUi()
{
	utils.removeScriptVar(self, "player_structure.destroy.pid");

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
	{
		utils.removeScriptVarTree(self, "player_structure.destroy");
		return SCRIPT_CONTINUE;
	}

	obj_id target = utils.getObjIdScriptVar(self, "player_structure.destroy.target");
	obj_id structure = player_structure.getStructure(self);
	if(!confirmDestroyTarget(structure, target))
		return SCRIPT_CONTINUE;

	string_id confirm_destruction_title = new string_id(STF, "confirm_destruction_t"); // Confirm Structure Destruction
	string title = getString(confirm_destruction_title);

	string_id redeed_structure_prefix = new string_id(STF, "your_structure_prefix"); // Your structure
	string prompt = getString(redeed_structure_prefix) + "\\";

	boolean willRedeed = utils.getBooleanScriptVar(self, "player_structure.destroy.willredeed");
	if(willRedeed)
	{
		string_id will_redeed_confirm_text = new string_id(STF, "will_redeed_confirm"); // WILL
		prompt += colors_hex.LIMEGREEN+getString(will_redeed_confirm_text);
	}
	else
	{
		string_id will_not_redeed_confirm_text = new string_id(STF, "will_not_redeed_confirm"); // WILL NOT
		prompt += colors_hex.TOMATO+getString(will_not_redeed_confirm_text);
	}

	prompt += "\\#.";
	string_id will_redeed_confirm_suffix_text = new string_id(STF, "will_redeed_suffix"); //  be redeeded. If you wish to continue with destroying your structure, please enter the following code into the inputbox.
	prompt += getString(will_redeed_confirm_suffix_text);

	int key = utils.getIntScriptVar(self, "player_structure.destroy.key");
	if(key == 0)
	{
		key = rand(100000, 999999);
		utils.setScriptVar(self, "player_structure.destroy.key", key);
	}

	prompt += "\n\nCode: "+key;

	//int pid = sui.inputbox(self, self, prompt, title, "handleDestroyConfirm", "");
	int pid = sui.inputbox(self, self, prompt, title, "handleDestroyConfirm", 6, false, "");
	if(pid > -1)
	{
		utils.setScriptVar(self, "player_structure.destroy.pid", pid);
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleDestroyConfirm()
{
	utils.removeScriptVar(self, "player_structure.destroy.pid");

	int bp = sui.getIntButtonPressed(params);
	string text = sui.getInputBoxText(params);
	if(bp == sui.BP_CANCEL || text == null || text.equals(""))
	{
		utils.removeScriptVarTree(self, "player_structure.destroy");
		return SCRIPT_CONTINUE;
	}

	obj_id target = utils.getObjIdScriptVar(self, "player_structure.destroy.target");
	obj_id structure = player_structure.getStructure(self);
	if(!confirmDestroyTarget(structure, target))
		return SCRIPT_CONTINUE;

	int key = utils.getIntScriptVar(self, "player_structure.destroy.key");
	string skey = Integer.toString(key);

	if(text.equals(skey))
	{
		if(tcg.isBarnStructure(structure) && tcg.getTotalBarnStoredBeasts(structure) > 0)
		{
			string title = utils.packStringId(new string_id("tcg", "barn_confirm_destroy_with_beasts_title"));
			string testMsg = utils.packStringId(new string_id("tcg", "barn_confirm_destroy_with_beasts_prompt"));
			string ok_button = utils.packStringId(new string_id ("quest/ground/util/quest_giver_object", "button_accept"));
			string cancel_button = utils.packStringId(new string_id ("quest/ground/util/quest_giver_object", "button_decline"));

			// Create the dialog page.
			int pid = sui.createSUIPage(sui.SUI_MSGBOX, self, self, "handleDestroyBarnAndBeastsConfirm");

			// Add elements text.
			setSUIProperty(pid, sui.MSGBOX_TITLE, sui.PROP_TEXT, title);
			setSUIProperty(pid, sui.MSGBOX_PROMPT, sui.PROP_TEXT, testMsg);

			// Add buttons.
			sui.msgboxButtonSetup(pid, sui.OK_ONLY);

			// Show dialog.
			utils.setScriptVar(self, "player_structure.destroy.barn_text", text);
			sui.showSUIPage(pid);
		}
		else
		{
		utils.setScriptVar(self, player_structure.VAR_CONFIRM_DESTROY, target);
		sendSystemMessage(self, new string_id(STF, "processing_destruction")); // Processing confirmed structure destruction...
		queueCommand(self, ##"destroyStructure", null, text, COMMAND_PRIORITY_DEFAULT);
	}
	}
	else
	{
		sui.msgbox(self, "@player_structure:incorrect_destroy_code");
		utils.removeScriptVarTree(self, "player_structure.destroy");
	}

	return SCRIPT_CONTINUE;
}

messageHandler handleDestroyBarnAndBeastsConfirm()
{

	return SCRIPT_CONTINUE;
}

//HOUSE PACK UP handlePlayerStructurePackupLockout()
//Called when the player uses the packup option on an
//abandoned structure (a sign or in case of factory
//the structure itself). The lockout sets a scriptvar
//that gates the player from packing up another structure
//before the current structure packs up or times out.
//On time out a messageto is sent to remove the scriptvar.
messageHandler handlePlayerStructurePackupLockout()
{
	/*
		Requirements line item 1
		Set scriptvar on packer when request to pack up abandoned house.
		Scriptvar will prevent player from requesting to pack up another abandoned house until this one is done.
		Scriptvar contains timeout value to allow player to try again after some period of time.
	*/
	if(!params.containsKey("house"))
	{
		blog("player_buidling.handlePlayerStructurePackupLockout() PARAMS MISSING, ABORTING.");
		return SCRIPT_CONTINUE;
	}

	obj_id structure = params.getObjId ("house");
	if(!isValidId(structure))
	{
		blog("player_buidling.handlePlayerStructurePackupLockout() Invalid Structure OID, ABORTING.");
		return SCRIPT_CONTINUE;
	}

	blog("player_buidling.packedAbandonedStructure() Message received by player to start lockout timer.");

	utils.setScriptVar(self, player_structure.SCRIPTVAR_HOUSE_PACKUP_LOCKOUT_TIME, getGameTime());
	messageTo(self, "handlePlayerStructurePackupLockoutRemoval", null, player_structure.HOUSE_PACKUP_LOCKOUT_TIMER, false);

	/*Set a script var to avoid other player packing up same structure.*/
	utils.setScriptVar(structure, player_structure.SCRIPTVAR_HOUSE_PACKUP_LOCKOUT_TIME, getGameTime());
	messageTo(structure, "handleStructurePackupLockoutRemoval", params, player_structure.HOUSE_PACKUP_LOCKOUT_TIMER, false);

	if(params != null && !params.equals(""))
	{
		CustomerServiceLog("housepackup", "Player: " + getPlayerName(self) + " (" + self+ ") is"
			+ " attempting to pack up a structure and has received lockout"
			+ " timer for packup event that will expire in "
			+ player_structure.HOUSE_PACKUP_LOCKOUT_TIMER + "."
			);
	}

	return SCRIPT_CONTINUE;
}

//HOUSE PACK UP handlePlayerStructurePackupLockoutRemoval()
//Called to remove the lockout timer either after the
//lockout timer has expired or the structure failed to
//packup.
messageHandler handlePlayerStructurePackupLockoutRemoval()
{
	blog("player_buidling.handlePlayerStructurePackupLockoutRemoval() Message received by player to remove lockout timer.");
	//removes all vars in tree
	utils.removeScriptVarTree(self, player_structure.SCRIPTVAR_HOUSE_PACKUP_TREE_PREFIX);
	return SCRIPT_CONTINUE;
}

//HOUSE PACK UP handleFailedStructurePackup()
//Called if the house fails to pack up during the
//pack up process. Designed to remove the lockout
//timer on the player so they can continue participating
//in the pack up event.
messageHandler handleFailedStructurePackup()
{
	blog("player_buidling.handleFailedStructurePackup() Message received by player to handle failed packup.");

	/*
		Requirements line item 3
		If house fails to packup for any reason, send messageTo() to packer to remove 'packup requested'
		scriptvar so packer can packup another structure.
		Display error message to packer so he knows the request failed and he can try again.
	*/
	messageTo(self, "handlePlayerStructurePackupLockoutRemoval", null, 0, false);

	//Don't give message if the player is maxed out on daily packup
	if(player_structure.canPackMoreToday(self))
		sendSystemMessage(self, SID_HOUSE_PACKUP_FAILED);

	CustomerServiceLog("housepackup", "Player: " + getPlayerName(self) + " (" + self+ ") has"
		+ " had lockout timer removed early due to structure packup problems."
		);

	return SCRIPT_CONTINUE;
}

//HOUSE PACK UP callAirStrikePackAbandonedStructure()
//This handles all the post pack up functionality
//when a player packs up an ABANDONED player structure.
//This messageHandler should never be called
//if the structure has failed to pack.
messageHandler callAirStrikePackAbandonedStructure()
{
	blog("player_buidling.callAirStrikePackAbandonedStructure() Message received by player to send animation, tally success.");

	if((params == null) || (params.isEmpty()))
	{
		blog("player_buidling.callAirStrikePackAbandonedStructure() ALL PARAMS MISSING, ABORTING.");
		messageTo(self, "handlePlayerStructurePackupLockoutRemoval", null, 0, false);
		return SCRIPT_CONTINUE;
	}

	if(!params.containsKey("structure") || !params.containsKey("structure_owner"))
	{
		blog("player_buidling.callAirStrikePackAbandonedStructure() PARAMS MISSING, ABORTING.");
		messageTo(self, "handlePlayerStructurePackupLockoutRemoval", null, 0, false);
		return SCRIPT_CONTINUE;
	}

	blog("player_buidling.callAirStrikePackAbandonedStructure() about to send animation request.");

	//This is so the comm player for
	//the player. MessageHandler is in
	//permanent_structure.script

	obj_id structure = params.getObjId ("structure");
	if(!isValidId(structure))
	{
		blog("player_building.moveStructureToSCD() MISSING PARAMS. ABORTING AIRSTRIKE");
		messageTo(self, "handlePlayerStructurePackupLockoutRemoval", null, 0, false);
		return SCRIPT_CONTINUE;
	}

	location where = getLocation(structure);
	if(player_structure.canPackMoreToday(self))
	{
		prose_package p = prose.getPackage(new string_id("spam", "house_packup_airstrike"));
		commPlayers(self, "object/mobile/dressed_hiddendagger_pilot_m_01.iff", "sound/sys_comm_other.snd", 5f, self, p);
		playClientEffectLoc(self, "clienteffect/house_packup_airstrike.cef", where, 0);
	}

	params.put("player", self);
	messageTo (structure, "moveStructureToSCD", params, 3, false);

	blog("player_buidling.callAirStrikePackAbandonedStructure() The animation will eventually play.");
	return SCRIPT_CONTINUE;
}

//HOUSE PACK UP msgConfirmHousePackup()
//Message Handler that is called via a SUI from
//player_structure library. This is going to be
//initiated by the player owner of the structure
//to verify the packup operation.
messageHandler msgConfirmHousePackup()
{
	if(!utils.hasScriptVar(self, "packup.structure"))
	{
		return SCRIPT_CONTINUE;
	}

	obj_id structure = utils.getObjIdScriptVar(self, "packup.structure");
	utils.removeScriptVar(self, "packup.structure");

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
	{
		LOG("house", "Declined packup.");
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.canPackBuilding(self, structure))
	{
		return SCRIPT_CONTINUE;
	}

	if(!player_structure.canPackStructureWithVendors(self, structure))
		return SCRIPT_CONTINUE;

	//float getDistance(location loc1, location loc2)
	location structLoc = getLocation(structure);
	location playerLoc = getLocation(self);
	if(structLoc == null || playerLoc == null)
		return SCRIPT_CONTINUE;
	if(getDistance(structLoc, playerLoc) > 10.0f)
	{
		sendSystemMessage(self, SID_PACKUP_TOO_FAR_AWAY);
		return SCRIPT_CONTINUE;
	}

	params.put("structure", structure);
	messageTo(self, "msgFinalizePackup", params, 0, false);

	return SCRIPT_CONTINUE;
}

//HOUSE PACK UP msgFinalizePackup()
//The original creator made an additional message
//handler so it could be used by both the player owner
//(via msgConfirmHousePackup) as well as any other player
//that was packing up an Abandoned structure.  This message
//handler is being called directly from player_structure
//library
messageHandler msgFinalizePackup()
{
	blog("player_building.msgFinalizePackup() init!");

	obj_id structure = params.getObjId("structure");
	blog("player_building.msgFinalizePackup() STRUCTURE CONTENTS LOADED? "+areAllContentsLoaded(structure));

	blog("player_building.msgFinalizePackup() STRUCTURE LOADED? "+structure.isLoaded());

	if(!isIdValid(structure))
		return SCRIPT_CONTINUE;

	if(!structure.isLoaded() || !structure.isAuthoritative())
	{
		blog("player_building.msgFinalizePackup() STRUCTURE LOADED? "+structure.isLoaded());
		blog("player_building.msgFinalizePackup() STRUCTURE CONTENTS LOADED? "+areAllContentsLoaded(structure));

		CustomerServiceLog("housepackup", "Structure (" + structure + ") could not be packed by player ("
			+ getPlayerName(self) + ") msgFinalizePackup -"
			+ " isLoaded = " + structure.isLoaded()
			+ " isAuthoritative = " + structure.isAuthoritative()
			);

		return SCRIPT_CONTINUE;
	}

	//This block is to avoid packing up a structure
	//that hasn't loaded all of it's contents yet.
	//loadBuildingContents is called which loads all
	//items in the house then FIRES OFF A TRIGGER
	//to pack up the house some time later
	if(!player_structure.isInstallation(structure) && !areAllContentsLoaded(structure) && !hasObjVar(structure, "structure.player.pack"))
	{

		// Set player as objvar
		setObjVar(structure, "structure.player.pack", self);
		// Call load contents
		loadBuildingContents(self, structure);
		return SCRIPT_CONTINUE;
	}

	if(!hasObjVar(structure, "structure.player.pack"))
	{
		blog("player_building.msgFinalizePackup() STRUCTURE IS GOOD FOR PACKUP");
		player_structure.finalizePackUp(self, structure);
	}
	return SCRIPT_CONTINUE;
}

messageHandler packUpCityAbandonedStructure()
{
	if((params == null) || (params.isEmpty()))
	{
		return SCRIPT_CONTINUE;
	}

	LOG("sissynoid", "Entered: packUpCityAbandonedStructure");
	obj_id structure = params.getObjId("house");

	if(!isIdValid(structure))
		return SCRIPT_CONTINUE;
	if(!isIdValid(self))
		return SCRIPT_CONTINUE;

	if(!player_structure.isCityPackupAuthoritative(self, structure)) //tests both player and structure
	{
		LOG("sissynoid", "packUpCityAbandonedStructure: Structure is not Loaded or Authoritative: ");
		CustomerServiceLog("city_house_packup",
			"'packUpCityAbandonedStructure' - Structure (" + structure +
			") could not be packed by player ("
			+ getPlayerName(self) + ") player -" +
			" isLoaded(Player) = " + self.isLoaded() +
			" isAuthoritative(Player) = " + self.isAuthoritative() +
			" isLoaded(Structure) = " + structure.isLoaded() +
			" isAuthoritative(Structure) = " + structure.isAuthoritative());
		return SCRIPT_CONTINUE;
	}

	//not installation, not loaded, doesn't have objvar (structure.player.pack)
	if(!player_structure.isInstallation(structure) && !areAllContentsLoaded(structure) && !hasObjVar(structure, "structure.player.pack"))
	{
		LOG("sissynoid", "packUpCityAbandonedStructure: Not Installation, Not Loaded, No Objvar");
		// Set player as structure.player.pack objvar
		setObjVar(structure, "structure.player.pack", self);
		// Call load contents
		loadBuildingContents(self, structure);
		return SCRIPT_CONTINUE;
	}

	//If it gets here - Everything in the house is loaded and ready to go!
	if(!hasObjVar(structure, "structure.player.pack"))
	{
		LOG("sissynoid", "Go! All Contents are Loaded!");
		player_structure.finalizeCityPackUp(self, structure);
	}

	return SCRIPT_CONTINUE;
}

// Placed here since vendors are in player buildings
messageHandler msgConfirmVendorPackup()
{
	if(!utils.hasScriptVar(self, "packup.vendor"))
	{
		return SCRIPT_CONTINUE;
	}

	if(utils.hasScriptVar(self, "packup.vendor.suiconfirm"))
	{
		 utils.removeScriptVar(self, "packup.vendor.suiconfirm");
	}

	obj_id vendor = utils.getObjIdScriptVar(self, "packup.vendor");
	utils.removeScriptVar(self, "packup.vendor");

	int bp = sui.getIntButtonPressed(params);
	if(bp == sui.BP_CANCEL)
	{
		LOG("vendor", "Declined packup.");
		return SCRIPT_CONTINUE;
	}

	obj_id vendorOwner = getObjIdObjVar(vendor, "vendor_owner");
	if(!isIdValid(vendorOwner))
		vendorOwner = getOwner(vendor);

	vendor_lib.finalizePackUp(vendorOwner, vendor, self, false);

	return SCRIPT_CONTINUE;
}

messageHandler getVendorInfoForPlayerRsp()
{
	String summary = params.getString("summary");
	if (summary == null)
		return SCRIPT_CONTINUE;

	String[] name = params.getStringArray("name");
	if (name == null)
		return SCRIPT_CONTINUE;

	String[] location = params.getStringArray("location");
	if ((location == null) || (location.length != name.length))
		return SCRIPT_CONTINUE;

	String[] tax = params.getStringArray("tax");
	if ((tax == null) || (tax.length != name.length))
		return SCRIPT_CONTINUE;

	String[] taxCity = params.getStringArray("taxCity");
	if ((taxCity == null) || (taxCity.length != name.length))
		return SCRIPT_CONTINUE;

	String[] emptyDate = params.getStringArray("emptyDate");
	if ((emptyDate == null) || (emptyDate.length != name.length))
		return SCRIPT_CONTINUE;

	String[] lastAccessDate = params.getStringArray("lastAccessDate");
	if ((lastAccessDate == null) || (lastAccessDate.length != name.length))
		return SCRIPT_CONTINUE;

	String[] inactiveDate = params.getStringArray("inactiveDate");
	if ((inactiveDate == null) || (inactiveDate.length != name.length))
		return SCRIPT_CONTINUE;

	String[] status = params.getStringArray("status");
	if ((status == null) || (status.length != name.length))
		return SCRIPT_CONTINUE;

	String[] searchable = params.getStringArray("searchable");
	if ((searchable == null) || (searchable.length != name.length))
		return SCRIPT_CONTINUE;

	String[] entranceCharge = params.getStringArray("entranceCharge");
	if ((entranceCharge == null) || (entranceCharge.length != name.length))
		return SCRIPT_CONTINUE;

	String[] itemCount = params.getStringArray("itemCount");
	if ((itemCount == null) || (itemCount.length != name.length))
		return SCRIPT_CONTINUE;

	String[] offerCount = params.getStringArray("offerCount");
	if ((offerCount == null) || (offerCount.length != name.length))
		return SCRIPT_CONTINUE;
		
	String[] stockRoomCount = params.getStringArray("stockRoomCount");
	if ((stockRoomCount == null) || (stockRoomCount.length != name.length))
		return SCRIPT_CONTINUE;

	string[] columnHeader     = {"Name", "Location", "Status", "Active Items", "Stockroom Items", "Offered Items", "% Tax",   "Tax City", "Searchable", "Entrance Fee", "Last Access Date", "Empty Date", "Inactive Date"};
	string[] columnHeaderType = {"text", "text",     "text",   "integer",      "integer",         "integer",       "integer", "text",     "text",       "integer",      "text",             "text",       "text"};
	string[][] columnData = new string[13][0];
	columnData[0] = name;
	columnData[1] = location;
	columnData[2] = status;
	columnData[3] = itemCount;
	columnData[4] = stockRoomCount;
	columnData[5] = offerCount;
	columnData[6] = tax;
	columnData[7] = taxCity;
	columnData[8] = searchable;
	columnData[9] = entranceCharge;
	columnData[10] = lastAccessDate;
	columnData[11] = emptyDate;
	columnData[12] = inactiveDate;

	sui.tableColumnMajor(self, self, sui.OK_ONLY, "Vendor Information", null, summary, columnHeader, columnHeaderType, columnData, true);

	return SCRIPT_CONTINUE;
}

/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/***** FUCTIONS ********************************************************/
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/

// Validate whether furniture move is valid.
boolean isMoveCommandValid(obj_id player, obj_id target)
{
	location loc = getLocation(player);
	obj_id structure = getTopMostContainer(loc.cell);

	if(!isIdValid(structure) || !isIdValid(target))
		return false;

	//Player is trying to move the control object for the Publish Gift the Magic Painting. We want to make sure it doesn't have a painting created and if it does, we're packing up that painting.
	if(hasObjVar (target, "paintingId"))
	{
		obj_id painting = getObjIdObjVar (target, "paintingId");
		destroyObject (painting);
		removeObjVar (target, "paintingId");

		sendSystemMessage (player, MOVED_CTRL_OBJ);

	}

	//Player is trying to move the Magic Painting
	if(static_item.isStaticItem(target))
	{
		string paintingName = static_item.getStaticItemName(target);
		if(paintingName.startsWith ("item_publish_gift_magic_painting_"))
		{
			sendSystemMessage (player, MOVED_PAINTING);
			return false;
		}
	}

	if(hasObjVar (target, "noMoveItem"))
	{
		sendSystemMessage (player, NO_MOVE_ITEM);
		return false;


	}

	if(getGameObjectType(structure) == GOT_building_factional && hasObjVar(structure, "hq"))
	{
		sendSystemMessage(player, new string_id(STF, "no_move_hq")); // You may not move or rotate objects inside a factional headquarters.
		return false;
	}

	if(!player_structure.isAdmin(structure, player))
	{
		LOG("LOG_CHANNEL", player + " ->You must be an admin to manipulate objects.");
		sendSystemMessage(player, new string_id(STF, "admin_move_only")); // You must be an admin to manipulate objects.
		return false;
	}
	if(!canManipulateSkipNoTradeCheck(player, target, true, false, 0, true)) // ignore noTrade, since we are just moving/rotating the item, not picking it up
	{
		sendSystemMessage(player, new string_id(STF, "cant_manipulate")); // You can't manipulate that.
		return false;
	}

	if(isPlayer(target) || (isMob(target) && !hasCondition(target, CONDITION_VENDOR)))
	{
		LOG("LOG_CHANNEL", player + " ->You can't manipulate that.");
		sendSystemMessage(player, new string_id(STF, "cant_manipulate")); // You can't manipulate that.
		return false;
	}

	// Make sure the object is in the structure.
	obj_id structure_obj = getTopMostContainer(target);
	if(structure != structure_obj || target == structure_obj)
	{
		LOG("LOG_CHANNEL", player + " -> That object is not within the building.");
		sendSystemMessage(player, new string_id(STF, "item_not_in_building")); // That object is not within the building.
		return false;
	}

	// Make sure the object is not one of the building's base objects.
	obj_id[] base_objects = player_structure.getStructureBaseObjects(structure);
	if(base_objects != null)
	{
		for(int i = 0; i < base_objects.length; i++)
		{
			if(target == base_objects[i])
			{
				LOG("LOG_CHANNEL", player + " -> You cannot move that object.");
				sendSystemMessage(player, new string_id(STF, "cant_move_item")); // You cannot move that object.
				return false;
			}
		}
	}

	return true;
}

string getCellName(obj_id building, obj_id cell) {

	string[] cellNames = getCellNames(building);

	for(int i = 0; i < cellNames.length; i++) {

		string cellName = cellNames[i];
		obj_id thisCell = getCellId(building, cellName);

		if(thisCell == cell) {

			return cellName;
		}
	}

	return "";
}

// Check to see if we can place a civic structure at this position.
boolean canPlaceCivic(obj_id player, obj_id deed, location position, string template)
{

	if(utils.isFreeTrial(player))
		return false;

	int city_id = getCityAtLocation(position, 0);
	if(!cityExists(city_id))
		return false;

	obj_id mayor = cityGetLeader(city_id);
	if(mayor != player)
		return false;

	return true;
}

// Check to see if we can place a unique civic structure in this city.
boolean canPlaceUnique(obj_id player, obj_id deed, location position, string template)
{
	int city_id = getCityAtLocation(position, 0);
	if(!cityExists(city_id))
		return false;

	if(utils.isFreeTrial(player))
		return false;

	// Is this a shuttleport?
	if(player_structure.isShuttleportTemplate(template))
	{
		// Does the city have one?
		int travelCost = cityGetTravelCost(city_id);
		if(travelCost > 0)
			return false;
		else
			return true;
	}
	else if(player_structure.isCloneTemplate(template))
	{
		// Does the city have one?
		obj_id clone = cityGetCloneId(city_id);
		if(isIdValid(clone))
		{
			// Check to see if a clone facility is in the city structure list, just in case the clone data is wrong.
			obj_id[] structures = cityGetStructureIds(city_id);
			for(int i=0; i<structures.length; i++)
			{
				if((structures[i] == clone) && (structures[i] != null))
					return false;
			}

			return true;
		}
		else
			return true;
	}

	return true;
}

boolean confirmDestroyTarget(obj_id structure, obj_id target)
{
	obj_id self = getSelf();
	if(!isIdValid(target))
	{
		sendSystemMessage(self, new string_id(STF, "invalid_target")); // Your original structure target is no longer valid. Aborting...
		return false;
	}

	if(!isIdValid(structure) || structure != target)
	{
		sendSystemMessage(self, new string_id(STF, "changed_target")); // Your current target is not the same as your original target. Aborting...
		return false;
	}

	return true;
}

boolean isFactionBaseEmpty(obj_id base, obj_id player)
{
	if(!hasScript(base, "faction_perk.hq.loader"))
		return true;

	obj_id[] players = trial.getPlayersInDungeon(base);

	if(players == null || players.length == 0)
		return true;


	if(players.length > 1)
		return false;

	return true;
}

//a small function to remove any scriptvars or objvars placed on a player
//to prevent uninteded use of the Vendor functionality
boolean removeVendorVars(obj_id self)
{
	if(!isValidId(self) || !exists(self))
		return false;
	utils.removeScriptVarTree(self, VENDOR_VAR_PREFIX);
	utils.removeScriptVarTree(self, "vendor");	
	blog("player_building.removeVendorVars: removed VENDOR_VAR_PREFIX Vars ");
	return true;
}


//Called from OnPlayerVendorCountReply to rout the player to the proper vendor
//setup menus.
boolean handleVendorTypeSelect(obj_id self)
{
	blog("player_building:handleVendorTypeSelect() - about to requestPlayerVendorCount");
	if(!isValidId(self) || !exists(self))
		return false;
	else if(!validateVendorPlacement(self)) //does all the prelim checks to make sure the player can create a vendor
		return false; //do not remove vars. The player must place the vendor or delete.

	blog("player_building:handleVendorTypeSelect() - SETTING CREATING_VENDOR to 1");
	utils.setScriptVar(self, CREATING_VENDOR, 1);
	requestPlayerVendorCount(self);  //gets the vendor count I assume.  See OnPlayerVendorCountReply trigger

	return true;
}

//a function that validates a player's ability to place a
//vendor
boolean validateVendorPlacement(obj_id self)
{
	if(!isValidId(self) || !exists(self))
		return false;
	if(player_structure.isCivic(self))
	{
		blog("player_building:validateVendorPlacement() - isCivic = true");
		return false;
	}
	if(utils.isFreeTrial(self))
	{
		blog("player_building:validateVendorPlacement() - Player is free trial");
		sendSystemMessage(self, SID_NO_VENDOR);
		return false;
	}
	if(hasObjVar(self, "vendor_not_initialized"))
	{
		blog("player_building:validateVendorPlacement() - has vendor_not_initialized");
		// You are already creating a vendor!
		sendSystemMessage(self, SID_SYS_VENDOR_NOT_INITIALIZED);
		return false;
	}
	blog("player_building:validateVendorPlacement() - Everything is good, player can place.");

	return true;
}

//get all the player skill mods so we can check to see if the player has
//a SPECIAL vendor in TBL_SPECIAL_PLAYER_VENDOR_TYPES
string[] getSpecialVendors(obj_id self, int hireMod)
{
	blog("player_building.getSpecialVendors: init");

	if(!isValidId(self) || !exists(self))
		return null;
	else if(hireMod < 50)
		return null;

	blog("player_building.getSpecialVendors: initial validation passes");

	string[] specialVendorNames = dataTableGetStringColumn(TBL_SPECIAL_PLAYER_VENDOR_TYPES, "special_vendor_name");
	if(specialVendorNames == null)
		return null;

	blog("player_building.getSpecialVendors: specialVendorNames received");

	string[] specialVendorSkillMod = dataTableGetStringColumn(TBL_SPECIAL_PLAYER_VENDOR_TYPES, "skill_mod");
	if(specialVendorSkillMod == null)
		return null;

	blog("player_building.getSpecialVendors: specialVendorSkillMod received");

	int[] requiredHireMod = dataTableGetIntColumn(TBL_SPECIAL_PLAYER_VENDOR_TYPES, "requires_hiring_mod");
	if(requiredHireMod == null)
		return null;

	blog("player_building.getSpecialVendors: requiredHireMod received");
	blog("player_building.getSpecialVendors: received specialVendorNames, specialVendorSkillMod, requiredHireMod");

	resizeable string[] allSpecialVendorsOfPlayerHireMod = new string[0];
	resizeable string[] allSpecialVendorsMods = new string[0];

	blog("player_building.getSpecialVendors: about to grab special vendor list");

	//WE CHECK FOR ALL SPECIAL VENDORS THAT THE PLAYER CAN HIRE WITH THIER CURRENT HIRE MOD
	for(int i = 0; i < specialVendorNames.length; i++)
	{
		if(requiredHireMod[i] <= hireMod)
		{
			blog("player_building.getSpecialVendors: "+specialVendorNames[i]+" had a hire mod of: "+requiredHireMod[i]+" and was added to list");
			utils.addElement(allSpecialVendorsOfPlayerHireMod, specialVendorNames[i]);
			utils.addElement(allSpecialVendorsMods, specialVendorSkillMod[i]);
			blog("player_building.getSpecialVendors: "+specialVendorNames[i]+" has a skill mod: "+specialVendorSkillMod[i]);
		}
	}
	if(allSpecialVendorsOfPlayerHireMod == null || allSpecialVendorsMods == null)
		return null;

	blog("player_building.getSpecialVendors: specialVendorNames.length: "+specialVendorNames.length);

	int vendorNameSize = allSpecialVendorsOfPlayerHireMod.size();
	int vendorModSize = allSpecialVendorsMods.size();
	if(vendorNameSize != vendorModSize) //both lists need to be same length
		return null;
	else if(vendorNameSize == 0 || vendorModSize == 0)//neither can have a size of zero
		return null;

	string[] vendorNames = new string[vendorNameSize];
	allSpecialVendorsOfPlayerHireMod.toArray(vendorNames);
	string[] vendorMods = new string[vendorModSize];
	allSpecialVendorsMods.toArray(vendorMods);

	resizeable string[] allSpecialVendors = new string[0];

	blog("player_building.getSpecialVendors: about to test each of the special vendors to see if I have the necessary skill mods.");

	for(int b = 0; b < specialVendorSkillMod.length; b++)
	{
		if(getSkillStatMod(self, vendorMods[b]) <= 0)
			continue;

		blog("player_building.getSpecialVendors: Found a skill mod I have: "+vendorMods[b]);
		utils.addElement(allSpecialVendors, vendorNames[b]); //notice I am adding the special vendor NAME, not the skill mod
	}
	blog("player_building.getSpecialVendors: allSpecialVendors.size(): "+allSpecialVendors.size());
	return allSpecialVendors;
}

//Logging
boolean blog(string msg)
{
	if(LOGGING_ON && msg != null && !msg.equals(""))
		LOG(LOGGING_CATEGORY, msg);
	return true;
}
