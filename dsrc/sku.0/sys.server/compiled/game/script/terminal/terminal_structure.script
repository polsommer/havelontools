/**********************************************************************
 * Copyright (c)2000-2002 Sony Online Entertainment Inc.
 * All Rights Reserved
 *
 * Title:        terminal_structure.script
 * Description:  script for player structure terminal mangement
 * @author       $Author:$
 * @version      $Revision:$
 ***********************************************************************/

/***** INCLUDES ********************************************************/

include library.city;
include library.faction_perk;
include library.player_structure;
include library.prose;
include library.session;
include library.static_item;
include library.sui;
include library.turnstile;
include library.utils;

/***** LOGGING *********************************************************/

const string TERMINAL_LOGGING						= "special_sign";
const boolean LOGGING_ON						= true;

/***** CONSTANTS *******************************************************/

const string_id SID_TERMINAL_PERMISSIONS 				= new string_id("player_structure", "permissions");
const string_id SID_TERMINAL_MANAGEMENT 				= new string_id("player_structure", "management");
const string_id SID_TERMINAL_PERMISSIONS_ENTER 				= new string_id("player_structure", "permission_enter");
const string_id SID_TERMINAL_PERMISSIONS_BANNED 			= new string_id("player_structure", "permission_banned");
const string_id SID_TERMINAL_PERMISSIONS_ADMIN	 			= new string_id("player_structure", "permission_admin");
const string_id SID_TERMINAL_PERMISSIONS_VENDOR	 			= new string_id("player_structure", "permission_vendor");
const string_id SID_TERMINAL_PERMISSIONS_HOPPER	 			= new string_id("player_structure", "permission_hopper");
const string_id SID_TERMINAL_MANAGEMENT_STATUS	 			= new string_id("player_structure", "management_status");
const string_id SID_TERMINAL_MANAGEMENT_PRIVACY	 			= new string_id("player_structure", "management_privacy");
const string_id SID_TERMINAL_MANAGEMENT_PRIVACY_PRIVATE		= new string_id("player_structure", "management_privacy_private");
const string_id SID_TERMINAL_MANAGEMENT_PRIVACY_PUBLIC		= new string_id("player_structure", "management_privacy_public");

const string_id SID_TERMINAL_MANAGEMENT_TRANSFER 			= new string_id("player_structure", "management_transfer");
const string_id SID_TERMINAL_MANAGEMENT_RESIDENCE			= new string_id("player_structure", "management_residence");
const string_id SID_TERMINAL_MANAGEMENT_DESTROY	 			= new string_id("player_structure", "permission_destroy");
const string_id SID_TERMINAL_MANAGEMENT_PAY	 			= new string_id("player_structure", "management_pay");
const string_id SID_TERMINAL_NAME_STRUCTURE				= new string_id("player_structure", "management_name_structure");
const string_id SID_TERMINAL_MANAGEMENT_ADD_TURNSTILE 			= new string_id("player_structure", "management_add_turnstile");
const string_id SID_TERMINAL_MANAGEMENT_REMOVE_TURNSTILE		= new string_id("player_structure", "management_remove_turnstile");
const string_id SID_TERMINAL_ASSIGN_DROID				= new string_id("player_structure", "assign_droid");
const string_id SID_TERMINAL_CREATE_VENDOR              		= new string_id("player_structure", "create_vendor");
const string_id SID_TERMINAL_PACK_HOUSE					= new string_id("sui", "packup_house");
const string_id SID_TERMINAL_MANAGEMENT_SPECIAL_SIGNS			= new string_id("player_structure", "special_sign_management");

const string_id SID_TERMINAL_PERMISSIONS_HARVESTER			= new string_id("harvester", "manage");
const string_id SID_TERMINAL_MANAGEMENT_POWER	 			= new string_id("player_structure", "management_power");
const string_id SID_TERMINAL_MANAGEMENT_MINE_INV 			= new string_id("player_structure", "management_mine_inv");
const string_id SID_TERMINAL_MANAGEMENT_CHANGE_SIGN			= new string_id("player_structure", "management_change_sign");
const string_id SID_PUBLIC_ONLY						= new string_id("player_structure", "public_only");
const string_id SID_WITHDRAW_MAINTENANCE				= new string_id("player_structure", "withdraw_maintenance");
const string_id SID_TERMINAL_REDEED_STORAGE 				= new string_id("player_structure", "redeed_storage");
const string_id SID_STORAGE_INCREASE_REDEED_TITLE			= new string_id("player_structure", "sui_storage_redeed_title");
const string_id SID_STORAGE_INCREASE_REDEED_PROMPT			= new string_id("player_structure", "sui_storage_redeed_prompt");
// Structure item management menu options.
const string_id SID_FIND_ALL_HOUSE_ITEMS					= new string_id( "player_structure", "find_items_find_all_house_items" );
const string_id SID_SEARCH_FOR_HOUSE_ITEMS					= new string_id( "player_structure", "find_items_search_for_house_items" );
const string_id SID_MOVE_FIRST_ITEM					= new string_id( "player_structure", "move_first_item" );
const string_id SID_MOVED_FIRST_ITEM					= new string_id( "player_structure", "moved_first_item" );
const string_id SID_DELETE_ALL_ITEMS					= new string_id( "player_structure", "delete_all_items" );
const string_id SID_ITEMS_DELETED					= new string_id( "player_structure", "items_deleted" );
const string_id SID_WHILE_DEAD						= new string_id( "player_structure", "while_dead" );
const string_id SID_TCG_VENDOR_CTS_WARNING				= new string_id( "player_vendor", "create_vendor_cts_warning");
const string_id SID_REVERT_CUSTOM_SIGN	 				= new string_id("player_structure", "revert_sign");
const string_id SID_STRUCTURE_DECOR	 				= new string_id("player_structure", "structure_decor_menu");
const string_id SID_STRUCTURE_ADD_DECOR	 				= new string_id("player_structure", "structure_add_decor");
const string_id SID_STRUCTURE_REMOVE_DECOR	 			= new string_id("player_structure", "structure_remove_decor");
// consts
const string STRUCTURE_MARK						= "turnstile.structureMark";

//Mayor can see owner of Harvesters/Generators/Factories
const string_id SID_MAYOR_HOUSE_SIGN_DISPLAY 			= new string_id("city/city", "installation_owner");
const string_id SID_SHOW_MAYOR_OWNER 				= new string_id("city/city", "installation_owner_option");
//City House Packup
const string_id SID_TERMINAL_CITY_PACK_HOUSE			= new string_id("city/city", "city_packup_house");


/***** TRIGGERS ********************************************************/
trigger OnObjectMenuRequest(obj_id player, menu_info mi)
{
	//not while dead or incapped
	if(isDead(player) || isIncapacitated(player) )
	{
		sendSystemMessage( player, SID_WHILE_DEAD );
		return SCRIPT_CONTINUE;
	}

	obj_id structure = self;
	blog("terminal_structure::OnObjectMenuRequest");

	player_structure.doOldToNewLotConversion(player, structure);

	if(!player_structure.isInstallation(structure))
	{
		structure = player_structure.getStructure(player);

		if(!isIdValid(structure))
			return SCRIPT_CONTINUE;
	}
	if(player_structure.isStructureCondemned(self) && player_structure.isOwner(player, structure))
	{
		player_structure.doCondemnedSui(self, player);
		return SCRIPT_OVERRIDE;
	}

	int got = getGameObjectType(structure);
	
	//Allowing Mayors to see the owner of Harvesters/Generators/Factories in their City.
	if(player_structure.isHarvester(structure) || player_structure.isGenerator(structure) || player_structure.isFactory(structure))
	{
		int city_id = getCityAtLocation(getLocation(self), 0);
		//If a Valid City - and - You are the Mayor - and - You are NOT the owner.
		if(cityExists(city_id) && city.isTheCityMayor(player, city_id) && !player_structure.isOwner(structure, player))
		{
			int owner_root = mi.addRootMenu(menu_info_types.SERVER_MENU16, SID_SHOW_MAYOR_OWNER);
		}
	}
	
	if (player_structure.isAdmin(structure, player))
	{
		blog("terminal_structure::OnObjectMenuRequest - you are admin");

		//must be owner to do anything on a harvester or generator
		if (player_structure.isHarvester(structure) || player_structure.isGenerator(structure))
		{
			if(!player_structure.isOwner(structure, player))
				return SCRIPT_CONTINUE;
		}
 
		int management_root = mi.addRootMenu (menu_info_types.SERVER_TERMINAL_MANAGEMENT, SID_TERMINAL_MANAGEMENT);

		mi.addSubMenu(management_root, menu_info_types.SERVER_TERMINAL_MANAGEMENT_DESTROY, SID_TERMINAL_MANAGEMENT_DESTROY);

		if ( got == GOT_installation_minefield )
			return SCRIPT_CONTINUE;

		//Let's allow status to be viewed by Civic Structures - they now have Storage Increase
		mi.addSubMenu(management_root, menu_info_types.SERVER_TERMINAL_MANAGEMENT_STATUS, SID_TERMINAL_MANAGEMENT_STATUS);

		string template = getTemplateName(structure);
		//We are going to allow City Hall Admin Privs. for decorating.
		if(player_structure.isCivic(structure))
		{
			blog("terminal_structure::OnObjectMenuRequest - I am civic");

			//allowing the renaming of Cloning Centers
			if(template.indexOf("cloning_") > -1)
			{
				mi.addSubMenu(management_root, menu_info_types.SET_NAME, new string_id());
			}
			if(template.indexOf("garden_") > -1)
			{
				mi.addSubMenu(management_root, menu_info_types.SET_NAME, new string_id());
			}
			if(!(template.indexOf("cityhall_") > -1))
			{
				return SCRIPT_CONTINUE;
			}
		}

		int permissions_root = 0;
		//no more adding people to admin list on harvesters / generators
		if (!player_structure.isHarvester(structure) && !player_structure.isGenerator(structure))
		{
			blog("terminal_structure::OnObjectMenuRequest - I am harvester/generator");
		
			permissions_root = mi.addRootMenu (menu_info_types.SERVER_TERMINAL_PERMISSIONS, SID_TERMINAL_PERMISSIONS);
			mi.addSubMenu(permissions_root, menu_info_types.SERVER_TERMINAL_PERMISSIONS_ADMIN, SID_TERMINAL_PERMISSIONS_ADMIN);
		}

		//stop City Hall Here
		if((template.indexOf("cityhall_") > -1))
		{
			return SCRIPT_CONTINUE;
		}

		mi.addSubMenu(management_root, menu_info_types.SERVER_TERMINAL_MANAGEMENT_PAY, SID_TERMINAL_MANAGEMENT_PAY);
		//mi.addSubMenu(management_root, menu_info_types.SERVER_TERMINAL_MANAGEMENT_TRANSFER, SID_TERMINAL_MANAGEMENT_TRANSFER);
		mi.addSubMenu(management_root, menu_info_types.SET_NAME, new string_id());

		if (player_structure.hasMaintenanceDroid(player))
			mi.addSubMenu(management_root, menu_info_types.SERVER_MENU5, SID_TERMINAL_ASSIGN_DROID);
		if (player_structure.canPackBuilding(player, structure))
		{
			mi.addSubMenu( management_root, menu_info_types.SERVER_MENU10, SID_TERMINAL_PACK_HOUSE);
		}

		if (player_structure.isBuilding(structure))
		{
			blog("terminal_structure::OnObjectMenuRequest - I am a building");

			boolean isStructureOwner = player_structure.isOwner(structure, player);
			
			if (permissions_root != 0)
			{
				permissions_root = mi.addRootMenu (menu_info_types.SERVER_TERMINAL_PERMISSIONS, SID_TERMINAL_PERMISSIONS);
			}
			// Entry,vendor, and residence are for buildings only
			//mi.addSubMenu(permissions_root, menu_info_types.SERVER_TERMINAL_PERMISSIONS_VENDOR, SID_TERMINAL_PERMISSIONS_VENDOR);
			mi.addSubMenu(permissions_root, menu_info_types.SERVER_TERMINAL_PERMISSIONS_ADMIN, SID_TERMINAL_PERMISSIONS_ADMIN);
			mi.addSubMenu(permissions_root, menu_info_types.SERVER_TERMINAL_PERMISSIONS_ENTER, SID_TERMINAL_PERMISSIONS_ENTER);
			mi.addSubMenu(management_root, menu_info_types.SERVER_TERMINAL_MANAGEMENT_RESIDENCE, SID_TERMINAL_MANAGEMENT_RESIDENCE);
			mi.addSubMenu(permissions_root, menu_info_types.SERVER_TERMINAL_PERMISSIONS_BANNED, SID_TERMINAL_PERMISSIONS_BANNED);

			// only add these options to buildings after the contents have been loaded
			if (areAllContentsLoaded(structure))
			{
				string_id privacyMenu_sid = SID_TERMINAL_MANAGEMENT_PRIVACY;
				if(permissionsIsPublic(structure))
				{
					privacyMenu_sid = SID_TERMINAL_MANAGEMENT_PRIVACY_PUBLIC;
				}
				else
				{
					privacyMenu_sid = SID_TERMINAL_MANAGEMENT_PRIVACY_PRIVATE;
				}
				mi.addSubMenu(management_root, menu_info_types.SERVER_TERMINAL_MANAGEMENT_PRIVACY, privacyMenu_sid);

				if ( getSkillStatMod(player, "manage_vendor") > 0 )
					mi.addSubMenu(management_root, menu_info_types.SERVER_TERMINAL_CREATE_VENDOR, SID_TERMINAL_CREATE_VENDOR);
				if ( utils.isProfession(player, utils.TRADER) )
				{
					// Turnstile.
					if ( turnstile.hasTurnstile( structure ) )
						mi.addSubMenu(management_root, menu_info_types.SERVER_MENU3, SID_TERMINAL_MANAGEMENT_REMOVE_TURNSTILE);
					else
						mi.addSubMenu(management_root, menu_info_types.SERVER_MENU4, SID_TERMINAL_MANAGEMENT_ADD_TURNSTILE);
				}
				/*
				if (hasObjVar(structure, player_structure.VAR_SIGN_BASE) && getSkillStatMod(player, "shop_sign") > 0)
				{
					if (!hasObjVar(structure, player_structure.MODIFIED_HOUSE_SIGN_MODEL))
					mi.addSubMenu(management_root, menu_info_types.SERVER_MENU7, SID_TERMINAL_MANAGEMENT_CHANGE_SIGN);

					else if (player_structure.isOwner(structure, player))
						mi.addSubMenu(management_root, menu_info_types.SERVER_MENU7, SID_TERMINAL_MANAGEMENT_CHANGE_SIGN);
				}
				*/
				if (player_structure.isGuildHall(structure))
					mi.addSubMenu(management_root, menu_info_types.SERVER_MENU8, SID_WITHDRAW_MAINTENANCE);

				// Structure item management options.
				mi.addSubMenu( management_root, menu_info_types.SERVER_MENU12, SID_FIND_ALL_HOUSE_ITEMS );
				mi.addSubMenu( management_root, menu_info_types.SERVER_MENU13, SID_SEARCH_FOR_HOUSE_ITEMS );
				mi.addSubMenu( management_root, menu_info_types.SERVER_MENU9, SID_MOVE_FIRST_ITEM );
				mi.addSubMenu( management_root, menu_info_types.SERVER_MENU2, SID_DELETE_ALL_ITEMS );

				// Allow the owner to redeed a storage increase
				if(player_structure.isOwner(structure, player))
				{
					// First Verify the house contains extra storage
					if (hasObjVar(structure, player_structure.OBJVAR_STRUCTURE_STORAGE_INCREASE))
					{
						// Add the storage redeed option here - out of server menus so we will use the dice roll for this
						// We will fail in the handler if the item count is higher than the base the house will hold and provide feedback
						mi.addSubMenu( management_root, menu_info_types.DICE_ROLL, SID_TERMINAL_REDEED_STORAGE);
					}
				}

			}
			else
				blog("terminal_structure::OnObjectMenuRequest - NOT ALL ITEMS LOADED");

			if (hasObjVar(structure, player_structure.MODIFIED_HOUSE_SIGN) && isStructureOwner)
			{
				mi.addSubMenu( management_root, menu_info_types.SERVER_MENU11, SID_REVERT_CUSTOM_SIGN );
			}
			if((hasObjVar(structure, player_structure.SPECIAL_SIGN) || player_structure.hasSpecialSignSkillMod(player, structure)))
			{
				blog("terminal_structure.OnObjectMenuRequest: Creating Special Sign Radial Option");
				mi.addSubMenu(management_root, menu_info_types.SERVER_MENU14, SID_TERMINAL_MANAGEMENT_SPECIAL_SIGNS);
			}

			if(player_structure.isOwner(structure, player) && isGod(player))
			{
					int decor_root = mi.addRootMenu(menu_info_types.SERVER_MENU14, SID_STRUCTURE_DECOR);
					mi.addSubMenu(decor_root, menu_info_types.SERVER_MENU15, SID_STRUCTURE_ADD_DECOR);
					mi.addSubMenu(decor_root, menu_info_types.SERVER_MENU16, SID_STRUCTURE_REMOVE_DECOR);
			}
		}
		else if (player_structure.isInstallation(structure))
		{
			
			if ( got != GOT_installation_turret )
			{
				// Give the ability to rename installations directly since they don't have signs.
				//mi.addSubMenu(management_root, menu_info_types.SERVER_MENU1, SID_TERMINAL_NAME_STRUCTURE);

				// Hopper is for non-turret installations only
				//mi.addSubMenu(permissions_root, menu_info_types.SERVER_TERMINAL_PERMISSIONS_HOPPER, SID_TERMINAL_PERMISSIONS_HOPPER);

				if ( (got == GOT_installation_harvester) || (got == GOT_installation_generator) )
				{
					mi.addSubMenu(management_root, menu_info_types.SERVER_HARVESTER_MANAGE, SID_TERMINAL_PERMISSIONS_HARVESTER);
				}

				if ( (got == GOT_installation_harvester) || (got == GOT_installation_factory) )
				{
					mi.addSubMenu(management_root, menu_info_types.SERVER_MENU6, SID_TERMINAL_MANAGEMENT_POWER);
				}
			}
			else
			{

			}
		}
	}
	else
	{
		if (player_structure.canPlayerPackAbandonedStructure(player, structure))
		{
			int management_root = mi.addRootMenu (menu_info_types.SERVER_TERMINAL_MANAGEMENT, SID_TERMINAL_MANAGEMENT);
			mi.addSubMenu( management_root, menu_info_types.SERVER_MENU10, SID_TERMINAL_PACK_HOUSE);
		}
		/* 
		*  City House Packup - This code is for Factories only -
		*  all other House Packup will be handled via the House Sign - 
		*  only non-owners can pack City House Packup Qualified Structures -
		*/
		if(player_structure.doesUnmarkedStructureQualifyForHousePackup(structure) /*checks: template, civic, installation*/
		&& !player_structure.isAbandoned(structure) /*checks: abandoned*/
		&& player_structure.isCityAbandoned(structure) /*checks for city abandoned objvar*/
		&& cityIsInactivePackupActive()) //checks server config 'cityCitizenshipInactivePackupStartTimeEpoch'
		{
			int management_root = mi.addRootMenu (menu_info_types.SERVER_TERMINAL_MANAGEMENT, SID_TERMINAL_MANAGEMENT);
			mi.addSubMenu(management_root, menu_info_types.SERVER_MENU15, SID_TERMINAL_CITY_PACK_HOUSE);
		}	
	}

	return SCRIPT_CONTINUE;
}


trigger OnObjectMenuSelect(obj_id player, int item)
{
	sendDirtyObjectMenuNotification(self);
	
	//not while dead or incapped
	if(isDead(player) || isIncapacitated(player) )
	{
		sendSystemMessage( player, SID_WHILE_DEAD );
		return SCRIPT_CONTINUE;
	}
	
	blog("terminal_structure::OnObjectMenuSelect item = " + item);
	blog("terminal_structure::OnObjectMenuSelect SERVER_TERMINAL_CREATE_VENDOR = " + menu_info_types.SERVER_TERMINAL_CREATE_VENDOR);

	if(utils.hasScriptVar(player, "packup.suiconfirm"))
	{
		sui.closeSUI(player, utils.getIntScriptVar(player, "packup.suiconfirm"));
	}

	if(item == menu_info_types.SERVER_MENU16)
	{
		int cityId = getCityAtLocation(getLocation(self), 0);
		if(cityExists(cityId) && city.isTheCityMayor(player, cityId) && !player_structure.isOwner(self, player))
		{
			//get the owner
			obj_id houseOwnerId = player_structure.getStructureOwnerObjId(self);
			//get owner's name
			string houseOwnerName = getPlayerFullName(houseOwnerId);
			//construct the text to show on the house sign.					
			prose_package pp = new prose_package();
			prose.setStringId(pp, SID_MAYOR_HOUSE_SIGN_DISPLAY);
//TODO: Remove Sign Name - Harvesters/Generators/Factories don't need names.
			//prose.setTT(pp, text);  
			prose.setTU(pp, houseOwnerName);
			//give them a SUI
			sui.msgbox(self, player, pp, "noHandlerNeeded");
			return SCRIPT_CONTINUE;
		}
	}	
	obj_id structure = self;
	//City House Packup System - 
	if(item == menu_info_types.SERVER_MENU15 && cityIsInactivePackupActive())
	{
		LOG("sissynoid", "Chose to Pack Structure - Calling player_structure.confirmCityAbandonedAndPack: StructureID" + structure);
		player_structure.confirmCityAbandonedAndPack(structure, player);	
	}
	
	if(!player_structure.isInstallation(structure))
	{
		structure = player_structure.getStructure( player );
		if(!isIdValid(structure))
			return SCRIPT_CONTINUE;
		if(player_structure.isHarvester(structure) || player_structure.isGenerator(structure))
			player_structure.validateHarvestedResources(structure);
	}
	
	if(!player_structure.isAdmin(structure, player) && !player_structure.isAbandoned(structure))
	{
		return SCRIPT_CONTINUE;
	}
	if(player_structure.isStructureCondemned(self) && player_structure.isOwner(player, structure))
	{
		player_structure.doCondemnedSui(self, player);
		return SCRIPT_OVERRIDE;
	}
	
	if ((item == menu_info_types.SERVER_TERMINAL_MANAGEMENT)||(item == menu_info_types.SERVER_TERMINAL_MANAGEMENT_STATUS))
	{
		queueCommand(player, ##"structureStatus", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	
	string template = getTemplateName(structure);
	if(player_structure.isCivic(structure))
	{
		//we allow renaming of cloning centers (update 8)
		if(template.indexOf("cloning_") > -1 && item == menu_info_types.SET_NAME)
		{
			queueCommand(player, ##"nameStructure", null, "", COMMAND_PRIORITY_DEFAULT);
		}
		//allows the naming of gardens!
		if(template.indexOf("garden_") > -1 && item == menu_info_types.SET_NAME)
		{
			queueCommand(player, ##"nameStructure", null, "", COMMAND_PRIORITY_DEFAULT);
		}
		//if it's not the city hall...and it's not the destroy option - bail.
		if(!(template.indexOf("cityhall_") > -1) && (item != menu_info_types.SERVER_TERMINAL_MANAGEMENT_DESTROY))
		{
			return SCRIPT_CONTINUE;
		}
	}

	if(player_structure.isHarvester(structure) || player_structure.isGenerator(structure))
		session.logActivity(player, session.ACTIVITY_ACCESS_HARVESTER);
	else if(player_structure.isFactory(structure))
		session.logActivity(player, session.ACTIVITY_ACCESS_FACTORY);
	else
		session.logActivity(player, session.ACTIVITY_ACCESS_STRUCTURE);

	if (item == menu_info_types.SERVER_TERMINAL_PERMISSIONS_ENTER)
	{
		// Call the command handler, setting the param to the list to be edited.
		queueCommand(player, ##"setPermission", null, "entry", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_PERMISSIONS_BANNED)
	{
		queueCommand(player, ##"setPermission", null, "ban", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_PERMISSIONS || item == menu_info_types.SERVER_TERMINAL_PERMISSIONS_ADMIN)
	{
		queueCommand(player, ##"setPermission", null, "admin", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_PERMISSIONS_VENDOR)
	{
		queueCommand(player, ##"setPermission", null, "vendor", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_PERMISSIONS_HOPPER)
	{
		queueCommand(player, ##"setPermission", null, "hopper", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_MANAGEMENT_PRIVACY)
	{
		queueCommand(player, ##"setPrivacy", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_MANAGEMENT_RESIDENCE)
	{
		queueCommand(player, ##"declareResidence", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_MANAGEMENT_TRANSFER)
	{
		queueCommand(player, ##"transferStructure", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_MANAGEMENT_DESTROY)
	{
		if(player_structure.isCivic(structure))
		{
			//the mayor and owner MUST match in order to destroy a Civic Structure 
			int city_id = getCityAtLocation(getLocation(structure), 0);
			//we are in a valid city.
			if(city_id > 0)
			{
				obj_id mayor = cityGetLeader(city_id);
				//we have a valid mayor
				if(isIdValid(mayor))
				{
					//are you trying to grief your former citizens?
					if(mayor != player)
					{
						//griefer message - then bail
						string city_name = cityGetName(city_id);
						string_id message = new string_id("player_structure", "no_longer_mayor_block_destroy");
						prose_package pp = new prose_package();
						prose.setStringId(pp, message);
						prose.setTO(pp, city_name);			
						sendSystemMessageProse(player, pp);
						//CS Logging 
						CustomerServiceLog("playerStructure", "Civic Structure Destruction: Player: " + player + " (" + getName(player) + ") is NO LONGER THE MAYOR and is trying to destroy a Structure (" + structure + 
						") before the City conversion is complete.  The NEW MAYOR is " + mayor + " (" + getName(mayor) + ") and is the only one with this authority." );
						return SCRIPT_CONTINUE;
					}
				}
				else
				{
					//INVALID MAYOR ID
					string_id message = new string_id("player_structure", "catastrophic_failure_city_destroy_structure");
					sendSystemMessage(player, message);
					return SCRIPT_CONTINUE;
				}
			}
		}
		queueCommand(player, ##"destroyStructure", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_MANAGEMENT_PAY)
	{
		queueCommand(player, ##"payMaintenance", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_MENU1 || item == menu_info_types.SET_NAME )
	{
		queueCommand(player, ##"nameStructure", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_HARVESTER_MANAGE)
	{
		activateHarvesterExtractionPage (player, self);
	}
	else if (item == menu_info_types.SERVER_TERMINAL_CREATE_VENDOR)
	{
		sendSystemMessage(player, SID_TCG_VENDOR_CTS_WARNING);
		queueCommand(player, ##"createVendor", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_MENU5)
	{
		queueCommand(player, ##"assignDroid", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	
	else if ( item == menu_info_types.SERVER_MENU12 )
	{
		// Find all house items and list them 50 at a time
		if ( !player_structure.isBuilding( structure ) )
		{
			return SCRIPT_CONTINUE;
		}
		int lockoutEnds = -1;
		if ( hasObjVar(self, "findItems.lockout") )
		{
			lockoutEnds = getIntObjVar(self, "findItems.lockout");
		}
		
		int currentTime = getGameTime();
		if ( currentTime > lockoutEnds || isGod(player) )
		{
			player_structure.initializeFindAllItemsInHouse(self, player);
			setObjVar(self, "findItems.lockout", currentTime + player_structure.HOUSE_ITEMS_SEARCH_LOCKOUT);
		}
		else
		{
			string_id message = new string_id ("player_structure", "find_items_locked_out");
			prose_package pp = prose.getPackage(message, player, player);
			prose.setTO(pp, utils.formatTimeVerbose(lockoutEnds - currentTime));
			sendSystemMessageProse(player, pp);
		}
	}
	else if ( item == menu_info_types.SERVER_MENU13 )
	{
		// Find asearch for an item based on a keyword or phrase
		if ( !player_structure.isBuilding( structure ) )
		{
			return SCRIPT_CONTINUE;
		}
			
		int lockoutEnds = -1;
		if ( hasObjVar(self, "findItems.lockout") )
		{
			lockoutEnds = getIntObjVar(self, "findItems.lockout");
		}
		
		int currentTime = getGameTime();
		if ( currentTime > lockoutEnds || isGod(player) )
		{
			player_structure.initializeItemSearchInHouse(self, player);
			setObjVar(self, "findItems.lockout", currentTime + player_structure.HOUSE_ITEMS_SEARCH_LOCKOUT);
		}
		else
		{
			string_id message = new string_id ("player_structure", "find_items_locked_out");
			prose_package pp = prose.getPackage(message, player, player);
			prose.setTO(pp, utils.formatTimeVerbose(lockoutEnds - currentTime));
			sendSystemMessageProse(player, pp);
		}
	}
	else if ( item == menu_info_types.SERVER_MENU9 )
	{
		if ( !player_structure.isBuilding( structure ) )
			return SCRIPT_CONTINUE;

		// Find the first item and move it to the player.
		moveFirstItem( self, player, structure );
	}
	else if ( item == menu_info_types.SERVER_MENU2 )
	{
		if ( !player_structure.isBuilding( structure ) )
			return SCRIPT_CONTINUE;

		// Delete all items in the player's house.
		deleteAllItems( self, player, structure );
	}
	else if ( item == menu_info_types.SERVER_MENU3 )
	{
		// Remove an existing turnstile.
		if ( !turnstile.hasTurnstile( structure ) )
			return SCRIPT_CONTINUE;
		turnstile.removeTurnstile( structure );
		sendSystemMessage( player, "Your building no longer has an access fee.", null );
	}
	else if (item == menu_info_types.SERVER_MENU4)
	{
		if ( !permissionsIsPublic(structure) )
		{
			sendSystemMessage( player, SID_PUBLIC_ONLY );
			return SCRIPT_CONTINUE;
		}
		if ( !turnstile.canAddTurnstile( player, structure ) )
			return SCRIPT_CONTINUE;
		if ( turnstile.hasTurnstile( structure ) || utils.hasScriptVar( player, "turnstile.querySetTurnstile" ) )
			return SCRIPT_CONTINUE;
		utils.setScriptVar( self, "turnstile.querySetTurnstile", 1 );
		utils.setScriptVar( self, STRUCTURE_MARK, structure);

		// Add a turnstile to this building.
		sui.inputbox( self, player, "@player_structure:access_fee", sui.OK_CANCEL, "@player_structure:access_fee_t", sui.INPUT_NORMAL, null, "handleSetAccessFee", null );
	}
	else if (item == menu_info_types.SERVER_MENU6)
	{
		queueCommand(player, ##"addPower", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_MENU8)
	{
		queueCommand(player, ##"paWithdraw", null, "", COMMAND_PRIORITY_DEFAULT);
	}
	else if (item == menu_info_types.SERVER_MENU7 )
	{
		player_structure.showChangeSignSui(structure, player);
	}
	else if(item == menu_info_types.SERVER_MENU10)
	{
		//Player is waiting on long pack up of structure or
		//timeout.
		if(player_structure.isAbandoned(structure) && player_structure.isPlayerGatedFromHousePackUp(player))
			return SCRIPT_CONTINUE;
		// Check if a structure has vendors and return if player is 
		// allowed to pack
		if (!player_structure.canPackStructureWithVendors(player, structure))
			return SCRIPT_CONTINUE;
		
		//called if player is owner
		if(player_structure.isOwner(structure, player) && player_structure.canPackBuilding(player, structure))
		{
			blog("owner is using pack up");
			player_structure.packBuilding(player, structure);
		}
		//called if structure is abandoned
		else if(player_structure.canPlayerPackAbandonedStructure(player, structure) && !utils.hasScriptVar(structure, player_structure.SCRIPTVAR_HOUSE_PACKUP_LOCKOUT_TIME))
		{
			blog("NON-OWNER is using pack up");
			dictionary params = new dictionary();
			params.put("player", player);
			params.put("house", structure);
			
			messageTo (player, "handlePlayerStructurePackupLockout", params, 0, false);
			messageTo (structure, "packAbandonedBuilding", params, 4, false);
		}

		return SCRIPT_CONTINUE;
	}
	//Removes custom house sign, replace it with default sign, and puts the static item sign back in the players inventory.
	else if (item == menu_info_types.SERVER_MENU11 )
	{
		player_structure.revertCustomSign(player, structure);
	}
	else if (item == menu_info_types.SERVER_MENU14)
	{
		blog("terminal_structure.OnMenuSelect: Player selected Special Sign Radial Option");
		getSpecialSignManagementMenu(player, structure);
	}	
	else if ( item == menu_info_types.SERVER_MENU15 )
	{
		blog("SERVER_MENU15 - selected");
		player_structure.getStructureDecorMenu(player, structure, template);
	}
	else if ( item == menu_info_types.SERVER_MENU16 )
	{
		blog("about to REMOVE DECOR");
		player_structure.removeStructureDecor(structure, player);
	}	
	else if (item == menu_info_types.DICE_ROLL )
	{
		if (!hasObjVar(structure, player_structure.OBJVAR_STRUCTURE_STORAGE_INCREASE))
			return SCRIPT_CONTINUE;

		// Should be safe here to redeed the storage -  handler = handleStorageRedeedChoice
		player_structure.displayAvailableNonGenericStorageTypes(player, self, structure);

	}

	return SCRIPT_CONTINUE;
}

messageHandler handleStorageRedeedChoice()
{
	obj_id player = sui.getPlayerId(params);
	string accessFee = sui.getInputBoxText(params);
	int btn = sui.getIntButtonPressed(params);
	
	if(btn == sui.BP_CANCEL)
		return SCRIPT_CONTINUE;

	obj_id structure = player_structure.getStructure(player);

	if(!player_structure.isOwner(structure, player))
	{
		return SCRIPT_CONTINUE;
	}

	if(hasObjVar(structure, player_structure.OBJVAR_STRUCTURE_STORAGE_INCREASE))
	{
		int storageRedeedSelected = 0;
		if ( params.containsKey(sui.LISTBOX_LIST + "." + sui.PROP_SELECTEDROW) )
		{
			storageRedeedSelected = sui.getListboxSelectedRow(params);
			if ( storageRedeedSelected  < 0)
			{
				sendSystemMessage(player, new string_id("player_structure", "storage_redeed_no_selection"));
				return SCRIPT_CONTINUE;
			}
		}

		if( player_structure.decrementStorageAmount(player, structure, self, storageRedeedSelected) )
		{
			sendSystemMessage(player, new string_id("player_structure", "storage_increase_redeeded"));
		}
	}

	return SCRIPT_CONTINUE;
}


messageHandler handleSetAccessFee()
{
	// Get the fee.
	obj_id player = sui.getPlayerId(params);
	string accessFee = sui.getInputBoxText( params );
	int btn = sui.getIntButtonPressed( params );
	if ( btn == sui.BP_CANCEL )
	{
		utils.removeScriptVar( self, "turnstile.querySetTurnstile" );
		return SCRIPT_CONTINUE;
	}

	// Convert fee.
	int fee = utils.stringToInt( accessFee );
	utils.setScriptVar( self, "turnstile.fee", fee );

	if ( (fee < 1) || (fee > 50000) )
	{
		sui.inputbox( self, player, "@player_structure:access_fee", sui.OK_CANCEL, "@player_structure:access_fee_t", sui.INPUT_NORMAL, null, "handleSetAccessFee", null );
		return SCRIPT_CONTINUE;
	}

	// Query length.
	sui.inputbox( self, player, "@player_structure:access_time", sui.OK_CANCEL, "@player_structure:access_time_t", sui.INPUT_NORMAL, null, "handleSetAccessLength", null );

	return SCRIPT_CONTINUE;
}

messageHandler handleSetAccessLength()
{
	// Get the length.
	obj_id player = sui.getPlayerId(params);
	string accessLength = sui.getInputBoxText( params );
	int btn = sui.getIntButtonPressed( params );
	if ( btn == sui.BP_CANCEL )
	{
		utils.removeScriptVar( self, "turnstile.querySetTurnstile" );
		return SCRIPT_CONTINUE;
	}

	// Convert length.
	int length = utils.stringToInt( accessLength );
	if ( length < 15 || length > 2880 )
	{
		sui.inputbox( self, player, "@player_structure:access_time", sui.OK_CANCEL, "@player_structure:access_time_t", sui.INPUT_NORMAL, null, "handleSetAccessLength", null );
		return SCRIPT_CONTINUE;
	}
	length *= 60; // Convert to seconds.

	int fee = utils.getIntScriptVar( self, "turnstile.fee" );

	// Add the turnstile.
	obj_id structure = self;
	if ( !player_structure.isInstallation(structure) )
	{
		structure = utils.getObjIdScriptVar(self, STRUCTURE_MARK);

		if(!isIdValid(structure) || !structure.isLoaded())
			return SCRIPT_CONTINUE;
	}
	turnstile.addTurnstile( structure, fee, length );

	// Notify the player.
	sendSystemMessage( player, "Other players will now be charged " + fee + " credits to access your building for " + length/60 + " minutes.", null );

	return SCRIPT_CONTINUE;
}

// Moves the first item in the player's house to his location.
void moveFirstItem( obj_id self, obj_id player, obj_id structure )
{
	sui.msgbox( self, player, "@player_structure:move_first_item_d", sui.OK_CANCEL, "@player_structure:move_first_item", sui.MSG_QUESTION, "handleMoveFirstItem" );
}

messageHandler handleMoveFirstItem()
{
	obj_id player = sui.getPlayerId( params );
	int btn = sui.getIntButtonPressed( params );
	if ( btn == sui.BP_CANCEL )
		return SCRIPT_CONTINUE;

	// The player wants to move the first object in his house to his location.
	// This is used to find objects that might have been pushed into walls.
	obj_id building = player_structure.getStructure( player );
	moveHouseItemToPlayer( building, player, 0 );
	sendSystemMessage( player, SID_MOVED_FIRST_ITEM );

	return SCRIPT_CONTINUE;
}

// Removes every object in the player's house.
void deleteAllItems( obj_id self, obj_id player, obj_id structure )
{
	sui.msgbox( self, player, "@player_structure:delete_all_items_d", sui.OK_CANCEL, "@player_structure:delete_all_items", sui.MSG_QUESTION, "handleDeleteSecondConfirm" );
}

messageHandler handleDeleteSecondConfirm()
{
	obj_id player = sui.getPlayerId( params );
	int btn = sui.getIntButtonPressed( params );
	if ( btn == sui.BP_CANCEL )
		return SCRIPT_CONTINUE;

	sui.msgbox( self, player, "@player_structure:delete_all_items_second_d", sui.OK_CANCEL, "@player_structure:delete_all_items", sui.MSG_QUESTION, "handleDeleteAllItemsCodeConfirm" );

	return SCRIPT_CONTINUE;
}

messageHandler handleDeleteAllItemsCodeConfirm()
{
	obj_id player = sui.getPlayerId(params);
	//close similar SUI if they have one.
	if(utils.hasScriptVar(self, "player_structure.destroyAllItems.pid"))
	{
		sui.closeSUI(player, utils.getIntScriptVar(self, "player_structure.destroyAllItems.pid"));
	}
	
	int key = rand(100000, 999999);
	utils.setScriptVar(self, "player_structure.destroyAllItems.key", key);
	
	int pid = sui.inputbox(self, player, "@player_structure:delete_all_items_prompt" + "\n\nCode: " + key, "@player_structure:delete_all_items_title", "handleDeleteAllItemsConfirmed", 6, false, "");
	if(pid > -1)
	{
		utils.setScriptVar(self, "player_structure.destroyAllItems.pid", pid);
	}
	
	return SCRIPT_CONTINUE;
}

messageHandler handleDeleteAllItemsConfirmed()
{
	int bp = sui.getIntButtonPressed(params);
	string text = sui.getInputBoxText(params);
	obj_id player = sui.getPlayerId(params);

	if(!isIdValid(player))
	{
		utils.removeScriptVarTree(self, "player_structure.destroyAllItems");
		return SCRIPT_CONTINUE;	
	}
	if(bp == sui.BP_CANCEL || text == null || text.equals(""))
	{
		utils.removeScriptVarTree(self, "player_structure.destroyAllItems");
		return SCRIPT_CONTINUE;
	}

	int key = utils.getIntScriptVar(self, "player_structure.destroyAllItems.key");
	string skey = Integer.toString(key);

	if(text.equals(skey))
	{
		int btn = sui.getIntButtonPressed(params);
		if(btn == sui.BP_CANCEL)
		{
			utils.removeScriptVarTree(self, "player_structure.destroyAllItems");
			return SCRIPT_CONTINUE;
		}

		//The player wants to delete everything.
		obj_id building = player_structure.getStructure(player);
		if(!isIdValid(building))
		{
			utils.removeScriptVarTree(self, "player_structure.destroyAllItems");
			return SCRIPT_CONTINUE;
		}
		deleteAllHouseItems(building, player);
		fixHouseItemLimit(building);
		sendSystemMessage(player, SID_ITEMS_DELETED);
		CustomerServiceLog("playerStructure", "deleteAllItems (Deleting all objects in house by player's request. Player had to enter a 6 Digit Code to confirm Deleting All Items.) Player: " + player + " (" + getName(player) + ") Structure: " + building);
	}
	else
	{
		sui.msgbox(player, "@player_structure:incorrect_destroy_all_items_code");
		utils.removeScriptVarTree(self, "player_structure.destroyAllItems");
	}

	return SCRIPT_CONTINUE;
}

//Collections:
//This messageHandler clears the picture objvar (Meatlump Collection)
messageHandler clearCollectionMeatlumpCamera()
{
	//Get the target's ID
	obj_id target = params.getObjId("target");
	utils.removeScriptVar(target, "collection.picture_taken");
	return SCRIPT_CONTINUE;
}

/***** ITEM SEARCH HANDLERS *************************************************/

messageHandler handlePlayerStructureFindItemsListResponse()
{
	player_structure.handleFindItemsListResponse(self, params);
	return SCRIPT_CONTINUE;
}

messageHandler handlePlayerStructureFindItemsPageResponse()
{
	player_structure.handleFindItemsChangePageResponse(self, params);
	return SCRIPT_CONTINUE;
}

messageHandler handlePlayerStructureSearchItemsGetKeyword()
{
	player_structure.handleSearchItemsGetKeyword(self, params);
	return SCRIPT_CONTINUE;
}

messageHandler handlePlayerStructureSearchItemsSelectedResponse()
{
	player_structure.handleSearchItemsSelectedResponse(self, params);
	return SCRIPT_CONTINUE;
}


/***** COMMANDHANDLERS *************************************************/


/***** FUNCTIONS *************************************************/
boolean getSpecialSignManagementMenu(obj_id player, obj_id structure)
{
	blog("terminal_structure.getSpecialSignManagementMenu: init");

	if(!isValidId(player) || !isValidId(structure))
		return false;
	if(player_structure.isInstallation(structure) || player_structure.isCivic(structure))
		return false;
	if(!player_structure.hasSpecialSignSkillMod(player, structure) && !hasObjVar(structure, player_structure.SPECIAL_SIGN))
		return false;
	if(sui.hasPid(player, player_structure.VAR_SPECIAL_SIGN_MENU_PID))
	{
		int pid = sui.getPid(player, player_structure.VAR_SPECIAL_SIGN_MENU_PID);
		forceCloseSUIPage(pid);
	}
	blog("terminal_structure.getSpecialSignManagementMenu: validation completed, getting menu options");

	resizeable string[] menuOptions = new string[0];
	resizeable string[] menuStrings = new string[0];
	boolean replaceSign = false;
	boolean removeSign = false;

	if(hasObjVar(structure, player_structure.SPECIAL_SIGN))
	{
		utils.addElement(menuStrings, "@player_structure:remove_current_sign");
		utils.addElement(menuOptions, "remove");
		removeSign = true;
	}

	if(player_structure.getSpecialSignList(player, structure))
	{
		//get scriptvars stored when getSpecialSignList was called
		string[] signList = utils.getStringArrayScriptVar(player, player_structure.VAR_SPECIAL_SIGN_LIST);
		string[] signName = utils.getStringArrayScriptVar(player, player_structure.VAR_SPECIAL_SIGN_NAMES);
		//if the scriptvars are no good, we have a problem
		if(signList != null && signList.length > 0 && signName != null && signName.length > 0)
		{		
			//set scriptVar on Player for later use
			utils.addElement(menuStrings, "@player_structure:replace_current_sign");
			utils.addElement(menuOptions, "replace");
			replaceSign = true;
		}	
		//if the list is just replace, take a short cut to the next menu
		//if it is just remove, the function continues - We don't want to anticipate the player intention on removal
		if(replaceSign && !removeSign)
		{
			blog("terminal_structure.getSpecialSignManagementMenu: the only option was replace");
			int pid = sui.listbox(structure, player, "@base_player:special_sign_ui_prompt", sui.OK_CANCEL, "@base_player:special_sign_ui_title", signName, "handleSpecialSignSelection", true);	
			sui.setPid(player, pid, player_structure.VAR_SPECIAL_SIGN_MENU_PID);
			return true;
		}
	}
	blog("terminal_structure.getSpecialSignManagementMenu: the menu was either just remove or remove and replace");

	string[] signList = new string[menuStrings.size()];
	string[] optionList = new string[menuOptions.size()];

	menuStrings.toArray(signList);
	menuOptions.toArray(optionList);
	
	blog("terminal_structure.getSpecialSignManagementMenu: menu options received");
	utils.setScriptVar(player, player_structure.VAR_SPECIAL_SIGN_MENU, optionList); //save the options, not the strings player sees
	
	int pid = sui.listbox(structure, player, "@base_player:special_sign_ui_prompt", sui.OK_CANCEL, "@base_player:special_sign_ui_title", signList, "handleSpecialSignManagementSelection", true);	
	sui.setPid(player, pid, player_structure.VAR_SPECIAL_SIGN_MENU_PID);
	return true;
}

boolean blog(string msg)
{
	if(msg == null || msg.equals(""))
		return false;
	if(LOGGING_ON)
		LOG(TERMINAL_LOGGING, msg);
		
	return true;
}
